## A - Gestos en Motion

#### 1. **Definición:**

Motion extiende los eventos básicos de React con un conjunto de **gestos de interfaz de usuario** muy fáciles de usar. Piensa en los gestos como acciones que puedes hacer con el ratón o con tus dedos en la pantalla, ¡y Motion los hace súper sencillos de implementar en tus componentes React!

#### 2. **Gestos Soportados:**

Motion actualmente soporta estos gestos:

- **hover** (pasar el ratón por encima)
- **tap** (tocar o hacer clic)
- **pan** (arrastrar en cualquier dirección)
- **drag** (arrastrar, pero con más control sobre el movimiento)
- **inView** (cuando un elemento se hace visible en la pantalla)

#### 3. **¿Para qué sirven?**

Cada uno de estos gestos viene con:

- **Event Listeners:** Funciones que se activan cuando realizas el gesto (como `onHoverStart` cuando empiezas a pasar el ratón por encima).
- **`while-` Animation Props:** Props especiales que te permiten animar un componente _mientras_ se está realizando un gesto (como `whileHover` para animar mientras el ratón está encima).

---

## B - Animation Props (`while-`)

#### 1. **Definición:**

Las `animation props` que empiezan por `while-` son como superpoderes para tus componentes `motion`. Te permiten definir animaciones que se activan **temporalmente** cuando un gesto está activo.

#### 2. **Animation Props Disponibles:**

- `whileHover`: Animación mientras el ratón está encima.
- `whileTap`: Animación mientras se está tocando o haciendo clic.
- `whileFocus`: Animación mientras el elemento tiene el foco (por ejemplo, cuando lo seleccionas con el teclado).
- `whileDrag`: Animación mientras se está arrastrando.
- `whileInView`: Animación mientras el elemento es visible en la pantalla.

#### 3. **Ejemplo:**

```jsx
<motion.button
  whileHover={{
    scale: 1.2, // Aumenta la escala al 120% al pasar el ratón
    transition: { duration: 1 }, // Anima la escala en 1 segundo
  }}
  whileTap={{ scale: 0.9 }} // Reduce la escala al 90% al hacer clic
>
  ¡Tócame o pasa el ratón!
</motion.button>
```

**Explicación del ejemplo:**
Este botón se hará un poco más grande (escala 1.2) cuando pases el ratón por encima, con una animación suave de 1 segundo. Y se hará un poco más pequeño (escala 0.9) cuando hagas clic en él. ¡Así de fácil!

#### 4. **Usando Variants:**

También puedes usar `variants` para que tu código sea más organizado y reutilizable.

```jsx
const buttonVariants = {
  hover: { scale: 1.2, transition: { duration: 0.5 } },
  tap: { scale: 0.9 },
};

<motion.button
  whileTap="tap" // Usa la variant 'tap'
  whileHover="hover" // Usa la variant 'hover'
  variants={buttonVariants} // ¡Aquí definimos las variants!
>
  Botón con Variants
</motion.button>;
```

**Explicación del ejemplo:**
Aquí definimos las animaciones `hover` y `tap` fuera del componente, en `buttonVariants`. Luego, simplemente las llamamos por su nombre (`"hover"`, `"tap"`) en las props `whileHover` y `whileTap`. ¡Mucho más limpio y fácil de mantener!

---

## C - Gesto Hover

#### 1. **Definición:**

El gesto `hover` detecta cuando el puntero del ratón **entra** o **sale** de un componente. Es más preciso que `onMouseEnter` y `onMouseLeave` porque solo se activa por eventos de ratón reales, no por eventos emulados desde la entrada táctil.

#### 2. **Event Listeners:**

- `onHoverStart`: Se activa cuando el puntero **entra** en el componente.
- `onHoverEnd`: Se activa cuando el puntero **sale** del componente.

#### 3. **`whileHover` Prop:**

- `whileHover`: Define la animación que se ejecuta **mientras** el puntero está sobre el componente.

#### 4. **Ejemplo:**

```jsx
<motion.a
  whileHover={{ scale: 1.2 }} // Aumenta la escala al pasar el ratón
  onHoverStart={(event) => {
    console.log("¡Hover Start!");
  }}
  onHoverEnd={(event) => {
    console.log("¡Hover End!");
  }}
  href="#"
>
  Pasa el ratón por aquí
</motion.a>
```

**Explicación del ejemplo:**
Este enlace se hará un poco más grande cuando pases el ratón por encima. Además, verás mensajes en la consola del navegador cuando el ratón entre y salga del enlace.

---

## D - Gesto Tap

#### 1. **Definición:**

El gesto `tap` detecta cuando el **puntero principal** (clic izquierdo del ratón o el primer dedo en una pantalla táctil) se presiona y se levanta **dentro del mismo componente**.

#### 2. **Eventos:**

- `onTap`: Se activa cuando el "tap" o clic **termina** dentro del mismo componente donde empezó.
- `onTapCancel`: Se activa si el "tap" o clic **termina fuera** del componente.

#### 3. **`whileTap` Prop:**

- `whileTap`: Define la animación que se ejecuta **mientras** se está tocando o haciendo clic en el componente.

#### 4. **Ejemplo:**

```jsx
<motion.button whileTap={{ scale: 0.9, rotate: 3 }}>¡Toca aquí!</motion.button>
```

**Explicación del ejemplo:**
Este botón se hará un poco más pequeño (escala 0.9) y rotará un poco (3 grados) mientras lo estés tocando o haciendo clic. ¡Un efecto sutil pero divertido!

#### 5. **Cancelación en Componentes Draggable:**

Si un componente con `tap` está dentro de un componente que se puede arrastrar (`draggable`), el gesto `tap` se cancelará automáticamente si el puntero se mueve más de 3 píxeles durante el gesto. Esto evita que se active un "tap" accidentalmente al intentar arrastrar.

#### 6. **Accesibilidad:**

¡Importante! Los elementos con eventos `tap` son **accesibles por teclado**.

- Cualquier elemento con una prop `tap` puede recibir **foco**.
- La tecla **`Enter`** puede usarse para activar eventos `tap` en elementos con foco.

  - **Presionar `Enter`**: Activa `onTapStart` y `whileTap`.
  - **Soltar `Enter`**: Activa `onTap`.
  - **Perder el foco antes de soltar `Enter`**: Activa `onTapCancel`.

---

## E - Gesto Pan

#### 1. **Definición:**

El gesto `pan` se reconoce cuando un puntero se presiona en un componente y se mueve **más de 3 píxeles**. El gesto `pan` termina cuando se levanta el puntero. Piensa en "panear" la pantalla, como mover un mapa.

#### 2. **Evento:**

- `onPan`: Se activa **mientras** se está arrastrando el puntero. Recibe dos argumentos:
  - `e`: El evento del puntero.
  - `pointInfo`: Información sobre el movimiento del puntero (como la posición actual y la delta desde el inicio del pan).

#### 3. **`while-` Prop:**

- Actualmente, `pan` **no tiene una prop `while-`** asociada. Si quieres animar durante el pan, tendrás que hacerlo manualmente dentro del `onPan`.

#### 4. **Ejemplo:**

```jsx
<motion.div
  style={{ width: 200, height: 200, backgroundColor: "lightblue" }}
  onPan={(event, pointInfo) => {
    console.log("Paneando:", pointInfo.deltaX, pointInfo.deltaY);
  }}
>
  ¡Arrastra aquí! (Pan)
</motion.div>
```

**Explicación del ejemplo:**
Este cuadrado azul claro registrará en la consola cuánto lo estás arrastrando horizontal (`deltaX`) y verticalmente (`deltaY`) mientras mantienes presionado el puntero y lo mueves dentro del cuadrado.

#### 5. **Nota Importante para Touch Input:**

Para que los gestos `pan` funcionen correctamente con **entrada táctil**, necesitas **deshabilitar el scroll táctil** en el eje X, Y o ambos del elemento usando la regla CSS `touch-action`.

Por ejemplo: `touch-action: pan-y;` (permite pan vertical, pero no horizontal) o `touch-action: none;` (deshabilita pan en ambos ejes).

---

## F - Gesto Drag

#### 1. **Definición:**

El gesto `drag` aplica el movimiento del puntero al eje X y/o Y del componente. Es como "arrastrar y soltar".

#### 2. **Props Principales:**

- `drag`: Activa el gesto de arrastrar. Puede ser:
  - `true`: Arrastrar en ambos ejes (X e Y).
  - `"x"`: Arrastrar solo horizontalmente (eje X).
  - `"y"`: Arrastrar solo verticalmente (eje Y).
- `whileDrag`: Define la animación que se ejecuta **mientras** se está arrastrando el componente.

#### 3. **Ejemplo Básico:**

```jsx
<motion.div
  drag // Permite arrastrar en ambos ejes
  whileDrag={{ scale: 1.2, backgroundColor: "#f00" }} // Anima al arrastrar
  style={{ width: 100, height: 100, backgroundColor: "blue", color: "white" }}
>
  ¡Arrastra!
</motion.div>
```

**Explicación del ejemplo:**
Este cuadrado azul se hará un poco más grande (escala 1.2) y se volverá rojo mientras lo estés arrastrando.

#### 4. **Inercia (`dragMomentum`, `dragTransition`):**

- Por defecto, al terminar de arrastrar, el elemento tendrá una animación de **inercia** basada en la velocidad final del arrastre.
- `dragMomentum={false}`: Desactiva la animación de inercia.
- `dragTransition`: Permite personalizar la transición de inercia.

#### 5. **Restricciones de Arrastre (`dragConstraints`):**

Puedes limitar el área donde se puede arrastrar el componente con `dragConstraints`.

- **Objeto con `top`, `left`, `right`, `bottom`:** Define los límites en píxeles.

  ```jsx
  <motion.div
    drag="x" // Arrastrar solo horizontalmente
    dragConstraints={{ left: 0, right: 300 }} // Limites: 0px a 300px a la derecha
    style={{
      width: 100,
      height: 100,
      backgroundColor: "green",
      color: "white",
    }}
  >
    Arrastra horizontalmente (limitado)
  </motion.div>
  ```

  **Explicación:** Este cuadrado verde solo se puede arrastrar horizontalmente entre 0 y 300 píxeles a la derecha de su posición inicial.

- **`ref` a otro componente:** Usa `React.useRef` para crear una referencia a otro componente y úsalo como contenedor de restricciones.

  ```jsx
  import React, { useRef } from "react";
  import { motion } from "framer-motion";

  const MyComponent = () => {
    const constraintsRef = useRef(null);

    return (
      <motion.div
        ref={constraintsRef}
        style={{ border: "2px dashed gray", padding: 20 }}
      >
        <motion.div
          drag
          dragConstraints={constraintsRef} // ¡Restringe el arrastre al div contenedor!
          style={{
            width: 80,
            height: 80,
            backgroundColor: "orange",
            color: "white",
          }}
        >
          Arrastra dentro del contenedor
        </motion.div>
      </motion.div>
    );
  };
  ```

  **Explicación:** El cuadrado naranja solo se puede arrastrar dentro del área del div gris punteado. ¡El `constraintsRef` define los límites!

#### 6. **Elasticidad en los Límites (`dragElastic`):**

- Por defecto, al arrastrar fuera de las restricciones, el elemento tendrá un efecto de "tirón" elástico.
- `dragElastic`: Controla la elasticidad. Valor entre `0` y `1`:
  - `0`: No hay movimiento fuera de las restricciones (se detiene bruscamente).
  - `1`: Movimiento completo fuera de las restricciones (sin elasticidad).
  - Valores intermedios (ej: `0.5`): Elasticidad moderada.

---

## G - Gesto Focus

#### 1. **Definición:**

El gesto `focus` detecta cuando un componente **gana o pierde el foco**. Sigue las mismas reglas que el selector CSS `:focus-visible`.

#### 2. **¿Cuándo se activa?**

- Típicamente, cuando un `<input>` recibe foco (de cualquier manera: clic, tabulación, etc.).
- Y cuando otros elementos reciben foco de manera accesible (principalmente a través de la navegación con el teclado, como con la tecla `Tab`).

#### 3. **`whileFocus` Prop:**

- `whileFocus`: Define la animación que se ejecuta **mientras** el componente tiene el foco.

#### 4. **Ejemplo:**

```jsx
<motion.a whileFocus={{ scale: 1.2 }} href="#">
  Enlace con Focus
</motion.a>
```

**Explicación del ejemplo:**
Este enlace se hará un poco más grande cuando reciba el foco, por ejemplo, al seleccionarlo con la tecla `Tab` en el navegador.

---

## H - Propagación de Eventos

#### 1. **Problema:**

A veces, quieres que un gesto en un componente hijo **no active** un gesto en un componente padre. Por ejemplo, un botón dentro de un div con `whileTap`.

#### 2. **Solución: `onPointerDownCapture` y `e.stopPropagation()`**

Puedes usar la prop `onPointerDownCapture` en el hijo y llamar a `e.stopPropagation()` para detener la propagación del evento hacia arriba en el árbol de componentes.

#### 3. **Ejemplo:**

```jsx
<motion.div whileTap={{ scale: 2 }}>
  <button onPointerDownCapture={(e) => e.stopPropagation()}>
    Botón que detiene el Tap del Padre
  </button>
</motion.div>
```

**Explicación del ejemplo:**
El `<div>` padre tiene `whileTap={{ scale: 2 }}`. Normalmente, al hacer clic en el `<button>`, el `<div>` también se escalaría. Pero, gracias a `onPointerDownCapture={(e) => e.stopPropagation()}` en el `<button>`, ¡el evento de clic se detiene en el botón y no llega al `<div>` padre! Así, solo el botón se comporta como botón normal, y el `<div>` padre no reacciona al clic en el botón.

---

## I - Nota: Filtros SVG

#### 1. **Problema:**

Los gestos **no se reconocen directamente** en componentes `<filter>` de SVG. Esto es porque los filtros SVG no tienen una presencia física en la pantalla y, por lo tanto, no reciben eventos.

#### 2. **Solución: Animar el Padre y Usar Variants**

Para animar filtros SVG con gestos, debes añadir las props `while-` y los event handlers a un **componente padre** del filtro (como el `<svg>` o un `<g>`). Luego, usa `variants` para animar las propiedades del filtro dentro del `<filter>`.

#### 3. **Ejemplo:**

```jsx
<motion.svg whileHover="hover">
  <filter id="blur">
    <motion.feGaussianBlur
      stdDeviation={0} // Desenfoque inicial 0
      variants={{ hover: { stdDeviation: 2 } }} // Variant 'hover' para desenfoque 2
    />
  </filter>
  {/* ... otros elementos SVG que usan el filtro ... */}
</motion.svg>
```

**Explicación del ejemplo:**
En este ejemplo, el gesto `whileHover="hover"` está en el `<motion.svg>`. Dentro del `<filter id="blur">`, el `<motion.feGaussianBlur>` usa `variants` para definir que cuando el `<svg>` tenga el estado "hover" (gracias al `whileHover`), la propiedad `stdDeviation` del filtro cambie a 2, creando un efecto de desenfoque al pasar el ratón por encima del SVG.

---

## J - Motion+ Examples

#### 1. **Motion+:**

Motion+ es una **membresía de pago único** que te da acceso a:

- **Código fuente** de una librería creciente de **ejemplos premium**.
- **Componentes premium** como `<Cursor>` y `<AnimateNumber>`.

#### 2. **Ejemplos de Gestos en Motion+:**

Motion+ incluye varios ejemplos avanzados que usan gestos, mostrando cómo combinarlos para crear interacciones más complejas y pulidas.
