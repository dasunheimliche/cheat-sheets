## A - Tipos de Animaciones con Scroll

#### 1. **Definición:**

Existen dos maneras principales de animar elementos web cuando el usuario hace scroll:

- **Scroll-triggered (Disparadas por Scroll):** Animaciones normales que se activan cuando un elemento entra o sale de la pantalla visible (viewport). Imagina una animación de "aparecer" cuando algo se asoma al bajar la página.
- **Scroll-linked (Enlazadas al Scroll):** Animaciones que cambian directamente según cuánto has scrolleado. Por ejemplo, una barra de progreso que se llena a medida que bajas en la página.

#### 2. **Ejemplo:**

Imagina que tienes una caja que quieres que se desvanezca a medida que haces scroll.

**Scroll-triggered (Aparecer al entrar en pantalla):** La caja empieza invisible (opacidad 0) y se vuelve completamente visible (opacidad 1) cuando la ves en la pantalla.

**Scroll-linked (Cambiar tamaño con el scroll):** La caja podría hacerse más grande o pequeña, o cambiar de color, directamente proporcional a cuánto has bajado en la página.

#### 3. **Notas o advertencias:**

- **Motion** (la librería que estamos usando) puede manejar ambos tipos de animaciones.

---

## B - Animaciones Scroll-triggered

#### 1. **Definición:**

Son animaciones que se inician cuando un elemento se hace visible en la pantalla (viewport) al hacer scroll. Es como si el scroll fuera el "interruptor" que enciende la animación.

#### 2. **Ejemplo:**

```jsx
<motion.div
  initial={{ opacity: 0 }} // Empieza invisible
  whileInView={{ opacity: 1 }} // Se vuelve visible al entrar en la pantalla
/>
```

**Explicación del ejemplo:**

Aquí usamos `motion.div` (un div especial de la librería Motion).

- `initial={{ opacity: 0 }}`: Define el estado inicial de la caja, con una opacidad de 0, o sea, invisible.
- `whileInView={{ opacity: 1 }}`: Le dice a Motion que cuando este `div` entre en la pantalla (`whileInView`), cambie la opacidad a 1, haciéndolo completamente visible.

#### 3. **Notas o advertencias:**

- `whileInView` es una propiedad especial de Motion que detecta cuando un elemento está en la pantalla.
- Estas animaciones son "normales" en el sentido de que una vez que se activan, se ejecutan como cualquier otra animación.

---

## C - Animaciones de una sola vez (One-time animations)

#### 1. **Definición:**

Por defecto, una animación `whileInView` se repite cada vez que el elemento entra y sale de la pantalla al hacer scroll arriba y abajo. Las animaciones "de una sola vez" se ejecutan solo la primera vez que el elemento entra en la pantalla y no se repiten si el elemento vuelve a salir y entrar.

#### 2. **Ejemplo:**

```jsx
<motion.div
  initial="hidden"
  whileInView="visible"
  viewport={{ once: true }} // Animación de una sola vez
/>
```

**Explicación del ejemplo:**

- `viewport={{ once: true }}`: Esta línea adicional dentro de `viewport` hace la magia. `once: true` le dice a Motion que ejecute la animación `whileInView` solo la primera vez que el elemento se vea.

#### 3. **Notas o advertencias:**

- `viewport` es una propiedad para configurar cómo `whileInView` detecta la visibilidad.
- `once: true` es útil para animaciones que solo quieres que ocurran una vez, como introducciones o efectos especiales que no deben repetirse al hacer scroll arriba y abajo.

---

## D - Cambiando el Contenedor de Scroll

#### 1. **Definición:**

Normalmente, `whileInView` considera que la "pantalla" es la ventana del navegador completa. Pero, a veces, tienes scroll dentro de un `div` más pequeño dentro de la página. Puedes decirle a `whileInView` que use ese `div` interno como referencia para detectar si el elemento está visible.

#### 2. **Ejemplo:**

```jsx
function Component() {
  const scrollRef = useRef(null); // Creamos una referencia al div con scroll

  return (
    <div
      ref={scrollRef}
      style={{ overflow: "scroll", height: "200px", border: "1px solid black" }}
    >
      {" "}
      {/* Div con scroll interno */}
      <motion.div
        initial={{ opacity: 0 }}
        whileInView={{ opacity: 1 }}
        viewport={{ root: scrollRef }} // Usamos scrollRef como el "viewport"
      />
    </div>
  );
}
```

**Explicación del ejemplo:**

- `useRef(null)`: `scrollRef` es una "referencia" que nos permite acceder al `div` con scroll.
- `<div ref={scrollRef} style={{ overflow: "scroll" }}>`: Este `div` es el contenedor con scroll. Le asignamos la referencia `scrollRef`.
- `viewport={{ root: scrollRef }}`: Aquí le decimos a `whileInView` que el "viewport" ya no es la ventana del navegador, sino el elemento al que apunta `scrollRef`, es decir, nuestro `div` con scroll interno.

#### 3. **Notas o advertencias:**

- `root: scrollRef` dentro de `viewport` es la clave para cambiar el contenedor de scroll.
- Esto es útil cuando tienes scrollable areas dentro de tu página y quieres que las animaciones se activen en relación a ese scroll interno, no al scroll de la página completa.

---

## E - Estableciendo Estado con la Visibilidad

#### 1. **Definición:**

No solo puedes animar componentes `motion`. A veces, solo quieres saber cuándo un elemento (cualquier elemento HTML, no solo uno de Motion) entra o sale de la pantalla para hacer otras cosas, como cambiar el estado de tu componente, mostrar u ocultar otros elementos, etc. Para esto, Motion ofrece un "hook" llamado `useInView`.

#### 2. **Ejemplo:**

```jsx
import { useInView } from "framer-motion"; // Importa el hook

function MiComponente() {
  const [ref, isInView] = useInView(); // Usa el hook

  return (
    <div ref={ref}>
      {" "}
      {/* Asigna la referencia al div que quieres observar */}
      {isInView ? "¡Estoy en la pantalla!" : "Aún no me ves..."}
    </div>
  );
}
```

**Explicación del ejemplo:**

- `useInView()`: Este hook te da dos cosas:
  - `ref`: Una referencia que debes asignar al elemento HTML que quieres observar (en este caso, el `div`).
  - `isInView`: Un valor booleano (`true` o `false`) que te dice si el elemento está actualmente en la pantalla (`true`) o no (`false`).
- `<div ref={ref}>`: Asignamos la referencia `ref` al `div`. Ahora `useInView` está "observando" este `div`.
- `{isInView ? ... : ...}`: Usamos `isInView` para mostrar un mensaje diferente dependiendo de si el `div` está visible o no.

#### 3. **Notas o advertencias:**

- `useInView` es un hook muy útil para controlar el estado de tu componente basado en la visibilidad de elementos, incluso si no los estás animando directamente con Motion.
- Puedes usar `isInView` para cualquier lógica que necesites activar cuando un elemento se hace visible.

---

## F - Animaciones Scroll-linked

#### 1. **Definición:**

En lugar de simplemente "dispararse" al entrar en la pantalla, las animaciones "scroll-linked" están directamente conectadas al progreso del scroll. A medida que haces scroll, los valores de la animación cambian en tiempo real, creando una relación directa entre el scroll y la animación.

#### 2. **Ejemplo:**

Imagina una barra de progreso horizontal que se llena de izquierda a derecha a medida que haces scroll hacia abajo en la página. La longitud de la barra está "enlazada" a cuánto has scrolleado.

#### 3. **Notas o advertencias:**

- Motion usa "motion values" (valores de movimiento) y el hook `useScroll` para crear este tipo de animaciones.

---

## G - Usando `useScroll` para Animaciones Scroll-linked

#### 1. **Definición:**

El hook `useScroll()` de Motion es la herramienta clave para crear animaciones scroll-linked. Te da acceso a valores de movimiento que representan el progreso del scroll.

#### 2. **Ejemplo:**

```jsx
import { useScroll, motion } from "framer-motion";

function BarraDeProgreso() {
  const { scrollYProgress } = useScroll(); // Obtiene el progreso vertical del scroll

  return (
    <motion.div
      style={{
        scaleX: scrollYProgress, // Ancho de la barra en función del progreso del scroll
        transformOrigin: "0% 0%", //  La barra crece desde la izquierda
        height: "5px",
        backgroundColor: "red",
      }}
    />
  );
}
```

**Explicación del ejemplo:**

- `useScroll()`: Este hook nos da varios valores relacionados con el scroll. Aquí usamos `scrollYProgress`.
- `scrollYProgress`: Es un "motion value" que representa el progreso del scroll vertical. Su valor va de `0` (al principio de la página) a `1` (al final de la página), y valores intermedios entre medio.
- `scaleX: scrollYProgress`: Aplicamos `scrollYProgress` a la propiedad `scaleX` del estilo de nuestro `motion.div`. `scaleX` controla el escalado horizontal. Cuando `scrollYProgress` es `0`, `scaleX` es `0` (ancho 0). Cuando `scrollYProgress` es `1`, `scaleX` es `1` (ancho completo, escala 1). Esto hace que el ancho de la barra crezca a medida que haces scroll.
- `transformOrigin: "0% 0%"`: Asegura que la barra crezca desde la izquierda (punto de origen en la esquina superior izquierda).

#### 3. **Notas o advertencias:**

- `useScroll()` devuelve varios "motion values" útiles:
  - `scrollX`: Cantidad de scroll horizontal en píxeles.
  - `scrollY`: Cantidad de scroll vertical en píxeles.
  - `scrollXProgress`: Progreso del scroll horizontal (de 0 a 1).
  - `scrollYProgress`: Progreso del scroll vertical (de 0 a 1).
- Puedes usar estos valores directamente en estilos de `motion.div` para crear animaciones scroll-linked.

---

## H - Detectando la Dirección del Scroll

#### 1. **Definición:**

A veces, quieres que tu animación reaccione de manera diferente dependiendo de si el usuario está haciendo scroll hacia arriba o hacia abajo. Puedes usar `useScroll` y un poco de lógica para detectar la dirección del scroll.

#### 2. **Ejemplo:**

```jsx
import { useScroll, useMotionValueEvent } from "framer-motion";
import { useState, useEffect } from "react";

function HeaderPegajoso() {
  const { scrollY } = useScroll(); // Obtiene el valor del scroll vertical
  const [scrollDirection, setScrollDirection] = useState("down"); // Estado para la dirección

  useEffect(() => {
    return useMotionValueEvent(scrollY, "change", (current) => {
      const previous = scrollY.getPrevious(); // Obtiene el valor anterior del scroll
      const diff = current - previous; // Calcula la diferencia

      setScrollDirection(diff > 0 ? "down" : "up"); // Actualiza la dirección
    });
  }, [scrollY]);

  return (
    <motion.header
      animate={{ y: scrollDirection === "down" ? 0 : -100 }} // Mueve el header hacia arriba o abajo
      transition={{ duration: 0.3 }}
      style={{
        position: "fixed",
        top: 0,
        width: "100%",
        backgroundColor: "lightblue",
        padding: "20px",
      }}
    >
      Header Pegajoso (Dirección: {scrollDirection})
    </motion.header>
  );
}
```

**Explicación del ejemplo:**

- `useScroll()`: Obtenemos `scrollY`, el valor del scroll vertical.
- `useState("down")`: `scrollDirection` guarda la dirección del scroll ("up" o "down"). Inicialmente, asumimos que es "down".
- `useMotionValueEvent(scrollY, "change", ...)`: Este hook escucha los cambios en el valor de `scrollY`. Cada vez que `scrollY` cambia (es decir, cada vez que haces scroll), se ejecuta la función dentro de `useMotionValueEvent`.
  - `scrollY.getPrevious()`: Obtiene el valor de `scrollY` antes del cambio actual.
  - `diff = current - previous`: Calcula la diferencia entre el valor actual y el anterior. Si `diff` es positivo, significa que el scroll está yendo hacia abajo. Si es negativo, hacia arriba.
  - `setScrollDirection(...)`: Actualiza el estado `scrollDirection` basado en si `diff` es positivo ("down") o negativo ("up").
- `<motion.header animate={{ y: ... }}>`: Animamos la posición vertical (`y`) del header.
  - `y: scrollDirection === "down" ? 0 : -100`: Si `scrollDirection` es "down", `y` es `0` (header en su posición normal). Si es "up", `y` es `-100` (header se mueve 100 píxeles hacia arriba, ocultándose parcialmente).
- `transition={{ duration: 0.3 }}`: Añade una transición suave a la animación.
- `position: "fixed", top: 0`: Hace que el header sea "pegajoso" y se quede fijo en la parte superior de la pantalla.

#### 3. **Notas o advertencias:**

- `useMotionValueEvent` es esencial para reaccionar a los cambios en los "motion values" en tiempo real.
- Este ejemplo muestra cómo crear un header pegajoso que se oculta al hacer scroll hacia abajo y reaparece al hacer scroll hacia arriba, un patrón común en muchos sitios web.

---

## I - Suavizando Valores con `useSpring`

#### 1. **Definición:**

A veces, los valores de scroll directamente de `useScroll` pueden sentirse un poco "directos" o "bruscos". `useSpring` te permite suavizar estos valores, creando animaciones más fluidas y con un efecto de "resorte".

#### 2. **Ejemplo:**

```jsx
import { useScroll, motion, useSpring } from "framer-motion";

function BarraDeProgresoSuave() {
  const { scrollYProgress } = useScroll();
  const scaleX = useSpring(scrollYProgress, {
    // Suaviza scrollYProgress con useSpring
    stiffness: 100,
    damping: 30,
    restDelta: 0.001,
  });

  return (
    <motion.div
      style={{
        scaleX: scaleX, // Usa el valor suavizado scaleX
        transformOrigin: "0% 0%",
        height: "5px",
        backgroundColor: "blue",
      }}
    />
  );
}
```

**Explicación del ejemplo:**

- `useSpring(scrollYProgress, { ... })`: En lugar de usar `scrollYProgress` directamente, lo pasamos a `useSpring`.
  - `scrollYProgress`: El valor que queremos suavizar (nuestro progreso de scroll).
  - `{ stiffness: 100, damping: 30, restDelta: 0.001 }`: Opciones para controlar el "resorte". `stiffness` (rigidez) y `damping` (amortiguación) controlan cómo de "elástico" es el resorte. `restDelta` define cuándo se considera que el resorte ha llegado a su "reposo".
- `scaleX: scaleX`: Ahora usamos `scaleX` (el valor suavizado por `useSpring`) en lugar de `scrollYProgress` directamente para controlar el ancho de la barra.

#### 3. **Notas o advertencias:**

- `useSpring` es muy útil para añadir un toque de suavidad y naturalidad a las animaciones scroll-linked.
- Experimenta con las opciones de `stiffness`, `damping` y `restDelta` para ajustar el efecto de resorte a tu gusto.

---

## J - Transformando Valores con `useTransform`

#### 1. **Definición:**

`useTransform` es un hook poderoso que te permite tomar un "motion value" (como `scrollYProgress`) y transformarlo en otro valor diferente. Puedes mapear rangos de valores de entrada a rangos de valores de salida. Esto es genial para cambiar colores, tamaños, posiciones, ¡casi cualquier cosa! basada en el scroll.

#### 2. **Ejemplo:**

```jsx
import { useScroll, motion, useTransform } from "framer-motion";

function FondoCambiante() {
  const { scrollYProgress } = useScroll();
  const backgroundColor = useTransform(
    // Transforma scrollYProgress en colores
    scrollYProgress,
    [0, 0.5, 1], // Rango de entrada de scrollYProgress (0 a 1)
    ["#f00", "#0f0", "#00f"] // Rango de salida de colores (rojo, verde, azul)
  );

  return (
    <motion.div
      style={{
        backgroundColor: backgroundColor, // Usa el color transformado
        height: "100vh", // Para que ocupe toda la pantalla vertical
      }}
    >
      {/* Contenido de tu página */}
    </motion.div>
  );
}
```

**Explicación del ejemplo:**

- `useTransform(scrollYProgress, [0, 0.5, 1], ["#f00", "#0f0", "#00f"])`: Aquí usamos `useTransform` para transformar `scrollYProgress` en colores.
  - `scrollYProgress`: El valor de entrada que queremos transformar (progreso del scroll).
  - `[0, 0.5, 1]`: El "rango de entrada". Esto significa:
    - Cuando `scrollYProgress` es `0` (inicio de la página)...
    - Cuando `scrollYProgress` es `0.5` (mitad de la página)...
    - Cuando `scrollYProgress` es `1` (final de la página)...
  - `["#f00", "#0f0", "#00f"]`: El "rango de salida". Corresponde al rango de entrada:
    - ... queremos que el color sea `"#f00"` (rojo).
    - ... queremos que el color sea `"#0f0"` (verde).
    - ... queremos que el color sea `"#00f"` (azul).
  - Motion interpolará los colores entre estos puntos. Así, a medida que haces scroll de 0 a 0.5, el color cambiará gradualmente de rojo a verde, y de 0.5 a 1, de verde a azul.
- `backgroundColor: backgroundColor`: Aplicamos el valor de color transformado (`backgroundColor`) al estilo del `motion.div`.

#### 3. **Notas o advertencias:**

- `useTransform` es extremadamente versátil. Puedes usarlo para transformar un valor de scroll en cualquier otro tipo de valor que puedas animar: posiciones, rotaciones, escalas, opacidades, ¡lo que se te ocurra!
- Los rangos de entrada y salida no tienen que ser solo tres puntos como en el ejemplo. Puedes tener tantos puntos como necesites para crear transformaciones complejas.
