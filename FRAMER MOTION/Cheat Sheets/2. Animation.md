## A - Componente `<motion />`

#### 1. **Definición:**

Es el corazón de Motion para React. Imagina que es un elemento HTML normal (`<div>`, `<button>`, `<span>`, etc.) pero con superpoderes de animación. Lo usas para animar cualquier cosa en tu interfaz web.

#### 2. **Ejemplo:**

```jsx
import { motion } from "motion/react";

function MiComponente() {
  return (
    <motion.div animate={{ opacity: 1 }}>¡Hola, mundo animado!</motion.div>
  );
}
```

**Explicación del ejemplo:**
Aquí importamos `motion` desde la librería y usamos `motion.div` en lugar de un `div` normal. El prop `animate={{ opacity: 1 }}` le dice a este `div` que se anime para tener una opacidad de 1. ¡Así de fácil!

#### 3. **Notas o advertencias:**

- Recuerda importar `motion` desde `"motion/react"` para poder usarlo.
- Casi todas las animaciones en Motion se hacen con este componente.

## B - Prop `animate`

#### 1. **Definición:**

Es el prop mágico que le dices al componente `<motion />` qué propiedades CSS quieres animar y a qué valores quieres que lleguen. Cuando cambias los valores en `animate`, ¡la animación ocurre automáticamente!

#### 2. **Ejemplo:**

```jsx
import { motion } from "motion/react";

function MiComponenteAnimado() {
  return (
    <motion.div
      animate={{
        x: 100, // Mueve el elemento 100px a la derecha
        opacity: 0.5, // Reduce la opacidad a la mitad
        rotate: 360, // Rota el elemento 360 grados
      }}
    >
      ¡Estoy animado!
    </motion.div>
  );
}
```

**Explicación del ejemplo:**
En este ejemplo, `animate` es un objeto que define varias animaciones a la vez: `x` para la posición horizontal, `opacity` para la transparencia y `rotate` para la rotación. ¡Todo se anima suavemente!

#### 3. **Notas o advertencias:**

- Puedes animar múltiples propiedades CSS al mismo tiempo dentro de un solo objeto `animate`.
- Motion se encarga de hacer la animación fluida entre el estado actual y los nuevos valores que definas en `animate`.

## C - Valores Animables

#### 1. **Definición:**

Motion es súper listo y puede animar casi cualquier valor CSS, ¡incluso algunos que los navegadores normalmente no animan! Soporta diferentes tipos de valores para que tus animaciones sean versátiles.

#### 2. **Tipos de valores animables:**

- **Números:** `0`, `100`, `-50`, etc. (ej: `opacity: 0.5`)
- **Strings con números y unidades:** `"0px"`, `"50%"`, `"10vh"`, etc. (ej: `width: "100px"`)
- **Colores:** Nombres de colores, hexadecimales (`"#FF0000"`), RGBA (`"rgba(255, 0, 0, 0.8)"`), HSLA.
- **Strings complejos:** Valores CSS que combinan números y/o colores, como `box-shadow`.
- `display: "none" / "block"` y `visibility: "hidden" / "visible"`.

#### 3. **Ejemplo:**

```jsx
import { motion } from "motion/react";

function ValoresAnimablesComponente() {
  return (
    <motion.div
      animate={{
        width: "50%", // String con porcentaje
        backgroundColor: "rgba(0, 128, 255, 0.7)", // Color RGBA
        boxShadow: "5px 5px 10px rgba(0, 0, 0, 0.3)", // String complejo
      }}
    >
      ¡Animando diferentes valores!
    </motion.div>
  );
}
```

**Explicación del ejemplo:**
Aquí vemos cómo `animate` puede manejar diferentes tipos de valores: un string con porcentaje para `width`, un color RGBA para `backgroundColor` y un string complejo para `boxShadow`.

#### 4. **Notas o advertencias:**

- Motion hace la magia de interpretar y animar estos diferentes tipos de valores sin que te preocupes por la conversión.
- ¡Experimenta con diferentes tipos de valores para crear efectos visuales interesantes!

## D - Conversión de Tipos de Valor

#### 1. **Definición:**

Normalmente, solo puedes animar entre valores del mismo tipo (ej: de `"0px"` a `"100px"`). Pero Motion es un poco más flexible, especialmente con colores y ciertas propiedades de tamaño y posición.

#### 2. **Conversiones automáticas:**

- **Colores:** Puedes animar libremente entre formatos hex, RGBA y HSLA. ¡Motion los convierte automáticamente!
- **`x`, `y`, `width`, `height`, `top`, `left`, `right`, `bottom`:** Estas propiedades pueden animarse entre diferentes tipos de valor. Por ejemplo, de porcentaje a píxeles.
- **`width` y `height` a `"auto"`:** Puedes animar el ancho y alto para que se ajusten automáticamente al contenido (`"auto"`).

#### 3. **Ejemplos:**

```jsx
import { motion } from "motion/react";

function ConversionesComponente() {
  return (
    <>
      <motion.div
        initial={{ x: "100%" }} // Valor inicial en porcentaje
        animate={{ x: "calc(100vw - 50%)" }} // Valor final con cálculo y vw
      >
        De porcentaje a cálculo con vw
      </motion.div>

      <motion.div
        initial={{ height: 0 }} // Altura inicial 0
        animate={{ height: "auto" }} // Altura final "auto"
      >
        Animando a altura automática
      </motion.div>
    </>
  );
}
```

**Explicación de los ejemplos:**

- El primer ejemplo muestra cómo `x` se anima desde un porcentaje (`"100%"`) a un cálculo que usa `vw` (viewport width).
- El segundo ejemplo anima `height` desde `0` hasta `"auto"`, haciendo que el elemento crezca para mostrar su contenido.

#### 4. **Nota importante sobre `display: none`:**

Si quieres animar `display` a `"none"`, es mejor usar `visibility: "hidden"` en su lugar. Elementos con `display: none` no tienen dimensiones, lo que puede causar problemas para las animaciones.

## E - Transforms (Transformaciones)

#### 1. **Definición:**

Las transforms son propiedades CSS que te permiten modificar la apariencia de un elemento: moverlo, escalarlo, rotarlo, inclinarlo, etc. Motion te da un control súper fino sobre cada transformación.

#### 2. **Transforms individuales en Motion:**

A diferencia del CSS normal, Motion te permite animar cada eje de transformación por separado:

- **Translate (posición):** `x`, `y`, `z` (horizontal, vertical, profundidad)
- **Scale (escala):** `scale`, `scaleX`, `scaleY` (escala uniforme, horizontal, vertical)
- **Rotate (rotación):** `rotate`, `rotateX`, `rotateY`, `rotateZ` (rotación en 2D, en eje X, Y, Z)
- **Skew (inclinación):** `skew`, `skewX`, `skewY` (inclinación general, horizontal, vertical)
- **Perspective (perspectiva):** `transformPerspective` (para efectos 3D)

#### 3. **Prop `style` mejorada:**

Los componentes `<motion />` tienen un prop `style` especial que te permite establecer transforms individuales directamente.

#### 4. **Ejemplos:**

```jsx
import { motion } from "motion/react";

function TransformsComponente() {
  return (
    <>
      <motion.section style={{ x: -20 }}>
        {" "}
        {/* Translate X */}
        Translate X con style
      </motion.section>

      <motion.button
        whileHover={{ scale: 1.1 }} // Escala al hacer hover
        whileTap={{ scale: 0.9 }} // Escala al hacer tap
      >
        Botón con escala interactiva
      </motion.button>

      <motion.li
        initial={{ transform: "translateX(-100px)" }} // Transform inicial CSS
        animate={{ transform: "translateX(0px)" }} // Transform final CSS
        transition={{ type: "spring" }} // Transición tipo spring
      >
        Lista con transform CSS y transición
      </motion.li>
    </>
  );
}
```

**Explicación de los ejemplos:**

- El primer ejemplo usa `style={{ x: -20 }}` para mover el elemento 20px a la izquierda.
- El botón usa `whileHover` y `whileTap` para cambiar la `scale` en interacciones.
- La lista muestra cómo usar `transform` directamente como en CSS, pero con la ventaja de las transiciones de Motion.

#### 5. **Nota para SVG:**

Para componentes SVG, usa `attrX` y `attrY` para animar los atributos `x` e `y` en lugar de las propiedades `style`.

## F - Transform Origin (Origen de Transformación)

#### 1. **Definición:**

`transform-origin` en CSS define el punto desde donde se aplican las transformaciones (rotación, escala, etc.). Motion te permite controlar y animar las partes del `transform-origin` por separado.

#### 2. **Propiedades shortcut:**

Motion tiene propiedades shortcut para `transform-origin`:

- `originX`
- `originY`
- `originZ`

Puedes animar cada una de estas individualmente.

#### 3. **Valores numéricos:**

Si usas números para `originX` e `originY`, se interpretan como un valor de progreso entre `0` y `1`. `0` es el inicio (izquierda/arriba) y `1` es el final (derecha/abajo). `originZ` por defecto usa píxeles.

#### 4. **Ejemplo:**

```jsx
import { motion } from "motion/react";

function OriginComponente() {
  return (
    <motion.div
      style={{ originX: 0.5, originY: 0.5 }} // Origen en el centro
      animate={{ rotate: 180 }} // Rotar desde el centro
      transition={{ duration: 2 }}
    >
      Rotando desde el centro
    </motion.div>
  );
}
```

**Explicación del ejemplo:**
Aquí, `originX: 0.5` y `originY: 0.5` centran el origen de la transformación. Luego, al rotar (`rotate: 180`), la rotación ocurre desde el centro del elemento.

## G - Variables CSS

#### 1. **Definición:**

Motion puede animar variables CSS y también usar variables CSS como destino para las animaciones. ¡Esto es genial para temas y animaciones dinámicas!

#### 2. **Animando variables CSS:**

Puedes animar el _valor_ de una variable CSS. Esto es útil para animar múltiples elementos hijos a la vez cambiando una sola variable en el padre.

#### 3. **Variables CSS como destino de animación:**

Puedes usar variables CSS como _destino_ en tu objeto `animate`. Motion entenderá que quieres animar la propiedad CSS que usa esa variable.

#### 4. **Ejemplos:**

```jsx
import { motion } from "motion/react";

function VariablesCSSComponente() {
  return (
    <motion.ul
      style={{ "--rotate": "0deg" }} // Variable CSS inicial
      initial={{ "--rotate": "0deg" }}
      animate={{ "--rotate": "360deg" }} // Animando la variable CSS
      transition={{ duration: 2, repeat: Infinity }}
    >
      <li style={{ transform: "rotate(var(--rotate))" }}>Item 1</li>
      <li style={{ transform: "rotate(var(--rotate))" }}>Item 2</li>
      <li style={{ transform: "rotate(var(--rotate))" }}>Item 3</li>
    </motion.ul>
  );
}
```

```jsx
import { motion } from "motion/react";

function VariableDestinoComponente() {
  return (
    <motion.li animate={{ backgroundColor: "var(--action-bg)" }}>
      {/* Usando variable CSS como destino */}
      Fondo con variable CSS
    </motion.li>
  );
}
```

**Explicación de los ejemplos:**

- El primer ejemplo anima la variable CSS `--rotate` en el `<ul>`. Los `<li>` hijos usan esta variable en su `transform`, así que todos rotan juntos.
- El segundo ejemplo usa `"var(--action-bg)"` como valor para `backgroundColor` en `animate`. Motion animará la propiedad `backgroundColor` al valor actual de la variable CSS `--action-bg`.

#### 5. **Nota de rendimiento:**

Animar variables CSS siempre dispara un "paint" (repintado) del navegador, lo cual puede ser menos eficiente que usar `MotionValue`s (que veremos más adelante) para este tipo de animaciones complejas.

## H - SVG Line Drawing (Dibujo de Líneas SVG)

#### 1. **Definición:**

Motion facilita animar el "dibujo" de líneas en SVG. Puedes hacer que las líneas SVG parezcan dibujarse o borrarse animando ciertas propiedades.

#### 2. **Propiedades especiales para SVG line drawing:**

- `pathLength`: Longitud total del camino SVG. Animando de `0` a `1` (progreso) hace que la línea parezca dibujarse.
- `pathSpacing`: Espaciado entre segmentos de la línea (menos común de animar).
- `pathOffset`: Desplazamiento del inicio del camino (también para efectos avanzados).

Estas propiedades se establecen como valores de progreso entre `0` y `1`, donde `1` representa la longitud total del camino.

#### 3. **Elementos SVG compatibles:**

Puedes usar estas animaciones con elementos SVG como: `<circle>`, `<ellipse>`, `<line>`, `<path>`, `<polygon>`, `<polyline>` y `<rect>`.

#### 4. **Ejemplo:**

```jsx
import { motion } from "motion/react";

function LineDrawingComponente() {
  return (
    <motion.svg width="200" height="200" viewBox="0 0 200 200">
      <motion.path
        d="M50 50 L150 50 L150 150 L50 150 Z" // Un cuadrado
        fill="none"
        stroke="blue"
        strokeWidth={5}
        initial={{ pathLength: 0 }} // Inicialmente sin línea
        animate={{ pathLength: 1 }} // Animar para dibujar la línea completa
      />
    </motion.svg>
  );
}
```

**Explicación del ejemplo:**
Animamos `pathLength` de `0` a `1` en un elemento `<motion.path>`. Esto hace que el cuadrado parezca dibujarse línea por línea.

## I - Transitions (Transiciones)

#### 1. **Definición:**

Las transitions controlan _cómo_ se realiza la animación. Definen la duración, la curva de easing (suavizado) y otros detalles de la animación.

#### 2. **Transiciones por defecto:**

Motion es inteligente y aplica transiciones por defecto que suelen ser adecuadas. Por ejemplo, para propiedades físicas como `x` o `scale`, usa animaciones tipo "spring" (resorte). Para `opacity` o `color`, usa curvas de easing basadas en duración.

#### 3. **Prop `transition`:**

Si quieres personalizar la transición, usa el prop `transition`.

#### 4. **Opciones comunes en `transition`:**

- `ease`: Define la curva de easing. Puedes usar nombres como `"easeOut"`, `"easeInOut"`, o funciones de easing personalizadas.
- `duration`: Duración de la animación en segundos.

#### 5. **Ejemplo:**

```jsx
import { motion } from "motion/react";

function TransitionComponente() {
  return (
    <motion.div
      animate={{ x: 100 }} // Animar la posición X
      transition={{ ease: "easeOut", duration: 2 }} // Transición personalizada
    >
      Animación con transición easeOut y duración de 2 segundos
    </motion.div>
  );
}
```

**Explicación del ejemplo:**
Aquí, `transition={{ ease: "easeOut", duration: 2 }}` define que la animación de `x` use una curva de easing "easeOut" y dure 2 segundos.

## J - Enter Animations (Animaciones de Entrada)

#### 1. **Definición:**

Las enter animations son las animaciones que ocurren cuando un componente `<motion />` aparece por primera vez en la pantalla (se monta en el DOM).

#### 2. **Comportamiento por defecto:**

Cuando un componente `<motion />` se crea, automáticamente se anima desde su estado inicial (ya sea definido en CSS o con el prop `initial`) hacia los valores definidos en `animate`.

#### 3. **Prop `initial`:**

- Puedes usar `initial` para definir los valores iniciales _antes_ de que comience la animación de entrada.
- Si no defines `initial`, Motion usará los valores iniciales que tenga el elemento por defecto (o definidos en CSS).

#### 4. **Desactivar la animación de entrada:**

Si no quieres animación de entrada, usa `initial={false}`. El componente se renderizará directamente con los valores de `animate`.

#### 5. **Ejemplos:**

```jsx
import { motion } from "motion/react";

function EnterAnimationComponente() {
  return (
    <>
      <motion.li
        initial={{ opacity: 0, scale: 0 }} // Estado inicial: invisible y pequeño
        animate={{ opacity: 1, scale: 1 }} // Animar a visible y tamaño normal
      >
        Lista con animación de entrada
      </motion.li>

      <motion.div
        initial={false} // Desactivar animación de entrada
        animate={{ y: 100 }} // Renderizar directamente con y: 100
      >
        Sin animación de entrada, renderizado directo
      </motion.div>
    </>
  );
}
```

**Explicación de los ejemplos:**

- El primer ejemplo anima la opacidad y la escala desde `0` a `1` al montarse el `<li>`.
- El segundo ejemplo usa `initial={false}` para que el `<div>` se renderice directamente con `y: 100` sin animación de entrada.

## K - Exit Animations (Animaciones de Salida)

#### 1. **Definición:**

Las exit animations son las animaciones que ocurren cuando un componente `<motion />` desaparece de la pantalla (se desmonta del DOM).

#### 2. **Componente `<AnimatePresence />`:**

Para animar la salida, necesitas envolver los componentes que quieres animar al desaparecer con el componente `<AnimatePresence />` de Motion. `<AnimatePresence />` mantiene el componente en el DOM durante la animación de salida.

#### 3. **Prop `exit`:**

Dentro de `<motion.div>` (o el componente que estés animando dentro de `<AnimatePresence />`), usa el prop `exit` para definir la animación de salida.

#### 4. **Prop `key`:**

Es importante dar a los componentes dentro de `<AnimatePresence />` un prop `key` único, especialmente si renderizas listas o componentes condicionalmente. Esto ayuda a React y Motion a identificar correctamente qué componente está entrando o saliendo.

#### 5. **Ejemplo:**

```jsx
import { motion, AnimatePresence } from "motion/react";
import { useState } from "react";

function ExitAnimationComponente() {
  const [isVisible, setIsVisible] = useState(true);

  return (
    <>
      <button onClick={() => setIsVisible(!isVisible)}>
        {isVisible ? "Ocultar" : "Mostrar"} Modal
      </button>

      <AnimatePresence>
        {isVisible && (
          <motion.div
            key="modal" // Key única para AnimatePresence
            initial={{ opacity: 0 }} // Animación de entrada
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }} // Animación de salida
            style={{
              position: "fixed",
              top: 50,
              left: "50%",
              transform: "translateX(-50%)",
              padding: 20,
              background: "white",
              border: "1px solid black",
            }}
          >
            ¡Soy un modal animado!
          </motion.div>
        )}
      </AnimatePresence>
    </>
  );
}
```

**Explicación del ejemplo:**

- `<AnimatePresence>` envuelve el `motion.div` del modal.
- `key="modal"` es importante para que `<AnimatePresence>` rastree el modal.
- `exit={{ opacity: 0 }}` define que al desaparecer, el modal se anime a opacidad 0.

## L - Keyframes (Keyframes o fotogramas clave)

#### 1. **Definición:**

En lugar de animar de un valor inicial a un valor final, puedes animar a través de una secuencia de valores usando keyframes. Esto te permite crear animaciones más complejas con múltiples etapas.

#### 2. **Array en `animate`:**

Para usar keyframes, define el valor de la propiedad en `animate` como un array de valores. Motion animará a través de estos valores en secuencia.

#### 3. **`null` como keyframe inicial:**

Puedes usar `null` como el primer valor en el array de keyframes. Esto significa "usar el estado actual como el primer keyframe". Es útil para que las animaciones se sientan más naturales si interrumpen otras animaciones.

#### 4. **Opción `times` en `transition`:**

Por defecto, los keyframes se espacian uniformemente en la duración de la animación. Con la opción `times` en `transition`, puedes personalizar el tiempo en el que ocurre cada keyframe.

- `times` es un array de valores de progreso entre `0` y `1`. Cada valor corresponde a la posición de un keyframe en la animación.

#### 5. **Ejemplos:**

```jsx
import { motion } from "motion/react";

function KeyframesComponente() {
  return (
    <>
      <motion.div animate={{ x: [0, 100, 0] }}>
        {" "}
        {/* Keyframes para x */}
        Animación de ida y vuelta en X
      </motion.div>

      <motion.div animate={{ x: [null, 100, 0] }}>
        {" "}
        {/* null como primer keyframe */}
        Keyframe inicial nulo
      </motion.div>

      <motion.svg width={600} height={200} viewBox="0 0 600 200">
        <motion.circle
          cx={500}
          cy={100}
          r={50}
          fill="red"
          animate={{
            cx: [null, 100, 200], // Keyframes para cx
            transition: { duration: 3, times: [0, 0.2, 1] }, // tiempos personalizados
          }}
        />
      </motion.svg>
    </>
  );
}
```

**Explicación de los ejemplos:**

- El primer ejemplo anima `x` a `0`, luego a `100`, y luego de vuelta a `0`.
- El segundo ejemplo usa `null` como primer keyframe para `x`.
- El tercer ejemplo usa `times: [0, 0.2, 1]` para que el segundo keyframe (cx: 100) ocurra al 20% de la duración total (3 segundos).

## M - Gesture Animations (Animaciones de Gestos)

#### 1. **Definición:**

Motion tiene props shortcut para crear animaciones que se activan con gestos del usuario (hover, click, drag, etc.). Esto hace que sea muy fácil crear interacciones animadas.

#### 2. **Props de gestos:**

- `whileHover`: Animación mientras el mouse está sobre el elemento.
- `whileTap`: Animación mientras se hace click (o tap) en el elemento.
- `whileDrag`: Animación mientras se arrastra el elemento.
- `whileFocus`: Animación cuando el elemento tiene el foco (por ejemplo, un input).
- `whileInView`: Animación cuando el elemento entra en el viewport (la parte visible de la pantalla).

#### 3. **Ejemplo:**

```jsx
import { motion } from "motion/react";

function GesturesComponente() {
  return (
    <motion.button
      initial={{ opacity: 0 }} // Inicialmente invisible
      whileHover={{ backgroundColor: "rgba(220, 220, 220, 1)" }} // Gris al hover
      whileTap={{ backgroundColor: "rgba(255, 255, 255, 1)" }} // Blanco al tap
      whileInView={{ opacity: 1 }} // Visible al entrar en viewport
    >
      Botón interactivo
    </motion.button>
  );
}
```

**Explicación del ejemplo:**
Este botón tiene diferentes animaciones para diferentes gestos:

- Inicialmente es invisible (`opacity: 0`).
- Se vuelve gris al hacer hover (`whileHover`).
- Se vuelve blanco al hacer tap (`whileTap`).
- Se hace visible cuando entra en el viewport (`whileInView`).

## N - Variants (Variantes)

#### 1. **Definición:**

Las variants son conjuntos de estilos de animación con nombres. Son muy útiles para organizar y reutilizar animaciones, especialmente en componentes complejos y para orquestar animaciones en grupos de elementos.

#### 2. **Objeto `variants`:**

Defines un objeto `variants` donde cada propiedad es el nombre de una variante (ej: `"visible"`, `"hidden"`) y el valor es un objeto de estilos de animación (como el que usas en `animate`).

#### 3. **Prop `variants` en `<motion />`:**

Pasa tu objeto `variants` al prop `variants` de tu componente `<motion />`.

#### 4. **Usando variantes con `animate`:**

Ahora puedes referirte a las variantes por su nombre en el prop `animate`. Por ejemplo, `animate="visible"` aplicará los estilos definidos en la variante `"visible"`.

#### 5. **Arrays de variantes:**

Puedes usar un array de nombres de variantes en `animate`. Motion aplicará todas las variantes en el array.

#### 6. **Ejemplo básico:**

```jsx
import { motion } from "motion/react";

const variants = {
  visible: { opacity: 1 },
  hidden: { opacity: 0 },
};

function VariantsBasicoComponente() {
  return (
    <motion.div
      variants={variants} // Pasar el objeto variants
      initial="hidden" // Variante inicial
      animate="visible" // Variante para animar
    >
      Soy un div con variantes
    </motion.div>
  );
}
```

**Explicación del ejemplo:**

- Definimos un objeto `variants` con dos variantes: `"visible"` y `"hidden"`.
- Pasamos `variants` al `<motion.div>`.
- `initial="hidden"` establece que al inicio se use la variante `"hidden"`.
- `animate="visible"` anima a la variante `"visible"`.

## O - Propagation (Propagación de Variantes)

#### 1. **Definición:**

Las variants se propagan hacia abajo a través de los componentes `<motion />` hijos. Esto significa que si un componente padre tiene una variante activa, sus hijos también pueden reaccionar a esa variante.

#### 2. **Orquestación de animaciones en listas y grupos:**

La propagación de variants es muy poderosa para orquestar animaciones en listas, menús y otros grupos de elementos. Puedes controlar la animación de todo un grupo desde el componente padre.

#### 3. **Ejemplo de lista animada:**

```jsx
import { motion } from "motion/react";

const list = {
  visible: { opacity: 1 },
  hidden: { opacity: 0 },
};

const item = {
  visible: { opacity: 1, x: 0 },
  hidden: { opacity: 0, x: -100 },
};

function PropagationComponente() {
  return (
    <motion.ul
      initial="hidden"
      whileInView="visible"
      variants={list} // Variants para el UL (contenedor)
    >
      <motion.li variants={item}>
        {" "}
        {/* Variants para los LI (items) */}
        Item 1
      </motion.li>
      <motion.li variants={item}>Item 2</motion.li>
      <motion.li variants={item}>Item 3</motion.li>
    </motion.ul>
  );
}
```

**Explicación del ejemplo:**

- El `<ul>` tiene variants `list` que controlan la opacidad general.
- Cada `<li>` tiene variants `item` que controlan su opacidad y posición X.
- Cuando el `<ul>` entra en el viewport (`whileInView="visible"`), se activa la variante `"visible"` en el `<ul>`.
- Debido a la propagación, los `<li>` hijos también reaccionan a la variante `"visible"` del padre y aplican sus propias variantes `item.visible`.

## P - Orchestration (Orquestación de Animaciones con Variantes)

#### 1. **Definición:**

La orquestación te permite controlar _cuándo_ empiezan las animaciones de los hijos en relación con la animación del padre. Con variants, tienes acceso a props de `transition` especiales para orquestación.

#### 2. **Props de `transition` para orquestación:**

- `when`: Controla _cuándo_ empiezan las animaciones de los hijos en relación con la animación del padre. Valores: `"beforeChildren"` (hijos animan antes), `"afterChildren"` (hijos animan después).
- `delayChildren`: Retraso (en segundos) antes de que empiecen las animaciones de los hijos.
- `staggerChildren`: Intervalo de tiempo (en segundos) entre el inicio de la animación de cada hijo. Crea un efecto de "cascada" o "onda".
- `staggerDirection`: Dirección del stagger. Valores: `1` (adelante, por defecto), `-1` (atrás).

#### 3. **Ejemplo de lista con stagger:**

```jsx
import { motion } from "motion/react";

const listOrchestration = {
  visible: {
    opacity: 1,
    transition: {
      when: "beforeChildren", // Padre anima antes que hijos
      staggerChildren: 0.3, // Stagger de 0.3 segundos entre hijos
    },
  },
  hidden: {
    opacity: 0,
    transition: {
      when: "afterChildren", // Padre anima después de hijos (en salida)
    },
  },
};

const itemOrchestration = {
  visible: { opacity: 1, x: 0 },
  hidden: { opacity: 0, x: -100 },
};

function OrchestrationComponente() {
  return (
    <motion.ul
      initial="hidden"
      whileInView="visible"
      variants={listOrchestration} // Variants con orquestación
    >
      <motion.li variants={itemOrchestration}>Item 1</motion.li>
      <motion.li variants={itemOrchestration}>Item 2</motion.li>
      <motion.li variants={itemOrchestration}>Item 3</motion.li>
    </motion.ul>
  );
}
```

**Explicación del ejemplo:**

- En `listOrchestration.visible.transition`:
  - `when: "beforeChildren"` hace que la animación del `<ul>` (opacidad) empiece _antes_ de las animaciones de los `<li>` hijos.
  - `staggerChildren: 0.3` retrasa el inicio de la animación de cada `<li>` hijo en 0.3 segundos, creando un efecto de stagger.
- `when: "afterChildren"` en `listOrchestration.hidden.transition` haría que la animación de salida del `<ul>` (opacidad a 0) ocurra _después_ de que los hijos terminen sus animaciones de salida (si las tuvieran).

## Q - Dynamic Variants (Variantes Dinámicas)

#### 1. **Definición:**

Las variants pueden ser funciones en lugar de objetos de estilo estáticos. Estas funciones se ejecutan cuando la variante se activa y reciben un argumento `custom` que puedes pasar al componente `<motion />`.

#### 2. **Funciones variant:**

Define cada variante como una función que retorna un objeto de estilos de animación.

#### 3. **Prop `custom`:**

Pasa un valor al prop `custom` del componente `<motion />`. Este valor se pasará como el primer argumento a la función variant.

#### 4. **Uso para animaciones personalizadas por elemento:**

Las variantes dinámicas son útiles para crear animaciones que varían para cada elemento en una lista o grupo, basadas en su índice, datos, etc.

#### 5. **Ejemplo de stagger dinámico con índice:**

```jsx
import { motion } from "motion/react";

const variantsDynamic = {
  hidden: { opacity: 0 },
  visible: (index) => ({
    // Variante visible es una función
    opacity: 1,
    transition: { delay: index * 0.3 }, // Retraso dinámico basado en index
  }),
};

function DynamicVariantsComponente() {
  const items = ["Item 1", "Item 2", "Item 3"];

  return (
    <ul>
      {items.map((item, index) => (
        <motion.li
          key={index}
          custom={index} // Pasar el índice como custom
          variants={variantsDynamic} // Usar variantes dinámicas
          initial="hidden"
          animate="visible"
        >
          {item}
        </motion.li>
      ))}
    </ul>
  );
}
```

**Explicación del ejemplo:**

- `variantsDynamic.visible` es una función que recibe `index` como argumento.
- El `transition.delay` se calcula dinámicamente como `index * 0.3`, creando un stagger que aumenta con el índice del item.
- En el `map`, pasamos `custom={index}` a cada `<motion.li>`. Este `index` se pasa a la función `variantsDynamic.visible`.

## R - Animation Controls (Controles de Animación)

#### 1. **Definición:**

Normalmente, las animaciones en Motion son declarativas (se basan en props como `animate`, `whileHover`, etc.). Pero a veces necesitas control manual sobre la reproducción de las animaciones: iniciar, pausar, detener, controlar el tiempo, etc. Para esto, Motion ofrece Animation Controls.

#### 2. **Hook `useAnimate`:**

El hook `useAnimate()` te da control manual sobre las animaciones. Retorna un array con dos elementos:

- `scope`: Una referencia (ref) que debes asignar al elemento o contenedor que quieres animar.
- `animate`: Una función que usas para definir y controlar las animaciones.

#### 3. **Función `animate()`:**

La función `animate()` recibe un array de animaciones. Cada animación en el array es un array con dos elementos:

- El primer elemento es el _selector_ del elemento a animar. Puede ser:
  - `scope.current`: Para animar el elemento al que se asignó la ref `scope`.
  - Un selector CSS (string): Para animar elementos dentro del scope (ej: `"li"`, `".my-class"`).
- El segundo elemento es el objeto de estilos de animación (como en `animate` prop).

`animate()` retorna un objeto `controls` que tiene métodos para controlar la animación: `play()`, `pause()`, `stop()`, `speed`, `time`, etc.

#### 4. **Ejemplo con `useAnimate`:**

```jsx
import { useAnimate } from "motion/react";
import { useEffect, useRef } from "react";

function AnimationControlsComponente() {
  const [scope, animate] = useAnimate(); // Hook useAnimate

  useEffect(() => {
    const controls = animate([
      // Función animate
      [scope.current, { x: "100%" }], // Animar el UL (scope.current)
      ["li", { opacity: 1 }], // Animar todos los LI dentro del scope
    ]);

    controls.speed = 0.8; // Reducir la velocidad de la animación

    return () => controls.stop(); // Detener la animación al desmontar
  }, []);

  return (
    <ul ref={scope}>
      {" "}
      {/* Asignar la ref scope al UL */}
      <li>Item 1</li>
      <li>Item 2</li>
      <li>Item 3</li>
    </ul>
  );
}
```

**Explicación del ejemplo:**

- `useAnimate()` nos da `scope` y `animate`.
- Asignamos `ref={scope}` al `<ul>`.
- En `useEffect`, llamamos a `animate()` con un array de dos animaciones:
  - La primera anima `scope.current` (el `<ul>`) moviéndolo 100% a la derecha.
  - La segunda anima todos los `"li"` dentro del `scope` a `opacity: 1`.
- `controls.speed = 0.8` reduce la velocidad de la animación.
- `controls.stop()` detiene la animación al desmontar el componente.

## S - Animate Content (Animar Contenido de Texto)

#### 1. **Definición:**

Motion te permite animar directamente el _contenido de texto_ de un componente `<motion />` de forma muy eficiente. En lugar de re-renderizar el componente con React state para cada valor animado, Motion actualiza el `innerHTML` directamente.

#### 2. **`MotionValue` como hijo:**

Para animar el contenido de texto, pasa un `MotionValue` (un valor animado de Motion) como hijo del componente `<motion />`. Motion renderizará el valor actual del `MotionValue` en el HTML.

#### 3. **Hook `useMotionValue` y función `animate`:**

- Usa `useMotionValue(valorInicial)` para crear un `MotionValue` con un valor inicial.
- Usa la función `animate(motionValue, valorFinal, opciones)` para animar el `MotionValue`.

#### 4. **Ejemplo de contador animado:**

```jsx
import { useMotionValue, motion, animate } from "motion/react";
import { useEffect } from "react";

function AnimateContentComponente() {
  const count = useMotionValue(0); // MotionValue inicializado en 0

  useEffect(() => {
    const controls = animate(count, 100, { duration: 5 }); // Animar count a 100
    return () => controls.stop();
  }, []);

  return <motion.pre>{count}</motion.pre>; // MotionValue como hijo
}
```

**Explicación del ejemplo:**

- `useMotionValue(0)` crea un `MotionValue` llamado `count` con valor inicial `0`.
- `animate(count, 100, { duration: 5 })` anima `count` desde `0` hasta `100` en 5 segundos.
- `<motion.pre>{count}</motion.pre>` renderiza el valor actual de `count` dentro del `<pre>`. A medida que `count` se anima, el número en el `<pre>` se actualiza directamente en el DOM.

#### 5. **Ventaja de rendimiento:**

Animar el contenido de texto con `MotionValue` es más eficiente que usar React state porque evita re-renderizados innecesarios del componente. Motion manipula el DOM directamente para actualizar el texto.
