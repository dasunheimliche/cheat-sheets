## A - Animaciones de Layout Básicas con `layout`

#### 1. **Definición:**

La propiedad `layout` es como magia ✨. Simplemente añádela a un componente `<motion.div>` y Motion se encargará de animar cualquier cambio en el layout de ese componente. ¡Incluso cosas que normalmente no se pueden animar con CSS!

#### 2. **Ejemplo:**

```jsx
<motion.div layout />
```

**Explicación del ejemplo:**
Con solo añadir `layout`, este `div` se animará suavemente cuando cambie su tamaño, posición o cualquier otra propiedad de layout debido a cambios en tu código React.

#### 3. **Notas o advertencias:**

- ¡Es súper sencillo! Solo necesitas la prop `layout`.
- Funciona con casi cualquier cambio de CSS que afecte al layout.

## B - Animando Propiedades CSS "Inanimables"

#### 1. **Definición:**

Normalmente, algunas propiedades de CSS como `flex-direction` o `grid-template-columns` no se pueden animar directamente con transiciones CSS. ¡Pero con `layout` de Motion, sí que puedes! Motion usa trucos bajo la manga para que estas animaciones sean posibles y fluidas.

#### 2. **Ejemplo:**

```jsx
import { motion } from "framer-motion";
import { useState } from "react";

function EjemploJustifyContent() {
  const [isOn, setIsOn] = useState(false);

  return (
    <motion.div
      layout
      style={{ justifyContent: isOn ? "flex-start" : "flex-end" }}
      onClick={() => setIsOn(!isOn)}
      style={{
        width: 200,
        height: 50,
        background: "lightblue",
        display: "flex",
      }}
    >
      Haz click aquí
    </motion.div>
  );
}
```

**Explicación del ejemplo:**
Aquí, al hacer clic en el `div`, cambiamos `justifyContent` entre `flex-start` y `flex-end`. ¡Normalmente esto no se animaría, pero con `layout`, mira cómo se mueve el contenido suavemente!

#### 3. **Notas o advertencias:**

- ¡Di adiós a las limitaciones de las transiciones CSS tradicionales!
- Ideal para animaciones de layout complejas y cambios de estructura.

## C - Animaciones Compartidas con `layoutId`

#### 1. **Definición:**

`layoutId` es como darle una "identidad única" a un elemento. Si tienes dos elementos con el mismo `layoutId` que aparecen y desaparecen, Motion puede animar la transición entre ellos como si fueran el mismo elemento moviéndose entre dos estados. ¡Es perfecto para crear transiciones avanzadas y efectos de "hero animation"!

#### 2. **Ejemplo:**

```jsx
<motion.li layoutId="item" />
```

**Explicación del ejemplo:**
Imagina que tienes una lista de elementos y al hacer clic en uno, quieres que se "transforme" en un modal. Usando el mismo `layoutId` en el elemento de la lista y en el modal, Motion animará esta transformación de forma fluida.

#### 3. **Notas o advertencias:**

- `layoutId` conecta elementos visualmente relacionados a través del tiempo.
- Ideal para microinteracciones y transiciones de página completas.

## D - Usando `layout` con Re-renders de React y `style`

#### 1. **Definición:**

Las animaciones de layout con `layout` se activan cuando React re-renderiza un componente y detecta cambios en su layout. Es importante que los cambios de CSS que quieres animar se hagan directamente a través de la prop `style`, no con `animate`. `layout` se encargará de la animación por ti.

#### 2. **Ejemplo:**

```jsx
import { motion } from "framer-motion";
import { useState } from "react";

function EjemploAnchoAnimado() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <motion.div
      layout
      style={{ width: isOpen ? "80vw" : 0, background: "lightcoral" }}
      onClick={() => setIsOpen(!isOpen)}
      style={{ height: 50, overflow: "hidden" }}
    >
      {isOpen ? "Cerrar" : "Abrir"}
    </motion.div>
  );
}
```

**Explicación del ejemplo:**
Aquí, el ancho del `div` cambia entre `0` y `80vw` cuando `isOpen` cambia. Usamos `style` para definir el ancho y `layout` para animar ese cambio. ¡Fíjate que no usamos `animate` para el ancho!

#### 3. **Notas o advertencias:**

- Usa `style` para los cambios de CSS que quieres animar con `layout`.
- `layout` detecta cambios en `width`, `height`, columnas de grid, reordenamiento de listas, añadir/eliminar elementos, ¡y más!

## E - Animaciones de Layout Compartidas y `AnimatePresence`

#### 1. **Definición:**

Cuando usas `layoutId` para animaciones compartidas, y quieres que un elemento que desaparece se anime _de vuelta_ a su layout original, `AnimatePresence` es tu amigo. `AnimatePresence` mantiene el componente en el DOM hasta que su animación de salida termine, asegurando una transición suave.

#### 2. **Ejemplo:**

```jsx
import { motion, AnimatePresence } from "framer-motion";
import { useState } from "react";

function EjemploModal() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <button onClick={() => setIsOpen(true)}>Abrir Modal</button>
      <AnimatePresence>
        {isOpen && (
          <motion.div
            layoutId="modal"
            style={{
              position: "fixed",
              top: 50,
              left: "25%",
              width: "50%",
              height: 200,
              background: "lightgreen",
            }}
            exit={{ opacity: 0, scale: 0.5 }}
            onClick={() => setIsOpen(false)}
          />
        )}
      </AnimatePresence>
    </>
  );
}
```

**Explicación del ejemplo:**
Aquí, el `motion.div` con `layoutId="modal"` aparece y desaparece. `AnimatePresence` asegura que cuando desaparece, se anime correctamente en lugar de simplemente desaparecer de golpe. Definimos una animación de `exit` para controlar cómo se va.

#### 3. **Notas o advertencias:**

- `AnimatePresence` es crucial para animaciones de salida fluidas en animaciones compartidas.
- Combina `AnimatePresence` con `layoutId` para transiciones de entrada y salida completas.

## F - Personalizando Transiciones con `transition`

#### 1. **Definición:**

Puedes controlar cómo se animan las animaciones de layout usando la prop `transition`. Puedes definir una transición general para todas las animaciones, o una transición específica solo para las animaciones de `layout`.

#### 2. **Ejemplo:**

```jsx
<motion.div layout transition={{ duration: 0.3 }} />
```

**Explicación del ejemplo:**
Este `div` con `layout` tendrá una animación de layout que dura 0.3 segundos.

#### 3. **Ejemplo con transición de layout específica:**

```jsx
<motion.div
  layout
  animate={{ opacity: 0.5 }}
  transition={{
    default: { ease: "linear" }, // Transición por defecto para otras animaciones
    layout: { duration: 0.3 }, // Transición específica para layout
  }}
/>
```

**Explicación del ejemplo:**
Aquí, la opacidad se anima con una transición lineal, pero la animación de layout tiene una duración específica de 0.3 segundos.

#### 4. **Transiciones en Animaciones Compartidas:**

En animaciones compartidas, la transición que se usa es la del elemento _al que se anima_, no del elemento original.

```jsx
import { motion, AnimatePresence } from "framer-motion";
import { useState } from "react";

function EjemploTransicionCompartida() {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <>
      <motion.button
        layoutId="modal"
        onClick={() => setIsOpen(true)}
        transition={{ type: "spring" }} // Esta NO se usa al abrir el modal
      >
        Abrir
      </motion.button>
      <AnimatePresence>
        {isOpen && (
          <motion.dialog
            layoutId="modal"
            open
            transition={{ duration: 0.3 }} // ¡Esta transición se usa al abrir!
            style={{
              position: "fixed",
              top: 50,
              left: "25%",
              width: "50%",
              height: 200,
              background: "lightgreen",
            }}
            onClose={() => setIsOpen(false)}
          />
        )}
      </AnimatePresence>
    </>
  );
}
```

**Explicación del ejemplo:**
Cuando el modal se abre, se usa la transición definida en `<motion.dialog>`. Cuando se cierra (y vuelve al botón), se usaría la transición en `<motion.button>` (si estuviera definida para la animación de cierre).

#### 5. **Notas o advertencias:**

- Usa `transition` para personalizar la duración, easing, y otros parámetros de la animación de layout.
- `transition.layout` te permite ser específico con las animaciones de layout.
- En animaciones compartidas, ¡piensa en la transición del elemento destino!

## G - Animando Dentro de Elementos Scrollables con `layoutScroll`

#### 1. **Definición:**

Si tienes animaciones de layout dentro de un elemento con `overflow: scroll`, necesitas añadir la prop `layoutScroll` al elemento scrollable. Esto le dice a Motion que tenga en cuenta el desplazamiento del scroll al medir la posición de los elementos hijos.

#### 2. **Ejemplo:**

```jsx
<motion.div layoutScroll style={{ overflow: "scroll", height: 200 }}>
  {/* ... contenido animado ... */}
</motion.div>
```

**Explicación del ejemplo:**
Al añadir `layoutScroll` al `div` con `overflow: scroll`, las animaciones de layout dentro de este `div` funcionarán correctamente, incluso si el usuario ha hecho scroll.

#### 3. **Notas o advertencias:**

- Imprescindible para animaciones de layout en contenedores scrollables.
- Asegura que Motion mida correctamente las posiciones relativas al scroll.

## H - Animando Dentro de Contenedores Fijos con `layoutRoot`

#### 1. **Definición:**

Similar a `layoutScroll`, si tienes animaciones de layout dentro de un elemento con `position: fixed`, necesitas usar `layoutRoot`. Esto le indica a Motion que considere el desplazamiento de la página completa al medir las posiciones de los hijos.

#### 2. **Ejemplo:**

```jsx
<motion.div
  layoutRoot
  style={{ position: "fixed", top: 0, left: 0, width: "100%", height: "100%" }}
>
  {/* ... contenido animado ... */}
</motion.div>
```

**Explicación del ejemplo:**
Con `layoutRoot` en el `div` fijo, las animaciones de layout dentro funcionarán bien, incluso si la página principal tiene scroll.

#### 3. **Notas o advertencias:**

- Necesario para animaciones de layout en elementos con `position: fixed`.
- Motion tendrá en cuenta el scroll de la página para mediciones precisas.

## I - Animaciones de Layout en Grupo con `LayoutGroup`

#### 1. **Definición:**

Normalmente, las animaciones de layout se activan cuando un componente se re-renderiza y su propio layout cambia. Pero, ¿qué pasa si tienes varios componentes que afectan el layout de los demás pero no se re-renderizan al mismo tiempo? `LayoutGroup` sincroniza las animaciones de layout entre múltiples componentes.

#### 2. **Ejemplo:**

```jsx
import { motion, LayoutGroup } from "framer-motion";
import { useState } from "react";

function Acordeon() {
  const [isOpen, setOpen] = useState(false);
  return (
    <motion.div
      layout
      style={{
        height: isOpen ? "auto" : "50px",
        overflow: "hidden",
        background: "lightyellow",
        padding: 10,
        marginBottom: 10,
      }}
      onClick={() => setOpen(!isOpen)}
    >
      Haz click para {isOpen ? "cerrar" : "abrir"}
      <motion.div layout style={{ padding: 10, background: "yellow" }}>
        {isOpen && "¡Contenido del acordeón!"}
      </motion.div>
    </motion.div>
  );
}

function ListaDeAcordeones() {
  return (
    <LayoutGroup>
      <Acordeon />
      <Acordeon />
    </LayoutGroup>
  );
}
```

**Explicación del ejemplo:**
En este ejemplo, si no usáramos `LayoutGroup`, al abrir un acordeón, el otro no se animaría para ajustarse al espacio. `LayoutGroup` hace que ambos acordeones se animen juntos de forma coordinada.

#### 3. **Notas o advertencias:**

- Usa `LayoutGroup` cuando tengas componentes que dependan del layout de otros y necesiten animarse juntos.
- Sincroniza animaciones de layout en grupos de componentes relacionados.

## J - Corrección de Escala (Scale Correction)

#### 1. **Definición:**

Motion usa `transform: scale` para animar el layout, lo cual es muy eficiente. Pero a veces, esto puede distorsionar visualmente los elementos hijos. Para corregir esto, puedes añadir `layout` también a los _primeros_ elementos hijos del componente animado.

#### 2. **Ejemplo:**

```jsx
<motion.section layout>
  <motion.img layout src="imagen.jpg" />
</motion.section>
```

**Explicación del ejemplo:**
Al añadir `layout` al `motion.img` dentro del `motion.section` con `layout`, la imagen se ajustará correctamente durante la animación de escala del `section`, evitando distorsiones.

#### 3. **Corrección Automática de `boxShadow` y `borderRadius`:**

Motion también corrige automáticamente la distorsión de `boxShadow` y `borderRadius` durante las animaciones de escala, ¡siempre y cuando los definas como motion values o en `style`!

```jsx
<motion.div
  layout
  style={{ borderRadius: 20, boxShadow: "0px 5px 10px rgba(0, 0, 0, 0.3)" }}
/>
```

#### 4. **Notas o advertencias:**

- Añade `layout` a los hijos para corregir distorsiones visuales por la animación de escala.
- Motion corrige automáticamente `boxShadow` y `borderRadius` si se definen en `style`.

## K - Troubleshooting: Problemas Comunes y Soluciones

#### 1. **El componente no se anima:**

- **Asegúrate de que `display` no sea `inline`:** Los navegadores no aplican `transform` a elementos `inline`. Usa `display: block` o `display: inline-block`.
- **Verifica que el componente se re-renderice:** La animación de layout se activa con re-renders. Asegúrate de que el estado o las props que controlan el layout estén cambiando y causando un re-render.

#### 2. **Animaciones de Layout en SVG rotas:**

- **SVG no soportado directamente:** Las animaciones de layout no funcionan directamente en componentes SVG. Anima directamente atributos SVG como `cx`, `cy`, `x`, `y`, etc.

#### 3. **El contenido se estira de forma no deseada:**

- **Usa `layout` en los hijos:** Como vimos en "Corrección de Escala", añadir `layout` a los elementos hijos a menudo soluciona este problema.
- **Considera `layout="position"`:** Para elementos como imágenes o texto que cambian de aspect ratio, `layout="position"` puede funcionar mejor.

#### 4. **`borderRadius` o `boxShadow` se comportan de forma extraña:**

- **Asegúrate de definirlos en `style`:** Motion corrige la distorsión de escala en estas propiedades solo si están definidas en la prop `style`.

#### 5. **El borde (border) se ve estirado durante la animación:**

- **Evita animar `border` directamente:** Animar `border` es ineficiente y limita la corrección de escala.
- **Usa un "borde falso" con padding:** Reemplaza `border` con un elemento padre con `padding` que actúe como borde.

```jsx
<motion.div layout style={{ borderRadius: 10, padding: 5 }}>
  <motion.div layout style={{ borderRadius: 5, background: "white" }} />
</motion.div>
```

## L - Diferencias con la View Transitions API

#### 1. **Beneficios de la View Transitions API (Nativa del Navegador):**

- **Incluida en el navegador:** No necesitas añadir una librería, ¡ya está ahí!
- **Sistema de rendering único:** Toma capturas de pantalla de la página anterior y las mezcla con la nueva página.

#### 2. **Drawbacks de la View Transitions API vs. Layout Animations de Motion:**

- **No interrumpible:** Las animaciones no se pueden interrumpir suavemente.
- **Bloquea la interacción:** Los elementos animados se superponen y bloquean los eventos del ratón.
- **Difícil de manejar `layoutId`s:** Más restrictivo que Motion en el uso de `layoutId`.
- **Menos performante:** Usa `width`/`height` en lugar de `transform`, menos eficiente para muchas animaciones.
- **No tiene en cuenta el scroll:** Problemas si el scroll de la página cambia durante la transición.
- **Sin animaciones relativas:** Problemas con delays en elementos anidados.
- **Una animación a la vez:** Dificultad para combinar con otras animaciones.

#### 3. **En resumen:**

- **View Transitions API:** Buena para transiciones simples y efectos de página completa.
- **Layout Animations de Motion:** Más potente, flexible y performante para animaciones de layout complejas y microinteracciones.
