## A - Transition

#### 1. **Definición:**

Una `transition` (transición) define el tipo de animación que se utiliza cuando cambias de un valor a otro en tus animaciones. Imagina que es como elegir un estilo de movimiento para tus elementos cuando se animan.

#### 2. **Ejemplo:**

```jsx
const transition = {
  duration: 0.8, // Duración de la animación en segundos
  delay: 0.5,    // Retraso antes de que empiece la animación en segundos
  ease: [0, 0.71, 0.2, 1.01], // Curva de aceleración personalizada
}

// Componente Motion
<motion.div
  animate={{ x: 100 }} // Anima la posición en el eje X a 100 píxeles
  transition={transition} // Aplica la transición definida arriba
/>
```

**Explicación del ejemplo:**
Aquí, `transition` es un objeto que configura cómo se animará la propiedad `x` del `motion.div`. `duration` dice que la animación durará 0.8 segundos, `delay` indica que esperará 0.5 segundos antes de empezar, y `ease` define una forma específica de aceleración y desaceleración para que la animación no sea lineal y se vea más natural.

#### 3. **Notas o advertencias:**

- Puedes usar `transition` tanto en componentes `<motion.div>` como en la función `animate()`.
- Esencialmente, `transition` controla _cómo_ cambian las propiedades animadas, no _qué_ propiedades cambian.

## B - Establecer una Transición (Setting a transition)

#### 1. **Definición:**

Puedes definir una `transition` directamente dentro de las propiedades de animación (`animate`, `whileHover`, etc.) de un componente `motion`. Esto te permite personalizar la animación para interacciones específicas.

#### 2. **Ejemplo:**

```jsx
<motion.div
  whileHover={{
    // Cuando el ratón pasa por encima...
    scale: 1.1, // ...escala el elemento a 1.1 veces su tamaño original
    transition: { duration: 0.2 }, // ...con una transición que dura 0.2 segundos
  }}
/>
```

**Explicación del ejemplo:**
En este caso, solo cuando el usuario pasa el ratón por encima del `motion.div`, se aplicará la transición. La propiedad `scale` se animará a 1.1 con una duración de 0.2 segundos. Esto significa que la escala cambiará suavemente en 0.2 segundos mientras el ratón esté encima.

#### 3. **Notas o advertencias:**

- Si defines `transition` dentro de `whileHover`, `whileTap`, etc., solo se aplicará a esa interacción específica.
- Es una forma rápida de añadir pequeñas animaciones interactivas.

## C - Transiciones Específicas por Valor (Value-specific transitions)

#### 1. **Definición:**

Cuando animas múltiples propiedades a la vez, puedes definir transiciones diferentes para cada una. Puedes tener una transición `default` que se aplica a todas las propiedades que no tienen una transición específica definida.

#### 2. **Ejemplo:**

```jsx
<motion.li
  animate={{
    x: 0, // Anima la posición X a 0
    opacity: 1, // Anima la opacidad a 1 (totalmente visible)
    transition: {
      default: { type: "spring" }, // Transición por defecto tipo "spring" para todas las propiedades...
      opacity: { ease: "linear" }, // ...pero para la opacidad usa una transición "linear" (velocidad constante)
    },
  }}
/>
```

**Explicación del ejemplo:**
Aquí, tanto `x` como `opacity` se animan. La propiedad `x` usará la transición `default`, que es de tipo "spring" (muelle, que veremos más adelante). Sin embargo, `opacity` usará una transición con `ease: "linear"`, lo que significa que la opacidad cambiará a una velocidad constante durante la animación, sin aceleración ni desaceleración.

#### 3. **Notas o advertencias:**

- `default` es muy útil para establecer un tipo de transición general y luego afinar transiciones específicas para ciertas propiedades.
- Esto te da un control muy preciso sobre cómo se animan diferentes aspectos de tu componente.

## D - Transiciones por Defecto (Default transitions)

#### 1. **Definición:**

Puedes establecer transiciones por defecto que se aplicarán a todos los componentes `motion` dentro de un cierto alcance. Esto se puede hacer de dos maneras: directamente en un componente `motion` o usando el componente `MotionConfig`.

#### 2. **Ejemplo:**

**a) En un componente `motion`:**

```jsx
<motion.div
  animate={{ x: 100 }}
  transition={{ type: "spring", stiffness: 100 }} // Transición por defecto para este div
/>
```

**b) Usando `MotionConfig` para un grupo de componentes:**

```jsx
import { MotionConfig } from "framer-motion";

<MotionConfig transition={{ duration: 0.4, ease: "easeInOut" }}>
  <App />{" "}
  {/* Todos los componentes motion dentro de App usarán esta transición por defecto */}
</MotionConfig>;
```

**Explicación del ejemplo:**
En el ejemplo **a)**, cualquier animación en este `<motion.div>` usará una transición de tipo "spring" con una rigidez (`stiffness`) de 100, a menos que se especifique otra transición.

En el ejemplo **b)**, `MotionConfig` envuelve el componente `<App />`. Esto significa que _todos_ los componentes `<motion.div>`, `<motion.ul>`, etc., que estén dentro de `<App />` usarán por defecto una transición con una duración de 0.4 segundos y una función de aceleración `easeInOut`, a menos que se defina una transición diferente en el componente individual.

#### 3. **Notas o advertencias:**

- `MotionConfig` es ideal para definir un estilo de animación consistente en toda tu aplicación.
- Si defines una transición en un componente `motion` individual, esta tendrá prioridad sobre la transición por defecto establecida en `MotionConfig`.

## E - Ajustes de Transición (Transition settings)

#### 1. **Definición:**

Las transiciones se configuran con varias opciones que controlan cómo se desarrolla la animación. La opción principal es `type`, que define el tipo de animación: `"tween"`, `"spring"` o `"inertia"`.

#### 2. **Ejemplo:**

```jsx
const transitionSettings = {
  type: "tween", // Tipo de animación: "tween" (animación lineal o con easing)
  duration: 1, // Duración de 1 segundo
  ease: "easeInOut", // Función de easing "easeInOut" (acelera al principio y desacelera al final)
};

<motion.div animate={{ opacity: 1 }} transition={transitionSettings} />;
```

**Explicación del ejemplo:**
Este ejemplo muestra una transición de tipo "tween" que dura 1 segundo y usa la función de easing "easeInOut". Cuando la opacidad del `motion.div` cambie a 1, lo hará con esta transición.

#### 3. **Notas o advertencias:**

- Las opciones disponibles dentro de `transition` dependen del `type` de transición que elijas.
- `type` es la propiedad más importante para entender cómo quieres que se comporte tu animación.

## F - Tipo de Transición: `type`

#### 1. **Definición:**

La propiedad `type` en la configuración de `transition` decide qué tipo de animación se usará. Puede ser `"tween"`, `"spring"` o `"inertia"`. Por defecto, es `"tween"` si no se especifica.

#### 2. **Tipos:**

- **`"tween"`:** Animaciones basadas en duración y una curva de _easing_ (suavizado). Son ideales para animaciones de duración fija y predecible.
- **`"spring"`:** Animaciones basadas en física de muelles o en duración y "rebote". Las basadas en física reaccionan a la velocidad existente, mientras que las de duración son más sencillas de configurar.
- **`"inertia"`:** Animaciones que desaceleran un valor basándose en su velocidad inicial. Se usan típicamente para desplazamiento inercial (como al hacer scroll).

#### 3. **Ejemplo:**

```jsx
<motion.path
  animate={{ pathLength: 1 }} // Anima la propiedad pathLength de un SVG path (dibuja el path completo)
  transition={{ duration: 2, type: "tween" }} // Usa una animación "tween" que dura 2 segundos
/>
```

**Explicación del ejemplo:**
Este ejemplo anima la propiedad `pathLength` de un `<motion.path>` (un elemento SVG). `pathLength: 1` significa dibujar el path completo. La transición es de tipo `"tween"` y dura 2 segundos, lo que hará que el path se dibuje suavemente en 2 segundos.

#### 4. **Notas o advertencias:**

- Elegir el `type` correcto es crucial para lograr el efecto de animación deseado.
- `"tween"` es bueno para animaciones simples y directas. `"spring"` añade un toque más natural y dinámico. `"inertia"` es específico para interacciones como arrastrar y soltar.

## G - Transición `tween`

#### 1. **Definición:**

Las transiciones de tipo `"tween"` son las más básicas. Animan un valor desde un punto inicial a un punto final durante una `duration` específica, usando una función de `ease` para controlar la velocidad de la animación en diferentes momentos.

#### 2. **Opciones principales:**

- **`duration`:** La duración de la animación en segundos. Por defecto es `0.3s` (o `0.8s` si usas _keyframes_).
- **`ease`:** La función de _easing_ que define cómo progresa la animación en el tiempo.

#### 3. **Ejemplo de `duration`:**

```jsx
animate("ul > li", { opacity: 1 }, { duration: 1 }); // Anima la opacidad de todos los <li> dentro de <ul> a 1, con una duración de 1 segundo
```

**Explicación del ejemplo:**
Este ejemplo usa la función `animate()` para seleccionar todos los elementos `<li>` que son hijos directos de un `<ul>` y anima su `opacity` a 1. La transición se configura con `duration: 1`, lo que significa que la animación de opacidad para cada `<li>` durará 1 segundo.

#### 4. **Ejemplo de `ease`:**

```jsx
<motion.div
  animate={{
    x: [0, 100, 0], // Anima la posición X a 0, luego a 100, luego de vuelta a 0 (keyframes)
    transition: { ease: ["easeIn", "easeOut"] }, // Usa "easeIn" para la primera parte y "easeOut" para la segunda
  }}
/>
```

**Explicación del ejemplo:**
Aquí, la animación de `x` tiene tres _keyframes_: `0`, `100`, y `0`. `transition: { ease: ["easeIn", "easeOut"] }` define las funciones de _easing_ para cada segmento de la animación. `"easeIn"` se usa para la transición de `0` a `100`, y `"easeOut"` para la transición de `100` a `0`.

#### 5. **Funciones de `ease` comunes:**

- `"linear"`: Velocidad constante.
- `"easeIn"`: Empieza lento y acelera.
- `"easeOut"`: Empieza rápido y desacelera.
- `"easeInOut"`: Empieza lento, acelera en medio, y desacelera al final.
- Otras opciones como `"circIn"`, `"circOut"`, `"circInOut"`, `"backIn"`, `"backOut"`, `"backInOut"`, `"anticipate"`.
- También puedes usar curvas Bézier cúbicas personalizadas (arrays de 4 números) o funciones de easing de JavaScript.

#### 6. **Notas o advertencias:**

- La elección de `ease` afecta mucho la "sensación" de la animación. `"easeOut"` suele ser una buena opción para animaciones de entrada y salida porque se siente responsiva.
- Para animaciones con _keyframes_, puedes especificar un array de funciones de `ease` para cada segmento entre _keyframes_.

## H - `times` en transiciones `tween`

#### 1. **Definición:**

Cuando usas _keyframes_ en una animación `tween`, `times` te permite controlar cuándo ocurre cada _keyframe_ dentro de la duración total de la animación. Cada valor en `times` es un número entre 0 y 1, representando el progreso de la animación.

#### 2. **Ejemplo:**

```jsx
<motion.div
  animate={{
    x: [0, 100, 0], // Keyframes para la posición X
    transition: { times: [0, 0.3, 1] }, // Define cuándo ocurre cada keyframe
  }}
/>
```

**Explicación del ejemplo:**
En este ejemplo, la animación de `x` tiene tres _keyframes_: `0`, `100`, y `0`. `times: [0, 0.3, 1]` significa:

- El primer _keyframe_ (`0`) ocurre al inicio de la animación (tiempo `0`).
- El segundo _keyframe_ (`100`) ocurre al 30% de la duración total de la animación (tiempo `0.3`).
- El tercer _keyframe_ (`0`) ocurre al final de la animación (tiempo `1`).

Si la duración total de la animación no se especifica explícitamente, se usará la duración por defecto. Si se especifica, por ejemplo, `duration: 2`, entonces el segundo _keyframe_ (`100`) ocurrirá a los `2 * 0.3 = 0.6` segundos de la animación.

#### 3. **Notas o advertencias:**

- El número de valores en `times` debe ser el mismo que el número de _keyframes_.
- Si no se especifica `times`, Framer Motion asume que los _keyframes_ están espaciados uniformemente a lo largo de la duración de la animación.
- `times` te da un control muy fino sobre el ritmo de tu animación con _keyframes_.

## I - Transición `spring`

#### 1. **Definición:**

Las transiciones de tipo `"spring"` simulan el movimiento de un muelle físico. Pueden ser basadas en física (más realistas) o basadas en duración (más fáciles de controlar). Aportan un movimiento más natural y elástico a las animaciones.

#### 2. **Opciones principales (basadas en duración):**

- **`bounce`:** Controla el "rebote" del muelle. `0` es sin rebote, `1` es muy rebotón.
- **`duration`:** Duración de la animación (también se puede usar con `bounce`).
- **`visualDuration`:** Duración _visual_ de la animación. La mayor parte de la animación ocurre antes de este tiempo, y el "rebote" después. Facilita coordinar animaciones de muelle con otras animaciones basadas en tiempo.

#### 3. **Ejemplo de `bounce`:**

```jsx
<motion.div
  animate={{ rotateX: 90 }} // Rota el elemento 90 grados en el eje X
  transition={{ type: "spring", bounce: 0.25 }} // Usa una transición "spring" con un rebote de 0.25
/>
```

**Explicación del ejemplo:**
Este ejemplo anima la rotación en el eje X de un `motion.div` a 90 grados usando una transición de tipo `"spring"` con `bounce: 0.25`. Esto hará que la rotación tenga un pequeño efecto de rebote al final, haciendo que el movimiento se sienta más natural que una rotación lineal.

#### 4. **Ejemplo de `visualDuration`:**

```jsx
<motion.div
  animate={{ rotateX: 90 }}
  transition={{
    type: "spring",
    visualDuration: 0.5, // Duración visual de 0.5 segundos
    bounce: 0.25,
  }}
/>
```

**Explicación del ejemplo:**
Aquí, aunque se usa una transición "spring", se especifica `visualDuration: 0.5`. Esto significa que la parte principal de la animación (la rotación hasta 90 grados) se completará visualmente en aproximadamente 0.5 segundos. Cualquier "rebote" o ajuste fino del muelle ocurrirá principalmente después de este tiempo. Esto es útil para sincronizar animaciones de muelle con otras animaciones que tienen una duración fija.

#### 5. **Notas o advertencias:**

- Si configuras `stiffness`, `damping`, o `mass` (parámetros de muelle basados en física), estos parámetros _sobrescriben_ `bounce` y `duration`.
- `visualDuration` es una herramienta útil para controlar la percepción del tiempo de una animación de muelle, especialmente cuando necesitas sincronizarla con otras animaciones.

## J - Opciones de `spring` basadas en física: `damping`, `mass`, `stiffness`, `velocity`, `restSpeed`, `restDelta`

#### 1. **Definición:**

Para un control más preciso y animaciones de muelle más realistas, puedes usar parámetros basados en física:

- **`damping`:** Fuerza de oposición al movimiento. Si es `0`, el muelle oscilará indefinidamente. Valor por defecto: `10`.
- **`mass`:** Masa del objeto que se mueve. Mayor masa resulta en movimiento más lento. Valor por defecto: `1`.
- **`stiffness`:** Rigidez del muelle. Mayor rigidez crea movimientos más bruscos. Valor por defecto: `100`.
- **`velocity`:** Velocidad inicial del muelle. Valor por defecto: Velocidad actual del valor.
- **`restSpeed`:** Velocidad mínima para considerar que la animación ha terminado. Si la velocidad cae por debajo de este valor y el desplazamiento es menor que `restDelta`, la animación termina. Valor por defecto: `0.1`.
- **`restDelta`:** Distancia mínima para considerar que la animación ha terminado. Si la distancia al objetivo es menor que este valor y la velocidad es menor que `restSpeed`, la animación termina. Valor por defecto: `0.01`.

#### 2. **Ejemplo de `damping`:**

```jsx
<motion.a
  animate={{ rotate: 180 }} // Rota el elemento 180 grados
  transition={{ type: "spring", damping: 300 }} // Muelle con alta amortiguación (damping)
/>
```

**Explicación del ejemplo:**
Un valor alto de `damping` (como 300) significa que el muelle tendrá mucha resistencia al movimiento. En este caso, la rotación a 180 grados será más "rígida" y menos rebotona en comparación con el valor por defecto de `damping` (que es 10).

#### 3. **Ejemplo de `mass`:**

```jsx
<motion.feTurbulence
  animate={{ baseFrequency: 0.5 }} // Anima la propiedad baseFrequency de un filtro SVG
  transition={{ type: "spring", mass: 0.5 }} // Muelle con masa baja
/>
```

**Explicación del ejemplo:**
Una `mass` baja (como 0.5) hace que el movimiento sea más ligero y rápido. En este caso, la animación de `baseFrequency` será más ágil y menos "pesada" en comparación con la masa por defecto (que es 1).

#### 4. **Ejemplo de `stiffness`:**

```jsx
<motion.section
  animate={{ rotate: 180 }}
  transition={{ type: "spring", stiffness: 50 }} // Muelle con baja rigidez (stiffness)
/>
```

**Explicación del ejemplo:**
Una `stiffness` baja (como 50) hace que el muelle sea menos rígido, resultando en un movimiento más suave y lento para alcanzar el objetivo (rotación de 180 grados). Un valor más alto de `stiffness` haría que la rotación fuera más rápida y brusca.

#### 5. **Notas o advertencias:**

- Experimentar con `damping`, `mass`, y `stiffness` puede ser un poco intuitivo al principio. Existen herramientas visuales (como la mencionada en el texto original) que pueden ayudar a entender cómo interactúan estos parámetros.
- `velocity`, `restSpeed`, y `restDelta` son opciones más avanzadas para afinar el comportamiento de la animación de muelle, especialmente en interacciones complejas.

## K - Transición `inertia`

#### 1. **Definición:**

La transición de tipo `"inertia"` simula la desaceleración inercial. Es ideal para animaciones que responden a gestos de usuario como arrastrar y soltar o scroll. La animación desacelera gradualmente basándose en la velocidad inicial.

#### 2. **Opciones principales:**

- **`power`:** Controla la distancia que recorrerá la animación. Mayor `power` significa que la animación llegará más lejos. Valor por defecto: `0.8`.
- **`timeConstant`:** Ajusta la duración de la desaceleración, afectando la "sensación" de la inercia. Valor por defecto: `700`.
- **`modifyTarget`:** Función para modificar el valor objetivo calculado automáticamente. Útil para "snap-to-grid" (alinear a una cuadrícula).
- **`min` y `max`:** Restricciones mínimas y máximas. Si se definen, la animación "rebotará" contra estos límites con un muelle.
- **`bounceStiffness`:** Rigidez del muelle de rebote cuando se alcanzan los límites `min` o `max`. Valor por defecto: `500`.
- **`bounceDamping`:** Amortiguación del muelle de rebote. Si es `0`, el muelle rebotará indefinidamente. Valor por defecto: `10`.

#### 3. **Ejemplo de `power`:**

```jsx
<motion.div
  drag // Permite arrastrar el elemento
  dragTransition={{ power: 0.2 }} // Transición inercial con bajo "power"
/>
```

**Explicación del ejemplo:**
Un valor bajo de `power` (como 0.2) hará que la animación inercial se detenga más rápidamente y recorra menos distancia después de soltar el elemento arrastrado.

#### 4. **Ejemplo de `timeConstant`:**

```jsx
<motion.div
  drag
  dragTransition={{ timeConstant: 200 }} // Transición inercial con "timeConstant" bajo
/>
```

**Explicación del ejemplo:**
Un `timeConstant` bajo (como 200) hará que la desaceleración sea más rápida y la animación inercial se detenga antes. Un valor más alto haría que la desaceleración fuera más lenta y la animación durara más.

#### 5. **Ejemplo de `modifyTarget`:**

```jsx
<motion.div
  drag
  dragTransition={{
    power: 0, // Desactiva el "power" inercial para simplificar el ejemplo
    modifyTarget: (target) => Math.round(target / 50) * 50, // Ajusta el objetivo al múltiplo de 50 más cercano
  }}
/>
```

**Explicación del ejemplo:**
`modifyTarget` es una función que toma el objetivo calculado automáticamente por la inercia y devuelve un nuevo objetivo. En este caso, `Math.round(target / 50) * 50` redondea el objetivo al múltiplo de 50 más cercano. Esto crea un efecto de "snap-to-grid" donde el elemento se alinea a una cuadrícula de 50 píxeles al final del arrastre.

#### 6. **Ejemplo de `min` y `max` con `bounceStiffness` y `bounceDamping`:**

```jsx
<motion.div
  drag
  dragTransition={{
    min: 0, // Límite mínimo en 0
    max: 100, // Límite máximo en 100
    bounceStiffness: 100, // Rigidez del rebote al alcanzar los límites
  }}
/>
```

**Explicación del ejemplo:**
Aquí, se definen límites de arrastre entre 0 y 100. Cuando el usuario intenta arrastrar el elemento más allá de estos límites, la animación inercial hará que el elemento "rebote" contra los límites. `bounceStiffness: 100` controla la rigidez de este rebote.

#### 7. **Notas o advertencias:**

- `inertia` es muy útil para mejorar la experiencia de usuario en interacciones de arrastre y scroll, haciendo que se sientan más naturales y fluidas.
- `modifyTarget` es una herramienta poderosa para añadir comportamientos personalizados al final de una animación inercial, como el "snap-to-grid".
- Las opciones `min`, `max`, `bounceStiffness`, y `bounceDamping` permiten crear límites de arrastre con un efecto de rebote realista.

## L - Orquestación de Transiciones

#### 1. **Definición:**

La orquestación de transiciones se refiere a cómo controlas el inicio, el retraso, la repetición y la sincronización de las animaciones, especialmente cuando tienes múltiples animaciones o componentes que animan juntos.

#### 2. **Opciones principales de orquestación:**

- **`delay`:** Retrasa el inicio de la animación en segundos.
- **`repeat`:** Número de veces que se repite la animación. `Infinity` para repetición infinita.
- **`repeatType`:** Cómo se repite la animación: `"loop"` (desde el inicio), `"reverse"` (ida y vuelta), `"mirror"` (invierte origen y destino en cada repetición).
- **`repeatDelay`:** Tiempo de espera en segundos entre repeticiones.
- **`when`:** (Con variantes) Define cuándo se ejecuta la animación de un componente padre en relación con sus hijos (`"beforeChildren"` o `"afterChildren"`).
- **`delayChildren`:** (Con variantes) Retrasa las animaciones de los hijos en segundos.
- **`staggerChildren`:** (Con variantes) Escalonar las animaciones de los hijos por una duración específica.
- **`staggerDirection`:** (Con variantes) Dirección del escalonamiento de los hijos (`1` de primero a último, `-1` de último a primero).

## M - `delay`

#### 1. **Definición:**

`delay` (retraso) te permite especificar un tiempo de espera en segundos antes de que comience una animación.

#### 2. **Ejemplo:**

```jsx
animate(element, { filter: "blur(10px)" }, { delay: 0.3 }); // Aplica un desenfoque y retrasa el inicio 0.3 segundos
```

**Explicación del ejemplo:**
Este ejemplo usa `animate()` para aplicar un filtro de desenfoque (`blur`) a un elemento. `delay: 0.3` asegura que la animación de desenfoque no comience inmediatamente, sino que espere 0.3 segundos antes de empezar.

#### 3. **Retraso negativo:**

- Si usas un `delay` negativo, la animación comenzará _ya avanzada_ en ese tiempo. Por ejemplo, `delay: -1` hará que la animación comience 1 segundo _dentro_ de su duración.

#### 4. **Notas o advertencias:**

- `delay` es útil para crear animaciones secuenciales o para sincronizar animaciones con otros eventos.
- El retraso negativo puede ser útil para efectos de entrada donde quieres que la animación ya esté parcialmente en marcha cuando el elemento se hace visible.

## N - `repeat`, `repeatType`, `repeatDelay`

#### 1. **Definición:**

Estas opciones controlan la repetición de una animación:

- **`repeat`:** Número de repeticiones. `0` (por defecto) significa que no se repite. `Infinity` para repetición continua.
- **`repeatType`:** Define cómo se repite la animación:
  - `"loop"`: Reinicia la animación desde el principio cada vez.
  - `"reverse"`: Alterna entre reproducción hacia adelante y hacia atrás.
  - `"mirror"`: Invierte el origen y el destino de la animación en cada iteración.
- **`repeatDelay`:** Tiempo de espera en segundos entre cada repetición.

#### 2. **Ejemplo de `repeat` e `repeatType`:**

```jsx
<motion.div
  animate={{ rotate: 180 }} // Rota 180 grados
  transition={{
    repeat: 1, // Repite una vez (total de 2 reproducciones: original + 1 repetición)
    repeatType: "reverse", // Repite en modo "reverse" (ida y vuelta)
    duration: 2, // Duración de 2 segundos por ciclo
  }}
/>
```

**Explicación del ejemplo:**
Este ejemplo anima una rotación de 180 grados. `repeat: 1` hace que la animación se repita una vez, y `repeatType: "reverse"` hace que la repetición sea en sentido inverso. El resultado es que el `motion.div` rota 180 grados, y luego vuelve a rotar -180 grados (o vuelve a su posición original) en un ciclo de 2 segundos por cada dirección.

#### 3. **Ejemplo de `repeatDelay`:**

```jsx
<motion.div
  animate={{ rotate: 180 }}
  transition={{ repeat: Infinity, repeatDelay: 1 }} // Repetición infinita con 1 segundo de pausa entre repeticiones
/>
```

**Explicación del ejemplo:**
Aquí, `repeat: Infinity` hace que la animación de rotación se repita continuamente. `repeatDelay: 1` añade una pausa de 1 segundo entre cada ciclo de rotación.

#### 4. **Notas o advertencias:**

- `repeat: Infinity` es útil para animaciones de bucle continuo, como loaders o animaciones de fondo sutiles.
- `repeatType: "reverse"` es ideal para animaciones de "ping-pong" o movimientos de vaivén.
- `repeatDelay` te permite controlar el ritmo de las repeticiones, evitando que las animaciones repetitivas sean demasiado intensas o molestas.

## O - `when`, `delayChildren`, `staggerChildren`, `staggerDirection` (Orquestación con Variantes)

#### 1. **Definición:**

Estas opciones se usan principalmente con _variantes_ para controlar cómo se animan los componentes padre e hijo en relación entre sí.

- **`when`:** Define cuándo debe comenzar la animación del padre en relación con las animaciones de sus hijos:
  - `"beforeChildren"`: La animación del padre termina _antes_ de que comiencen las animaciones de los hijos.
  - `"afterChildren"`: La animación del padre comienza _después_ de que terminen las animaciones de los hijos.
- **`delayChildren`:** Retrasa el inicio de las animaciones de _todos_ los hijos por una duración específica.
- **`staggerChildren`:** Escalona el inicio de las animaciones de los hijos. Cada hijo comienza su animación con un retraso incremental.
- **`staggerDirection`:** Define la dirección del escalonamiento: `1` (por defecto) escalona de primer hijo a último, `-1` escalona de último hijo a primero.

#### 2. **Ejemplo de `when`:**

```jsx
const list = {
  hidden: {
    opacity: 0,
    transition: { when: "afterChildren" }, // La animación del padre (ul) empieza DESPUÉS de los hijos (li)
  },
  show: {
    opacity: 1,
    transition: { when: "beforeChildren" }, // La animación del padre (ul) termina ANTES de los hijos (li)
  },
};

const item = {
  hidden: { opacity: 0, transition: { duration: 2 } }, // Animación de los hijos (li)
  show: { opacity: 1, transition: { duration: 2 } },
};

return (
  <motion.ul variants={list} animate="show" initial="hidden">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
);
```

**Explicación del ejemplo:**
En este ejemplo, `when: "afterChildren"` en la variante `hidden` del `<ul>` significa que la animación de opacidad del `<ul>` a `0` comenzará _después_ de que las animaciones de opacidad de todos los `<li>` hijos a `0` hayan terminado. En la variante `show`, `when: "beforeChildren"` significa que la animación de opacidad del `<ul>` a `1` terminará _antes_ de que comiencen las animaciones de opacidad de los `<li>` hijos a `1`. Esto permite controlar la secuencia de animaciones entre padre e hijos.

#### 3. **Ejemplo de `delayChildren`:**

```jsx
const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: { delayChildren: 0.5 }, // Retrasa las animaciones de los hijos 0.5 segundos
  },
};

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 },
};

return (
  <motion.ul variants={container} initial="hidden" animate="show">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
);
```

**Explicación del ejemplo:**
`delayChildren: 0.5` en la variante `show` del `<ul>` retrasa el inicio de las animaciones de _todos_ los `<li>` hijos por 0.5 segundos. Cuando el `<ul>` cambia al estado "show", los `<li>` hijos no comenzarán a animarse hasta 0.5 segundos después de que el `<ul>` comience su propia animación (si la tuviera).

#### 4. **Ejemplo de `staggerChildren` y `staggerDirection`:**

```jsx
const container = {
  hidden: { opacity: 0 },
  show: {
    opacity: 1,
    transition: { staggerChildren: 0.5, staggerDirection: -1 }, // Escalonamiento de 0.5s, dirección inversa
  },
};

const item = {
  hidden: { opacity: 0 },
  show: { opacity: 1 },
};

return (
  <motion.ul variants={container} initial="hidden" animate="show">
    <motion.li variants={item} />
    <motion.li variants={item} />
  </motion.ul>
);
```

**Explicación del ejemplo:**
`staggerChildren: 0.5` en la variante `show` del `<ul>` hace que las animaciones de los `<li>` hijos se escalonen por 0.5 segundos. El primer `<li>` comienza su animación inmediatamente, el segundo `<li>` comienza 0.5 segundos después, el tercero 1 segundo después, y así sucesivamente. `staggerDirection: -1` invierte la dirección del escalonamiento, haciendo que el escalonamiento comience desde el _último_ hijo hacia el _primero_.

#### 5. **Notas o advertencias:**

- `when`, `delayChildren`, `staggerChildren`, y `staggerDirection` son herramientas poderosas para crear animaciones coordinadas y complejas entre componentes padre e hijo, especialmente al usar variantes.
- `staggerChildren` es muy útil para crear efectos de lista o galería donde los elementos aparecen uno tras otro de forma animada.
- Experimentar con `staggerDirection` te permite variar la dirección de la animación escalonada para diferentes efectos visuales.
