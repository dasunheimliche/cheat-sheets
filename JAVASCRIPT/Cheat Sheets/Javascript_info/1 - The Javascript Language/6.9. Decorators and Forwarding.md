## A - Decoradores y Reenv√≠o, call/apply üé≠

#### 1. **Definici√≥n:**

En JavaScript, los decoradores son funciones que modifican el comportamiento de otras funciones. El reenv√≠o de llamadas implica pasar una llamada de funci√≥n a otra, a menudo con un contexto (`this`) diferente. `call` y `apply` son m√©todos que permiten controlar el contexto y los argumentos al llamar a una funci√≥n.

## B - Almacenamiento en Cach√© Transparente üóÑÔ∏è

#### 1. **Definici√≥n:**

El almacenamiento en cach√© transparente es una t√©cnica para recordar los resultados de una funci√≥n costosa (en t√©rminos de tiempo de procesamiento) para evitar recalcularlos cuando se llama con los mismos argumentos.

#### 2. **Ejemplo:**

```javascript
function slow(x) {
  // Simula una tarea costosa
  alert(`Llamada con ${x}`);
  return x;
}

function cachingDecorator(func) {
  let cache = new Map();
  return function (x) {
    if (cache.has(x)) {
      return cache.get(x); // Devuelve el resultado de la cach√©
    }
    let result = func(x); // Llama a la funci√≥n original
    cache.set(x, result); // Guarda el resultado en la cach√©
    return result;
  };
}

slow = cachingDecorator(slow);

alert(slow(1)); // Primera llamada, se calcula y se guarda en cach√©
alert("De nuevo: " + slow(1)); // Segunda llamada, se devuelve de la cach√©
alert(slow(2)); // Primera llamada con 2, se calcula y se guarda en cach√©
alert("De nuevo: " + slow(2)); // Segunda llamada con 2, se devuelve de la cach√©
```

**Explicaci√≥n del ejemplo**:
`cachingDecorator` es un decorador que envuelve la funci√≥n `slow`. La primera vez que se llama a `slow` con un argumento, se calcula el resultado y se guarda en la cach√©. Las siguientes veces, si se llama con el mismo argumento, se devuelve el resultado de la cach√©, evitando el c√°lculo costoso.

## C - Uso de "func.call" para el Contexto üéØ

#### 1. **Definici√≥n:**

`func.call(context, arg1, arg2, ...)` permite llamar a una funci√≥n (`func`) estableciendo expl√≠citamente el valor de `this` (`context`) y pasando argumentos individuales.

#### 2. **Ejemplo:**

```javascript
function sayHi() {
  alert(this.name);
}

let user = { name: "John" };
let admin = { name: "Admin" };

sayHi.call(user); // Muestra "John", this es user
sayHi.call(admin); // Muestra "Admin", this es admin
```

**Explicaci√≥n del ejemplo**:
`call` permite ejecutar la funci√≥n `sayHi` con diferentes contextos (`this`).

#### 3. **Problema con el decorador anterior:**

El decorador `cachingDecorator` anterior no funciona correctamente con m√©todos de objetos porque pierde el contexto `this`.

#### 4. **Soluci√≥n con `call`:**

```javascript
let worker = {
  someMethod() {
    return 1;
  },
  slow(x) {
    alert("Llamada con " + x);
    return x * this.someMethod();
  },
};

function cachingDecorator(func) {
  let cache = new Map();
  return function (x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func.call(this, x); // Usa call para pasar el contexto
    cache.set(x, result);
    return result;
  };
}

worker.slow = cachingDecorator(worker.slow);

alert(worker.slow(2)); // Funciona correctamente
alert(worker.slow(2)); // Funciona correctamente, resultado de la cach√©
```

**Explicaci√≥n del ejemplo**:
Al usar `func.call(this, x)` dentro del decorador, se asegura que el contexto `this` se pase correctamente a la funci√≥n original.

## D - Funciones con M√∫ltiples Argumentos üßÆ

#### 1. **Problema:**

El decorador anterior solo funciona con funciones de un argumento. Necesitamos una soluci√≥n para funciones con m√∫ltiples argumentos.

#### 2. **Soluci√≥n:**

- Usar un hash para crear una clave √∫nica a partir de los argumentos.
- Usar `func.call(this, ...arguments)` para pasar todos los argumentos a la funci√≥n original.

#### 3. **Ejemplo:**

```javascript
let worker = {
  slow(min, max) {
    alert(`Llamada con ${min}, ${max}`);
    return min + max;
  },
};

function cachingDecorator(func, hash) {
  let cache = new Map();
  return function () {
    let key = hash(arguments);
    if (cache.has(key)) {
      return cache.get(key);
    }
    let result = func.call(this, ...arguments);
    cache.set(key, result);
    return result;
  };
}

function hash(args) {
  return args[0] + "," + args[1];
}

worker.slow = cachingDecorator(worker.slow, hash);

alert(worker.slow(3, 5)); // Funciona correctamente
alert("De nuevo " + worker.slow(3, 5)); // Funciona correctamente, resultado de la cach√©
```

**Explicaci√≥n del ejemplo**:
El decorador ahora usa una funci√≥n `hash` para crear una clave √∫nica a partir de los argumentos y `func.call(this, ...arguments)` para pasar todos los argumentos a la funci√≥n original.

## E - func.apply ‚öôÔ∏è

#### 1. **Definici√≥n:**

`func.apply(context, args)` es similar a `func.call`, pero toma un array-like object (`args`) como argumentos en lugar de argumentos individuales.

#### 2. **Ejemplo:**

```javascript
function say(phrase) {
  alert(this.name + ": " + phrase);
}

let user = { name: "John" };

say.apply(user, ["Hello"]); // Muestra "John: Hello"
```

**Explicaci√≥n del ejemplo**:
`apply` ejecuta la funci√≥n `say` con el contexto `user` y el argumento "Hello".

#### 3. **Reenv√≠o de Llamadas:**

`func.apply(this, arguments)` es una forma sencilla de reenviar una llamada a otra funci√≥n, manteniendo el contexto y los argumentos.

## F - Tomando Prestado un M√©todo ü§ù

#### 1. **Definici√≥n:**

El "method borrowing" es una t√©cnica para usar un m√©todo de un objeto en otro objeto.

#### 2. **Ejemplo:**

```javascript
function hash() {
  alert([].join.call(arguments)); // Usa el m√©todo join de un array en arguments
}

hash(1, 2); // Muestra "1,2"
```

**Explicaci√≥n del ejemplo**:
El m√©todo `join` de un array se usa en el objeto `arguments` usando `call`.

## G - Decoradores y Propiedades de Funciones üè∑Ô∏è

#### 1. **Problema:**

Si una funci√≥n original tiene propiedades (por ejemplo, `func.calledCount`), un decorador puede no mantener esas propiedades, ya que el decorador es un envoltorio.

#### 2. **Soluci√≥n:**

Se puede usar un objeto `Proxy` para crear decoradores que mantengan las propiedades de la funci√≥n original. (Se ver√° en el art√≠culo [Proxy and Reflect](https://javascript.info/proxy#proxy-apply)).

## H - Resumen üìù

- Los decoradores modifican el comportamiento de las funciones.
- El almacenamiento en cach√© transparente mejora el rendimiento.
- `call` y `apply` permiten controlar el contexto y los argumentos al llamar a una funci√≥n.
- `call` toma argumentos individuales, `apply` toma un array-like object.
- El reenv√≠o de llamadas pasa una llamada a otra funci√≥n.
- El "method borrowing" permite usar m√©todos de un objeto en otro.
- Los decoradores pueden perder propiedades de la funci√≥n original.
