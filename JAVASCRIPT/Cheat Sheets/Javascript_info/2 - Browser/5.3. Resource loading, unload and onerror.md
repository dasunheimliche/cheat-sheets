## A - `onload` y `onerror`: Tus Porteros para Cargar Scripts üü°

#### 1. **Introducci√≥n:**

Imagina que pides una pizza (`script`); `onload` es el timbre que suena cuando el repartidor llega con la pizza correcta y caliente, y `onerror` es el mensaje de texto que te avisa que la pizzer√≠a se incendi√≥ y no recibir√°s nada.

#### 2. **Ejemplo:**

Vamos a crear una funci√≥n que intenta cargar un script y nos dice si lo logr√≥ o no. ¬°Es como enviar a un mensajero y pedirle que nos avise qu√© pas√≥!

```javascript
function cargarScript(url, exito, fallo) {
  let script = document.createElement("script");
  script.src = url;
  document.head.append(script);

  // Si el script se carga y ejecuta correctamente, se dispara esta funci√≥n.
  script.onload = () => exito(script);

  // Si el navegador no puede encontrar o descargar el script, se dispara esta otra.
  script.onerror = () =>
    fallo(new Error(`¬°Ups! Hubo un error cargando ${url}`));
}

// --- Probemos con un script que S√ç existe ---
cargarScript(
  "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js",
  (script) => {
    // Como el script se carg√≥, la librer√≠a lodash (que se asigna a la variable "_") ya existe.
    alert(`¬°√âxito! La versi√≥n de Lodash es: ${_.VERSION}`);
  },
  (error) => {
    alert(error.message);
  }
);

// --- Ahora probemos con uno que NO existe ---
cargarScript(
  "https://ejemplo.com/script-que-no-existe.js",
  (script) => {
    // Esta parte nunca se ejecutar√°
  },
  (error) => {
    // El navegador no lo encontr√≥ (error 404), as√≠ que se ejecuta el "fallo".
    alert(error.message);
  }
);
```

**Explicaci√≥n del ejemplo:**
Hemos creado una funci√≥n `cargarScript` s√∫per √∫til. Le dices qu√© script cargar (`url`), qu√© hacer si todo va bien (`exito`), y qu√© hacer si algo sale mal (`fallo`). Por dentro, crea una etiqueta `<script>`, le asigna los "porteros" `onload` y `onerror`, y la a√±ade a la p√°gina para que el navegador empiece a descargarla. As√≠, tienes control total sobre el proceso de carga.

#### 3. **Desarrollo**:

Estos dos eventos son tus herramientas para manejar recursos que no est√°n inmediatamente disponibles. `onload` se ejecuta cuando el recurso (un script, en este caso) ha sido descargado y ejecutado por completo. A partir de ese momento, puedes usar con seguridad cualquier variable o funci√≥n que ese script haya creado.

Por otro lado, `onerror` es tu red de seguridad. Se activa si el navegador falla en descargar el script, ya sea por un error 404 (no encontrado), un problema de red, o porque el servidor est√° ca√≠do.

**¬°CUIDADO! Una trampa muy com√∫n:** `onload` y `onerror` solo se preocupan por la **descarga** del archivo. Si el archivo se descarga bien pero el c√≥digo _dentro_ del script tiene un error de programaci√≥n (por ejemplo, `console.logg('hola');` con una "g" de m√°s), `onload` se disparar√° igualmente. Estos eventos no analizan la calidad del c√≥digo, solo si el archivo lleg√≥ a su destino. Para capturar errores de ejecuci√≥n dentro de los scripts, necesitar√°s otra herramienta como `window.onerror` (que veremos m√°s adelante).

üü° **Importante**: Saber manejar la carga as√≠ncrona de scripts es clave. Lo usar√°s para cargar librer√≠as de terceros, widgets, o para optimizar la carga de tu propia p√°gina, cargando scripts solo cuando los necesites. Es una t√©cnica fundamental en el desarrollo web moderno.

---

## B - `onload` y `onerror` en Otros Recursos (Im√°genes, iframes) üîµ

#### 1. **Introducci√≥n:**

La misma idea de los "porteros" `onload` y `onerror` no es exclusiva de los scripts; tambi√©n puedes usarlos para vigilar la carga de otros elementos, como im√°genes (`<img>`) o ventanas incrustadas (`<iframe>`).

#### 2. **Ejemplo:**

Vamos a intentar cargar una imagen. Si se carga, mostraremos su tama√±o. Si no, mostraremos una alerta de error.

```javascript
let img = document.createElement("img");

// 1. Preparamos a nuestros "porteros" ANTES de dar la orden de carga.
img.onload = function () {
  alert(`¬°Imagen cargada! Tama√±o: ${img.width}x${img.height}`);
  document.body.append(img); // La mostramos solo si se carg√≥ bien
};

img.onerror = function () {
  alert("¬°Error! No se pudo cargar la imagen. Quiz√°s el link est√° roto.");
};

// 2. AHORA le damos la URL. En cuanto asignas el 'src', el navegador intenta cargarla.
img.src = "https://js.cx/clipart/train.gif"; // Intenta con una URL que funcione

// Para probar el error, podr√≠as usar una URL rota como:
// img.src = "https://js.cx/clipart/tren-que-no-existe.gif";
```

**Explicaci√≥n del ejemplo:**
Creamos un elemento de imagen en la memoria de JavaScript. Le asignamos las funciones `onload` y `onerror` para que sepan qu√© hacer en cada caso. El punto clave es que la descarga de la imagen no comienza hasta que le asignamos una URL a su propiedad `src`. Una vez que lo hacemos, el navegador se pone a trabajar y, dependiendo del resultado, llamar√° a uno de nuestros dos "porteros".

#### 3. **Desarrollo**:

Aunque el concepto es el mismo, hay peque√±as diferencias (peculiaridades, dir√≠a yo) que debes conocer para no llevarte sorpresas:

- **Im√°genes (`<img>`):** La carga se inicia en el momento exacto en que asignas una URL a la propiedad `img.src`. Por eso es crucial definir `onload` y `onerror` _antes_ de asignar el `src`. Si lo haces al rev√©s, la imagen podr√≠a cargarse tan r√°pido que tus eventos no se lleguen a registrar, y nunca te enterar√≠as.
- **iframes (`<iframe>`):** Aqu√≠ hay una curiosidad hist√≥rica. El evento `iframe.onload` se dispara **siempre** que el `iframe` termina de cargar, ¬°incluso si lo que carg√≥ fue una p√°gina de error! No hay un `onerror` tan fiable como en las im√°genes o scripts. Es un detalle a tener en cuenta si trabajas con ellos.

üîµ **Espec√≠fico**: No usar√°s esto todos los d√≠as, pero cuando necesites, por ejemplo, mostrar un "spinner" de carga mientras una imagen se descarga, o ejecutar una acci√≥n justo cuando un `iframe` est√© listo, saber que `onload` y `onerror` existen para estos elementos te salvar√° la vida. Es una de esas herramientas que es bueno tener en tu cintur√≥n de Batman.

---

## C - Pol√≠tica de Cross-Origin (CORS): La Regla del "No Espiar al Vecino" üî¥

#### 1. **Introducci√≥n:**

Por defecto, los navegadores aplican una regla de seguridad estricta: una p√°gina web de un sitio (`https://mi-banco.com`) tiene terminantemente prohibido acceder a informaci√≥n de otro sitio (`https://tu-correo.com`).

#### 2. **Ejemplo:**

Imagina que intentas usar `window.onerror` para registrar todos los errores de tu web. Ahora, cargas dos scripts: uno de tu propio dominio y otro de un dominio diferente. Ambos tienen un error dentro.

```html
<!-- Este manejador de errores global intentar√° mostrar los detalles de cualquier error -->
<script>
  window.onerror = function (message, url, line, col, error) {
    alert(`Error: ${message}\nEn: ${url}, l√≠nea: ${line}, columna: ${col}`);
  };
</script>

<!-- 1. Cargamos un script desde NUESTRO MISMO DOMINIO con un error -->
<!-- Supongamos que error-local.js contiene la l√≠nea: funcionInexistente(); -->
<script src="/js/error-local.js"></script>
<!-- RESULTADO: Ver√°s un error detallado y √∫til:
     "Error: Uncaught ReferenceError: funcionInexistente is not defined
      En: https://tu-sitio.com/js/error-local.js, l√≠nea: 1, columna: 1" -->

<!-- 2. Cargamos un script desde OTRO DOMINIO con un error -->
<!-- Supongamos que error-externo.js tambi√©n contiene: funcionInexistente(); -->
<script src="https://otro-sitio.com/js/error-externo.js"></script>
<!-- RESULTADO: Ver√°s un error gen√©rico e in√∫til:
     "Error: Script error.
      En: , l√≠nea: 0, columna: 0" -->
```

**Explicaci√≥n del ejemplo:**
Cuando el error ocurre en un script de tu propio dominio, el navegador te da toda la informaci√≥n: el mensaje, el archivo, la l√≠nea y la columna. ¬°Genial para depurar! Pero cuando el mismo tipo de error ocurre en un script cargado desde otro dominio, el navegador oculta todos los detalles por seguridad y solo te dice "Script error.". No te dice qu√© fall√≥, ni d√≥nde, ni por qu√©.

#### 3. **Desarrollo**:

Esta pol√≠tica se llama **Same-Origin Policy** (Pol√≠tica del Mismo Origen). Un "origen" es la combinaci√≥n de protocolo (http/https), dominio y puerto. Si alguno de estos tres es diferente, se consideran or√≠genes distintos.

¬øPor qu√© existe? Imagina que visitas una p√°gina maliciosa. Sin esta regla, un script en esa p√°gina podr√≠a intentar leer tus correos de Gmail, acceder a tu cuenta de Facebook o mirar el saldo de tu banco si los ten√≠as abiertos en otras pesta√±as. Ser√≠a un desastre de seguridad.

El problema del "Script error." es un efecto secundario de esta protecci√≥n. El navegador ve que un script de otro origen ha fallado, pero piensa: "No puedo mostrarte los detalles del error, porque esos detalles podr√≠an contener informaci√≥n sensible del otro sitio". As√≠ que, por precauci√≥n, lo oculta todo. Para solucionar esto y poder ver los errores, necesitamos pedir permiso expl√≠citamente, lo cual nos lleva al siguiente punto.

üî¥ **Fundamental**: Este es uno de los conceptos m√°s importantes y que m√°s frustraci√≥n causa a los principiantes. Si no entiendes por qu√© tus peticiones a APIs de terceros o la carga de ciertos recursos falla, la respuesta casi siempre est√° relacionada con CORS. Entenderlo no es opcional, es una necesidad absoluta para cualquier desarrollador web.

---

## D - El Atributo `crossorigin`: Pidiendo Permiso para Ver los Errores Ajenos üü°

#### 1. **Introducci√≥n:**

Para saltarte la restricci√≥n de seguridad y poder ver los detalles de errores en scripts de otros dominios, necesitas hacer dos cosas: t√∫ debes pedir permiso en tu etiqueta `<script>`, y el servidor remoto debe concederlo.

#### 2. **Ejemplo:**

As√≠ es como pides permiso desde tu lado. Simplemente a√±ades el atributo `crossorigin` a la etiqueta del script.

```html
<!-- Antes (el que daba el error gen√©rico) -->
<script src="https://otro-sitio.com/js/error-externo.js"></script>

<!-- Ahora (pidiendo permiso para ver los detalles del error) -->
<script
  src="https://otro-sitio.com/js/error-externo.js"
  crossorigin="anonymous"
></script>
```

**Explicaci√≥n del ejemplo:**
Al a√±adir `crossorigin="anonymous"`, le est√°s diciendo al navegador: "Oye, s√© que este script es de otro sitio, pero me gustar√≠a ver los detalles si algo sale mal. Por favor, preg√∫ntale al otro servidor si le parece bien. Ah, y no env√≠es mis cookies ni datos de autenticaci√≥n, quiero ir de inc√≥gnito".

#### 3. **Desarrollo**:

A√±adir el atributo es solo el primer paso. El servidor remoto **debe** estar configurado para aceptar tu petici√≥n. Aqu√≠ es donde la cosa se pone interesante. Hay tres niveles de acceso, y es crucial que entiendas la diferencia:

- **Nivel 1: Sin atributo `crossorigin` (El Predeterminado)**

  - **Tu parte (HTML):** No pones nada. `<script src="...">`.
  - **La parte del servidor:** No importa lo que haga el servidor.
  - **Resultado:** Acceso prohibido. Si hay un error en el script, ver√°s el in√∫til "Script error.".

- **Nivel 2: `crossorigin="anonymous"` (El Visitante An√≥nimo)**

  - **Tu parte (HTML):** `<script src="..." crossorigin="anonymous">`.
  - **La parte del servidor:** Debe responder con una cabecera (header) espec√≠fica: `Access-Control-Allow-Origin: *` (acepta a cualquiera) o `Access-Control-Allow-Origin: https://tu-sitio.com` (te acepta solo a ti).
  - **Resultado:** ¬°Acceso permitido! Si el servidor coopera, podr√°s ver los detalles completos del error. El navegador **no** enviar√° cookies ni credenciales de autenticaci√≥n a ese servidor. Es la opci√≥n m√°s com√∫n y segura.

- **Nivel 3: `crossorigin="use-credentials"` (El Visitante VIP)**
  - **Tu parte (HTML):** `<script src="..." crossorigin="use-credentials">`.
  - **La parte del servidor:** Debe responder con **dos** cabeceras: `Access-Control-Allow-Origin: https://tu-sitio.com` (no puede ser `*`, debe ser tu dominio espec√≠fico) Y `Access-Control-Allow-Credentials: true`.
  - **Resultado:** Acceso permitido con privilegios. Igual que el anterior, pero esta vez el navegador **s√≠** enviar√° las cookies y credenciales de autenticaci√≥n que tenga para ese dominio. √ösalo solo cuando el script externo necesite saber qui√©n eres (por ejemplo, para una API que requiere login).

**Nota del Pedagogo Paranoico:**
Quiero que esto quede grabado a fuego en tu mente. **No puedes forzar a un servidor a que te d√© permiso**. Si a√±ades `crossorigin="anonymous"` y sigues viendo "Script error.", no es que t√∫ hayas hecho algo mal. Significa que el due√±o del otro servidor no ha configurado la cabecera `Access-Control-Allow-Origin`. Es un acuerdo entre dos partes: t√∫ pides y el otro concede. Si el otro no concede, no hay trato.

üü° **Importante**: En el mundo real, constantemente interactuar√°s con CDNs (para cargar librer√≠as como React o jQuery), APIs de terceros (como Google Maps) y otros servicios. Todos ellos viven en otros dominios. Saber c√≥mo funciona `crossorigin` es esencial para poder depurar problemas y hacer que tus integraciones funcionen correctamente.

```

```
