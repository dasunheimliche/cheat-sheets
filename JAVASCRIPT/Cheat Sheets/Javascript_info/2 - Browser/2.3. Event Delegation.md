## A - Delegaci칩n de Eventos: Un solo guardi치n para controlarlos a todos 游댮

#### 1. **Introducci칩n:**

En lugar de poner un vigilante (`manejador de eventos`) en cada una de las 100 puertas de un edificio (`<td>`, `<li>`, etc.), pones un 칰nico y s칰per eficiente vigilante en la entrada principal (`<table>`, `<ul>`) que se encarga de averiguar qu칠 puerta se us칩.

#### 2. **Ejemplo:**

Imagina esta tabla. Queremos que al hacer clic en una celda (`<td>`), esta se ilumine.

**El HTML (un fragmento):**

```html
<table id="bagua-table">
  <tr>
    <td class="nw">
      <strong>Noroeste</strong><br />Metal<br />Plata<br />Ancianos
    </td>
    <td class="n">...</td>
    <td class="ne">...</td>
  </tr>
  <!-- ... m치s filas ... -->
</table>
```

**El JavaScript (con delegaci칩n):**

```javascript
let tabla = document.getElementById("bagua-table");
let celdaSeleccionada;

tabla.onclick = function (event) {
  // 1. 쮻칩nde ocurri칩 el clic exactamente?
  let objetivo = event.target;

  // 2. Si no fue en una celda (TD), no me interesa. 춰Adi칩s!
  if (objetivo.tagName != "TD") return;

  // 3. Si fue en una celda, la ilumino.
  iluminar(objetivo);
};

function iluminar(td) {
  // Si ya hab칤a una celda iluminada, le quito el brillo.
  if (celdaSeleccionada) {
    celdaSeleccionada.classList.remove("highlight");
  }
  // Ahora, la nueva celda es la seleccionada y la ilumino.
  celdaSeleccionada = td;
  celdaSeleccionada.classList.add("highlight");
}
```

**Explicaci칩n del ejemplo:**
F칤jate bien: 춰solo hay **un** `onclick`! Est치 en el elemento `<table>`. Cuando haces clic en cualquier lugar dentro de la tabla, este 칰nico manejador se activa. Dentro, `event.target` nos dice _exactamente_ qu칠 elemento recibi칩 el clic. Comprobamos si ese elemento es un `<td>` y, si lo es, 춰lo iluminamos! Simple, 쯨erdad?

#### 3. **Desarrollo:**

La magia de este patr칩n es su **eficiencia y flexibilidad**.

- **Eficiencia:** Imagina 1000 celdas. Asignar 1000 manejadores de eventos consumir칤a m치s memoria y recursos. Con la delegaci칩n, solo tienes uno. 춰Uno! Es como pagarle a un solo empleado en lugar de a mil.
- **Flexibilidad:** 쯏 si ma침ana a침ades o quitas celdas (`<td>`) con JavaScript? No pasa nada. No tienes que preocuparte por a침adir o quitar manejadores de eventos. El guardi치n de la `<table>` seguir치 funcionando perfectamente para las celdas nuevas o las que queden.

游댮 **Fundamental**: Este es uno de los patrones m치s importantes en el manejo de eventos del DOM. Es la base para crear aplicaciones web interactivas, r치pidas y que no consuman memoria innecesariamente. Entender esto te ahorrar치 incontables dolores de cabeza.

---

## B - El Click Travieso y la Soluci칩n con `closest()` 游댮

#### 1. **Introducci칩n:**

A veces, el usuario no hace clic _exactamente_ en la celda (`<td>`), sino en algo que est치 _dentro_ de ella (como el texto en `<strong>`), pero no te preocupes, `closest()` es nuestro detective que siempre encontrar치 al ancestro que buscamos.

#### 2. **Ejemplo:**

En nuestro ejemplo anterior, si haces clic en "Noroeste", `event.target` ser치 el elemento `<strong>`, 춰no el `<td>`! El c칩digo anterior fallar칤a.

![Diagrama que muestra un clic en el elemento strong, y c칩mo el evento burbujea hacia el td, tr, tbody y table.](https://javascript.info/article/event-delegation/bagua-bubble.svg)

**El JavaScript MEJORADO:**

```javascript
tabla.onclick = function (event) {
  // 1. Busca el ancestro <td> m치s cercano al lugar del clic.
  let td = event.target.closest("td");

  // 2. Si no encontr칩 ning칰n <td> (porque el clic fue fuera de una celda), no hagas nada.
  if (!td) return;

  // 3. EXTRA: Aseg칰rate de que el <td> encontrado pertenece a NUESTRA tabla.
  // (Esto es 칰til si tienes tablas dentro de otras tablas).
  if (!tabla.contains(td)) return;

  // 4. 춰Ahora s칤! Ilumina la celda correcta.
  iluminar(td); // Usamos la misma funci칩n de antes.
};
```

**Explicaci칩n del ejemplo:**
No importa si el `event.target` es el `<strong>`, el `<br>` o el texto mismo. La l칤nea `event.target.closest('td')` es la estrella. Empieza desde el objetivo del clic y "escala" hacia arriba en el 치rbol DOM hasta que encuentra un elemento que coincide con el selector `'td'`. Si lo encuentra, nos lo da. Si no, devuelve `null`. 춰Problema resuelto!

#### 3. **Desarrollo:**

Este es el punto que hace que la delegaci칩n de eventos sea robusta y a prueba de balas. Casi nunca tendr치s elementos vac칤os; siempre habr치 texto, im치genes, u otros tags dentro.

- **`elem.closest(selector)`**: Es tu mejor amigo en la delegaci칩n de eventos. Viaja hacia **arriba** desde `elem` (incluy칠ndose a s칤 mismo) y te devuelve el primer ancestro que cumpla con el `selector`.
- **La comprobaci칩n `!tabla.contains(td)`**: Esto es paranoia en su m치xima expresi칩n, 춰y por eso es genial! Imagina que tienes una tabla peque침a _dentro_ de una celda de tu tabla grande. Si haces clic en la tabla interna, `closest('td')` podr칤a devolverte una celda de esa tabla interna. Esta l칤nea se asegura de que la celda que vamos a iluminar es, sin lugar a dudas, una hija directa o indirecta de `tabla`, la tabla que nos interesa.

游댮 **Fundamental**: La delegaci칩n de eventos sin `closest()` es como un coche sin volante. Funciona en l칤nea recta, pero en cuanto aparece una curva (un elemento anidado), te estrellas. Considera `event.target.closest()` como parte inseparable del patr칩n de delegaci칩n.

---

## C - Acciones en el HTML con `data-action` 游리

#### 1. **Introducci칩n:**

Puedes hacer que tu HTML sea m치s "inteligente" a침adiendo atributos `data-*` que le digan a tu JavaScript qu칠 funci칩n espec칤fica ejecutar, permitiendo que un solo manejador de eventos controle un men칰 completo de acciones.

#### 2. **Ejemplo:**

Imagina un men칰 con botones. Cada bot칩n debe llamar a un m칠todo diferente de un objeto `Menu`.

**El HTML:**

```html
<div id="menu">
  <button data-action="save">Guardar</button>
  <button data-action="load">Cargar</button>
  <button data-action="search">Buscar</button>
</div>
```

**El JavaScript:**

```javascript
class Menu {
  constructor(elem) {
    this._elem = elem;
    // 춰OJO AQU칈! Atamos "this" para que no se pierda en el evento.
    elem.onclick = this.onClick.bind(this);
  }

  save() {
    alert("guardando");
  }
  load() {
    alert("cargando");
  }
  search() {
    alert("buscando");
  }

  onClick(event) {
    // Leemos el valor del atributo data-action del bot칩n pulsado.
    let accion = event.target.dataset.action;
    if (accion) {
      // Usamos el valor ("save", "load", etc.) para llamar al m칠todo correspondiente.
      this[accion]();
    }
  }
}

new Menu(menu);
```

**Explicaci칩n del ejemplo:**
Cuando haces clic en el bot칩n "Guardar", `event.target.dataset.action` nos da el string `"save"`. Luego, la l칤nea `this[accion]()` se convierte m치gicamente en `this.save()`. Es una forma incre칤blemente limpia y din치mica de conectar tu HTML con tu l칩gica de JavaScript.

#### 3. **Desarrollo:**

Este patr칩n es declarativo. Describes la acci칩n en el HTML, y el JavaScript simplemente la ejecuta.

- **`dataset`**: Es una propiedad especial que te da acceso a todos los atributos `data-*` de un elemento. `data-action` se convierte en `dataset.action`, `data-user-id` se convertir칤a en `dataset.userId`, etc.
- **La trampa mortal de `this`**: La l칤nea `elem.onclick = this.onClick.bind(this);` es **VITAL**. Si escribieras `elem.onclick = this.onClick;`, cuando el evento ocurra, `this` dentro de `onClick` apuntar칤a al elemento del DOM (`div#menu`), no a nuestra instancia de `Menu`. El c칩digo se romper칤a porque `div#menu` no tiene m칠todos `save()`, `load()`, etc. `.bind(this)` crea una nueva funci칩n que garantiza que `this` siempre ser치 nuestra instancia de `Menu`. 춰Gr치batelo a fuego!

游리 **Importante**: Este es un patr칩n extremadamente com칰n y 칰til. Hace que tu HTML sea m치s legible y que tu JavaScript sea m치s gen칠rico y reutilizable. Es el siguiente paso l칩gico despu칠s de entender la delegaci칩n b치sica.

---

## D - El Patr칩n "Behavior" (Comportamiento) 游리

#### 1. **Introducci칩n:**

Es la evoluci칩n del concepto anterior: creas atributos HTML personalizados que describen un "comportamiento", y un 칰nico manejador de eventos global (en `document`) se encarga de darle vida a cualquier elemento que use ese atributo.

#### 2. **Ejemplo:**

Vamos a crear un comportamiento `data-counter`. Cualquier elemento con este atributo incrementar치 su valor al hacerle clic.

**El HTML:**

```html
Contador: <input type="button" value="1" data-counter /> Otro contador:
<input type="button" value="2" data-counter />
```

**El JavaScript (un solo listener para toda la p치gina):**

```javascript
document.addEventListener("click", function (event) {
  // Si el elemento clickeado tiene el atributo "data-counter"...
  if (event.target.dataset.counter !== undefined) {
    // ...incrementa su valor.
    event.target.value++;
  }
});
```

**Explicaci칩n del ejemplo:**
No importa cu치ntos botones con `data-counter` a침adas a tu p치gina, ahora o en el futuro. Este 칰nico y simple manejador de eventos en `document` los escuchar치 a todos. Detecta si el elemento clickeado tiene el atributo `data-counter` y, si es as칤, aplica la l칩gica. 춰Acabas de "extender" HTML con una nueva funcionalidad!

#### 3. **Desarrollo:**

Este patr칩n es incre칤blemente poderoso para separar la estructura (HTML) del comportamiento (JS).

1.  **Parte 1: Declaraci칩n en HTML.** A침ades un atributo a un elemento para "marcarlo" con un comportamiento deseado (ej: `data-counter`, `data-toggle-id`).
2.  **Parte 2: Manejador Global en JS.** Un 칰nico manejador de eventos, usualmente en `document`, est치 a la escucha. Cuando un evento ocurre, comprueba si el `event.target` (o un ancestro cercano) tiene uno de tus atributos de comportamiento y act칰a en consecuencia.

Esto es genial porque no necesitas "inicializar" scripts para cada elemento. Simplemente a침ades el atributo en tu HTML y "simplemente funciona".

游리 **Importante**: Este es un enfoque de arquitectura de software muy elegante. Te permite crear componentes reutilizables y declarativos sin la necesidad de frameworks complejos. Es pensar en tu c칩digo de una manera m치s organizada y escalable.

---

## E - Behavior en Acci칩n: El "Toggler" con `data-toggle-id` 游댯

#### 1. **Introducci칩n:**

Un ejemplo perfecto del patr칩n "Behavior": un simple atributo `data-toggle-id` en un bot칩n puede m치gicamente mostrar u ocultar cualquier otro elemento de la p치gina, sin escribir una l칤nea de JS espec칤fica para ese bot칩n.

#### 2. **Ejemplo:**

**El HTML:**

```html
<!-- Este bot칩n controlar치 el formulario de abajo -->
<button data-toggle-id="subscribe-mail">
  Mostrar el formulario de suscripci칩n
</button>

<!-- Este formulario est치 oculto inicialmente -->
<form id="subscribe-mail" hidden>Tu email: <input type="email" /></form>
```

**El JavaScript (el mismo principio que el contador):**

```javascript
document.addEventListener("click", function (event) {
  // 1. 쮼l elemento clickeado tiene el atributo data-toggle-id?
  const id = event.target.dataset.toggleId;
  if (!id) return; // Si no, no me interesa.

  // 2. Si lo tiene, busco el elemento a controlar por su ID.
  const elem = document.getElementById(id);

  // 3. Muestro/oculto el elemento invirtiendo su propiedad "hidden".
  if (elem) {
    elem.hidden = !elem.hidden;
  }
});
```

**Explicaci칩n del ejemplo:**
Al hacer clic en el bot칩n, nuestro listener global se activa. Lee el valor de `data-toggle-id` (que es `"subscribe-mail"`). Luego, busca un elemento con `id="subscribe-mail"` y simplemente invierte su estado `hidden`. Si estaba oculto (`hidden=true`), lo muestra (`hidden=false`), y viceversa.

#### 3. **Desarrollo:**

Piensa en la belleza de esto. Para crear otro par de bot칩n-elemento que se oculta, 쯤u칠 tienes que hacer en JavaScript? 춰Absolutamente nada! Solo tienes que a침adir el HTML correspondiente con un nuevo `id` y el atributo `data-toggle-id` apuntando a 칠l.

Puedes incluso combinar comportamientos. Un elemento podr칤a tener `data-counter` y `data-toggle-id` y ambos funcionar칤an independientemente. Has creado un sistema de plugins para tu HTML.

游댯 **Espec칤fico**: Este es un ejemplo concreto y muy 칰til, pero lo m치s importante es que entiendas el patr칩n "Behavior" (Concepto D) que lo hace posible. Este tipo de "togglers" son muy comunes en las interfaces de usuario.

---

## F - La Regla de Oro: `document` y `addEventListener` 游리

#### 1. **Introducci칩n:**

Cuando quieras que tu guardi치n vigile todo el edificio (el `document`), usa siempre `addEventListener`, porque usar `document.onclick` es como darle la 칰nica llave del edificio a una sola persona, bloqueando a todas las dem치s.

#### 2. **Ejemplo:**

**La forma INCORRECTA (춰Peligro!)**

```javascript
// El script del contador hace esto:
document.onclick = function () {
  /* l칩gica del contador */
};

// Otro script, en otra parte, para el toggler, hace esto:
document.onclick = function () {
  /* l칩gica del toggler */
};
// 춰ERROR! La funci칩n del contador acaba de ser BORRADA. Solo funcionar치 el toggler.
```

**La forma CORRECTA (춰Segura y cooperativa!)**

```javascript
// El script del contador:
document.addEventListener("click", function () {
  /* l칩gica del contador */
});

// El script del toggler:
document.addEventListener("click", function () {
  /* l칩gica del toggler */
});
// 춰PERFECTO! Ambas funciones se ejecutar치n cuando ocurra un clic.
```

#### 3. **Desarrollo:**

Piensa en `on<evento>` (como `onclick`, `onmouseover`, etc.) como una propiedad que solo puede tener **un valor**. Si le asignas algo nuevo, lo anterior se pierde para siempre. Es como una variable.

`addEventListener`, en cambio, es como una lista de invitados. Puedes a침adir tantos "oyentes" (funciones) como quieras al mismo evento (`'click'`). Cuando el evento ocurre, JavaScript amablemente los llama a todos, uno por uno.

En un proyecto real, es casi seguro que diferentes partes de tu c칩digo (o incluso librer칤as de terceros) querr치n escuchar eventos en `document`. Si usas `document.onclick`, crear치s conflictos muy dif칤ciles de depurar. Usar `addEventListener` es la pr치ctica profesional y segura.

游리 **Importante**: Esta no es una sugerencia, es una regla fundamental para escribir JavaScript robusto y compatible. Usa `addEventListener` para manejadores a nivel de documento (y en general, es una buena pr치ctica preferirlo siempre que puedas).
