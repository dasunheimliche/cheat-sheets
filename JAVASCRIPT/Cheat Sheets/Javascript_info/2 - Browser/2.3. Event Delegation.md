## A - Delegación de Eventos: Un solo guardián para controlarlos a todos 🔴

#### 1. **Introducción:**

En lugar de poner un vigilante (`manejador de eventos`) en cada una de las 100 puertas de un edificio (`<td>`, `<li>`, etc.), pones un único y súper eficiente vigilante en la entrada principal (`<table>`, `<ul>`) que se encarga de averiguar qué puerta se usó.

#### 2. **Ejemplo:**

Imagina esta tabla. Queremos que al hacer clic en una celda (`<td>`), esta se ilumine.

**El HTML (un fragmento):**

```html
<table id="bagua-table">
  <tr>
    <td class="nw">
      <strong>Noroeste</strong><br />Metal<br />Plata<br />Ancianos
    </td>
    <td class="n">...</td>
    <td class="ne">...</td>
  </tr>
  <!-- ... más filas ... -->
</table>
```

**El JavaScript (con delegación):**

```javascript
let tabla = document.getElementById("bagua-table");
let celdaSeleccionada;

tabla.onclick = function (event) {
  // 1. ¿Dónde ocurrió el clic exactamente?
  let objetivo = event.target;

  // 2. Si no fue en una celda (TD), no me interesa. ¡Adiós!
  if (objetivo.tagName != "TD") return;

  // 3. Si fue en una celda, la ilumino.
  iluminar(objetivo);
};

function iluminar(td) {
  // Si ya había una celda iluminada, le quito el brillo.
  if (celdaSeleccionada) {
    celdaSeleccionada.classList.remove("highlight");
  }
  // Ahora, la nueva celda es la seleccionada y la ilumino.
  celdaSeleccionada = td;
  celdaSeleccionada.classList.add("highlight");
}
```

**Explicación del ejemplo:**
Fíjate bien: ¡solo hay **un** `onclick`! Está en el elemento `<table>`. Cuando haces clic en cualquier lugar dentro de la tabla, este único manejador se activa. Dentro, `event.target` nos dice _exactamente_ qué elemento recibió el clic. Comprobamos si ese elemento es un `<td>` y, si lo es, ¡lo iluminamos! Simple, ¿verdad?

#### 3. **Desarrollo:**

La magia de este patrón es su **eficiencia y flexibilidad**.

- **Eficiencia:** Imagina 1000 celdas. Asignar 1000 manejadores de eventos consumiría más memoria y recursos. Con la delegación, solo tienes uno. ¡Uno! Es como pagarle a un solo empleado en lugar de a mil.
- **Flexibilidad:** ¿Y si mañana añades o quitas celdas (`<td>`) con JavaScript? No pasa nada. No tienes que preocuparte por añadir o quitar manejadores de eventos. El guardián de la `<table>` seguirá funcionando perfectamente para las celdas nuevas o las que queden.

🔴 **Fundamental**: Este es uno de los patrones más importantes en el manejo de eventos del DOM. Es la base para crear aplicaciones web interactivas, rápidas y que no consuman memoria innecesariamente. Entender esto te ahorrará incontables dolores de cabeza.

---

## B - El Click Travieso y la Solución con `closest()` 🔴

#### 1. **Introducción:**

A veces, el usuario no hace clic _exactamente_ en la celda (`<td>`), sino en algo que está _dentro_ de ella (como el texto en `<strong>`), pero no te preocupes, `closest()` es nuestro detective que siempre encontrará al ancestro que buscamos.

#### 2. **Ejemplo:**

En nuestro ejemplo anterior, si haces clic en "Noroeste", `event.target` será el elemento `<strong>`, ¡no el `<td>`! El código anterior fallaría.

![Diagrama que muestra un clic en el elemento strong, y cómo el evento burbujea hacia el td, tr, tbody y table.](https://javascript.info/article/event-delegation/bagua-bubble.svg)

**El JavaScript MEJORADO:**

```javascript
tabla.onclick = function (event) {
  // 1. Busca el ancestro <td> más cercano al lugar del clic.
  let td = event.target.closest("td");

  // 2. Si no encontró ningún <td> (porque el clic fue fuera de una celda), no hagas nada.
  if (!td) return;

  // 3. EXTRA: Asegúrate de que el <td> encontrado pertenece a NUESTRA tabla.
  // (Esto es útil si tienes tablas dentro de otras tablas).
  if (!tabla.contains(td)) return;

  // 4. ¡Ahora sí! Ilumina la celda correcta.
  iluminar(td); // Usamos la misma función de antes.
};
```

**Explicación del ejemplo:**
No importa si el `event.target` es el `<strong>`, el `<br>` o el texto mismo. La línea `event.target.closest('td')` es la estrella. Empieza desde el objetivo del clic y "escala" hacia arriba en el árbol DOM hasta que encuentra un elemento que coincide con el selector `'td'`. Si lo encuentra, nos lo da. Si no, devuelve `null`. ¡Problema resuelto!

#### 3. **Desarrollo:**

Este es el punto que hace que la delegación de eventos sea robusta y a prueba de balas. Casi nunca tendrás elementos vacíos; siempre habrá texto, imágenes, u otros tags dentro.

- **`elem.closest(selector)`**: Es tu mejor amigo en la delegación de eventos. Viaja hacia **arriba** desde `elem` (incluyéndose a sí mismo) y te devuelve el primer ancestro que cumpla con el `selector`.
- **La comprobación `!tabla.contains(td)`**: Esto es paranoia en su máxima expresión, ¡y por eso es genial! Imagina que tienes una tabla pequeña _dentro_ de una celda de tu tabla grande. Si haces clic en la tabla interna, `closest('td')` podría devolverte una celda de esa tabla interna. Esta línea se asegura de que la celda que vamos a iluminar es, sin lugar a dudas, una hija directa o indirecta de `tabla`, la tabla que nos interesa.

🔴 **Fundamental**: La delegación de eventos sin `closest()` es como un coche sin volante. Funciona en línea recta, pero en cuanto aparece una curva (un elemento anidado), te estrellas. Considera `event.target.closest()` como parte inseparable del patrón de delegación.

---

## C - Acciones en el HTML con `data-action` 🟡

#### 1. **Introducción:**

Puedes hacer que tu HTML sea más "inteligente" añadiendo atributos `data-*` que le digan a tu JavaScript qué función específica ejecutar, permitiendo que un solo manejador de eventos controle un menú completo de acciones.

#### 2. **Ejemplo:**

Imagina un menú con botones. Cada botón debe llamar a un método diferente de un objeto `Menu`.

**El HTML:**

```html
<div id="menu">
  <button data-action="save">Guardar</button>
  <button data-action="load">Cargar</button>
  <button data-action="search">Buscar</button>
</div>
```

**El JavaScript:**

```javascript
class Menu {
  constructor(elem) {
    this._elem = elem;
    // ¡OJO AQUÍ! Atamos "this" para que no se pierda en el evento.
    elem.onclick = this.onClick.bind(this);
  }

  save() {
    alert("guardando");
  }
  load() {
    alert("cargando");
  }
  search() {
    alert("buscando");
  }

  onClick(event) {
    // Leemos el valor del atributo data-action del botón pulsado.
    let accion = event.target.dataset.action;
    if (accion) {
      // Usamos el valor ("save", "load", etc.) para llamar al método correspondiente.
      this[accion]();
    }
  }
}

new Menu(menu);
```

**Explicación del ejemplo:**
Cuando haces clic en el botón "Guardar", `event.target.dataset.action` nos da el string `"save"`. Luego, la línea `this[accion]()` se convierte mágicamente en `this.save()`. Es una forma increíblemente limpia y dinámica de conectar tu HTML con tu lógica de JavaScript.

#### 3. **Desarrollo:**

Este patrón es declarativo. Describes la acción en el HTML, y el JavaScript simplemente la ejecuta.

- **`dataset`**: Es una propiedad especial que te da acceso a todos los atributos `data-*` de un elemento. `data-action` se convierte en `dataset.action`, `data-user-id` se convertiría en `dataset.userId`, etc.
- **La trampa mortal de `this`**: La línea `elem.onclick = this.onClick.bind(this);` es **VITAL**. Si escribieras `elem.onclick = this.onClick;`, cuando el evento ocurra, `this` dentro de `onClick` apuntaría al elemento del DOM (`div#menu`), no a nuestra instancia de `Menu`. El código se rompería porque `div#menu` no tiene métodos `save()`, `load()`, etc. `.bind(this)` crea una nueva función que garantiza que `this` siempre será nuestra instancia de `Menu`. ¡Grábatelo a fuego!

🟡 **Importante**: Este es un patrón extremadamente común y útil. Hace que tu HTML sea más legible y que tu JavaScript sea más genérico y reutilizable. Es el siguiente paso lógico después de entender la delegación básica.

---

## D - El Patrón "Behavior" (Comportamiento) 🟡

#### 1. **Introducción:**

Es la evolución del concepto anterior: creas atributos HTML personalizados que describen un "comportamiento", y un único manejador de eventos global (en `document`) se encarga de darle vida a cualquier elemento que use ese atributo.

#### 2. **Ejemplo:**

Vamos a crear un comportamiento `data-counter`. Cualquier elemento con este atributo incrementará su valor al hacerle clic.

**El HTML:**

```html
Contador: <input type="button" value="1" data-counter /> Otro contador:
<input type="button" value="2" data-counter />
```

**El JavaScript (un solo listener para toda la página):**

```javascript
document.addEventListener("click", function (event) {
  // Si el elemento clickeado tiene el atributo "data-counter"...
  if (event.target.dataset.counter !== undefined) {
    // ...incrementa su valor.
    event.target.value++;
  }
});
```

**Explicación del ejemplo:**
No importa cuántos botones con `data-counter` añadas a tu página, ahora o en el futuro. Este único y simple manejador de eventos en `document` los escuchará a todos. Detecta si el elemento clickeado tiene el atributo `data-counter` y, si es así, aplica la lógica. ¡Acabas de "extender" HTML con una nueva funcionalidad!

#### 3. **Desarrollo:**

Este patrón es increíblemente poderoso para separar la estructura (HTML) del comportamiento (JS).

1.  **Parte 1: Declaración en HTML.** Añades un atributo a un elemento para "marcarlo" con un comportamiento deseado (ej: `data-counter`, `data-toggle-id`).
2.  **Parte 2: Manejador Global en JS.** Un único manejador de eventos, usualmente en `document`, está a la escucha. Cuando un evento ocurre, comprueba si el `event.target` (o un ancestro cercano) tiene uno de tus atributos de comportamiento y actúa en consecuencia.

Esto es genial porque no necesitas "inicializar" scripts para cada elemento. Simplemente añades el atributo en tu HTML y "simplemente funciona".

🟡 **Importante**: Este es un enfoque de arquitectura de software muy elegante. Te permite crear componentes reutilizables y declarativos sin la necesidad de frameworks complejos. Es pensar en tu código de una manera más organizada y escalable.

---

## E - Behavior en Acción: El "Toggler" con `data-toggle-id` 🔵

#### 1. **Introducción:**

Un ejemplo perfecto del patrón "Behavior": un simple atributo `data-toggle-id` en un botón puede mágicamente mostrar u ocultar cualquier otro elemento de la página, sin escribir una línea de JS específica para ese botón.

#### 2. **Ejemplo:**

**El HTML:**

```html
<!-- Este botón controlará el formulario de abajo -->
<button data-toggle-id="subscribe-mail">
  Mostrar el formulario de suscripción
</button>

<!-- Este formulario está oculto inicialmente -->
<form id="subscribe-mail" hidden>Tu email: <input type="email" /></form>
```

**El JavaScript (el mismo principio que el contador):**

```javascript
document.addEventListener("click", function (event) {
  // 1. ¿El elemento clickeado tiene el atributo data-toggle-id?
  const id = event.target.dataset.toggleId;
  if (!id) return; // Si no, no me interesa.

  // 2. Si lo tiene, busco el elemento a controlar por su ID.
  const elem = document.getElementById(id);

  // 3. Muestro/oculto el elemento invirtiendo su propiedad "hidden".
  if (elem) {
    elem.hidden = !elem.hidden;
  }
});
```

**Explicación del ejemplo:**
Al hacer clic en el botón, nuestro listener global se activa. Lee el valor de `data-toggle-id` (que es `"subscribe-mail"`). Luego, busca un elemento con `id="subscribe-mail"` y simplemente invierte su estado `hidden`. Si estaba oculto (`hidden=true`), lo muestra (`hidden=false`), y viceversa.

#### 3. **Desarrollo:**

Piensa en la belleza de esto. Para crear otro par de botón-elemento que se oculta, ¿qué tienes que hacer en JavaScript? ¡Absolutamente nada! Solo tienes que añadir el HTML correspondiente con un nuevo `id` y el atributo `data-toggle-id` apuntando a él.

Puedes incluso combinar comportamientos. Un elemento podría tener `data-counter` y `data-toggle-id` y ambos funcionarían independientemente. Has creado un sistema de plugins para tu HTML.

🔵 **Específico**: Este es un ejemplo concreto y muy útil, pero lo más importante es que entiendas el patrón "Behavior" (Concepto D) que lo hace posible. Este tipo de "togglers" son muy comunes en las interfaces de usuario.

---

## F - La Regla de Oro: `document` y `addEventListener` 🟡

#### 1. **Introducción:**

Cuando quieras que tu guardián vigile todo el edificio (el `document`), usa siempre `addEventListener`, porque usar `document.onclick` es como darle la única llave del edificio a una sola persona, bloqueando a todas las demás.

#### 2. **Ejemplo:**

**La forma INCORRECTA (¡Peligro!)**

```javascript
// El script del contador hace esto:
document.onclick = function () {
  /* lógica del contador */
};

// Otro script, en otra parte, para el toggler, hace esto:
document.onclick = function () {
  /* lógica del toggler */
};
// ¡ERROR! La función del contador acaba de ser BORRADA. Solo funcionará el toggler.
```

**La forma CORRECTA (¡Segura y cooperativa!)**

```javascript
// El script del contador:
document.addEventListener("click", function () {
  /* lógica del contador */
});

// El script del toggler:
document.addEventListener("click", function () {
  /* lógica del toggler */
});
// ¡PERFECTO! Ambas funciones se ejecutarán cuando ocurra un clic.
```

#### 3. **Desarrollo:**

Piensa en `on<evento>` (como `onclick`, `onmouseover`, etc.) como una propiedad que solo puede tener **un valor**. Si le asignas algo nuevo, lo anterior se pierde para siempre. Es como una variable.

`addEventListener`, en cambio, es como una lista de invitados. Puedes añadir tantos "oyentes" (funciones) como quieras al mismo evento (`'click'`). Cuando el evento ocurre, JavaScript amablemente los llama a todos, uno por uno.

En un proyecto real, es casi seguro que diferentes partes de tu código (o incluso librerías de terceros) querrán escuchar eventos en `document`. Si usas `document.onclick`, crearás conflictos muy difíciles de depurar. Usar `addEventListener` es la práctica profesional y segura.

🟡 **Importante**: Esta no es una sugerencia, es una regla fundamental para escribir JavaScript robusto y compatible. Usa `addEventListener` para manejadores a nivel de documento (y en general, es una buena práctica preferirlo siempre que puedas).
