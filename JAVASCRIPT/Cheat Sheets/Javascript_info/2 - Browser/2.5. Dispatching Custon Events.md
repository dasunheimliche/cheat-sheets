### A - `new Event()`: Creando el Borrador de tu Propio Anuncio üî¥

#### 1. **Introducci√≥n:**

Imagina que quieres anunciar que "algo pas√≥"; `new Event()` es la herramienta para crear el borrador de ese anuncio, definiendo qu√© tipo de anuncio es y c√≥mo debe comportarse, pero ¬°ojo!, crearlo no significa publicarlo todav√≠a.

#### 2. **Ejemplo:**

Supongamos que tenemos un videojuego y queremos crear un evento para cuando el jugador sube de nivel.

```javascript
// 1. Creamos el borrador del anuncio.
//    Tipo: 'levelUp' (un nombre que inventamos nosotros).
//    Opciones: bubbles: true (permitimos que el anuncio se propague hacia arriba).
const levelUpEvent = new Event("levelUp", { bubbles: true });

// Por ahora, 'levelUpEvent' es solo un objeto en memoria.
// No ha sido "publicado" ni "anunciado" a nadie.
// Es como tener una carta escrita pero a√∫n no enviada.
console.log(levelUpEvent); // Muestra el objeto Event { type: 'levelUp', ... }
```

**Explicaci√≥n del ejemplo:**
Aqu√≠, `new Event('levelUp', ...)` no hace que nada "suba de nivel" m√°gicamente. Simplemente hemos fabricado un objeto de evento, una "notificaci√≥n" estandarizada. Le dimos un nombre (`'levelUp'`) para poder identificarlo m√°s tarde y le dijimos que puede "burbujear" (`bubbles: true`), algo que veremos en un momento. Piensa que acabas de escribir en un papel: "Anuncio: ¬°Alguien subi√≥ de nivel!". Ese papel es tu objeto `Event`.

#### 3. **Desarrollo:**

El constructor `Event` es la base para crear cualquier evento. Acepta dos argumentos:

1.  **`type` (tipo):** Una cadena de texto que nombra tu evento. Puede ser un nombre de evento nativo como `'click'` o uno completamente inventado por ti, como `'taco-tuesday'`. ¬°La creatividad es el l√≠mite!
2.  **`options` (opciones):** Un objeto opcional con dos propiedades clave que debes conocer s√≠ o s√≠:
    - `bubbles: true/false`: Si es `true`, el evento "burbujear√°" o se propagar√° desde el elemento donde se origina hacia sus padres, abuelos, etc., hasta llegar a `document`. Si es `false` (el valor por defecto), solo el elemento original se enterar√° del evento. ¬°Esto es crucial!
    - `cancelable: true/false`: Si es `true`, permite que los "oyentes" del evento puedan cancelar la acci√≥n por defecto asociada a √©l (lo veremos m√°s adelante con `event.preventDefault()`). Por defecto es `false`.

üî¥ **Fundamental**: Es la piedra angular para crear eventos desde tu c√≥digo. Aunque a menudo usar√°s variantes m√°s espec√≠ficas como `CustomEvent` (que veremos en un momento), entender `new Event` es absolutamente esencial porque todos los dem√°s se basan en √©l.

---

### B - `elem.dispatchEvent()`: Publicando tu Anuncio en el Tabl√≥n üü°

#### 1. **Introducci√≥n:**

Si `new Event()` era escribir la carta, `dispatchEvent(event)` es el acto de ir al tabl√≥n de anuncios de un elemento espec√≠fico (`elem`) y clavar esa carta para que todos los interesados puedan verla y reaccionar.

#### 2. **Ejemplo:**

Continuando con nuestro videojuego, ahora vamos a "publicar" el evento `levelUp` en el elemento que representa a nuestro jugador.

```html
<div id="player" data-level="1">Jugador (Nivel 1)</div>

<script>
  const playerElement = document.getElementById("player");

  // Oyente: El "gerente del juego" est√° escuchando en el jugador.
  playerElement.addEventListener("levelUp", function (event) {
    // Cuando escucha el anuncio 'levelUp', realiza una acci√≥n.
    let currentLevel = parseInt(playerElement.dataset.level, 10);
    currentLevel++;
    playerElement.dataset.level = currentLevel;
    playerElement.textContent = `Jugador (Nivel ${currentLevel}) ¬°Felicidades!`;
    console.log("¬°El evento levelUp fue escuchado y procesado!");
  });

  // Creamos el evento (la carta).
  const levelUpEvent = new Event("levelUp");

  // M√°s tarde, en alguna parte de nuestro juego...
  // ¬°Publicamos el evento en el tabl√≥n de anuncios del jugador!
  console.log("Lanzando el evento...");
  playerElement.dispatchEvent(levelUpEvent);
  console.log("¬°Evento lanzado!");
</script>
```

**Explicaci√≥n del ejemplo:**

1.  Primero, preparamos un "oyente" (`addEventListener`) en el `div` del jugador. Este oyente est√° esperando espec√≠ficamente el anuncio `'levelUp'`.
2.  Luego, creamos nuestro objeto de evento `levelUpEvent`.
3.  Finalmente, la l√≠nea `playerElement.dispatchEvent(levelUpEvent)` es la magia. Le dice al `playerElement`: "¬°Oye, publica este anuncio!". Inmediatamente, todos los oyentes de `'levelUp'` en `playerElement` se activan, y nuestro c√≥digo para actualizar el nivel y el texto se ejecuta.

#### 3. **Desarrollo:**

`dispatchEvent` es el puente entre la creaci√≥n de un evento y su ejecuci√≥n. Sin √©l, tu objeto de evento es in√∫til. Cuando lo llamas, el sistema de eventos del navegador se hace cargo y act√∫a como si el evento hubiera ocurrido de forma natural (casi... como veremos con `isTrusted`). Si el evento se cre√≥ con `bubbles: true`, despu√©s de notificarse en `elem`, viajar√° hacia los elementos padres, activando cualquier oyente que encuentre en el camino.

üü° **Importante**: Es la pareja inseparable de `new Event`. Crear un evento sin despacharlo no sirve de nada. Es una funci√≥n que usar√°s siempre que trabajes con eventos program√°ticos.

---

### C - `event.isTrusted`: ¬øEste Clic es Real o es una Simulaci√≥n? üîµ

#### 1. **Introducci√≥n:**

La propiedad `event.isTrusted` es como un detector de mentiras para eventos: te dice si el evento fue generado por una acci√≥n humana real (`true`) o si fue creado y lanzado por un script (`false`).

#### 2. **Ejemplo:**

Imagina un bot√≥n de "Lanzar Misiles". Queremos asegurarnos de que solo un clic humano real pueda activarlo, no un script travieso.

```html
<button id="launchButton">Lanzar Misiles</button>

<script>
  const button = document.getElementById("launchButton");

  button.addEventListener("click", function (event) {
    if (event.isTrusted) {
      // isTrusted es true porque T√ö hiciste clic en el bot√≥n.
      console.log(
        "Confianza: ALTA. Clic de un humano real. ¬°Misiles en camino!"
      );
    } else {
      // isTrusted es false porque el evento fue creado por nuestro script.
      console.log(
        "Confianza: BAJA. Clic simulado por un script. Misi√≥n abortada."
      );
    }
  });

  // Ahora, vamos a simular un clic con nuestro c√≥digo.
  const fakeClickEvent = new Event("click");
  button.dispatchEvent(fakeClickEvent); // Esto imprimir√° el mensaje de "Confianza: BAJA".
</script>
```

**Explicaci√≥n del ejemplo:**
Cuando haces clic f√≠sicamente en el bot√≥n, el navegador genera un evento `click` con `isTrusted` establecido en `true`. Nuestro oyente lo detecta y confirma que es un humano. Sin embargo, cuando creamos nuestro propio evento `fakeClickEvent` y lo lanzamos con `dispatchEvent`, el navegador sabe que fue un script, por lo que `isTrusted` es `false`. Nuestro c√≥digo puede usar esta informaci√≥n para reaccionar de manera diferente.

#### 3. **Desarrollo:**

Esta propiedad es una medida de seguridad y de depuraci√≥n. Te permite distinguir entre interacciones genuinas del usuario y eventos que tu propio c√≥digo ha simulado, lo cual es especialmente √∫til en tests autom√°ticos o para prevenir acciones no deseadas que podr√≠an ser activadas por scripts. No puedes falsificar esta propiedad; siempre ser√° `false` para eventos creados manualmente.

üîµ **Espec√≠fico**: No la necesitar√°s todos los d√≠as, pero es invaluable cuando la seguridad o la integridad de la interacci√≥n del usuario son importantes. Es una de esas herramientas que te alegra saber que existen cuando te enfrentas a un problema espec√≠fico.

---

### D - Eventos con "Burbujas" (`bubbles: true`): Dejando que el Chisme Suba üü°

#### 1. **Introducci√≥n:**

La opci√≥n `bubbles: true` es como darle alas a tu evento para que, despu√©s de manifestarse en su elemento de origen, vuele hacia arriba, notificando a su padre, abuelo, y a toda la jerarqu√≠a del DOM hasta llegar a `document`.

#### 2. **Ejemplo:**

Imagina que haces clic en un `<span>` dentro de un `<div>` que est√° dentro del `<body>`. Si el evento de clic "burbujea", primero se enterar√° el `<span>`, luego el `<div>`, y finalmente el `<body>`. Vamos a crear nuestro propio evento que haga esto.

```html
<div id="grandparent">
  Abuelo
  <div id="parent">
    Padre
    <h1 id="child">¬°Hola desde el hijo!</h1>
  </div>
</div>

<script>
  // Oyente en el ABUELO (document) para el evento 'hello'
  document.addEventListener("hello", function (event) {
    // Gracias a las burbujas, el evento lanzado en H1 llega hasta aqu√≠.
    alert(`El chisme lleg√≥ al documento desde ${event.target.tagName}!`);
  });

  const childElement = document.getElementById("child");

  // Creamos un evento personalizado CON la capacidad de burbujear.
  const bubblingEvent = new Event("hello", { bubbles: true });

  // Lanzamos el evento SOLO en el elemento hijo (H1).
  childElement.dispatchEvent(bubblingEvent);
</script>
```

**Explicaci√≥n del ejemplo:**

1.  Ponemos un "esp√≠a" (`addEventListener`) en `document`, esperando un evento llamado `'hello'`.
2.  Creamos nuestro evento `'hello'` con la opci√≥n m√°gica `{ bubbles: true }`. Sin esto, el plan fracasa.
3.  Lanzamos el evento _√∫nicamente_ en el `<h1>` (`childElement`).
4.  Como el evento tiene `bubbles: true`, despu√©s de notificarse en el `<h1>`, viaja hacia su padre (`div#parent`), luego a su abuelo (`div#grandparent`), y as√≠ sucesivamente hasta que llega a `document`, donde nuestro esp√≠a lo atrapa y muestra la alerta. Si `bubbles` fuera `false`, la alerta nunca aparecer√≠a.

#### 3. **Desarrollo:**

El burbujeo es un pilar del manejo de eventos en el DOM. Permite un patr√≥n muy eficiente llamado **delegaci√≥n de eventos**, donde puedes poner un √∫nico oyente en un elemento padre para manejar eventos de muchos elementos hijos.

**¬°Dos trampas comunes a evitar!**

1.  **Olvidar `bubbles: true`**: Es el error m√°s com√∫n. Si tu evento no llega a donde esperas, revisa esto primero. Por defecto es `false`.
2.  **Usar `on<evento>` para eventos personalizados**: Propiedades como `document.onhello` o `elem.onmyevent` **no funcionan**. Solo existen para eventos nativos (`onclick`, `onmouseover`, etc.). Para tus eventos personalizados, **siempre** debes usar `addEventListener`.

üü° **Importante**: Entender el burbujeo es fundamental para no volverse loco depurando por qu√© un evento no se dispara donde esperas. Es clave para escribir c√≥digo de eventos limpio y eficiente.

---

### E - `new MouseEvent()` vs `new Event()`: La Herramienta Correcta para el Trabajo Correcto üü°

#### 1. **Introducci√≥n (El Dilema):**

Quieres simular un clic, pero un clic real tiene m√°s informaci√≥n que solo "¬°hey, un clic!". Tiene coordenadas (¬ød√≥nde se hizo clic?), si se presion√≥ la tecla `Ctrl`, etc. `new Event('click')` es un clic gen√©rico y vac√≠o, mientras que `new MouseEvent('click', ...)` es un clic detallado y realista.

#### 2. **Ejemplo Comparativo (¬°La diferencia se ve aqu√≠!):**

```javascript
// --- Intento #1: Usando el constructor gen√©rico 'Event' ---
console.log("--- Usando new Event() ---");
const genericClick = new Event("click", {
  bubbles: true,
  cancelable: true,
  clientX: 100, // Intentamos a√±adir una coordenada de mouse
  clientY: 200,
});

// Lanzamos el evento en el documento para que un oyente lo reciba
document.addEventListener(
  "click",
  (e) => {
    console.log(`Clic gen√©rico - Coordenada X: ${e.clientX}`); // ¬°OJO AQU√ç!
  },
  { once: true }
); // {once: true} para que el oyente se elimine solo

document.dispatchEvent(genericClick); // Salida: Clic gen√©rico - Coordenada X: undefined

// --- Intento #2: Usando el constructor espec√≠fico 'MouseEvent' ---
console.log("\n--- Usando new MouseEvent() ---");
const specificClick = new MouseEvent("click", {
  bubbles: true,
  cancelable: true,
  clientX: 100, // Ahora s√≠ funcionar√°
  clientY: 200,
});

// Lanzamos el evento en el documento para que un oyente lo reciba
document.addEventListener(
  "click",
  (e) => {
    console.log(`Clic espec√≠fico - Coordenada X: ${e.clientX}`); // ¬°√âXITO!
  },
  { once: true }
);

document.dispatchEvent(specificClick); // Salida: Clic espec√≠fico - Coordenada X: 100
```

**Explicaci√≥n del ejemplo:**
En el primer intento, el constructor `new Event()` es como un empleado de oficina generalista: solo entiende de `bubbles` y `cancelable`. Ignora por completo las propiedades espec√≠ficas de un evento de mouse como `clientX`. Por eso, el resultado es `undefined`.

En el segundo intento, `new MouseEvent()` es un especialista. Su constructor est√° dise√±ado para aceptar y procesar propiedades de eventos de mouse. Por eso, `clientX` se establece correctamente y el valor `100` est√° disponible en el oyente.

#### 3. **Desarrollo:**

La regla de oro es: **si quieres simular un evento que ya existe en el navegador, usa su constructor espec√≠fico**.

- Para clics, movimientos de mouse, etc. -> `MouseEvent`
- Para pulsaciones de teclas -> `KeyboardEvent`
- Para cambios de foco -> `FocusEvent`
- Y as√≠ sucesivamente...

Usar el constructor correcto no solo es una buena pr√°ctica, sino que garantiza que tu evento simulado se comporte de la manera m√°s parecida posible a un evento real generado por el navegador, lo cual es crucial para realizar pruebas autom√°ticas fiables.

üü° **Importante**: No caigas en la trampa de usar `new Event()` para todo. Conocer y usar los constructores espec√≠ficos (`MouseEvent`, `KeyboardEvent`, etc.) te ahorrar√° muchos dolores de cabeza y har√° que tus simulaciones de eventos sean precisas y funcionales.

---

### F - `new CustomEvent()`: Tus Eventos con un "Paquete" de Datos Extra üî¥

#### 1. **Introducci√≥n:**

`CustomEvent` es tu mejor amigo cuando quieres crear un evento personalizado y, adem√°s, necesitas enviarle informaci√≥n adicional de forma segura y ordenada, usando un "compartimento" especial llamado `detail`.

#### 2. **Ejemplo:**

Imagina un componente de chat. Cuando se recibe un nuevo mensaje, queremos lanzar un evento `newMessage` que no solo anuncie "¬°hay un mensaje!", sino que tambi√©n lleve el contenido del mensaje y el nombre del autor.

```html
<div id="chat-window"></div>

<script>
  const chatWindow = document.getElementById("chat-window");

  // Oyente: El UI del chat est√° escuchando por nuevos mensajes.
  chatWindow.addEventListener("newMessage", function (event) {
    // Desempaquetamos los datos del compartimento 'detail'.
    const author = event.detail.from;
    const text = event.detail.message;

    const messageElement = document.createElement("p");
    messageElement.innerHTML = `<strong>${author}:</strong> ${text}`;
    chatWindow.appendChild(messageElement);
  });

  // En otra parte del c√≥digo (ej: cuando llega una conexi√≥n de red)...
  // Creamos el evento personalizado con su paquete de datos.
  const aNewMessageEvent = new CustomEvent("newMessage", {
    detail: {
      // ¬°Aqu√≠ est√° la magia!
      message: "¬°Hola a todos! ¬øC√≥mo va?",
      from: "Ana",
    },
  });

  // Lanzamos el evento en la ventana del chat.
  chatWindow.dispatchEvent(aNewMessageEvent);
</script>
```

**Explicaci√≥n del ejemplo:**

1.  Creamos un evento `newMessage` usando `new CustomEvent`.
2.  En el segundo argumento, adem√°s de las opciones que ya conocemos, a√±adimos una propiedad `detail`. El valor de `detail` es un objeto que contiene toda la informaci√≥n extra que queremos enviar.
3.  El oyente (`addEventListener`) recibe el evento y puede acceder a ese paquete de datos de forma muy sencilla a trav√©s de `event.detail`.

#### 3. **Desarrollo:**

"Pero, un momento", podr√≠as pensar, "¬øno podr√≠a simplemente a√±adir propiedades a un `new Event()` normal, como `miEvento.miDato = 'info'`?". T√©cnicamente, s√≠, podr√≠as. Pero es una mala pr√°ctica y peligrosa. ¬øPor qu√©? Porque podr√≠as crear un conflicto. Imagina que en el futuro, el est√°ndar de JavaScript a√±ade una propiedad llamada `miDato` a los eventos. Tu c√≥digo se romper√≠a.

La propiedad `detail` es un espacio seguro, un "namespace", reservado exclusivamente para tus datos personalizados. Usar `CustomEvent` y su propiedad `detail` es la forma correcta, limpia y a prueba de futuro de pasar datos con tus eventos.

üî¥ **Fundamental**: `CustomEvent` es la herramienta por excelencia para la comunicaci√≥n entre componentes desacoplados en JavaScript moderno. Si est√°s construyendo una aplicaci√≥n compleja, usar `CustomEvent` para que tus componentes se "hablen" entre s√≠ sin conocer los detalles internos de los dem√°s es una t√©cnica esencial y elegante.

---

### G - `event.preventDefault()` en Eventos Personalizados: Dando el Poder de "Veto" üîµ

#### 1. **Introducci√≥n:**

En tus eventos personalizados, puedes dar a los "oyentes" la capacidad de cancelar la acci√≥n que tu c√≥digo planeaba hacer despu√©s de lanzar el evento, como si tuvieran un bot√≥n de "veto".

#### 2. **Ejemplo:**

Imagina un conejo que se va a esconder. Antes de esconderse, lanza un evento `"hide"`. Un oyente puede "convencer" al conejo de que no se esconda.

![Un conejo hecho con caracteres ASCII](https://javascript.info/article/dispatch-events/rabbit.png)

```html
<pre id="rabbit">
   |\   /|
    \|_|/
    /. .\
   =\_Y_/=
    {>o<}
</pre>
<button onclick="hide()">Esconder Conejo</button>

<script>
  const rabbit = document.getElementById("rabbit");

  function hide() {
    // 1. Creamos un evento CANCELABLE. Sin esto, el veto no funciona.
    const hideEvent = new CustomEvent("hide", { cancelable: true });

    // 2. Lanzamos el evento y ¬°OJO! guardamos el resultado.
    //    dispatchEvent devuelve 'false' si alguien llam√≥ a preventDefault().
    const wasNotCancelled = rabbit.dispatchEvent(hideEvent);

    // 3. Verificamos si alguien vet√≥ la acci√≥n.
    if (wasNotCancelled) {
      rabbit.hidden = true; // Nadie se opuso, el conejo se esconde.
    } else {
      alert("La acci√≥n fue cancelada. ¬°El conejo se queda!");
    }
  }

  // Un oyente que puede vetar la acci√≥n.
  rabbit.addEventListener("hide", function (event) {
    const userResponse = confirm("¬øQuieres evitar que el conejo se esconda?");
    if (userResponse) {
      event.preventDefault(); // ¬°VETO!
    }
  });
</script>
```

**Explicaci√≥n del ejemplo:**

1.  **`cancelable: true`**: Al crear el evento, le damos esta bandera. Es como decir: "Este plan puede ser cancelado". Si olvidas esto, `event.preventDefault()` ser√° ignorado silenciosamente.
2.  **`event.preventDefault()`**: El oyente, si el usuario lo decide, llama a este m√©todo. Es el acto de levantar la mano y decir "¬°Me opongo!".
3.  **`if (rabbit.dispatchEvent(...))`**: El c√≥digo que lanz√≥ el evento (la funci√≥n `hide`) tiene la **responsabilidad** de comprobar el resultado de `dispatchEvent`. Si devuelve `true`, v√≠a libre. Si devuelve `false`, significa que alguien en la cadena de oyentes llam√≥ a `preventDefault()`, y la acci√≥n debe ser abortada.

#### 3. **Desarrollo:**

Este patr√≥n es incre√≠blemente √∫til para crear APIs flexibles. Permite que tu componente anuncie una intenci√≥n ("voy a hacer X") y que el resto de la aplicaci√≥n pueda reaccionar e incluso impedir esa acci√≥n sin tener que modificar el c√≥digo original del componente. Es una forma de validaci√≥n o intercepci√≥n muy poderosa.

üîµ **Espec√≠fico**: Es un patr√≥n de dise√±o avanzado para componentes reutilizables. No lo usar√°s en cada evento, pero cuando necesites crear c√≥digo extensible donde los consumidores puedan influir en el comportamiento, esta es la t√©cnica a utilizar.

---

### H - Eventos S√≠ncronos Anidados: La Sorprendente Interrupci√≥n en la Conversaci√≥n üîµ

#### 1. **Introducci√≥n:**

Normalmente, los eventos esperan en una cola para ser procesados uno tras otro. Pero si lanzas un nuevo evento desde dentro del manejador de otro evento, el nuevo evento interrumpe todo, se procesa de inmediato, y solo despu√©s se reanuda el manejador original.

#### 2. **Ejemplo:**

Al hacer clic en un men√∫, lanzamos un evento `menu-open`. Ver√°s que el manejador de `menu-open` se ejecuta _en medio_ del manejador del clic.

```html
<button id="menu">Men√∫ (haz clic)</button>

<script>
  const menu = document.getElementById("menu");

  // Oyente para el evento anidado 'menu-open'
  document.addEventListener("menu-open", () => {
    alert("ANIDADO: El men√∫ se est√° abriendo ahora mismo.");
  });

  // Manejador del clic original
  menu.onclick = function () {
    alert("1. Clic detectado. A punto de abrir el men√∫...");

    // Lanzamos el evento anidado. ¬°Esto causa la interrupci√≥n!
    menu.dispatchEvent(new CustomEvent("menu-open", { bubbles: true }));

    alert("2. ...Clic original terminado.");
  };
</script>
```

**Explicaci√≥n del ejemplo:**
Al hacer clic, el orden de las alertas ser√°:

1.  `"1. Clic detectado..."`
2.  `"ANIDADO: El men√∫ se est√° abriendo..."`
3.  `"2. ...Clic original terminado."`

El `dispatchEvent` no espera. Pausa la ejecuci√≥n del `onclick`, ejecuta todos los manejadores para `menu-open` (en este caso, la alerta "ANIDADO"), y una vez que termina, regresa para ejecutar el resto del `onclick`.

#### 3. **Desarrollo y Soluci√≥n:**

Este comportamiento s√≠ncrono puede ser confuso y causar efectos secundarios inesperados. ¬øY si quieres que el `onclick` termine por completo antes de que se procese el evento `menu-open`?

La soluci√≥n es hacer que el `dispatchEvent` sea as√≠ncrono, sac√°ndolo de la pila de ejecuci√≥n actual. La forma m√°s sencilla es envolverlo en un `setTimeout` con un retardo de 0.

**Ejemplo con la soluci√≥n:**

```javascript
menu.onclick = function () {
  alert("1. Clic detectado.");

  // Ponemos el dispatch en la cola de tareas, para despu√©s.
  setTimeout(() => {
    menu.dispatchEvent(new CustomEvent("menu-open", { bubbles: true }));
  });

  alert(
    "2. Clic original terminado. El evento de apertura se procesar√° en breve."
  );
};
```

Ahora, el orden de las alertas ser√°:

1.  `"1. Clic detectado."`
2.  `"2. Clic original terminado..."`
3.  `"ANIDADO: El men√∫ se est√° abriendo..."`

`setTimeout` le dice al navegador: "Oye, cuando termines con todo lo que est√°s haciendo ahora (incluido este `onclick`), ejecuta esto". As√≠, los eventos se procesan de forma separada y predecible.

üîµ **Espec√≠fico**: Este es un detalle sutil sobre el bucle de eventos de JavaScript. Conocerlo es crucial para depurar problemas de temporizaci√≥n complejos. Si alguna vez ves un comportamiento extra√±o donde un evento parece interrumpir a otro, acu√©rdate de esto y de la soluci√≥n con `setTimeout`.

```

```
