### A - La Jerarqu√≠a de Clases del DOM: El √Årbol Geneal√≥gico de tus Etiquetas HTML üîµ

#### 1. **Introducci√≥n:**

Imagina que cada etiqueta en tu HTML (`<p>`, `<div>`, `<a>`, etc.) no es solo un trozo de texto, sino un objeto con una "familia" y una "herencia", y esta jerarqu√≠a define qu√© "poderes" (propiedades y m√©todos) tiene cada uno.

#### 2. **Ejemplo:**

![Jerarqu√≠a de clases del DOM](https://javascript.info/article/basic-dom-node-properties/dom-class-hierarchy.svg)

```javascript
// Vamos a inspeccionar el <body> de nuestra p√°gina
let miBody = document.body;

// ¬øDe qu√© "familia" o clase es?
console.log(miBody.constructor.name); // Muestra "HTMLBodyElement"

// Gracias a la herencia, podemos verificar si pertenece a sus "ancestros"
console.log(miBody instanceof HTMLBodyElement); // true (es su clase directa)
console.log(miBody instanceof HTMLElement); // true (es un elemento HTML)
console.log(miBody instanceof Element); // true (es un elemento gen√©rico)
console.log(miBody instanceof Node); // true (es un nodo del DOM)
console.log(miBody instanceof EventTarget); // true (puede reaccionar a eventos)
```

**Explicaci√≥n del ejemplo:**
El c√≥digo demuestra que el objeto `document.body` no es solo un `HTMLBodyElement`, sino que tambi√©n hereda las caracter√≠sticas de todas sus clases "padre" en la jerarqu√≠a. Por eso, `instanceof` devuelve `true` para todas ellas. Es como decir que "un caniche es un perro, que es un mam√≠fero, que es un animal".

#### 3. **Desarrollo:**

No te asustes por el diagrama, ¬°es m√°s sencillo de lo que parece! Pi√©nsalo as√≠:

- **EventTarget**: Es el "Ad√°n y Eva" de todos los nodos. Su √∫nico s√∫per poder es la capacidad de **escuchar y reaccionar a eventos** (como clics, pasar el rat√≥n por encima, etc.). Todos los nodos heredan esto.
- **Node**: El siguiente en la l√≠nea. Aporta las habilidades b√°sicas para navegar por el √°rbol del DOM, como `parentNode` (qui√©n es mi padre), `childNodes` (qui√©nes son mis hijos) y `nextSibling` (qui√©n es mi hermano de al lado).
- **Element**: ¬°Aqu√≠ se pone interesante! Esta es la base para **todas las etiquetas HTML**. Aporta herramientas para buscar dentro del DOM (`querySelector`) y navegar entre elementos (`children`, `nextElementSibling`).
- **HTMLElement**: Es el especialista en HTML. Es la base para **TODAS** las etiquetas que conoces (`<div>`, `<span>`, `<p>`, etc.).
- **Clases Espec√≠ficas (ej: `HTMLInputElement`)**: Son los s√∫per-especialistas. Un `<input>` tiene propiedades √∫nicas como `.value` que un `<div>` no tiene. Un `<a>` tiene `.href`. Esta es la herencia en acci√≥n.

**¬øPor qu√© te deber√≠a importar esto?** Porque explica _por qu√©_ un elemento `<input>` tiene una propiedad `.value` y un `<div>` no. El `<input>` hereda todo lo de `HTMLElement`, `Element`, `Node` y `EventTarget`, y adem√°s a√±ade sus propias propiedades exclusivas de la clase `HTMLInputElement`.

üîµ **Espec√≠fico**: No necesitas memorizar este √°rbol geneal√≥gico, pero entender el concepto de herencia te ayudar√° a comprender por qu√© ciertos elementos tienen propiedades y m√©todos que otros no. Es conocimiento de fondo que te convierte en un mejor detective de c√≥digo.

---

### B - `nodeType`: El DNI Num√©rico de un Nodo üü°

#### 1. **Introducci√≥n:**

Es una forma "cl√°sica" y r√°pida de saber qu√© tipo de nodo tienes (un elemento, un texto, un comentario, etc.) usando un simple n√∫mero en lugar de su nombre de clase.

#### 2. **Ejemplo:**

```html
<body>
  <!-- Soy un comentario -->
  <p>Soy un p√°rrafo</p>
  <script>
    let body = document.body;

    // El nodo del elemento <body>
    console.log(body.nodeType); // Muestra 1

    // El primer hijo del body es un nodo de texto (los espacios en blanco cuentan!)
    // Pero para que sea m√°s claro, veamos el nodo de comentario
    let comentario = body.childNodes[1]; // El nodo de comentario <!--...-->
    console.log(comentario.nodeType); // Muestra 8 (Aunque el texto original dice 3 para texto, los comentarios son 8)

    // El nodo del documento completo
    console.log(document.nodeType); // Muestra 9
  </script>
</body>
```

_(Nota: El texto original menciona `elem.firstChild.nodeType` como 3 (texto), lo cual es cierto si hay texto o incluso un espacio/salto de l√≠nea justo despu√©s de `<body>`. Aqu√≠ usamos el comentario para m√°s claridad sobre los diferentes tipos)._

**Explicaci√≥n del ejemplo:**
Cada tipo de nodo tiene un c√≥digo num√©rico asignado. El c√≥digo `1` es el m√°s com√∫n que ver√°s, ya que representa a los elementos (etiquetas HTML). El `9` representa al objeto `document` entero. El `3` es para nodos de texto y el `8` para comentarios.

#### 3. **Desarrollo:**

La propiedad `nodeType` es de **solo lectura**. No puedes cambiarla. Es una reliquia de los viejos tiempos de la web, pero a veces resulta √∫til para una comprobaci√≥n r√°pida en una funci√≥n.

Los n√∫meros m√°s importantes que debes recordar son:

- `1`: Un nodo de **Elemento** (ej: `<div>`, `<p>`, `<span>`).
- `3`: Un nodo de **Texto** (el texto dentro de una etiqueta).
- `9`: El nodo del **Documento**.
- `8`: Un nodo de **Comentario** (`<!-- ... -->`).

Hoy en d√≠a, es m√°s moderno y a menudo m√°s claro usar `miNodo instanceof Element` para ver si algo es un elemento, pero `nodeType` sigue siendo v√°lido y funcional.

üü° **Importante**: Aunque hay formas m√°s modernas de verificar el tipo de un nodo, `nodeType` es tan com√∫n en c√≥digo antiguo y ejemplos en l√≠nea que es fundamental saber qu√© significa para no quedarte perplejo cuando lo veas.

---

### C - `tagName` vs. `nodeName`: ¬øC√≥mo te Llamas? üü°

#### 1. **Introducci√≥n:**

Ambas propiedades te dan el "nombre" de un nodo, pero con una diferencia sutil pero crucial: `tagName` es exclusivo para elementos, mientras que `nodeName` funciona para cualquier tipo de nodo.

#### 2. **Ejemplo:**

```html
<body>
  <!-- Soy un comentario -->
  <div>Soy un div</div>
  <script>
    let comentario = document.body.childNodes[1];
    let div = document.querySelector("div");

    // Para el elemento <div>
    console.log(div.tagName); // "DIV"
    console.log(div.nodeName); // "DIV" (Para elementos, son id√©nticos)

    // Para el nodo de comentario
    console.log(comentario.tagName); // undefined (¬°Un comentario no es un elemento!)
    console.log(comentario.nodeName); // "#comment" (Aqu√≠ nodeName nos da informaci√≥n √∫til)

    // Para el objeto document
    console.log(document.tagName); // undefined (El documento no es un elemento)
    console.log(document.nodeName); // "#document"
  </script>
</body>
```

**Explicaci√≥n del ejemplo:**
Como puedes ver, cuando trabajas con un elemento como `<div>`, `tagName` y `nodeName` te dan el mismo resultado. Pero si intentas usar `tagName` en algo que no es un elemento (como un comentario o el propio `document`), te dar√° `undefined`. En esos casos, `nodeName` s√≠ te da una respuesta, dici√©ndote qu√© tipo de nodo es.

#### 3. **Desarrollo:**

La regla de oro es simple:

- **¬øEst√°s 100% seguro de que trabajas con un elemento HTML?** Puedes usar `tagName` o `nodeName`, da igual.
- **¬øNo est√°s seguro o podr√≠as estar tratando con texto, comentarios, etc.?** Usa `nodeName` para obtener siempre una respuesta.

**¬°Un detalle paranoico importante!** En los documentos HTML, el nombre de la etiqueta siempre se devuelve en **MAY√öSCULAS**, sin importar c√≥mo lo escribiste en el archivo (`<BoDy>` o `<body>`, `tagName` siempre ser√° `"BODY"`).

üü° **Importante**: Conocer esta diferencia te evita errores tontos. Si alguna vez `tagName` te da `undefined`, ya sabes por qu√©: ¬°probablemente no est√°s trabajando con un nodo de elemento!

---

### D - `innerHTML`: El Contenido de la Caja como HTML üî¥

#### 1. **Introducci√≥n:**

`innerHTML` te permite ver y **reemplazar** todo el contenido HTML que hay _dentro_ de un elemento como si fuera una simple cadena de texto.

#### 2. **Ejemplo:**

```html
<div id="saludo">
  <p>Hola, <strong>viejo</strong> mundo!</p>
</div>

<script>
  let divSaludo = document.getElementById("saludo");

  // 1. LEER el contenido
  console.log(divSaludo.innerHTML);
  // Muestra: "<p>Hola, <strong>viejo</strong> mundo!</p>"

  // 2. REEMPLAZAR el contenido
  divSaludo.innerHTML = "<h2>Hola, <i>nuevo</i> mundo!</h2>";
  // El div ahora contiene un h2 con texto en cursiva.
</script>
```

**Explicaci√≥n del ejemplo:**
Primero, usamos `innerHTML` para "leer" el HTML dentro del `div` y mostrarlo en la consola. Luego, le asignamos una nueva cadena de texto con HTML. El navegador interpreta ese texto y reemplaza completamente el contenido anterior del `div` con el nuevo HTML.

#### 3. **Desarrollo:**

`innerHTML` es incre√≠blemente poderoso y una de las herramientas m√°s usadas para manipular el DOM. Te permite construir fragmentos de HTML en una cadena de texto y meterlos en la p√°gina de un solo golpe.

**¬°Cuidado!** Si insertas HTML "roto" (como `<b>texto sin cerrar`), el navegador intentar√° arreglarlo por ti (lo convertir√° en `<b>texto sin cerrar</b>`).

**Otra advertencia crucial:** Si el HTML que insertas contiene una etiqueta `<script>`, el script **NO se ejecutar√°**. Es una medida de seguridad de los navegadores para prevenir ataques.

üî¥ **Fundamental**: Esta es una de las propiedades m√°s b√°sicas y potentes para la manipulaci√≥n del DOM. La usar√°s constantemente para actualizar din√°micamente el contenido de tu p√°gina.

---

### E - El Peligro de `innerHTML +=`: La Trampa de la "Adici√≥n" üî¥

#### 1. **Introducci√≥n:**

Aunque parece una forma f√°cil de a√±adir HTML al final de un elemento, `elem.innerHTML += "..."` en realidad **borra todo y lo reescribe desde cero**, lo cual es ineficiente y puede causar problemas inesperados.

#### 2. **Ejemplo:**

Imagina que tienes un chat y quieres a√±adir un mensaje nuevo.

```html
<div id="chat">
  <div>Juan: Hola! <img src="carita-feliz.gif" /></div>
</div>

<script>
  let chatDiv = document.getElementById("chat");

  // A√ëADIMOS un nuevo mensaje usando el m√©todo PELIGROSO
  chatDiv.innerHTML += "<div>Maria: ¬øQu√© tal?</div>";
</script>
```

**Explicaci√≥n del ejemplo:**
Podr√≠as pensar que JavaScript simplemente a√±ade el `div` de Mar√≠a al final. ¬°Pero no es as√≠! Lo que realmente ocurre es esto:

1.  El navegador lee el `innerHTML` actual: `<div>Juan: Hola! <img src="carita-feliz.gif"></div>`.
2.  Crea la nueva cadena: `<div>Juan: Hola! <img src="carita-feliz.gif"></div><div>Maria: ¬øQu√© tal?</div>`.
3.  **Borra COMPLETAMENTE** todo el contenido del `chatDiv`.
4.  Escribe la nueva cadena completa dentro del `chatDiv`.

#### 3. **Desarrollo:**

**¬øY cu√°l es el problema?** Este proceso de "borrar y reescribir" tiene efectos secundarios desastrosos:

- **Recarga de Recursos:** La imagen `carita-feliz.gif` se volver√° a cargar desde el servidor (o la cach√©), causando un parpadeo y consumo innecesario de red. Si tuvieras 100 im√°genes, ¬°las 100 se recargar√≠an!
- **P√©rdida de Estado:** Si el usuario hab√≠a seleccionado texto en el chat, esa selecci√≥n se perder√°. Si hab√≠a un `<input>` con texto escrito por el usuario, ¬°ese texto desaparecer√°!
- **Ineficiencia:** Es mucho m√°s lento que usar m√©todos dise√±ados para a√±adir elementos (que veremos m√°s adelante), especialmente con contenidos grandes y complejos.

**Moraleja:** `innerHTML +=` es un atajo que parece conveniente, pero es una trampa. Es como querer a√±adir un ladrillo a una pared y, en lugar de eso, demolerla y reconstruirla con un ladrillo m√°s.

üî¥ **Fundamental**: Entender por qu√© `innerHTML +=` es malo te separa de los principiantes y te acerca a escribir c√≥digo eficiente y sin bugs. ¬°Ev√≠talo siempre que puedas! Hay mejores maneras de a√±adir contenido.

---

### F - `outerHTML`: El Hermano Mayor que se Reemplaza a S√≠ Mismo üü°

#### 1. **Introducci√≥n:**

`outerHTML` es como `innerHTML`, pero incluye tambi√©n la propia etiqueta del elemento; sin embargo, al asignarle un valor, ocurre algo muy extra√±o: **reemplaza el elemento original en el DOM en lugar de solo cambiar su contenido**.

#### 2. **Ejemplo:**

```html
<div id="miDiv">Hola Mundo</div>

<script>
  let div = document.querySelector("#miDiv");

  // 1. LEER el outerHTML
  console.log(div.outerHTML);
  // Muestra: '<div id="miDiv">Hola Mundo</div>'

  // 2. ASIGNAR un nuevo valor (¬°aqu√≠ viene lo raro!)
  div.outerHTML = "<p>Adi√≥s Mundo</p>";

  // 3. INTENTAR USAR LA VARIABLE 'div' OTRA VEZ
  console.log(div.outerHTML);
  // Muestra: '<div id="miDiv">Hola Mundo</div>' ¬°La variable 'div' no ha cambiado!
  // Pero si miras la p√°gina, el div original ha sido reemplazado por el p√°rrafo <p>.
</script>
```

**Explicaci√≥n del ejemplo:**
Al hacer `div.outerHTML = '<p>...'`, no modificamos el objeto `div`. Lo que hicimos fue:

1.  Arrancar el `div` del documento.
2.  Poner el `<p>A new element</p>` en su lugar.
3.  La variable `div` sigue apuntando al objeto `div` original, que ahora est√° "hu√©rfano" y ya no forma parte de la p√°gina.

#### 3. **Desarrollo:**

Esta es una de las mayores "trampas" del DOM. La intuici√≥n te dice que al modificar `div.outerHTML`, la variable `div` ahora deber√≠a referirse al nuevo contenido, pero no es as√≠.

**La lecci√≥n m√°s importante:** Despu√©s de una asignaci√≥n a `outerHTML`, la variable que usaste para hacer la asignaci√≥n se vuelve in√∫til porque apunta a un elemento que ya no est√° en el DOM. Si necesitas trabajar con el nuevo elemento que insertaste, tendr√°s que buscarlo de nuevo en el DOM (por ejemplo, con `document.querySelector`).

üü° **Importante**: Es crucial conocer este comportamiento para no caer en la trampa de seguir usando una variable que apunta a un elemento "fantasma". Su uso es menos com√∫n que `innerHTML`, pero saber c√≥mo funciona te salvar√° de horas de depuraci√≥n frustrante.

---

### G - `nodeValue` / `data`: El Contenido de los que no son Elementos üîµ

#### 1. **Introducci√≥n:**

Mientras que `innerHTML` es para elementos, `nodeValue` y `data` te permiten leer y modificar el contenido de otros tipos de nodos, como los **nodos de texto** y los **comentarios**.

#### 2. **Ejemplo:**

```html
<body>
  ¬°Hola!<!-- Esto es un comentario secreto -->
</body>

<script>
  // El primer hijo del body es un nodo de texto
  let nodoTexto = document.body.firstChild;
  console.log(nodoTexto.data); // Muestra "¬°Hola!"

  // El siguiente hermano es el nodo de comentario
  let nodoComentario = nodoTexto.nextSibling;
  console.log(nodoComentario.data); // Muestra " Esto es un comentario secreto "

  // Tambi√©n podemos modificarlo
  nodoTexto.data = "¬°Adi√≥s!"; // El texto en la p√°gina cambia
</script>
```

**Explicaci√≥n del ejemplo:**
Accedemos al primer hijo del `<body>`, que es el texto "¬°Hola!", y leemos su contenido con `.data`. Luego, hacemos lo mismo con su hermano, el comentario, para leer su contenido. Ambas propiedades (`nodeValue` y `data`) funcionan de manera muy similar; `data` es simplemente m√°s corta de escribir.

#### 3. **Desarrollo:**

Normalmente no interact√∫as tanto con nodos de texto o comentarios, pero es √∫til saber que puedes hacerlo. Algunos desarrolladores usan comentarios en el HTML para guardar informaci√≥n o instrucciones que luego JavaScript puede leer y procesar. Por ejemplo:

```html
<!-- component-type:user-profile -->
<div class="profile">...</div>
```

Un script podr√≠a buscar este comentario, leer su `data` y saber qu√© tipo de componente es el `div` que le sigue.

üîµ **Espec√≠fico**: No usar√°s esto todos los d√≠as, pero es la herramienta correcta para una tarea muy espec√≠fica: leer o escribir el contenido de un nodo de texto o un comentario. Es bueno saber que existe por si alguna vez la necesitas.

---

### H - `textContent`: El Contenido como Texto Puro y Seguro üî¥

#### 1. **Introducci√≥n:**

`textContent` te da todo el texto dentro de un elemento y sus hijos, **ignorando y eliminando por completo todas las etiquetas HTML**. Es la forma m√°s segura de insertar texto en la p√°gina.

#### 2. **Comparaci√≥n `textContent` vs. `innerHTML`:**

Esta es una de las distinciones m√°s importantes que debes dominar. ¬°Vamos a dejarla meridianamente clara!

**Escenario:** Un usuario introduce su nombre en un campo de texto. Su nombre es `<b>Super Hacker</b>`.

```html
<div id="bienvenida-insegura"></div>
<div id="bienvenida-segura"></div>

<script>
  let nombreUsuario = "<b>Super Hacker</b>";

  // M√âTODO INSEGURO con innerHTML
  let divInseguro = document.getElementById("bienvenida-insegura");
  divInseguro.innerHTML = `Bienvenido, ${nombreUsuario}`;
  // Resultado en la p√°gina: Bienvenido, **Super Hacker** (el texto aparece en negrita)

  // M√âTODO SEGURO con textContent
  let divSeguro = document.getElementById("bienvenida-segura");
  divSeguro.textContent = `Bienvenido, ${nombreUsuario}`;
  // Resultado en la p√°gina: Bienvenido, <b>Super Hacker</b> (las etiquetas se muestran como texto literal)
</script>
```

**Explicaci√≥n de la Comparaci√≥n:**

- **`innerHTML`** interpreta la cadena de texto como HTML. Si encuentra etiquetas (`<b>`, `<i>`, `<script>`), las procesa como tales. Esto es peligroso si el texto viene de un usuario, porque podr√≠a inyectar HTML o scripts maliciosos (un ataque conocido como XSS).
- **`textContent`** trata la cadena de texto como... bueno, ¬°texto! No interpreta nada. Simplemente toma todos los caracteres y los muestra tal cual. Es inmune a la inyecci√≥n de HTML.

#### 3. **Desarrollo:**

**Regla de oro para elegir:**

- **¬øQuieres insertar HTML formateado y conf√≠as 100% en la fuente de ese HTML (por ejemplo, lo escribiste t√∫)?** Usa `innerHTML`.
- **¬øQuieres insertar texto que proviene de un usuario o de una fuente externa no confiable?** **USA SIEMPRE `textContent`**. Es tu escudo protector.

Escribir en `textContent` es la forma "segura por defecto" de poner texto en la p√°gina.

üî¥ **Fundamental**: Dominar la diferencia entre `innerHTML` y `textContent` es absolutamente cr√≠tico para la seguridad y la robustez de tu aplicaci√≥n. `textContent` es tu mejor amigo para manejar datos de usuarios.

---

### I - La Propiedad `hidden`: La Forma Moderna de Esconder Cosas üü°

#### 1. **Introducci√≥n:**

La propiedad `hidden` es un booleano (`true`/`false`) que te permite ocultar o mostrar un elemento de una forma simple y sem√°ntica, funcionando como un interruptor de visibilidad.

#### 2. **Ejemplo:**

```html
<div id="parpadeante">¬°M√≠rame parpadear!</div>
<button onclick="toggleVisibilidad()">Ocultar/Mostrar</button>

<script>
  let elemento = document.getElementById("parpadeante");

  function toggleVisibilidad() {
    // Si est√° oculto (hidden=true), lo mostramos (hidden=false), y viceversa.
    elemento.hidden = !elemento.hidden;
  }

  // O para hacer que parpadee solo:
  setInterval(() => {
    elemento.hidden = !elemento.hidden;
  }, 1000);
</script>
```

**Explicaci√≥n del ejemplo:**
El c√≥digo crea un elemento que parpadea cada segundo. Lo logra simplemente invirtiendo el valor de la propiedad `hidden` de `true` a `false` y de `false` a `true` repetidamente.

#### 3. **Desarrollo:**

T√©cnicamente, asignar `elemento.hidden = true` es lo mismo que hacer `elemento.style.display = 'none'`. Entonces, ¬øpor qu√© usar `hidden`?

- **Es m√°s corto y legible:** `elemento.hidden = true` es m√°s claro y directo que `elemento.style.display = 'none'`.
- **Es m√°s sem√°ntico:** Est√°s declarando la _intenci√≥n_ de que el elemento est√© oculto, en lugar de simplemente manipular su estilo de visualizaci√≥n.

Puedes usarlo tanto en HTML (`<div hidden>...</div>`) como en JavaScript.

üü° **Importante**: Es una forma moderna y limpia de controlar la visibilidad de los elementos. Es una excelente alternativa a manipular directamente los estilos CSS para esta tarea com√∫n.

---

### J - M√°s Propiedades: Los Atajos a los Atributos HTML üî¥

#### 1. **Introducci√≥n:**

Muchos de los atributos m√°s comunes que escribes en tus etiquetas HTML (como `id`, `value`, `href`, `type`) tienen una propiedad correspondiente directamente en el objeto DOM, permiti√©ndote acceder a ellos y modificarlos de forma muy sencilla.

#### 2. **Ejemplo:**

```html
<input id="miInput" type="text" value="Texto inicial" />
<a id="miEnlace" href="/pagina-vieja.html">Un enlace</a>

<script>
  let input = document.getElementById("miInput");
  let enlace = document.getElementById("miEnlace");

  // Leer propiedades del input
  console.log(input.id); // "miInput"
  console.log(input.type); // "text"
  console.log(input.value); // "Texto inicial"

  // Modificar propiedades
  input.value = "¬°Texto cambiado por JS!";
  enlace.href = "/pagina-nueva.html";

  // Ahora el input muestra el nuevo texto y el enlace apunta a otro sitio.
</script>
```

**Explicaci√≥n del ejemplo:**
En lugar de usar m√©todos complicados para leer o cambiar los atributos, simplemente accedemos a ellos como si fueran propiedades de un objeto normal. `input.value` nos da el valor actual del campo de texto, y al asignarle un nuevo valor, lo actualizamos en la pantalla.

#### 3. **Desarrollo:**

Esta es la forma m√°s com√∫n y directa de trabajar con los atributos est√°ndar de HTML. Casi todos los atributos que se te ocurran tienen su reflejo como una propiedad en el objeto DOM:

- `value` para `<input>`, `<select>`, `<textarea>`.
- `href` para `<a>`.
- `id` para cualquier elemento.
- `src` para `<img>` y `<script>`.
- `className` para el atributo `class`. (Ojo, se llama `className` y no `class` porque `class` es una palabra reservada en JavaScript).

Si alguna vez tienes dudas sobre qu√© propiedades tiene un elemento, hay un truco infalible:

1.  Abre la consola de desarrollador de tu navegador.
2.  Selecciona el elemento que te interesa.
3.  Escribe `console.dir($0)` (en Chrome/Edge) o simplemente `console.dir(miVariableDeElemento)`.
4.  ¬°Explora la lista interactiva de todas sus propiedades!

üî¥ **Fundamental**: Acceder a los atributos como propiedades es el pan de cada d√≠a en la manipulaci√≥n del DOM. Es la forma m√°s r√°pida y legible de interactuar con las caracter√≠sticas de tus elementos.
