## A - Eventos de Clic: `mousedown`, `mouseup` y `click` 🔴

#### 1. **Introducción:**

Estos tres eventos son la santísima trinidad de cualquier clic: uno para cuando **presionas** el botón, otro para cuando lo **sueltas**, y uno final que confirma el "clic" **completo**.

#### 2. **Ejemplo:**

```html
<button id="miBoton">¡Haz clic aquí y mira la consola!</button>
<div id="log"></div>

<script>
  const boton = document.getElementById("miBoton");
  const log = document.getElementById("log");

  function registrarEvento(e) {
    // Añadimos el nombre del evento al div 'log'
    log.innerHTML += e.type + "<br>";
  }

  boton.addEventListener("mousedown", registrarEvento);
  boton.addEventListener("mouseup", registrarEvento);
  boton.addEventListener("click", registrarEvento);
</script>
```

**Explicación del ejemplo:**
Hemos creado un botón. Le hemos pedido que "escuche" tres eventos: `mousedown`, `mouseup` y `click`. Cada vez que uno de ellos ocurre, su nombre se escribe en el `div` de abajo. Si haces un clic normal y rápido, verás que aparecen en este orden exacto: `mousedown`, luego `mouseup`, y finalmente `click`. ¡No hay otra forma!

#### 3. **Desarrollo:**

La clave aquí es el **orden inmutable** en que ocurren:

1.  `mousedown`: Se dispara en el instante en que tu dedo baja y presiona el botón del ratón.
2.  `mouseup`: Se dispara en el instante en que levantas el dedo y sueltas el botón.
3.  `click`: Se dispara **solo si** `mousedown` y `mouseup` ocurrieron sobre el **mismo elemento** y con el botón izquierdo. Es la confirmación del ciclo completo.

**¿Por qué te debería importar esto hasta la paranoia?** Porque te da un control absoluto. Si quieres que algo suceda justo cuando el usuario presiona (como empezar a arrastrar un objeto), usas `mousedown`. Si quieres que suceda cuando suelta (como soltar el objeto arrastrado), usas `mouseup`. El evento `click` es para acciones simples y directas, como navegar a un enlace o enviar un formulario.

🔴 **Fundamental**: Son la base de la interacción más común en la web: hacer clic. Sin entender esta secuencia, no puedes programar botones, menús o cualquier elemento interactivo de forma fiable. Es como intentar escribir sin conocer las letras.

---

## B - Eventos de Movimiento: `mouseover`, `mouseout` y `mousemove` 🟡

#### 1. **Introducción:**

Estos eventos rastrean la presencia y el movimiento del puntero del ratón sobre un elemento, como un guardia de seguridad que informa si alguien entra, sale o se mueve dentro de una habitación.

#### 2. **Ejemplo:**

```html
<style>
  #zonaSensible {
    width: 300px;
    height: 150px;
    border: 2px solid steelblue;
    display: flex;
    align-items: center;
    justify-content: center;
  }
</style>

<div id="zonaSensible">Pasa el ratón por aquí</div>
<p>Último evento: <span id="info">---</span></p>

<script>
  const zona = document.getElementById("zonaSensible");
  const info = document.getElementById("info");

  zona.addEventListener(
    "mouseover",
    () => (info.textContent = "¡El ratón ha entrado! (mouseover)")
  );
  zona.addEventListener(
    "mouseout",
    () => (info.textContent = "¡El ratón ha salido! (mouseout)")
  );
  zona.addEventListener("mousemove", (e) => {
    // Para no saturar, solo actualizamos la posición en el texto del div
    zona.textContent = `Moviéndose en X:${e.clientX}, Y:${e.clientY}`;
  });
</script>
```

**Explicación del ejemplo:**
Tenemos un recuadro azul. `mouseover` se dispara una sola vez, justo cuando el puntero entra en el recuadro. `mouseout` se dispara una sola vez, justo cuando sale. Mientras el puntero se mueva _dentro_ del recuadro, `mousemove` se disparará continuamente, actualizando las coordenadas.

#### 3. **Desarrollo:**

- `mouseover`: El puntero del ratón **entra** en los límites de un elemento.
- `mouseout`: El puntero del ratón **sale** de los límites de un elemento.
- `mousemove`: Se dispara **cada vez que el ratón se mueve un solo píxel** mientras está sobre el elemento. ¡Cuidado! Este evento puede dispararse muchísimas veces por segundo, así que evita poner tareas muy pesadas en su manejador para no ralentizar la página.

🟡 **Importante**: Esencial para crear interfaces dinámicas como menús desplegables que aparecen al pasar el ratón (`mouseover`), mostrar información adicional (tooltips) o para cualquier funcionalidad de arrastrar y soltar (`mousemove`).

---

## C - Clics Especiales: `dblclick` y `contextmenu` 🔵

#### 1. **Introducción:**

Estos son los eventos para interacciones menos comunes: el doble clic y el clic derecho del ratón.

#### 2. **Ejemplo:**

```html
<div
  id="areaEspecial"
  style="padding: 20px; background-color: #f0f0f0; border: 1px solid #ccc;"
>
  Haz doble clic o clic derecho aquí.
</div>
<p id="resultado"></p>

<script>
  const area = document.getElementById("areaEspecial");
  const resultado = document.getElementById("resultado");

  // Doble clic
  area.addEventListener("dblclick", () => {
    resultado.textContent = "¡Detectado un DOBLE CLIC!";
  });

  // Clic derecho
  area.addEventListener("contextmenu", (e) => {
    e.preventDefault(); // ¡Muy importante! Evita que aparezca el menú normal del navegador.
    resultado.textContent =
      "¡Detectado un CLIC DERECHO! Menú personalizado iría aquí.";
  });
</script>
```

**Explicación del ejemplo:**
Al hacer doble clic en el área gris, se activa el evento `dblclick`. Al hacer clic derecho, en lugar de ver el menú típico del navegador (como "Guardar imagen" o "Inspeccionar"), activamos nuestro propio mensaje gracias a `e.preventDefault()`, que cancela la acción por defecto.

#### 3. **Desarrollo:**

- `dblclick`: Se dispara tras dos eventos `click` que ocurren muy seguidos sobre el mismo elemento.
- `contextmenu`: Se dispara cuando se presiona el botón derecho del ratón. Ojo, también puede activarse con una tecla especial del teclado, por lo que no es _exclusivamente_ un evento de ratón.

🔵 **Específico**: No los usarás todos los días. `dblclick` se usa poco porque no es muy intuitivo para los usuarios en la web. `contextmenu` es muy útil para crear menús contextuales personalizados en aplicaciones web complejas (como un editor de fotos o un gestor de archivos online), pero es excesivo para una página web simple.

---

## D - ¿Qué Botón se Presionó?: La Propiedad `event.button` 🟡

#### 1. **Introducción:**

Cuando un evento como `mousedown` ocurre, esta propiedad te dice exactamente qué botón del ratón se usó, como un chismoso que te cuenta quién tocó el timbre.

#### 2. **Ejemplo:**

```html
<button id="botonMultiUso">Prueba todos los botones de tu ratón aquí</button>
<p id="infoBoton"></p>

<script>
  const boton = document.getElementById("botonMultiUso");
  const info = document.getElementById("infoBoton");

  boton.addEventListener("mousedown", (e) => {
    let nombreBoton;
    switch (e.button) {
      case 0:
        nombreBoton = "Izquierdo (Principal)";
        break;
      case 1:
        nombreBoton = "Medio (Rueda)";
        break;
      case 2:
        nombreBoton = "Derecho (Secundario)";
        break;
      default:
        nombreBoton = `Otro (${e.button})`; // Para ratones con más botones
    }
    info.textContent = `Presionaste el botón: ${nombreBoton}`;
  });
</script>
```

**Explicación del ejemplo:**
Este código escucha el evento `mousedown` en un botón. Dentro de la función, usamos `e.button` para comprobar el número del botón presionado y mostramos un mensaje amigable. Prueba a hacer clic con el botón izquierdo, derecho y, si tienes, con la rueda del medio.

#### 3. **Desarrollo:**

Los valores de `event.button` son un estándar que debes memorizar:

- `0`: Botón izquierdo (el que usas el 99% del tiempo).
- `1`: Botón medio (normalmente, al presionar la rueda de scroll).
- `2`: Botón derecho (el que abre el menú contextual).
- `3` y `4`: Botones extra como "Atrás" y "Adelante" en ratones de gaming.

**¡Alerta de trampa!** No necesitas `event.button` para los eventos `click` (que _solo_ se dispara con el botón izquierdo) o `contextmenu` (que _solo_ se dispara con el derecho). Su verdadero poder está en `mousedown` y `mouseup`, que se disparan con _cualquier_ botón.

**Nota sobre el pasado oscuro:** Si ves código antiguo con `event.which`, ¡huye! Es una forma obsoleta y no estándar de hacer lo mismo. `event.button` es el camino correcto.

🟡 **Importante**: Es crucial si tu aplicación necesita distinguir entre diferentes tipos de clics en el mismo elemento. Por ejemplo, en un juego, el clic izquierdo podría disparar y el derecho apuntar.

---

## E - Teclas Modificadoras: `shiftKey`, `altKey`, `ctrlKey`, `metaKey` 🟡

#### 1. **Introducción:**

Estas propiedades del evento te permiten saber si el usuario mantenía presionadas las teclas `Shift`, `Alt`, `Ctrl` o `Cmd` (en Mac) mientras ocurría el evento del ratón.

#### 2. **Ejemplo:**

```html
<div
  id="areaSecreta"
  style="border: 2px dashed grey; padding: 20px; text-align: center;"
>
  Intenta hacer clic normal... no pasa nada. <br />
  Ahora intenta hacer <b>Alt + Shift + Clic</b>.
</div>

<script>
  const area = document.getElementById("areaSecreta");
  area.addEventListener("click", (e) => {
    // Comprobamos si AMBAS teclas, Alt y Shift, estaban presionadas
    if (e.altKey && e.shiftKey) {
      alert("¡Acceso concedido! Has usado la combinación secreta.");
    }
  });
</script>
```

**Explicación del ejemplo:**
El `div` solo reacciona al clic si, y solo si, las teclas `Alt` y `Shift` están presionadas en ese preciso momento. Las propiedades `e.altKey` y `e.shiftKey` son booleanas (`true` o `false`), lo que las hace perfectas para una condición `if`.

#### 3. **Desarrollo:**

- `event.shiftKey`: `true` si `Shift` está presionado.
- `event.altKey`: `true` si `Alt` (u `Opt` en Mac) está presionado.
- `event.ctrlKey`: `true` si `Ctrl` está presionado.
- `event.metaKey`: `true` si `Cmd` (⌘) está presionado en Mac (o la tecla de Windows en Windows).

**El truco de compatibilidad que te salvará la vida (Mac vs. Windows):**
Los usuarios de Mac están acostumbrados a usar `Cmd` donde los de Windows/Linux usan `Ctrl`. Por ejemplo, `Cmd+C` para copiar. Si creas un atajo como `Ctrl+Clic`, un usuario de Mac podría intentar `Cmd+Clic`. Peor aún, en Mac, `Ctrl+Clic` ¡se interpreta como un clic derecho y dispara `contextmenu`!

**Solución paranoica y perfecta:** Siempre comprueba ambas teclas.

```javascript
// En lugar de esto:
if (event.ctrlKey) {
  /* ... */
}

// Haz SIEMPRE esto para que todos tus usuarios te amen:
if (event.ctrlKey || event.metaKey) {
  /* Tu lógica para Ctrl+Clic o Cmd+Clic */
}
```

🟡 **Importante**: Fundamental para crear atajos de teclado (shortcuts) que mejoran la usabilidad de tu aplicación, como seleccionar múltiples elementos con `Shift+Clic` o abrir un menú de opciones con `Ctrl+Clic`.

---

## F - Coordenadas del Ratón: La Lucha entre `clientX/Y` y `pageX/Y` 🔴

#### 1. **Introducción:**

Ambos te dicen dónde está el ratón, pero miden desde puntos de referencia totalmente distintos. No entender esta diferencia es, sin exagerar, la causa #1 de dolores de cabeza y elementos que aparecen donde no deben.

#### 2. **El Duelo: `client` vs. `page` (La Comparación Definitiva)**

Imagina que estás mirando por la ventana de tu habitación.

- **`clientX / clientY` (Coordenadas de la Ventana/Cliente):**

  - **Qué son:** La posición del ratón **relativa a la parte visible de la ventana del navegador**.
  - **La analogía:** El marco de tu ventana. La esquina superior izquierda de TU VENTANA es siempre `(0, 0)`. No importa si afuera ves árboles o edificios (es decir, si has hecho scroll en la página), la esquina de tu ventana no se mueve.
  - **Comportamiento con scroll:** Si haces scroll en la página, los valores de `clientX/Y` **cambian** para un mismo punto del contenido, porque su posición relativa a la ventana ha cambiado.

- **`pageX / pageY` (Coordenadas de la Página):**
  - **Qué son:** La posición del ratón **relativa a la totalidad del documento HTML**.
  - **La analogía:** Un mapa del tesoro gigante desenrollado en el suelo. La esquina superior izquierda de TODO EL MAPA es siempre `(0, 0)`. La "X" que marca el tesoro siempre tendrá las mismas coordenadas en el mapa, sin importar qué parte del mapa estés mirando en este momento.
  - **Comportamiento con scroll:** Si haces scroll, los valores de `pageX/Y` **NO cambian** para un mismo punto del contenido, porque su posición en el "mapa" total de la página es fija.

#### 3. **Ejemplo para que lo veas con tus propios ojos:**

```html
<style>
  body {
    height: 2000px; /* Forzamos el scroll */
  }
  #tracker {
    position: fixed;
    top: 10px;
    left: 10px;
    background: lightyellow;
    padding: 10px;
    border: 1px solid black;
  }
</style>

<div id="tracker">
  <b>Coordenadas de la Ventana (client):</b> <span id="clientCoords"></span
  ><br />
  <b>Coordenadas de la Página (page):</b> <span id="pageCoords"></span>
</div>

<script>
  document.addEventListener("mousemove", (e) => {
    document.getElementById(
      "clientCoords"
    ).textContent = `X: ${e.clientX}, Y: ${e.clientY}`;
    document.getElementById(
      "pageCoords"
    ).textContent = `X: ${e.pageX}, Y: ${e.pageY}`;
  });
</script>
```

**Explicación del ejemplo:**
Mueve el ratón por la página. Ahora, **haz scroll hacia abajo** y vuelve a mover el ratón. Observa el cuadro de información:

- `clientX/Y` siempre serán valores pequeños si mantienes el ratón en la parte superior de tu pantalla.
- `pageX/Y` seguirán aumentando a medida que bajas por la página, ¡reflejando la distancia total desde el inicio del documento!

#### 4. **Desarrollo:**

**La pregunta del millón: ¿Cuándo uso cuál?**

- Usa `clientX / clientY` cuando necesites posicionar algo **relativo a la pantalla**, algo que no se mueva con el scroll. El ejemplo perfecto es un menú modal o un `tooltip` que debe aparecer junto al puntero, sin importar en qué parte de la página estés. Piensa en `position: fixed`.
- Usa `pageX / pageY` cuando necesites interactuar con el **contenido mismo de la página**. Por ejemplo, si estás haciendo una aplicación para poner "chinchetas" virtuales en un artículo largo, necesitas `pageX/Y` para que la chincheta se quede pegada a ese párrafo específico, incluso si el usuario hace scroll.

🔴 **Fundamental**: Esto no es opcional. Si quieres posicionar CUALQUIER cosa con el ratón (tooltips, menús, elementos arrastrables), necesitas dominar estas coordenadas. Equivocarte aquí hará que tus elementos aparezcan en lugares completamente inesperados.

---

## G - Evitando Efectos Secundarios: Prevenir la Selección y la Copia 🟡

#### 1. **Introducción:**

A veces, las acciones del ratón tienen efectos secundarios por defecto del navegador (como seleccionar texto al hacer doble clic) que queremos evitar para mejorar la experiencia en nuestra aplicación.

#### 2. **Ejemplo:**

```html
<!-- CASO 1: Evitar que el texto se seleccione al hacer doble clic -->
<p>
  Intenta hacer doble clic en esta palabra:
  <b ondblclick="alert('¡Doble clic!')">NORMAL</b>. (El texto se selecciona,
  ¿verdad?)
</p>
<p>
  Ahora aquí:
  <b ondblclick="alert('¡Doble clic!')" onmousedown="return false;">BLOQUEADO</b
  >. (¡Magia! El texto ya no se selecciona).
</p>

<!-- CASO 2: Evitar que se copie el contenido -->
<div oncopy="alert('¡Copiar está prohibido!'); return false;">
  Intenta seleccionar y copiar este texto (Ctrl+C o Cmd+C). No podrás.
</div>
```

**Explicación del ejemplo:**

- **Caso 1:** En el segundo `<b>`, añadimos `onmousedown="return false;"`. Esto le dice al navegador: "cuando el usuario presione el botón del ratón sobre este elemento, cancela cualquier acción que fueras a hacer por defecto". Como la selección de texto comienza en `mousedown`, la detenemos antes de que empiece.
- **Caso 2:** Interceptamos el evento `oncopy`. Cuando el usuario intenta copiar, mostramos una alerta y, de nuevo, `return false` cancela la acción de copiado.

#### 3. **Desarrollo:**

La técnica clave aquí es **prevenir la acción por defecto del navegador**. Hay dos formas principales:

1.  **`return false;`** desde un manejador de eventos HTML (como en el ejemplo). Es una forma rápida y antigua.
2.  **`event.preventDefault();`** desde un manejador de eventos en JavaScript. Es la forma moderna y más flexible.

El texto del ejemplo `onmousedown="return false;"` es equivalente a esto en JavaScript:

```javascript
const elemento = document.getElementById("miElemento");
elemento.addEventListener("mousedown", function (event) {
  event.preventDefault();
});
```

**¿Por qué es importante?** Porque las interfaces de aplicaciones web ricas (como un editor de texto tipo Google Docs o una herramienta de diseño como Figma) no pueden permitirse que el navegador interfiera. Imagina que al hacer doble clic para editar una forma, se seleccionara todo el texto de la página. Sería un desastre. Saber cancelar estos comportamientos por defecto te da el control para construir experiencias de usuario pulidas y sin interrupciones.

🟡 **Importante**: Es una técnica esencial para crear interfaces de usuario avanzadas que se sientan como aplicaciones de escritorio, donde tienes control total sobre lo que cada acción del ratón hace, sin los "efectos secundarios" del navegador.
