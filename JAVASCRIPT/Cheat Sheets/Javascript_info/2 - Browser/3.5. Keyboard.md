### A - Advertencia Amistosa: `keydown` no es para Rellenar Campos ğŸŸ¡

#### 1. **IntroducciÃ³n:**

Antes de lanzarnos de cabeza, una advertencia crucial: si solo quieres saber quÃ© ha escrito un usuario en un campo de texto (`<input>`), los eventos de teclado no son tu mejor herramienta.

#### 2. **Ejemplo:**

Imagina este escenario:

- Un usuario escribe "hola" con el teclado -> `keydown` funciona.
- Un usuario pega "hola" con el ratÃ³n -> `keydown` **no se entera de nada**.
- Un usuario dicta "hola" usando el reconocimiento de voz del mÃ³vil -> `keydown` **tampoco se entera**.

**ExplicaciÃ³n del "problema":**
`keydown` y `keyup` solo reaccionan a pulsaciones de teclas fÃ­sicas (o virtuales). No detectan otras formas de introducir texto. Para eso, existe un evento mucho mÃ¡s adecuado llamado `input`, que veremos mÃ¡s adelante. Â¡Prometido!

#### 3. **Desarrollo:**

Entonces, Â¿para quÃ© usamos los eventos de teclado? Â¡Para todo lo demÃ¡s que tenga que ver con el teclado! Son perfectos cuando necesitas reaccionar a teclas especÃ­ficas que no necesariamente escriben un carÃ¡cter, como las flechas de direcciÃ³n (`â†‘`, `â†“`), la tecla `Escape`, o para crear atajos de teclado (los famosos _hotkeys_) como `Ctrl + S` para guardar.

ğŸŸ¡ **Importante**: Saber esto desde el principio te ahorrarÃ¡ muchÃ­simos dolores de cabeza. Es una de esas "trampas" clÃ¡sicas en las que caen los principiantes: intentan validar un formulario usando `keydown` y se sorprenden cuando los usuarios pueden saltarse las reglas pegando texto con el ratÃ³n. Â¡TÃº ya no caerÃ¡s en ella!

---

### B - `keydown` y `keyup`: El DÃºo DinÃ¡mico del Teclado ğŸ”´

#### 1. **IntroducciÃ³n:**

Estos son los dos eventos de teclado fundamentales: `keydown` se dispara justo cuando presionas una tecla, y `keyup` se dispara cuando la sueltas.

#### 2. **Ejemplo:**

```html
<input type="text" id="miInput" placeholder="Presiona una tecla aquÃ­..." />

<script>
  const input = document.getElementById("miInput");

  input.addEventListener("keydown", () => {
    console.log("Â¡Tecla PRESIONADA!");
  });

  input.addEventListener("keyup", () => {
    console.log("Â¡Tecla SUELTA!");
  });
</script>
```

**ExplicaciÃ³n del ejemplo:**
Si vas al campo de texto y mantienes presionada la tecla "A", verÃ¡s "Â¡Tecla PRESIONADA!" en la consola inmediatamente. Solo cuando sueltes la tecla "A", aparecerÃ¡ el mensaje "Â¡Tecla SUELTA!".

#### 3. **Desarrollo:**

Piensa en ello como un interruptor de luz. `keydown` es el "clic" que haces al encenderlo, y `keyup` es el "clic" que haces al apagarlo. La mayorÃ­a de las veces, trabajarÃ¡s con `keydown` porque te permite capturar la acciÃ³n en el momento en que ocurre, e incluso cancelarla si es necesario (lo veremos mÃ¡s adelante en la **secciÃ³n G**).

ğŸ”´ **Fundamental**: Estos son los cimientos de toda interacciÃ³n con el teclado en JavaScript. No puedes hacer nada relacionado con teclas sin entender este par. Son el pan y la mantequilla de los eventos de teclado.

---

### C - `event.key`: El CarÃ¡cter que Ves en Pantalla ğŸ”´

#### 1. **IntroducciÃ³n:**

Dentro de un evento de teclado, la propiedad `event.key` te dice el **carÃ¡cter** exacto que corresponde a la tecla que presionaste, respetando mayÃºsculas, minÃºsculas y el idioma del teclado.

#### 2. **Ejemplo:**

```javascript
document.addEventListener("keydown", (event) => {
  // Si presionas la tecla 'a' -> event.key serÃ¡ "a"
  // Si presionas 'Shift' + 'a' -> event.key serÃ¡ "A"
  // Si presionas la tecla 'Enter' -> event.key serÃ¡ "Enter"
  // Si tienes un teclado en espaÃ±ol y presionas la 'Ã±' -> event.key serÃ¡ "Ã±"

  console.log(`La propiedad event.key es: ${event.key}`);
});
```

**ExplicaciÃ³n del ejemplo:**
Este cÃ³digo escucha cualquier tecla que presiones en la pÃ¡gina. `event.key` te da el valor "lÃ³gico" de la tecla. Es inteligente: si presionas `Shift`, sabe que el siguiente carÃ¡cter debe ser mayÃºscula. Si cambias de idioma, te darÃ¡ el carÃ¡cter de ese idioma.

#### 3. **Desarrollo:**

`event.key` es tu mejor amigo cuando te importa **quÃ©** se estÃ¡ intentando "escribir". Si estÃ¡s haciendo un juego donde el personaje se mueve con las teclas "w", "a", "s", "d", usar `event.key` es una opciÃ³n muy intuitiva. Su valor es casi siempre lo que esperarÃ­as. Para teclas que no son caracteres, como `Shift` o `F1`, su valor es un nombre descriptivo como `"Shift"` o `"F1"`.

ğŸ”´ **Fundamental**: Es la forma mÃ¡s moderna y legible de saber quÃ© tecla se ha pulsado en tÃ©rminos del carÃ¡cter que representa. En el 90% de los casos donde te importe el carÃ¡cter, usarÃ¡s `event.key`.

---

### D - `event.code`: La Tecla FÃ­sica que Pulsas ğŸ”´

#### 1. **IntroducciÃ³n:**

La propiedad `event.code` te dice la **ubicaciÃ³n fÃ­sica** de la tecla en un teclado estÃ¡ndar estadounidense (QWERTY), sin importar el idioma o si `Shift` estÃ¡ presionado.

#### 2. **Ejemplo:**

```javascript
document.addEventListener("keydown", (event) => {
  // Presiones 'a' o 'A' (Shift + 'a') -> event.code siempre serÃ¡ "KeyA"
  // Presiones '7' en la fila superior o en el teclado numÃ©rico:
  // - Fila superior: event.code serÃ¡ "Digit7"
  // - Teclado numÃ©rico: event.code serÃ¡ "Numpad7"
  // Presiones la tecla Shift izquierda o derecha:
  // - Izquierda: event.code serÃ¡ "ShiftLeft"
  // - Derecha: event.code serÃ¡ "ShiftRight"

  console.log(`La propiedad event.code es: ${event.code}`);
});
```

**ExplicaciÃ³n del ejemplo:**
`event.code` no se preocupa por el carÃ¡cter. Se preocupa por el trozo de plÃ¡stico que estÃ¡s presionando. `KeyA` se refiere a la tecla que tiene la "A" en un teclado QWERTY. `ShiftLeft` se refiere inequÃ­vocamente al `Shift` de la izquierda. Es un cÃ³digo de "hardware".

#### 3. **Desarrollo:**

Piensa en `event.code` como el nÃºmero de serie de la tecla. No cambia. Esto es increÃ­blemente Ãºtil para atajos de teclado que no deberÃ­an cambiar si el usuario cambia de idioma. Por ejemplo, en muchos juegos, las teclas `W`, `A`, `S`, `D` se usan para el movimiento. Si usas `event.code` (`KeyW`, `KeyA`, `KeyS`, `KeyD`), el juego funcionarÃ¡ igual sin importar el idioma del teclado del jugador, porque las posiciones fÃ­sicas de esas teclas son las mismas.

ğŸ”´ **Fundamental**: Es la contraparte de `event.key`. Entender `event.code` es crucial para crear atajos de teclado robustos e independientes del idioma. No puedes ignorarlo.

---

### E - `key` vs. `code`: La Batalla por el Atajo Perfecto ğŸ”´

#### 1. **IntroducciÃ³n:**

AquÃ­ es donde muchos se confunden, pero no te preocupes, vamos a dejarlo meridianamente claro: la elecciÃ³n entre `event.key` y `event.code` depende de **quÃ© quieres que haga tu atajo de teclado**.

#### 2. **El Dilema: El Teclado AlemÃ¡n**

Imagina que creas un atajo para "deshacer" con `Ctrl + Z`.

- **Tu lÃ³gica:** `if (event.ctrlKey && event.code === 'KeyZ') { undo(); }`

Ahora, mira estos dos teclados. El de arriba es el estÃ¡ndar (US QWERTY), el de abajo es el alemÃ¡n (QWERTZ).

![Teclado US QWERTY](https://javascript.info/article/keyboard-events/us-layout.svg)![Teclado AlemÃ¡n QWERTZ](https://javascript.info/article/keyboard-events/german-layout.svg)

**Â¡LA TRAMPA!**
En el teclado alemÃ¡n, la tecla fÃ­sica que estÃ¡ en la posiciÃ³n de la "Z" en un teclado americano, en realidad tiene una "Y".

**Consecuencia:**
Un usuario con teclado alemÃ¡n, al presionar la tecla `Y`, Â¡activarÃ¡ tu atajo `Ctrl + Z`! Porque para tu cÃ³digo, Ã©l estÃ¡ presionando `KeyZ` (`event.code`), aunque en su pantalla aparezca una "y" (`event.key`). Â¡Esto es sÃºper confuso para el usuario!

#### 3. **Desarrollo: Â¿CuÃ¡ndo usar cada uno?**

AquÃ­ tienes la regla de oro. LÃ©ela, relÃ©ela y tatÃºatela en el alma:

- **Usa `event.key` si tu atajo estÃ¡ ligado al _significado_ de la letra.**

  - **Ejemplo:** Quieres que `Ctrl + Z` siempre corresponda a la letra "Z", sin importar dÃ³nde estÃ© esa tecla en el teclado del usuario. Tu cÃ³digo serÃ­a: `if (event.ctrlKey && event.key === 'z')`. Esto es mÃ¡s respetuoso con la configuraciÃ³n del usuario.

- **Usa `event.code` si tu atajo estÃ¡ ligado a la _posiciÃ³n fÃ­sica_ de la tecla, como en los videojuegos.**
  - **Ejemplo:** Quieres que las teclas `W, A, S, D` siempre sirvan para moverse, porque estÃ¡n agrupadas convenientemente en el lado izquierdo del teclado. Tu cÃ³digo serÃ­a: `if (event.code === 'KeyW')`. AsÃ­, garantizas que la "experiencia muscular" sea la misma para todos.

ğŸ”´ **Fundamental**: Esta distinciÃ³n es la diferencia entre una aplicaciÃ³n que se siente "rota" para usuarios internacionales y una que funciona de maravilla. No es una preferencia, es una decisiÃ³n de diseÃ±o crucial. Â¡Ahora ya lo sabes y tienes el poder de decidir correctamente!

---

### F - Auto-repeticiÃ³n: Cuando una Tecla se Queda Atascada ğŸŸ¡

#### 1. **IntroducciÃ³n:**

Si mantienes una tecla presionada, el evento `keydown` no se dispara una sola vez, sino que empieza a repetirse una y otra vez hasta que la sueltas.

#### 2. **Ejemplo:**

```javascript
let i = 0;
document.addEventListener("keydown", (event) => {
  // La primera vez que presiones, event.repeat serÃ¡ `false`.
  // Todas las veces siguientes (mientras la mantengas presionada), serÃ¡ `true`.
  if (event.repeat) {
    console.log("Â¡Esto es una repeticiÃ³n! No es la primera vez.");
  } else {
    console.log("Â¡Primera pulsaciÃ³n!");
  }
});
```

**ExplicaciÃ³n del ejemplo:**
Abre la consola de tu navegador y mantÃ©n presionada cualquier tecla. VerÃ¡s "Â¡Primera pulsaciÃ³n!" una vez, y luego una avalancha de "Â¡Esto es una repeticiÃ³n!". La propiedad `event.repeat` nos permite distinguir la pulsaciÃ³n inicial de las repeticiones automÃ¡ticas.

#### 3. **Desarrollo:**

Â¿Por quÃ© es esto importante? Imagina que estÃ¡s haciendo un juego y cada vez que el usuario presiona la barra espaciadora, dispara un misil. Si no tienes en cuenta la auto-repeticiÃ³n, al mantener la barra espaciadora presionada, el jugador dispararÃ­a una rÃ¡faga infinita de misiles, lo cual podrÃ­a no ser lo que quieres. Usando `if (!event.repeat)` puedes asegurarte de que la acciÃ³n (disparar) solo ocurra en la primera pulsaciÃ³n.

ğŸŸ¡ **Importante**: Conocer `event.repeat` te da un control mÃ¡s fino sobre la interacciÃ³n. Te permite decidir si una acciÃ³n debe ocurrir solo una vez por pulsaciÃ³n o continuamente mientras la tecla estÃ© presionada.

---

### G - Cancelando Acciones: Â¡TÃº Tienes el Control! ğŸ”´

#### 1. **IntroducciÃ³n:**

Puedes evitar que el navegador realice su acciÃ³n por defecto para una tecla (como escribir una letra o desplazarse por la pÃ¡gina) usando `event.preventDefault()`.

#### 2. **Ejemplo:**

Vamos a crear un campo de texto que solo acepta nÃºmeros.

```html
<!-- El `return false` en el HTML hace lo mismo que event.preventDefault() en JS -->
<input
  type="text"
  placeholder="Solo nÃºmeros, por favor"
  onkeydown="return esNumero(event.key)"
/>

<script>
  function esNumero(tecla) {
    // Lista de teclas permitidas
    const teclasPermitidas = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "Backspace",
      "Delete",
      "ArrowLeft",
      "ArrowRight",
      "Tab", // Â¡No olvides las teclas de ediciÃ³n!
    ];

    if (teclasPermitidas.includes(tecla)) {
      return true; // Permite la acciÃ³n (la tecla funciona)
    } else {
      return false; // Cancela la acciÃ³n (la tecla no hace nada)
    }
  }
</script>
```

**ExplicaciÃ³n del ejemplo:**
La funciÃ³n `esNumero` comprueba si la tecla presionada (`event.key`) estÃ¡ en nuestra lista de teclas vÃ¡lidas. Si lo estÃ¡, devuelve `true` y no pasa nada. Pero si presionas, por ejemplo, la letra "a", la funciÃ³n devuelve `false`. Devolver `false` desde un manejador de eventos en lÃ­nea (en el HTML) es una forma clÃ¡sica de decirle al navegador: "Oye, cancela lo que sea que ibas a hacer con esta tecla". El resultado es que la "a" nunca aparecerÃ¡ en el campo de texto.

#### 3. **Desarrollo:**

Prevenir la acciÃ³n por defecto es una tÃ©cnica poderosÃ­sima. Te permite tomar el control total del teclado. Sin embargo, Â¡cuidado! Hay algunas acciones que no puedes cancelar, como `Alt+F4` en Windows, que cierra la ventana del navegador. Esas son manejadas por el sistema operativo y estÃ¡n fuera de tu alcance. AdemÃ¡s, como vimos en la **secciÃ³n A**, este filtro no es 100% seguro, ya que el usuario aÃºn puede pegar texto no vÃ¡lido.

ğŸ”´ **Fundamental**: `event.preventDefault()` (o `return false`) es una herramienta esencial en el arsenal de cualquier desarrollador de JavaScript. Es la clave para crear interfaces de usuario interactivas y personalizadas.

---

### H - Teclados MÃ³viles: Un Mundo Diferente ğŸŸ¡

#### 1. **IntroducciÃ³n:**

En dispositivos mÃ³viles, los teclados virtuales (llamados IME) a veces se comportan de manera impredecible y no siempre siguen las reglas de `event.key` y `event.code`.

#### 2. **El Problema:**

Cuando usas un teclado mÃ³vil, especialmente para idiomas asiÃ¡ticos o al usar la autocorrecciÃ³n/sugerencias, el navegador puede no saber quÃ© tecla "real" se estÃ¡ presionando hasta que confirmas una palabra. Durante este proceso intermedio, puede que recibas eventos de teclado con:

- `event.key` = `"Unidentified"`
- `event.keyCode` (una propiedad antigua) = `229`

**ExplicaciÃ³n:**
Esto es una seÃ±al del sistema que dice: "El usuario estÃ¡ componiendo texto, pero aÃºn no lo ha finalizado. Â¡No te fÃ­es de este evento de teclado para saber el carÃ¡cter final!".

#### 3. **Desarrollo:**

La lecciÃ³n aquÃ­ es: no confÃ­es ciegamente en que tu lÃ³gica de teclado de escritorio funcionarÃ¡ a la perfecciÃ³n en mÃ³viles. Si tu aplicaciÃ³n depende crÃ­ticamente de la detecciÃ³n de teclas, pruÃ©bala exhaustivamente en dispositivos mÃ³viles. A menudo, para la entrada de texto en mÃ³viles, es mucho mÃ¡s fiable volver a la idea de la **secciÃ³n A** y usar el evento `input`, que se dispara de forma fiable despuÃ©s de que el valor del campo ha cambiado, sin importar cÃ³mo.

ğŸŸ¡ **Importante**: El mundo es mÃ³vil. Ignorar las peculiaridades de los teclados virtuales es una receta para el desastre. Ser consciente de que `event.key` puede ser `"Unidentified"` te prepararÃ¡ para manejar estos casos y no asumir que tu cÃ³digo "simplemente funcionarÃ¡".

---

### I - El Pasado Oscuro: `keypress`, `keyCode` y Otros Fantasmas âšª

#### 1. **IntroducciÃ³n:**

Antes de tener `event.key` y `event.code`, existÃ­an otras propiedades y eventos como `keypress`, `keyCode`, `charCode` y `which`, pero hoy en dÃ­a estÃ¡n obsoletos y no deberÃ­as usarlos.

#### 2. **Ejemplo (Â¡NO LO USES!):**

```javascript
// CÃ“DIGO ANTIGUO Y CONFUSO - SOLO PARA FINES HISTÃ“RICOS
document.addEventListener("keydown", (event) => {
  // Antes, tenÃ­as que hacer cosas raras como esta para saber la tecla:
  const keyCode = event.keyCode || event.which; // Inconsistente entre navegadores

  if (keyCode === 65) {
    // 65 era el cÃ³digo para la 'A'
    console.log("Presionaste la A, Â¡creo!");
  }
});
```

**ExplicaciÃ³n del ejemplo:**
Este cÃ³digo es un desastre. `keyCode` devolvÃ­a valores diferentes en diferentes navegadores para la misma tecla. Era una pesadilla de incompatibilidades.

#### 3. **Desarrollo:**

Los creadores de los estÃ¡ndares web vieron este caos y decidieron crear un sistema nuevo, limpio y lÃ³gico: `event.key` y `event.code`. Los navegadores modernos aÃºn soportan las propiedades antiguas para no "romper" pÃ¡ginas web viejas, pero no hay absolutamente ninguna razÃ³n para que un desarrollador moderno las utilice en cÃ³digo nuevo.

âšª **Raramente usado**: Considera estas propiedades como artefactos de museo. Es bueno saber que existieron para que si alguna vez te encuentras con ellas en cÃ³digo antiguo (legacy code), sepas que son la versiÃ³n "vieja y mala" de `event.key` y `event.code`. Â¡Huye de ellas y abraza el presente
