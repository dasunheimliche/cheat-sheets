## A - `mouseover`/`mouseout`: Los Detectives del Movimiento üßê üü°

#### 1. **Introducci√≥n:**

Estos dos eventos te avisan justo cuando el puntero del rat√≥n entra (`mouseover`) o sale (`mouseout`) del √°rea de un elemento.

#### 2. **Ejemplo:**

Imagina que cada parte de estas caritas es un "elemento". Mueve el rat√≥n sobre ellas y mira el registro de abajo. ¬°Es como un chism√≥grafo de eventos!

![Caritas sonrientes para demostrar los eventos del rat√≥n](https://javascript.info/article/mousemove-mouseover-mouseout-mouseenter-mouseleave/mouseover-mouseout.svg)

```html
<!-- HTML B√°sico -->
<div id="container">
  <div class="smiley-green">
    <div class="left-eye"></div>
    <div class="right-eye"></div>
    <div class="smile"></div>
  </div>
  <!-- ... m√°s caritas ... -->
</div>
<textarea id="log"></textarea>

<script>
  // JavaScript
  let container = document.getElementById("container");
  let log = document.getElementById("log");

  container.onmouseover = container.onmouseout = function (event) {
    // 'event.target' es el elemento EXACTO sobre el que est√° el rat√≥n.
    let target = event.target;

    // 'event.relatedTarget' es el elemento del que vienes o al que vas.
    let relatedTarget = event.relatedTarget;

    // Mostramos la informaci√≥n en el log
    log.value += `${event.type}: target=${target.className}, relatedTarget=${
      relatedTarget ? relatedTarget.className : "null"
    }\n`;
    log.scrollTop = log.scrollHeight; // Para hacer scroll autom√°tico

    // Pintamos el elemento para que sea s√∫per visual
    if (event.type == "mouseover") {
      target.style.background = "pink";
    }
    if (event.type == "mouseout") {
      target.style.background = "";
    }
  };
</script>
```

**Explicaci√≥n del ejemplo:**
F√≠jate bien en esto, que es la clave de todo:

- `event.target`: Es el protagonista. El elemento que dispara el evento. Si pones el rat√≥n sobre un ojo, `event.target` es ESE ojo.
- `event.relatedTarget`: Es el actor de reparto. Nos dice con qui√©n se relaciona el `target`.
  - En un `mouseover`: `relatedTarget` es el elemento **de donde vienes**.
  - En un `mouseout`: `relatedTarget` es el elemento **hacia donde vas**.

Pi√©nsalo como si cambiaras de habitaci√≥n: `target` es la habitaci√≥n a la que entras, `relatedTarget` es la que dejas atr√°s.

#### 3. **Desarrollo**:

Aqu√≠ viene la parte que quiero que te grabes a fuego. `relatedTarget` es tu mejor amigo para entender qu√© est√° pasando realmente. Cuando el rat√≥n entra a la p√°gina desde fuera (por ejemplo, desde la barra de direcciones del navegador), no viene de ning√∫n otro elemento, ¬øverdad? En ese caso, `event.relatedTarget` ser√° `null`. ¬°Ojo con esto! Si intentas acceder a una propiedad de `null` (como `event.relatedTarget.className`), tu c√≥digo explotar√° con un error. ¬°Siempre comprueba si existe antes de usarlo!

üü° **Importante**: Estos eventos son la base, pero tienen un comportamiento "nervioso" que puede ser confuso, especialmente con elementos anidados (un `<div>` dentro de otro `<div>`). En el siguiente punto ver√°s por qu√© y cu√°l es su alternativa m√°s "tranquila".

---

## B - El "Salto" del Rat√≥n: El Navegador no es un Superh√©roe üîµ

#### 1. **Introducci√≥n:**

Si mueves el rat√≥n muy, muy r√°pido, el navegador puede "saltarse" algunos elementos que est√°n en medio del trayecto para no sobrecargarse de trabajo.

#### 2. **Ejemplo:**

![Diagrama que muestra el puntero del rat√≥n saltando elementos intermedios](https://javascript.info/article/mousemove-mouseover-mouseout-mouseenter-mouseleave/mouseover-mouseout-over-elems.svg)

**Explicaci√≥n del ejemplo:**
Imagina que mueves el rat√≥n a la velocidad de la luz desde el elemento `#FROM` hasta el `#TO`. El navegador, que est√° optimizando el rendimiento, podr√≠a no registrar los eventos `mouseover` y `mouseout` para los `<div>` que est√°n en medio. Simplemente dir√°: "Ok, saliste de `#FROM` y entraste en `#TO`".

#### 3. **Desarrollo**:

Esto no es un error, ¬°es una caracter√≠stica de rendimiento! Imagina una p√°gina con cientos de peque√±os elementos. Si el navegador tuviera que procesar la entrada y salida de cada uno de ellos en un movimiento r√°pido, la p√°gina se volver√≠a lent√≠sima.

La regla de oro que debes recordar es: **No asumas que el puntero "visita" cada elemento en su camino**. Puede saltar. Sin embargo, hay una garant√≠a importante: si el navegador registra un `mouseover` en un elemento, te promete que, cuando salgas de √©l, registrar√° su correspondiente `mouseout`. No te dejar√° "colgado".

üîµ **Espec√≠fico**: No es algo por lo que debas preocuparte todos los d√≠as, pero es vital saberlo para no volverte loco buscando un bug que no existe. Si alguna vez un efecto no se activa en un elemento intermedio durante un movimiento r√°pido, ya sabes por qu√© es.

---

## C - `mouseover`/`mouseout` vs. `mouseenter`/`mouseleave`: La Batalla Definitiva üî¥

#### 1. **Introducci√≥n:**

Ambos pares de eventos detectan la entrada y salida del rat√≥n, pero su diferencia es la causa n√∫mero uno de bugs y frustraci√≥n en principiantes. ¬°Vamos a dejarlo meridianamente claro para que a ti no te pase!

#### 2. **La Comparaci√≥n Directa (¬°Atenci√≥n m√°xima aqu√≠!)**

Imagina esta estructura: un `<div>` padre que contiene un `<div>` hijo.

```html
<div id="parent">
  Padre
  <div id="child">Hijo</div>
</div>
```

Ahora veamos c√≥mo reacciona cada par de eventos cuando mueves el rat√≥n desde el "Padre" hacia el "Hijo".

---

### **`mouseover`/`mouseout` (El D√∫o "Nervioso" y "Hablador")**

Estos eventos se disparan constantemente, incluso al moverse entre un elemento y sus propios hijos.

![Diagrama que muestra mouseout y mouseover dispar√°ndose en el padre al entrar al hijo](https://javascript.info/article/mousemove-mouseover-mouseout-mouseenter-mouseleave/mouseover-to-child.svg)

**Comportamiento:**
Cuando mueves el rat√≥n del √°rea del `padre` al √°rea del `hijo`:

1.  Se dispara `mouseout` en el `padre` (¬°¬øQu√©?! ¬°Pero si sigo dentro!).
2.  Se dispara `mouseover` en el `hijo`.
3.  Como el evento `mouseover` del hijo "burbujea" hacia arriba, ¬°el `padre` tambi√©n recibe un `mouseover`!

**¬øPor qu√© esta locura?**
Para el navegador, el puntero solo puede estar sobre **un** elemento a la vez: el m√°s profundo. Al entrar en el `hijo`, t√©cnicamente "sales" del `padre` para entrar en un nuevo elemento. Esto provoca que se disparen un mont√≥n de eventos que, a menudo, no quieres y que causan efectos visuales parpadeantes o animaciones que se reinician sin parar.

---

### **`mouseenter`/`mouseleave` (El D√∫o "Tranquilo" y "Preciso")**

Estos eventos son mucho m√°s simples y, cr√©eme, son tus verdaderos amigos.

**Comportamiento:**
Cuando mueves el rat√≥n del √°rea del `padre` al √°rea del `hijo`:

- **No pasa NADA.** Absolutamente nada.

Estos eventos solo se disparan cuando el puntero entra o sale de los **l√≠mites exteriores del elemento** que los escucha. No les importa en absoluto lo que pase dentro con sus hijos o descendientes.

**Ejemplo Visual:**
En el siguiente ejemplo, el `div` padre tiene `mouseenter`/`mouseleave`. Mueve el rat√≥n hacia dentro y hacia fuera, y luego sobre el hijo. Ver√°s que los eventos solo se registran cuando cruzas la frontera del padre.

![Ejemplo de mouseenter/mouseleave ignorando al hijo](https://javascript.info/article/mousemove-mouseover-mouseout-mouseenter-mouseleave/mouseleave/index.html)

#### 3. **Desarrollo (La Conclusi√≥n del Pedagogo Paranoico):**

- **¬øCu√°ndo usar cu√°l?**

  - **Usa `mouseenter` y `mouseleave` el 99% del tiempo.** Son predecibles, eficientes y hacen exactamente lo que la mayor√≠a de las veces esperas: saber si el rat√≥n ha entrado o salido de un √°rea de la interfaz.
  - **Usa `mouseover` y `mouseout` SOLO cuando necesites hacer "delegaci√≥n de eventos"** (lo veremos a continuaci√≥n) o si tienes un caso de uso muy, muy espec√≠fico donde necesitas rastrear cada movimiento entre elementos anidados.

- **La Trampa a Evitar:** La trampa mortal es usar `mouseover`/`mouseout` para un simple men√∫ desplegable o para resaltar un contenedor. El resultado ser√° un desastre parpadeante en cuanto el rat√≥n toque cualquier texto o icono dentro del contenedor.

- **La Otra Gran Diferencia (¬°Importante!):**
  - `mouseover`/`mouseout` **se propagan** (hacen "bubbling"). El evento de un hijo "sube" y puede ser capturado por sus padres.
  - `mouseenter`/`mouseleave` **NO se propagan**. Son eventos locales y discretos.

üî¥ **Fundamental**: Entender esta diferencia no es opcional. Es la clave para evitar horas de frustraci√≥n. Si te quedas con una sola cosa de toda esta gu√≠a, que sea esta.

---

## D - Delegaci√≥n de Eventos: El Arte de Poner un Solo Vigilante üîµ

#### 1. **Introducci√≥n:**

Dado que `mouseenter`/`mouseleave` no se propagan, no sirven para la "delegaci√≥n de eventos", una t√©cnica s√∫per eficiente que consiste en poner un √∫nico "listener" en un elemento padre para gestionar los eventos de todos sus hijos.

#### 2. **Ejemplo (El Reto de la Tabla):**

Imagina una tabla con docenas de celdas (`<td>`). Poner un `event listener` en cada una ser√≠a una locura de rendimiento. Lo inteligente es poner un solo `listener` en la `<table>`.

**El Problema:** Si usamos `mouseenter` en la `<table>`, solo se activar√° una vez (al entrar en la tabla), pero no se enterar√° de cu√°ndo pasamos de una celda a otra.

**La Soluci√≥n (un truco con `mouseover`/`mouseout`):**
Podemos usar `mouseover` y `mouseout` en la tabla y, con un poco de l√≥gica inteligente, filtrar los eventos "ruidosos" para que se comporten como si fueran `mouseenter`/`mouseleave` en cada celda.

```javascript
// Nuestra "memoria": guarda la celda en la que estamos ahora.
let currentElem = null;

table.onmouseover = function (event) {
  // 1. DEFENSA ANTI-RUIDO INTERNO:
  // Si ya est√°bamos sobre una celda (currentElem no es null),
  // este evento es un movimiento DENTRO de ella. Lo ignoramos.
  if (currentElem) return;

  // 2. IDENTIFICAR EL OBJETIVO REAL:
  // event.target puede ser un <strong> o <b> dentro de la celda.
  // .closest('td') nos asegura que siempre obtengamos la celda <td>.
  let target = event.target.closest("td");

  // 3. DEFENSA DE VALIDEZ:
  // Si no hemos entrado a una celda (ej: estamos sobre el borde de la tabla)
  // o la celda no pertenece a nuestra tabla, lo ignoramos.
  if (!target || !table.contains(target)) return;

  // 4. ¬°√âXITO! HEMOS ENTRADO A UNA NUEVA CELDA:
  // Guardamos la nueva celda en nuestra memoria y ejecutamos nuestra funci√≥n.
  currentElem = target;
  onEnter(currentElem);
};

table.onmouseout = function (event) {
  // 1. DEFENSA DE SALIDA:
  // Si no est√°bamos en ninguna celda, no hay nada de qu√© salir. Ignoramos.
  if (!currentElem) return;

  // 2. LA PREGUNTA CLAVE: ¬øA D√ìNDE VAMOS?
  // relatedTarget nos dice el nuevo elemento bajo el puntero.
  let relatedTarget = event.relatedTarget;

  // 3. LA DEFENSA M√ÅS IMPORTANTE (ANTI-FALSAS SALIDAS):
  // Recorremos los padres del elemento al que nos dirigimos.
  // Si en esa cadena de padres encontramos nuestra celda actual (currentElem),
  // significa que nos movimos a un hijo. ¬°No es una salida real! Ignoramos.
  while (relatedTarget) {
    if (relatedTarget == currentElem) return;
    relatedTarget = relatedTarget.parentNode;
  }

  // 4. ¬°ES UNA SALIDA REAL!
  // Si el bucle termina, es que nos hemos ido de verdad.
  // Ejecutamos nuestra funci√≥n y, CRUCIAL, limpiamos nuestra memoria.
  onLeave(currentElem);
  currentElem = null;
};

// Funciones que hacen algo visual
function onEnter(elem) {
  elem.style.background = "pink";
}
function onLeave(elem) {
  elem.style.background = "";
}
```

**Explicaci√≥n del ejemplo:**
He puesto comentarios s√∫per detallados en el c√≥digo porque quiero que entiendas cada l√≠nea. Este patr√≥n es como construir un filtro de agua: `mouseover`/`mouseout` nos dan agua "sucia" (con muchos eventos), y nuestra l√≥gica la purifica para darnos solo los eventos que nos importan (entradas y salidas "reales" de las celdas). La variable `currentElem` es la clave de todo, act√∫a como la memoria a corto plazo de nuestro vigilante.

#### 3. **Desarrollo**:

Esta t√©cnica es un poco m√°s avanzada, pero es un ejemplo perfecto de c√≥mo, a veces, necesitamos las herramientas m√°s "complicadas" (`mouseover`/`mouseout`) para resolver problemas de rendimiento y estructura en aplicaciones complejas. No te obsesiones con memorizar el c√≥digo, pero aseg√∫rate de entender la **estrategia**: usar un listener padre, guardar el estado actual en una variable y filtrar los eventos no deseados comprobando `target` y `relatedTarget`.

üîµ **Espec√≠fico**: Esta es una t√©cnica de nivel intermedio. Es bueno que sepas que existe y por qu√© es necesaria. Cuando te enfrentes a una lista larga o una cuadr√≠cula de elementos interactivos, te acordar√°s de esto y sabr√°s qu√© buscar.
