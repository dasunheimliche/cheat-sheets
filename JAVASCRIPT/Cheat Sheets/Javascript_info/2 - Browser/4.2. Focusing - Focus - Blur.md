## A - Eventos `focus` y `blur`: Reaccionando cuando el usuario entra y sale üî¥

#### 1. **Introducci√≥n:**

Estos son los dos eventos m√°s b√°sicos para saber cu√°ndo un usuario ha puesto su atenci√≥n en un elemento (`focus`) o la ha quitado (`blur`).

#### 2. **Ejemplo:**

Imagina que quieres validar un campo de email. El usuario escribe, y cuando hace clic en otro lugar, ¬°zas!, comprobamos si es v√°lido.

```html
<!-- HTML -->
<style>
  .invalid {
    border-color: red;
  }
  #error {
    color: red;
  }
</style>

Tu email por favor: <input type="email" id="input" />
<div id="error"></div>

<!-- JavaScript -->
<script>
  // Cuando el usuario SALE del input (pierde el foco)
  input.onblur = function () {
    // Si el valor NO incluye una '@'
    if (!input.value.includes("@")) {
      // Mostramos un error
      input.classList.add("invalid");
      error.innerHTML = "Por favor, introduce un email correcto.";
    }
  };

  // Cuando el usuario ENTRA al input (gana el foco)
  input.onfocus = function () {
    // Si el campo estaba marcado como inv√°lido...
    if (this.classList.contains("invalid")) {
      // ...quitamos el error para que pueda corregirlo.
      this.classList.remove("invalid");
      error.innerHTML = "";
    }
  };
</script>
```

**Explicaci√≥n del ejemplo:**

- **`onblur` (al salir):** Se activa cuando el usuario hace clic fuera del campo de email. En ese momento, nuestro c√≥digo comprueba si lo que escribi√≥ parece un email (si tiene una `@`). Si no, le pone un borde rojo y muestra un mensaje de error. Lo consideramos el momento de "validar los datos".
- **`onfocus` (al entrar):** Se activa cuando el usuario vuelve a hacer clic en el campo. Si hab√≠a un error, lo limpiamos todo para que no se sienta presionado y pueda volver a intentarlo tranquilamente. Es el momento de "preparar el campo para recibir datos".

#### 3. **Desarrollo**:

Piensa en el **foco** como el haz de luz de un foco de teatro. Solo un actor (un elemento) puede estar bajo el foco a la vez. El usuario dirige ese foco haciendo clic o usando la tecla `Tab`.

- **`focus`**: Ocurre cuando el elemento "entra en escena". Es tu oportunidad para inicializar cosas, mostrar herramientas relacionadas o, como en el ejemplo, limpiar errores previos.
- **`blur`**: Ocurre cuando el elemento "sale de escena" (el foco se va a otro lado). Es el momento perfecto para comprobar lo que el usuario ha introducido, guardarlo, o enviarlo a un servidor.

**¬°Una trampa mental com√∫n!** Que un elemento pierda el foco (`blur`) no significa necesariamente que el usuario haya "terminado" con ese campo para siempre. Simplemente ha movido su atenci√≥n a otro lugar. Podr√≠a querer rellenar otro campo y luego volver. Por eso, es importante mostrar errores de forma amigable, sin bloquearle el paso.

üî¥ **Fundamental**: Estos son los eventos b√°sicos e imprescindibles para gestionar la interacci√≥n del usuario con formularios y otros elementos interactivos. No puedes crear una experiencia de usuario decente en un formulario sin entender `focus` y `blur`.

---

## B - M√©todos `focus()` y `blur()`: Tomando el control del foco üü°

#### 1. **Introducci√≥n:**

A diferencia de los _eventos_ que reaccionan a las acciones del usuario, estos son _m√©todos_ que te permiten, desde tu c√≥digo JavaScript, forzar a que un elemento gane (`focus()`) o pierda (`blur()`) el foco.

#### 2. **Ejemplo:**

Imagina que quieres ser MUY insistente y no dejar que el usuario abandone un campo de email si lo que ha escrito es incorrecto.

```html
<!-- HTML -->
<style>
  .error {
    background: red;
  }
</style>

Tu email por favor: <input type="email" id="input" />
<input
  type="text"
  placeholder="Intenta hacer foco aqu√≠ con un email inv√°lido"
/>

<!-- JavaScript -->
<script>
  input.onblur = function () {
    // Si el valor no incluye una '@'
    if (!this.value.includes("@")) {
      this.classList.add("error");
      // ¬°OJO AQU√ç! Forzamos el foco a volver al input
      input.focus();
    } else {
      this.classList.remove("error");
    }
  };
</script>
```

**Explicaci√≥n del ejemplo:**
Cuando el usuario intenta salir del campo (`onblur`) y el email es inv√°lido, no solo a√±adimos una clase de error, sino que inmediatamente ejecutamos `input.focus()`. Esto le dice al navegador: "¬°No, no, no! Vuelve a poner el foco en este campo de texto". El resultado es que el usuario queda "atrapado" hasta que escriba un email v√°lido.

#### 3. **Desarrollo**:

Usar `elem.focus()` y `elem.blur()` te da el poder de guiar al usuario. Por ejemplo, si hay un error de validaci√≥n al enviar un formulario, puedes usar `campoConError.focus()` para llevar al usuario directamente al campo que necesita corregir.

**¬°ADVERTENCIA DE UN PEDAGOGO PARANOICO!**
El ejemplo de "atrapar" al usuario es pedag√≥gicamente √∫til para entender c√≥mo funciona `focus()`, ¬°pero es una **p√©sima idea** en la pr√°ctica! Es incre√≠blemente frustrante para el usuario. Imagina que quiere copiar una direcci√≥n de email de otra ventana; tu c√≥digo no le dejar√≠a salir del campo.

**Regla de oro:** Muestra los errores, gu√≠a al usuario, pero **nunca le impidas moverse libremente por tu p√°gina**. Usa `focus()` para ayudar, no para obligar.

Tambi√©n ten cuidado con efectos secundarios: un `alert()` en JavaScript roba el foco, y cuando se cierra, el foco vuelve. Esto puede disparar eventos `blur` y `focus` que no esperabas.

üü° **Importante**: Aunque no los uses todos los d√≠as, saber c√≥mo controlar el foco mediante c√≥digo es crucial para crear interfaces pulidas y guiar al usuario de forma inteligente, especialmente en formularios complejos o aplicaciones de una sola p√°gina (SPA).

---

## C - Atributo `tabindex`: Haciendo que cualquier elemento sea enfocable üü°

#### 1. **Introducci√≥n:**

Por defecto, solo puedes hacer foco en elementos interactivos como `<input>`, `<button>` o `<a>`. El atributo `tabindex` te permite hacer que _cualquier_ elemento (como un `<div>` o un `<li>`) pueda recibir foco.

#### 2. **Ejemplo:**

Aqu√≠ tenemos una lista. Normalmente, no podr√≠as navegar por los `<li>` con la tecla `Tab`, pero con `tabindex`, s√≠ puedes.

```html
<ul>
  <li tabindex="1">Uno (primero en el orden de Tab)</li>
  <li tabindex="2">Dos (segundo en el orden de Tab)</li>
  <li tabindex="0">Cero (tercero, va con los elementos por defecto)</li>
  <li tabindex="-1">Menos uno (no se puede llegar con Tab, solo con JS)</li>
</ul>

<style>
  li {
    cursor: pointer;
  }
  :focus {
    outline: 2px solid green;
  } /* Estilo para el elemento enfocado */
</style>
```

**Explicaci√≥n del ejemplo:**
Si haces clic en el primer elemento y empiezas a presionar la tecla `Tab`, ver√°s un comportamiento especial:

1.  El foco saltar√° de "Uno" (`tabindex="1"`) a "Dos" (`tabindex="2"`). Sigue el orden num√©rico positivo.
2.  Luego, saltar√° a "Cero" (`tabindex="0"`).
3.  El elemento "Menos uno" (`tabindex="-1"`) **ser√° ignorado por completo** por la tecla `Tab`.

#### 3. **Desarrollo**:

`tabindex` es tu navaja suiza para la accesibilidad y la creaci√≥n de componentes personalizados. Te permite controlar el orden de navegaci√≥n y hacer que tus widgets personalizados se comporten como elementos nativos.

**Desglose paranoico de los valores de `tabindex`:**

- **`tabindex="1"` (o cualquier n√∫mero mayor que 0):**

  - **Qu√© hace:** Crea un orden de tabulaci√≥n expl√≠cito. El navegador primero saltar√° entre todos los elementos con `tabindex` de `1` en adelante, en orden num√©rico (`1`, `2`, `3`, ...).
  - **Cu√°ndo usarlo:** ¬°Casi nunca! Cambiar el orden de tabulaci√≥n natural (el orden en que aparecen las cosas en el HTML) es confuso y malo para la accesibilidad. Es mejor estructurar bien tu HTML.
  - **Mi consejo obsesivo:** Finge que este no existe a menos que un experto en accesibilidad te diga lo contrario.

- **`tabindex="0"`:**

  - **Qu√© hace:** Hace que un elemento no interactivo (como un `<div>`) sea enfocable y lo inserta en el orden de tabulaci√≥n natural, como si fuera un `<input>` m√°s.
  - **Cu√°ndo usarlo:** ¬°Este es el bueno! √ösalo cuando construyas un componente personalizado con JavaScript (un men√∫ desplegable, un slider) y quieras que los usuarios puedan navegar hacia √©l con la tecla `Tab`.
  - **Ejemplo mental:** Creas un `<div>` que funciona como un bot√≥n. Le pones `tabindex="0"` para que la gente pueda "tabular" hasta tu falso bot√≥n.

- **`tabindex="-1"`:**
  - **Qu√© hace:** Hace que un elemento sea enfocable, pero **√∫nicamente a trav√©s de JavaScript** (usando `miElemento.focus()`). La tecla `Tab` lo ignora por completo.
  - **Cu√°ndo usarlo:** ¬°S√∫per √∫til! Perfecto para cosas que no deber√≠an estar en la secuencia de navegaci√≥n normal pero que necesitan foco en ciertos momentos. El caso cl√°sico es una ventana modal: cuando la abres, usas JavaScript para poner el foco en ella (`modal.focus()`), pero no quieres que el usuario llegue a ella accidentalmente con `Tab` mientras est√° oculta.

üü° **Importante**: Entender `tabindex` es fundamental para la accesibilidad web (a11y). Usar `tabindex="0"` y `tabindex="-1"` correctamente te permitir√° crear aplicaciones web complejas que todos puedan usar.

---

## D - `focusin` y `focusout`: Los gemelos que s√≠ saben delegar üü°

#### 1. **Introducci√≥n:**

Son las versiones "burbujeantes" de `focus` y `blur`. Te permiten detectar un cambio de foco en un elemento hijo escuchando el evento desde un elemento padre, algo que `focus` y `blur` no pueden hacer.

#### 2. **Ejemplo (El Problema y La Soluci√≥n):**

**El Problema:** Quieres resaltar un formulario entero cuando el usuario hace foco en _cualquiera_ de sus campos. Este c√≥digo **NO FUNCIONA**:

```html
<!-- ESTO NO FUNCIONA COMO ESPERAS -->
<form onfocus="this.className='focused'">
  <input type="text" value="Nombre" />
  <input type="text" value="Apellido" />
</form>

<style>
  .focused {
    outline: 2px solid red;
  }
</style>
```

**¬øPor qu√© no funciona?** Porque el evento `focus` se dispara en el `<input>` y muere ah√≠. No "burbujea" o se propaga hacia arriba para avisarle al `<form>`.

**La Soluci√≥n con `focusin` y `focusout`:**

```html
<!-- ESTO S√ç FUNCIONA -->
<form id="form">
  <input type="text" value="Nombre" />
  <input type="text" value="Apellido" />
</form>

<style>
  .focused {
    outline: 2px solid red;
  }
</style>

<script>
  // Escuchamos 'focusin' en el formulario
  form.addEventListener("focusin", () => form.classList.add("focused"));

  // Escuchamos 'focusout' en el formulario
  form.addEventListener("focusout", () => form.classList.remove("focused"));
</script>
```

**Explicaci√≥n del ejemplo:**
Ahora, cuando haces clic en cualquier `input`, el evento `focusin` se dispara. A diferencia de `focus`, `focusin` s√≠ viaja hacia arriba, llegando hasta el `<form>`. Nuestro `addEventListener` en el formulario lo captura y a√±ade la clase `focused`. Cuando el foco sale de todo el formulario, `focusout` hace lo mismo y quita la clase.

#### 3. **Desarrollo y Comparaci√≥n Paranoica:**

Esta es una de esas cosas que confunde a todo el mundo al principio, as√≠ que vamos a dejarla meridianamente clara.

| Caracter√≠stica      | `focus` / `blur`                                                    | `focusin` / `focusout`                                                                         |
| :------------------ | :------------------------------------------------------------------ | :--------------------------------------------------------------------------------------------- |
| **¬øQu√© hacen?**     | Se disparan cuando un elemento gana/pierde el foco.                 | Exactamente lo mismo.                                                                          |
| **Burbujeo**        | **NO.** Son antisociales. El evento ocurre y muere en el elemento.  | **S√ç.** Son comunicativos. El evento viaja hacia arriba por el DOM.                            |
| **Caso de uso**     | Manejar el foco en un elemento espec√≠fico (`miInput.onblur = ...`). | Manejar el foco para un grupo de elementos (delegaci√≥n de eventos).                            |
| **C√≥mo se asignan** | `elem.onfocus` o `elem.addEventListener('focus', ...)`              | **Solo con `elem.addEventListener('focusin', ...)`**. ¬°No existen `onfocusin` ni `onfocusout`! |

**¬øPor qu√© elegir `focusin`/`focusout`?**
La raz√≥n principal es la **delegaci√≥n de eventos**. Es mucho m√°s eficiente poner un solo "escuchador" en un contenedor (como el `<form>`) que poner uno en cada uno de los 20 campos que pueda tener dentro. Si a√±ades o quitas campos din√°micamente con JavaScript, el escuchador del formulario seguir√° funcionando sin que tengas que hacer nada. ¬°Es m√°s limpio, m√°s eficiente y menos propenso a errores!

_(Nota hist√≥rica: el texto menciona que `focus`/`blur` se pueden usar con `addEventListener` en la fase de "captura". Si bien es cierto, es un concepto m√°s avanzado y menos intuitivo. Para el 99% de los casos de delegaci√≥n de foco, `focusin`/`focusout` son la herramienta correcta y m√°s clara)._

üü° **Importante**: Entender la delegaci√≥n de eventos es un pilar de JavaScript eficiente. `focusin` y `focusout` son las herramientas espec√≠ficas para aplicar este patr√≥n al manejo del foco. Conocerlas te ahorrar√° muchos dolores de cabeza.
