## A - `DOMContentLoaded`: Cuando la Estructura de tu Página Está Lista 🔴

#### 1. **Introducción:**

Este evento es como el grito de "¡Listo!" del navegador cuando ha terminado de leer y construir el esqueleto HTML de tu página (el famoso DOM), pero ¡ojo!, todavía podría estar descargando las imágenes, las hojas de estilo u otros archivos pesados.

#### 2. **Ejemplo:**

```html
<script>
  function ready() {
    alert("¡DOM listo!");
    // La imagen aún no se ha cargado (a menos que esté en caché),
    // por lo que su tamaño será 0x0. ¡No te asustes, es normal!
    alert(`Tamaño de la imagen: ${img.offsetWidth}x${img.offsetHeight}`);
  }

  // Así es como "escuchamos" el evento.
  document.addEventListener("DOMContentLoaded", ready);
</script>

<img id="img" src="https://en.js.cx/clipart/train.gif?speed=1&cache=0" />
```

**Explicación del ejemplo:**
El primer `alert` ('¡DOM listo!') aparece en cuanto el navegador ha procesado todo el HTML, incluido el tag `<img>`. Sin embargo, el navegador aún no ha terminado de _descargar_ el archivo de la imagen del tren. Por eso, cuando el código intenta medir sus dimensiones (`offsetWidth` y `offsetHeight`), el resultado es `0x0`. El código se ejecuta demasiado pronto para conocer el tamaño real de la imagen.

#### 3. **Desarrollo**:

Piensa en `DOMContentLoaded` como el momento en que los albañiles han terminado de levantar las paredes y el techo de una casa. La estructura está ahí, puedes recorrer las habitaciones (acceder a los nodos del DOM), pero aún no han llegado los muebles, la pintura ni la decoración (imágenes, estilos, etc.).

Es el momento perfecto para ejecutar tu código JavaScript que necesita interactuar con los elementos de la página, como añadir un `click` a un botón, porque tienes la garantía de que todos los elementos HTML ya existen.

**Puntos clave que DEBES conocer para no caer en trampas:**

- **Scripts que bloquean:** Si el navegador encuentra una etiqueta `<script>` normal (sin `async` o `defer`), detendrá la construcción del DOM, ejecutará el script y luego continuará. Esto significa que `DOMContentLoaded` esperará a que todos esos scripts terminen.
- **Estilos que (indirectamente) bloquean:** Una hoja de estilos externa (`<link rel="stylesheet">`) por sí sola no retrasa `DOMContentLoaded`. ¡PERO! Si tienes un script _después_ de la hoja de estilos, el navegador es lo suficientemente inteligente como para pensar: "Hmm, este script podría querer saber el color o el tamaño de un elemento, así que mejor espero a que la hoja de estilos se cargue por completo antes de ejecutar el script". Como `DOMContentLoaded` espera a los scripts, indirectamente termina esperando también a la hoja de estilos en este caso.
- **Autocompletado del navegador:** Navegadores como Chrome o Firefox rellenan los formularios de usuario y contraseña justo en el evento `DOMContentLoaded`. Si alguna vez has visto que un formulario tarda en autocompletarse, es probable que sea porque `DOMContentLoaded` estaba esperando a que se cargara un script pesado.

🔴 **Fundamental**: Este es uno de los eventos más importantes. El 90% de las veces que quieras manipular la página con JavaScript, lo harás después de que se dispare este evento. Usarlo te asegura que no intentarás modificar un elemento que ¡todavía no existe!

---

## B - `window.onload`: Cuando ABSOLUTAMENTE TODO está Cargado 🔴

#### 1. **Introducción:**

Este evento es el "paciente de la familia"; no se dispara hasta que no solo el HTML está listo, sino que también se han descargado y aplicado **TODOS** los recursos externos: imágenes, hojas de estilo, iframes, etc.

#### 2. **Ejemplo:**

```html
<script>
  window.onload = function () {
    // También puedes usar addEventListener
    alert("¡Página completamente cargada!");

    // ¡Ahora sí! La imagen ya se descargó por completo.
    alert(`Tamaño de la imagen: ${img.offsetWidth}x${img.offsetHeight}`);
  };
</script>

<img id="img" src="https://en.js.cx/clipart/train.gif?speed=1&cache=0" />
```

**Explicación del ejemplo:**
A diferencia del ejemplo anterior, aquí el código dentro de `window.onload` espera pacientemente. El `alert` no se mostrará hasta que la imagen del tren se haya descargado por completo. Por eso, cuando medimos sus dimensiones, ahora sí obtenemos el tamaño correcto (por ejemplo, `136x60`).

#### 3. **Desarrollo**:

Volviendo a la analogía de la casa: `window.onload` es el momento en que no solo la estructura está lista, sino que ya han llegado y se han colocado todos los muebles, la pintura está seca en las paredes y la decoración está en su sitio. La casa está 100% lista para la fiesta de inauguración.

**La Gran Diferencia: `DOMContentLoaded` vs. `window.onload`**

Imagina que no te queda clara la diferencia. Piénsalo así:

- **Usa `DOMContentLoaded` si:** Tu script solo necesita que los elementos HTML existan. Por ejemplo, para añadir un evento de clic a un botón. No te importa si la imagen de cabecera gigante todavía se está cargando. Quieres que tu página sea interactiva lo más rápido posible.
- **Usa `window.onload` si:** Tu script depende de recursos externos. Por ejemplo, si necesitas saber el tamaño de una imagen para colocarla correctamente, o si quieres asegurarte de que todos los estilos CSS se han aplicado antes de ejecutar una animación.

![Diagrama de flujo de eventos](https://es.javascript.info/article/onload-ondomcontentloaded/page-lifecycle-events.svg)

🔴 **Fundamental**: Al igual que `DOMContentLoaded`, este evento es crucial. Elegir entre uno y otro depende de _qué_ necesita tu código para funcionar correctamente. Usar `window.onload` innecesariamente puede hacer que tu página se sienta más lenta, porque el usuario tendrá que esperar a que todo se cargue para poder interactuar.

---

## C - `window.onbeforeunload`: El "¿Estás seguro de que te quieres ir?" 🟡

#### 1. **Introducción:**

Este evento es tu última oportunidad para "detener" al usuario antes de que abandone la página (ya sea cerrando la pestaña, recargando o yendo a otro sitio), mostrándole un diálogo de confirmación.

#### 2. **Ejemplo:**

```javascript
// Si el usuario ha escrito algo en un formulario y no ha guardado,
// podemos usar este evento para advertirle.
window.onbeforeunload = function () {
  // Al devolver cualquier cadena de texto (o `false`),
  // el navegador mostrará un mensaje de confirmación genérico.
  return "Hay cambios sin guardar. ¿Seguro que quieres salir?";
};
```

**Explicación del ejemplo:**
Si ejecutas este código e intentas recargar o cerrar la página, el navegador detendrá la acción y mostrará un cuadro de diálogo con un mensaje como "¿Seguro que quieres salir de este sitio?". Es importante entender que, por razones de seguridad, **ya no puedes personalizar este mensaje en los navegadores modernos**. No importa qué texto devuelvas, el navegador mostrará su propio mensaje genérico. El simple hecho de devolver un valor no vacío es la señal para que el navegador pida confirmación.

#### 3. **Desarrollo**:

Este evento es extremadamente útil para evitar que los usuarios pierdan su trabajo por accidente. Piensa en Google Docs o en un editor de texto online: si intentas cerrar la pestaña sin guardar, te salta una advertencia. Eso es `beforeunload` en acción.

**¡Cuidado con esto!**
La forma "moderna" de hacer esto con `addEventListener` es un poco extraña. No usas `event.preventDefault()`, que es lo que harías normalmente. En su lugar, asignas una cadena de texto a `event.returnValue`:

```javascript
window.addEventListener("beforeunload", function (event) {
  // Esto hace lo mismo que el `return` en el ejemplo anterior.
  event.returnValue = "Hay cambios sin guardar.";
});
```

🟡 **Importante**: No lo necesitarás en todas las páginas, pero es vital para aplicaciones web donde el usuario introduce datos (formularios, editores, etc.). Usarlo demuestra que te preocupas por el trabajo del usuario.

---

## D - `window.onunload`: El Adiós Final y Silencioso 🔵

#### 1. **Introducción:**

Este evento se dispara justo cuando el usuario ya se ha ido y la página se está "descargando" de la memoria. No puedes detener al usuario aquí, solo puedes realizar una tarea muy rápida y final.

#### 2. **Ejemplo:**

```javascript
// Supongamos que hemos recopilado datos de uso de la página.
let analyticsData = {
  timeSpent: 120, // segundos
  clicks: 15,
};

window.addEventListener("unload", function () {
  // ¡No uses fetch() normal aquí! La página se cerrará antes de que termine.
  // Usa navigator.sendBeacon(), que está diseñado para esto.
  navigator.sendBeacon("/analytics", JSON.stringify(analyticsData));
});
```

**Explicación del ejemplo:**
Cuando el usuario cierra la página, queremos enviar un último paquete de datos a nuestro servidor (por ejemplo, para analíticas). No podemos hacer una petición de red normal porque la página desaparecerá antes de recibir una respuesta. `navigator.sendBeacon()` es la solución perfecta: es como echar una carta al buzón. El navegador se encarga de que se envíe en segundo plano, de forma fiable, sin retrasar el cierre de la página. Es un método de "dispara y olvida".

#### 3. **Desarrollo**:

La principal y casi única utilidad de `unload` hoy en día es enviar estadísticas o datos de telemetría. En el pasado se intentaba usar para otras cosas, pero es muy poco fiable para tareas que requieren tiempo.

**`beforeunload` vs. `unload`:**

- `beforeunload`: Ocurre **antes** de que el usuario se vaya. Puedes **cancelar** la salida. Úsalo para preguntar "¿Estás seguro?".
- `unload`: Ocurre **mientras** el usuario se está yendo. **No puedes** cancelar nada. Úsalo para decir un "adiós" rápido y silencioso, como enviar datos con `sendBeacon`.

🔵 **Específico**: Es un evento para un caso de uso muy concreto: enviar datos de última hora cuando el usuario se va. Es bueno saber que existe, pero lo que realmente necesitas recordar es `navigator.sendBeacon()`, que es la herramienta que se usa dentro de este evento.

---

## E - `document.readyState`: Preguntando "¿Ya llegamos?" al Documento 🟡

#### 1. **Introducción:**

Esta no es un evento, sino una propiedad que te permite "espiar" y saber en qué fase de carga se encuentra el documento en cualquier momento.

#### 2. **Ejemplo:**

```javascript
function miCodigoSuperImportante() {
  // ...código que manipula el DOM...
  console.log("¡Mi código se ha ejecutado!");
}

// ¿Y si mi script se carga después de que la página ya esté lista?
// ¡No hay problema! Verificamos el estado actual.

if (document.readyState === "loading") {
  // Aún está cargando, así que esperamos al evento.
  document.addEventListener("DOMContentLoaded", miCodigoSuperImportante);
} else {
  // El DOM ya está listo, ¡ejecutamos el código ahora mismo!
  miCodigoSuperImportante();
}
```

**Explicación del ejemplo:**
Este código resuelve un problema muy común: ¿qué pasa si mi script se carga de forma asíncrona y, para cuando se ejecuta, el evento `DOMContentLoaded` ya se ha disparado? Si solo añadiéramos el `addEventListener`, nuestra función nunca se ejecutaría. Este patrón es a prueba de fallos: primero comprueba el estado. Si la página todavía está en `loading`, espera al evento. Si ya ha pasado esa fase (`interactive` o `complete`), ejecuta la función inmediatamente.

#### 3. **Desarrollo**:

La propiedad `document.readyState` puede tener tres valores, que son como las paradas de un tren:

1.  `"loading"`: El documento se está cargando. El tren acaba de salir de la estación.
2.  `"interactive"`: El documento ha sido completamente leído y parseado. El tren ha llegado a la estación `DOMContentLoaded`. El esqueleto HTML está listo.
3.  `"complete"`: El documento y todos sus recursos (imágenes, estilos) se han cargado. El tren ha llegado a la estación `window.onload`. Todo está en su sitio.

Existe un evento llamado `readystatechange` que se dispara cada vez que este estado cambia, pero es mucho menos común usarlo directamente en comparación con `DOMContentLoaded` y `load`.

🟡 **Importante**: Aunque no lo uses todos los días, conocer `document.readyState` es la marca de un desarrollador cuidadoso. Te permite escribir código robusto que funciona correctamente sin importar _cuándo_ se ejecute. Es tu red de seguridad para no perderte los eventos de carga.
