## A - `DOMContentLoaded`: Cuando la Estructura de tu P치gina Est치 Lista 游댮

#### 1. **Introducci칩n:**

Este evento es como el grito de "춰Listo!" del navegador cuando ha terminado de leer y construir el esqueleto HTML de tu p치gina (el famoso DOM), pero 춰ojo!, todav칤a podr칤a estar descargando las im치genes, las hojas de estilo u otros archivos pesados.

#### 2. **Ejemplo:**

```html
<script>
  function ready() {
    alert("춰DOM listo!");
    // La imagen a칰n no se ha cargado (a menos que est칠 en cach칠),
    // por lo que su tama침o ser치 0x0. 춰No te asustes, es normal!
    alert(`Tama침o de la imagen: ${img.offsetWidth}x${img.offsetHeight}`);
  }

  // As칤 es como "escuchamos" el evento.
  document.addEventListener("DOMContentLoaded", ready);
</script>

<img id="img" src="https://en.js.cx/clipart/train.gif?speed=1&cache=0" />
```

**Explicaci칩n del ejemplo:**
El primer `alert` ('춰DOM listo!') aparece en cuanto el navegador ha procesado todo el HTML, incluido el tag `<img>`. Sin embargo, el navegador a칰n no ha terminado de _descargar_ el archivo de la imagen del tren. Por eso, cuando el c칩digo intenta medir sus dimensiones (`offsetWidth` y `offsetHeight`), el resultado es `0x0`. El c칩digo se ejecuta demasiado pronto para conocer el tama침o real de la imagen.

#### 3. **Desarrollo**:

Piensa en `DOMContentLoaded` como el momento en que los alba침iles han terminado de levantar las paredes y el techo de una casa. La estructura est치 ah칤, puedes recorrer las habitaciones (acceder a los nodos del DOM), pero a칰n no han llegado los muebles, la pintura ni la decoraci칩n (im치genes, estilos, etc.).

Es el momento perfecto para ejecutar tu c칩digo JavaScript que necesita interactuar con los elementos de la p치gina, como a침adir un `click` a un bot칩n, porque tienes la garant칤a de que todos los elementos HTML ya existen.

**Puntos clave que DEBES conocer para no caer en trampas:**

- **Scripts que bloquean:** Si el navegador encuentra una etiqueta `<script>` normal (sin `async` o `defer`), detendr치 la construcci칩n del DOM, ejecutar치 el script y luego continuar치. Esto significa que `DOMContentLoaded` esperar치 a que todos esos scripts terminen.
- **Estilos que (indirectamente) bloquean:** Una hoja de estilos externa (`<link rel="stylesheet">`) por s칤 sola no retrasa `DOMContentLoaded`. 춰PERO! Si tienes un script _despu칠s_ de la hoja de estilos, el navegador es lo suficientemente inteligente como para pensar: "Hmm, este script podr칤a querer saber el color o el tama침o de un elemento, as칤 que mejor espero a que la hoja de estilos se cargue por completo antes de ejecutar el script". Como `DOMContentLoaded` espera a los scripts, indirectamente termina esperando tambi칠n a la hoja de estilos en este caso.
- **Autocompletado del navegador:** Navegadores como Chrome o Firefox rellenan los formularios de usuario y contrase침a justo en el evento `DOMContentLoaded`. Si alguna vez has visto que un formulario tarda en autocompletarse, es probable que sea porque `DOMContentLoaded` estaba esperando a que se cargara un script pesado.

游댮 **Fundamental**: Este es uno de los eventos m치s importantes. El 90% de las veces que quieras manipular la p치gina con JavaScript, lo har치s despu칠s de que se dispare este evento. Usarlo te asegura que no intentar치s modificar un elemento que 춰todav칤a no existe!

---

## B - `window.onload`: Cuando ABSOLUTAMENTE TODO est치 Cargado 游댮

#### 1. **Introducci칩n:**

Este evento es el "paciente de la familia"; no se dispara hasta que no solo el HTML est치 listo, sino que tambi칠n se han descargado y aplicado **TODOS** los recursos externos: im치genes, hojas de estilo, iframes, etc.

#### 2. **Ejemplo:**

```html
<script>
  window.onload = function () {
    // Tambi칠n puedes usar addEventListener
    alert("춰P치gina completamente cargada!");

    // 춰Ahora s칤! La imagen ya se descarg칩 por completo.
    alert(`Tama침o de la imagen: ${img.offsetWidth}x${img.offsetHeight}`);
  };
</script>

<img id="img" src="https://en.js.cx/clipart/train.gif?speed=1&cache=0" />
```

**Explicaci칩n del ejemplo:**
A diferencia del ejemplo anterior, aqu칤 el c칩digo dentro de `window.onload` espera pacientemente. El `alert` no se mostrar치 hasta que la imagen del tren se haya descargado por completo. Por eso, cuando medimos sus dimensiones, ahora s칤 obtenemos el tama침o correcto (por ejemplo, `136x60`).

#### 3. **Desarrollo**:

Volviendo a la analog칤a de la casa: `window.onload` es el momento en que no solo la estructura est치 lista, sino que ya han llegado y se han colocado todos los muebles, la pintura est치 seca en las paredes y la decoraci칩n est치 en su sitio. La casa est치 100% lista para la fiesta de inauguraci칩n.

**La Gran Diferencia: `DOMContentLoaded` vs. `window.onload`**

Imagina que no te queda clara la diferencia. Pi칠nsalo as칤:

- **Usa `DOMContentLoaded` si:** Tu script solo necesita que los elementos HTML existan. Por ejemplo, para a침adir un evento de clic a un bot칩n. No te importa si la imagen de cabecera gigante todav칤a se est치 cargando. Quieres que tu p치gina sea interactiva lo m치s r치pido posible.
- **Usa `window.onload` si:** Tu script depende de recursos externos. Por ejemplo, si necesitas saber el tama침o de una imagen para colocarla correctamente, o si quieres asegurarte de que todos los estilos CSS se han aplicado antes de ejecutar una animaci칩n.

![Diagrama de flujo de eventos](https://es.javascript.info/article/onload-ondomcontentloaded/page-lifecycle-events.svg)

游댮 **Fundamental**: Al igual que `DOMContentLoaded`, este evento es crucial. Elegir entre uno y otro depende de _qu칠_ necesita tu c칩digo para funcionar correctamente. Usar `window.onload` innecesariamente puede hacer que tu p치gina se sienta m치s lenta, porque el usuario tendr치 que esperar a que todo se cargue para poder interactuar.

---

## C - `window.onbeforeunload`: El "쮼st치s seguro de que te quieres ir?" 游리

#### 1. **Introducci칩n:**

Este evento es tu 칰ltima oportunidad para "detener" al usuario antes de que abandone la p치gina (ya sea cerrando la pesta침a, recargando o yendo a otro sitio), mostr치ndole un di치logo de confirmaci칩n.

#### 2. **Ejemplo:**

```javascript
// Si el usuario ha escrito algo en un formulario y no ha guardado,
// podemos usar este evento para advertirle.
window.onbeforeunload = function () {
  // Al devolver cualquier cadena de texto (o `false`),
  // el navegador mostrar치 un mensaje de confirmaci칩n gen칠rico.
  return "Hay cambios sin guardar. 쯉eguro que quieres salir?";
};
```

**Explicaci칩n del ejemplo:**
Si ejecutas este c칩digo e intentas recargar o cerrar la p치gina, el navegador detendr치 la acci칩n y mostrar치 un cuadro de di치logo con un mensaje como "쯉eguro que quieres salir de este sitio?". Es importante entender que, por razones de seguridad, **ya no puedes personalizar este mensaje en los navegadores modernos**. No importa qu칠 texto devuelvas, el navegador mostrar치 su propio mensaje gen칠rico. El simple hecho de devolver un valor no vac칤o es la se침al para que el navegador pida confirmaci칩n.

#### 3. **Desarrollo**:

Este evento es extremadamente 칰til para evitar que los usuarios pierdan su trabajo por accidente. Piensa en Google Docs o en un editor de texto online: si intentas cerrar la pesta침a sin guardar, te salta una advertencia. Eso es `beforeunload` en acci칩n.

**춰Cuidado con esto!**
La forma "moderna" de hacer esto con `addEventListener` es un poco extra침a. No usas `event.preventDefault()`, que es lo que har칤as normalmente. En su lugar, asignas una cadena de texto a `event.returnValue`:

```javascript
window.addEventListener("beforeunload", function (event) {
  // Esto hace lo mismo que el `return` en el ejemplo anterior.
  event.returnValue = "Hay cambios sin guardar.";
});
```

游리 **Importante**: No lo necesitar치s en todas las p치ginas, pero es vital para aplicaciones web donde el usuario introduce datos (formularios, editores, etc.). Usarlo demuestra que te preocupas por el trabajo del usuario.

---

## D - `window.onunload`: El Adi칩s Final y Silencioso 游댯

#### 1. **Introducci칩n:**

Este evento se dispara justo cuando el usuario ya se ha ido y la p치gina se est치 "descargando" de la memoria. No puedes detener al usuario aqu칤, solo puedes realizar una tarea muy r치pida y final.

#### 2. **Ejemplo:**

```javascript
// Supongamos que hemos recopilado datos de uso de la p치gina.
let analyticsData = {
  timeSpent: 120, // segundos
  clicks: 15,
};

window.addEventListener("unload", function () {
  // 춰No uses fetch() normal aqu칤! La p치gina se cerrar치 antes de que termine.
  // Usa navigator.sendBeacon(), que est치 dise침ado para esto.
  navigator.sendBeacon("/analytics", JSON.stringify(analyticsData));
});
```

**Explicaci칩n del ejemplo:**
Cuando el usuario cierra la p치gina, queremos enviar un 칰ltimo paquete de datos a nuestro servidor (por ejemplo, para anal칤ticas). No podemos hacer una petici칩n de red normal porque la p치gina desaparecer치 antes de recibir una respuesta. `navigator.sendBeacon()` es la soluci칩n perfecta: es como echar una carta al buz칩n. El navegador se encarga de que se env칤e en segundo plano, de forma fiable, sin retrasar el cierre de la p치gina. Es un m칠todo de "dispara y olvida".

#### 3. **Desarrollo**:

La principal y casi 칰nica utilidad de `unload` hoy en d칤a es enviar estad칤sticas o datos de telemetr칤a. En el pasado se intentaba usar para otras cosas, pero es muy poco fiable para tareas que requieren tiempo.

**`beforeunload` vs. `unload`:**

- `beforeunload`: Ocurre **antes** de que el usuario se vaya. Puedes **cancelar** la salida. 칔salo para preguntar "쮼st치s seguro?".
- `unload`: Ocurre **mientras** el usuario se est치 yendo. **No puedes** cancelar nada. 칔salo para decir un "adi칩s" r치pido y silencioso, como enviar datos con `sendBeacon`.

游댯 **Espec칤fico**: Es un evento para un caso de uso muy concreto: enviar datos de 칰ltima hora cuando el usuario se va. Es bueno saber que existe, pero lo que realmente necesitas recordar es `navigator.sendBeacon()`, que es la herramienta que se usa dentro de este evento.

---

## E - `document.readyState`: Preguntando "쯏a llegamos?" al Documento 游리

#### 1. **Introducci칩n:**

Esta no es un evento, sino una propiedad que te permite "espiar" y saber en qu칠 fase de carga se encuentra el documento en cualquier momento.

#### 2. **Ejemplo:**

```javascript
function miCodigoSuperImportante() {
  // ...c칩digo que manipula el DOM...
  console.log("춰Mi c칩digo se ha ejecutado!");
}

// 쯏 si mi script se carga despu칠s de que la p치gina ya est칠 lista?
// 춰No hay problema! Verificamos el estado actual.

if (document.readyState === "loading") {
  // A칰n est치 cargando, as칤 que esperamos al evento.
  document.addEventListener("DOMContentLoaded", miCodigoSuperImportante);
} else {
  // El DOM ya est치 listo, 춰ejecutamos el c칩digo ahora mismo!
  miCodigoSuperImportante();
}
```

**Explicaci칩n del ejemplo:**
Este c칩digo resuelve un problema muy com칰n: 쯤u칠 pasa si mi script se carga de forma as칤ncrona y, para cuando se ejecuta, el evento `DOMContentLoaded` ya se ha disparado? Si solo a침adi칠ramos el `addEventListener`, nuestra funci칩n nunca se ejecutar칤a. Este patr칩n es a prueba de fallos: primero comprueba el estado. Si la p치gina todav칤a est치 en `loading`, espera al evento. Si ya ha pasado esa fase (`interactive` o `complete`), ejecuta la funci칩n inmediatamente.

#### 3. **Desarrollo**:

La propiedad `document.readyState` puede tener tres valores, que son como las paradas de un tren:

1.  `"loading"`: El documento se est치 cargando. El tren acaba de salir de la estaci칩n.
2.  `"interactive"`: El documento ha sido completamente le칤do y parseado. El tren ha llegado a la estaci칩n `DOMContentLoaded`. El esqueleto HTML est치 listo.
3.  `"complete"`: El documento y todos sus recursos (im치genes, estilos) se han cargado. El tren ha llegado a la estaci칩n `window.onload`. Todo est치 en su sitio.

Existe un evento llamado `readystatechange` que se dispara cada vez que este estado cambia, pero es mucho menos com칰n usarlo directamente en comparaci칩n con `DOMContentLoaded` y `load`.

游리 **Importante**: Aunque no lo uses todos los d칤as, conocer `document.readyState` es la marca de un desarrollador cuidadoso. Te permite escribir c칩digo robusto que funciona correctamente sin importar _cu치ndo_ se ejecute. Es tu red de seguridad para no perderte los eventos de carga.
