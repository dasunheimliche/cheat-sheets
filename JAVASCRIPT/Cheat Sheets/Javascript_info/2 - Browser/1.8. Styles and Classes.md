## A - Clases CSS vs. Estilos en línea (`style`): La Regla de Oro 🔴

#### 1. **Introducción:**

La forma más limpia y profesional de dar estilo a tus elementos es usando clases de CSS, reservando los estilos en línea (`style`) solo para casos muy específicos y calculados al momento.

#### 2. **Ejemplo:**

Imagina que quieres resaltar un mensaje de error.

**MÉTODO RECOMENDADO (Usando Clases):**

- **En tu archivo CSS:**
  ```css
  .texto-error {
    color: red;
    font-weight: bold;
    border: 1px solid red;
  }
  ```
- **En tu archivo JavaScript:**
  ```javascript
  let mensaje = document.getElementById("mensaje-final");
  mensaje.classList.add("texto-error"); // ¡Limpio y reutilizable!
  ```

**MÉTODO NO RECOMENDADO (Usando `style`):**

- **En tu archivo JavaScript:**
  ```javascript
  let mensaje = document.getElementById("mensaje-final");
  mensaje.style.color = "red";
  mensaje.style.fontWeight = "bold";
  mensaje.style.border = "1px solid red"; // ¡Esto se vuelve un caos!
  ```

**Excepción Aceptable (para `style`):**

- **En tu archivo JavaScript:**
  ```javascript
  // Imagina que calculas la posición exacta de un tooltip
  let tooltip = document.getElementById("ayuda-contextual");
  tooltip.style.top = "152px"; // Valor calculado dinámicamente
  tooltip.style.left = "310px"; // ¡Para esto sí está bien usar .style!
  ```

#### 3. **Desarrollo:**

Piénsalo como vestir a una persona. Las **clases CSS** son como tener conjuntos de ropa ya preparados: "traje de oficina", "ropa de deporte", "pijama". Con una sola orden (`classList.add('traje-de-oficina')`), la persona se viste de pies a cabeza de forma coherente. Es fácil de mantener: si quieres cambiar el "traje de oficina", solo modificas el conjunto en el armario (tu archivo CSS) y todos los que lo usen se actualizarán.

Usar `style` es como decirle a la persona, prenda por prenda, qué ponerse: "ponte este calcetín derecho de color azul", "ahora el zapato izquierdo marrón", "la camisa a 20 grados de inclinación...". Es útil si necesitas hacer un ajuste milimétrico y único (como colocar un broche en un lugar exacto), pero para el día a día es terriblemente ineficiente, desorganizado y una pesadilla de mantener.

🔴 **Fundamental**: Esta es la base de un código limpio y escalable. Grábate esto a fuego: **primero clases, y `style` solo como último recurso para valores dinámicos.**

---

## B - `className`: El "Todo o Nada" para las Clases 🟡

#### 1. **Introducción:**

`elem.className` te permite leer o escribir _toda la cadena_ de clases de un elemento como si fuera un simple texto, reemplazando todo lo que había antes.

#### 2. **Ejemplo:**

```html
<div id="miDiv" class="alerta principal">Cuidado</div>
<script>
  let div = document.getElementById("miDiv");

  // 1. Leer todas las clases a la vez
  console.log(div.className); // Muestra en consola: "alerta principal"

  // 2. Reemplazar TODAS las clases
  div.className = "exito"; // ¡Adiós a "alerta" y "principal"!
  // Ahora el HTML se ve así: <div id="miDiv" class="exito">Cuidado</div>
</script>
```

**Explicación del ejemplo:**
Al asignar `"exito"` a `div.className`, no estamos _añadiendo_ una clase. Estamos arrancando la etiqueta de clases anterior y pegando una completamente nueva. Es una operación de reemplazo total.

#### 3. **Desarrollo:**

`className` es la forma "antigua" de manejar las clases. Imagina que el atributo `class` es una pizarra. `className` te permite leer todo lo que está escrito en la pizarra o borrarla por completo y escribir algo nuevo. No te permite borrar solo una palabra o añadir una coma. Es una herramienta tosca, como un martillo. A veces necesitas un martillo, pero la mayoría de las veces, para trabajos de detalle, es demasiado.

🟡 **Importante**: Aunque `classList` (que veremos a continuación) es casi siempre mejor, te toparás con `className` en código más antiguo o en librerías. Es crucial que entiendas su comportamiento de **"reemplazo total"** para no borrar clases importantes por accidente. ¡Es una trampa muy común!

---

## C - `classList`: El Cirujano de las Clases 🔴

#### 1. **Introducción:**

`elem.classList` es tu navaja suiza para manipular clases: te da métodos precisos para añadir, quitar, alternar o verificar clases de forma individual, sin tocar las demás.

#### 2. **Ejemplo:**

```html
<button id="miBoton" class="btn">Comprar</button>
<script>
  let boton = document.getElementById("miBoton");

  // 1. AÑADIR una clase:
  boton.classList.add("btn-primario");
  // HTML ahora: class="btn btn-primario"

  // 2. QUITAR una clase:
  boton.classList.remove("btn");
  // HTML ahora: class="btn-primario"

  // 3. ALTERNAR (toggle): si la tiene, la quita; si no, la añade.
  boton.classList.toggle("activo"); // La añade -> class="btn-primario activo"
  boton.classList.toggle("activo"); // La quita  -> class="btn-primario"

  // 4. COMPROBAR si tiene una clase:
  let tieneClase = boton.classList.contains("btn-primario"); // Devuelve: true
  console.log("¿El botón es primario?", tieneClase);
</script>
```

**Explicación del ejemplo:**
Cada operación con `classList` es quirúrgica. `add` solo añade, `remove` solo quita. Las otras clases que ya estaban ni se enteran. Es seguro, predecible y claro.

#### 3. **Desarrollo:**

Si `className` era un martillo, `classList` es un bisturí láser. Te da un control absoluto y seguro sobre cada clase.

- `add('clase')`: Añade la clase. Si ya la tiene, no hace nada (¡seguro!).
- `remove('clase')`: Quita la clase. Si no la tiene, no hace nada (¡seguro!).
- `toggle('clase')`: El interruptor de luz. Perfecto para menús, modos oscuros, etc.
- `contains('clase')`: Tu detective privado. Te dice `true` o `false`.

Además, `classList` es "iterable", lo que significa que puedes recorrer las clases una por una con un bucle `for...of`, algo muy útil para depurar.

🔴 **Fundamental**: Esta es la herramienta moderna, segura y preferida. El 99% de las veces que necesites tocar las clases de un elemento, **debes usar `classList`**.

### **Comparación CRÍTICA: `className` vs. `classList`**

Para que NUNCA más te confundas:

| Característica       | `className` (El Martillo 🔨)                                                        | `classList` (El Bisturí 🔪)                           |
| :------------------- | :---------------------------------------------------------------------------------- | :---------------------------------------------------- |
| **¿Qué manipula?**   | TODA la cadena de clases (`"clase1 clase2"`)                                        | Clases INDIVIDUALES                                   |
| **Acción principal** | REEMPLAZA todo el contenido                                                         | AÑADE, QUITA, ALTERNA una sola clase                  |
| **Riesgo**           | **Altísimo.** Puedes borrar clases importantes sin darte cuenta.                    | **Bajísimo.** Solo afecta a la clase que especificas. |
| **Cuándo usarlo**    | Casi nunca. Solo si estás 100% seguro de que quieres borrar todo y empezar de cero. | **¡CASI SIEMPRE!** Es la forma segura y moderna.      |
| **Ejemplo mental**   | Cambiar el nombre de un archivo.                                                    | Añadir o quitar una etiqueta a un email.              |

**En resumen: A menos que un dinosaurio te persiga y la única forma de salvarte sea usando `className`, opta siempre por `classList`.**

---

## D - `elem.style`: Tu Pincel para Estilos Directos 🔴

#### 1. **Introducción:**

La propiedad `elem.style` te permite acceder y modificar los estilos CSS que están escritos directamente en el atributo `style` de un elemento HTML.

#### 2. **Ejemplo:**

```html
<div id="caja">Hola Mundo</div>
<script>
  let caja = document.getElementById("caja");

  // Esto es lo mismo que escribir en HTML:
  // <div id="caja" style="background-color: cornflowerblue; color: white; padding: 20px;">
  caja.style.backgroundColor = "cornflowerblue";
  caja.style.color = "white";
  caja.style.padding = "20px";
</script>
```

**Explicación del ejemplo:**
Cada línea de JavaScript está "pintando" un estilo directamente sobre el elemento. Fíjate en `backgroundColor`: las propiedades CSS con guiones se transforman (ver siguiente concepto).

#### 3. **Desarrollo:**

`elem.style` es tu acceso directo para cambiar la apariencia de un elemento sobre la marcha. Es crucial que entiendas su limitación más importante: **solo escribe y lee los estilos que están en el atributo `style="..."`**. Es ciego a los estilos que vienen de tus archivos `.css`. Es una herramienta de **escritura**, no un lector universal de estilos.

🔴 **Fundamental**: Es la forma básica de cambiar dinámicamente la apariencia de un elemento desde JavaScript, especialmente para propiedades que dependen de cálculos en tiempo de real (posiciones, tamaños, colores generados al azar, etc.).

---

## E - `camelCase`: El Traductor de Nombres CSS 🔴

#### 1. **Introducción:**

Como en JavaScript los guiones (`-`) se usan para restar, las propiedades CSS de varias palabras (ej: `background-color`) se transforman a `camelCase` (ej: `backgroundColor`) para poder usarlas en `elem.style`.

#### 2. **Ejemplo:**

```javascript
// CSS: font-size         -> JS: elemento.style.fontSize
// CSS: z-index           -> JS: elemento.style.zIndex
// CSS: border-left-width -> JS: elemento.style.borderLeftWidth

let boton = document.getElementById("miBoton");
boton.style.borderLeftWidth = "5px"; // en vez de 'border-left-width'
```

**Explicación del ejemplo:**
La regla es simple: cuando veas un guion en CSS, quítalo y pon la siguiente letra en mayúscula. `background-color` se convierte en `backgroundColor`. ¡Así de fácil! Esto también aplica a propiedades con prefijos de navegador como `-moz-border-radius`, que se convertiría en `style.MozBorderRadius`.

#### 3. **Desarrollo:**

Esto no es un capricho, es una necesidad técnica. Si intentaras escribir `elemento.style.background-color`, JavaScript pensaría que quieres restar una variable `color` de `elemento.style.background`, lo cual no tiene sentido y provocaría un error. El `camelCase` resuelve esta ambigüedad. Acostúmbrate a esta traducción, la usarás todo el tiempo.

🔴 **Fundamental**: No puedes usar `elem.style` correctamente si no dominas esta regla de conversión. Es un conocimiento básico e indispensable.

---

## F - Reiniciar un Estilo: Volviendo a la Normalidad 🟡

#### 1. **Introducción:**

Para eliminar un estilo en línea que añadiste con JavaScript y hacer que el elemento vuelva a usar sus estilos CSS originales, simplemente asigna una cadena vacía (`""`) a esa propiedad.

#### 2. **Ejemplo:**

```javascript
let parrafo = document.getElementById("miParrafo");

// Ocultamos el párrafo añadiendo un estilo en línea
parrafo.style.display = "none";

// Después de 2 segundos, queremos que vuelva a ser visible
setTimeout(() => {
  // ¡Esta es la magia! Al poner "", es como si nunca hubiéramos tocado style.display
  parrafo.style.display = "";
}, 2000);
```

**Explicación del ejemplo:**
Al hacer `parrafo.style.display = ""`, no le estamos diciendo "usa un display vacío". Le estamos diciendo al navegador: "Olvida la regla `display` que te di en el atributo `style`. Vuelve a calcular cuál debería ser su `display` basándote en los archivos CSS y en tus propias reglas por defecto (por ejemplo, `block` para un `div` o `inline` para un `span`)".

#### 3. **Desarrollo:**

Tu primer instinto podría ser usar `delete parrafo.style.display`, pero eso no funciona. La forma correcta y estándar es asignar una cadena vacía. También existe un método más explícito, `elem.style.removeProperty('property-name')`, que hace exactamente lo mismo (ej: `parrafo.style.removeProperty('display')`). Ambas formas son válidas, pero asignar `""` es más común.

🟡 **Importante**: Es una técnica muy común cuando manipulas la visibilidad o el estado de los elementos de forma temporal. Saber cómo "deshacer" un cambio de estilo es tan importante como saber hacerlo.

---

## G - `style.cssText`: El "Formateo de Disco" de los Estilos 🔵

#### 1. **Introducción:**

La propiedad `style.cssText` te permite reemplazar _todos_ los estilos en línea de un elemento de una sola vez, usando una cadena de texto CSS normal.

#### 2. **Ejemplo:**

```html
<div id="caja" style="color: blue; font-size: 16px;">Texto original</div>
<script>
  let caja = document.getElementById("caja");

  // Esto BORRARÁ "color: blue" y "font-size: 16px" y lo REEMPLAZARÁ con lo nuevo.
  caja.style.cssText = `
    background-color: yellow;
    width: 200px;
    text-align: center;
  `;
</script>
```

**Explicación del ejemplo:**
`style.cssText` no añade estilos, los sobrescribe por completo. Los estilos originales (`color` y `font-size`) desaparecieron para siempre, reemplazados por el nuevo bloque de CSS.

#### 3. **Desarrollo:**

Piensa en `style.cssText` como un "borrado total" para el atributo `style`. Es una herramienta muy potente pero también peligrosa, porque no respeta nada de lo que había antes. Es útil principalmente cuando creas un elemento nuevo desde cero con JavaScript y quieres aplicarle un montón de estilos de golpe. En la mayoría de los otros casos, es más seguro modificar las propiedades una por una con `elem.style.propiedad` para no destruir algo sin querer.

🔵 **Específico**: No es algo que uses todos los días. Es bueno saber que existe para situaciones muy concretas, pero para el trabajo diario, es mejor y más seguro usar `elem.style.propiedad`.

---

## H - ¡No Olvides las Unidades! (px, %, em...) 🔴

#### 1. **Introducción:**

Cuando asignas un valor numérico a una propiedad de estilo en JavaScript (como `width`, `margin`, `font-size`), casi siempre debes incluir la unidad CSS (`'px'`, `'%'`, `'em'`, etc.) como parte de la cadena de texto.

#### 2. **Ejemplo:**

```javascript
let caja = document.getElementById("caja");

// ❌ INCORRECTO: El navegador ignorará esto en silencio.
caja.style.width = 100;
caja.style.marginTop = 20;

// ✅ CORRECTO: Añadimos la unidad como texto.
caja.style.width = "100px";
caja.style.marginTop = "20px";
caja.style.fontSize = "1.5em";
```

**Explicación del ejemplo:**
El navegador no es adivino. No sabe si `100` significa 100 píxeles, 100 por ciento o 100 patatas. Tienes que ser explícito. Por eso, el valor que asignas debe ser un _string_ (texto entre comillas) que incluya el número y su unidad.

#### 3. **Desarrollo:**

Este es, sin duda, uno de los errores más comunes y frustrantes para principiantes. Escribes el código, no ves ningún error en la consola, pero... ¡nada cambia en la pantalla! La razón suele ser esta: olvidaste las unidades. El navegador, al no entender el valor, simplemente lo ignora. ¡Que no te pase a ti! Grábatelo a fuego: **los valores de estilo necesitan unidades**. (Hay poquísimas excepciones, como `zIndex` u `opacity`, que son números puros, pero son la minoría).

🔴 **Fundamental**: Si no sigues esta regla, tus estilos simplemente no funcionarán. Es un requisito absoluto para la manipulación de estilos geométricos.

---

## I - `getComputedStyle`: El Lector de Mentes del Navegador 🔴

#### 1. **Introducción:**

`getComputedStyle(elemento)` es la herramienta que necesitas para _leer_ el valor final y real de una propiedad CSS de un elemento, después de que el navegador haya aplicado todas las reglas de estilo posibles (de archivos CSS, estilos en línea, etc.).

#### 2. **Ejemplo:**

```html
<style>
  #mi-div {
    margin-top: 20px;
    color: red;
  }
</style>
<div id="mi-div" style="padding-left: 15px;">...</div>

<script>
  let div = document.getElementById("mi-div");

  // ❌ Intento fallido: .style es miope, solo ve el atributo "style"
  console.log(div.style.color); // Muestra "" (vacío), porque "color: red" está en <style>.
  console.log(div.style.paddingLeft); // Muestra "15px", esto sí lo ve.

  // ✅ La forma correcta: getComputedStyle lo ve TODO
  let estilosCalculados = getComputedStyle(div);
  console.log(estilosCalculados.color); // Muestra "rgb(255, 0, 0)" (el valor final de 'red')
  console.log(estilosCalculados.marginTop); // Muestra "20px"
</script>
```

**Explicación del ejemplo:**
`div.style` solo puede ver lo que está escrito explícitamente en el atributo `style="..."`. En cambio, `getComputedStyle(div)` tiene superpoderes: lee los estilos del `<style>`, los de archivos CSS externos, los del atributo `style`, los combina, calcula los valores finales y te dice lo que el usuario realmente está viendo en su pantalla.

#### 3. **Desarrollo:**

- **Valores Resueltos:** `getComputedStyle` es increíblemente útil porque te da los valores finales y absolutos. Si un `width` es del `50%`, no te devolverá `"50%"` sino el valor en píxeles que eso representa en ese momento, por ejemplo `"450.5px"`. Esto es oro puro para hacer cálculos precisos.
- **Sé Específico:** Siempre pide la propiedad completa y final que buscas (`paddingLeft`, `marginTop`), no una propiedad genérica como `padding`.

🔴 **Fundamental**: Es la única forma fiable de _leer_ el estado visual de un elemento. Indispensable si tu JavaScript necesita reaccionar o basar sus cálculos en los estilos actuales de un elemento.

### **Comparación CRÍTICA: `elem.style` vs. `getComputedStyle`**

Para que quede grabado en tu cerebro para siempre:

| Característica          | `elem.style` (El Escritor ✍️)                          | `getComputedStyle` (El Lector 🧐)                                    |
| :---------------------- | :----------------------------------------------------- | :------------------------------------------------------------------- |
| **Propósito Principal** | **ESCRIBIR** o **MODIFICAR** estilos.                  | **LEER** estilos. Es de solo lectura.                                |
| **¿Qué ve?**            | Solo lo que está DENTRO del atributo `style="..."`.    | **TODO:** archivos CSS, etiquetas `<style>`, `style="..."`, etc.     |
| **Analogía**            | El bolígrafo con el que escribes notas sobre una foto. | Una lupa de alta tecnología que te muestra cómo se ve la foto final. |
| **Cuándo usarlo**       | Para **CAMBIAR** el estilo de un elemento.             | Para **SABER** qué estilo tiene un elemento.                         |

**En resumen: ¿Quieres cambiar algo? `elem.style`. ¿Quieres saber algo? `getComputedStyle`. No hay más.**

---

## J - El Misterio de los Estilos `:visited` 🔵

#### 1. **Introducción:**

Por motivos de privacidad, JavaScript tiene prohibido leer la mayoría de los estilos que se aplican a los enlaces ya visitados a través de la pseudo-clase `:visited` de CSS.

#### 2. **Ejemplo:**

```html
<style>
  a:link {
    color: blue;
  }
  a:visited {
    color: purple;
  } /* El usuario ve esto si ya visitó el enlace */
</style>
<a id="miEnlace" href="https://www.google.com">Un enlace a Google</a>
<script>
  // Supongamos que el usuario ya ha visitado Google.
  let enlace = document.getElementById("miEnlace");
  let estilos = getComputedStyle(enlace);

  // AUNQUE el enlace se vea morado en la pantalla...
  // ...JavaScript te "mentirá" por seguridad.
  console.log(estilos.color); // Probablemente mostrará "rgb(0, 0, 255)" (azul), no el morado.
</script>
```

**Explicación del ejemplo:**
Aunque el enlace se muestre morado, `getComputedStyle` te devolverá el color del estado no visitado (`:link`). El navegador protege la privacidad del usuario.

#### 3. **Desarrollo:**

¿Por qué esta regla tan rara? ¡Para evitar el espionaje! Si una página web maliciosa pudiera crear enlaces a `tucuenta@banco.com`, `facebook.com`, etc., y luego usar JavaScript para comprobar su color, podría deducir qué sitios has visitado. Para evitarlo, los navegadores "mienten" a JavaScript sobre los estilos de `:visited`. Es una pequeña limitación con la que vivimos para proteger la privacidad de todos.

🔵 **Específico**: Es un caso límite que solo te afectará si intentas hacer algo muy concreto con los estilos de enlaces visitados. Es bueno conocerlo para no volverte loco depurando, pero no afecta al 99% de tu trabajo diario con estilos.
