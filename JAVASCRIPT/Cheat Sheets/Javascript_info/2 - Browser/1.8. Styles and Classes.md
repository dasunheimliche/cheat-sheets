## A - Clases CSS vs. Estilos en l√≠nea (`style`): La Regla de Oro üî¥

#### 1. **Introducci√≥n:**

La forma m√°s limpia y profesional de dar estilo a tus elementos es usando clases de CSS, reservando los estilos en l√≠nea (`style`) solo para casos muy espec√≠ficos y calculados al momento.

#### 2. **Ejemplo:**

Imagina que quieres resaltar un mensaje de error.

**M√âTODO RECOMENDADO (Usando Clases):**

- **En tu archivo CSS:**
  ```css
  .texto-error {
    color: red;
    font-weight: bold;
    border: 1px solid red;
  }
  ```
- **En tu archivo JavaScript:**
  ```javascript
  let mensaje = document.getElementById("mensaje-final");
  mensaje.classList.add("texto-error"); // ¬°Limpio y reutilizable!
  ```

**M√âTODO NO RECOMENDADO (Usando `style`):**

- **En tu archivo JavaScript:**
  ```javascript
  let mensaje = document.getElementById("mensaje-final");
  mensaje.style.color = "red";
  mensaje.style.fontWeight = "bold";
  mensaje.style.border = "1px solid red"; // ¬°Esto se vuelve un caos!
  ```

**Excepci√≥n Aceptable (para `style`):**

- **En tu archivo JavaScript:**
  ```javascript
  // Imagina que calculas la posici√≥n exacta de un tooltip
  let tooltip = document.getElementById("ayuda-contextual");
  tooltip.style.top = "152px"; // Valor calculado din√°micamente
  tooltip.style.left = "310px"; // ¬°Para esto s√≠ est√° bien usar .style!
  ```

#### 3. **Desarrollo:**

Pi√©nsalo como vestir a una persona. Las **clases CSS** son como tener conjuntos de ropa ya preparados: "traje de oficina", "ropa de deporte", "pijama". Con una sola orden (`classList.add('traje-de-oficina')`), la persona se viste de pies a cabeza de forma coherente. Es f√°cil de mantener: si quieres cambiar el "traje de oficina", solo modificas el conjunto en el armario (tu archivo CSS) y todos los que lo usen se actualizar√°n.

Usar `style` es como decirle a la persona, prenda por prenda, qu√© ponerse: "ponte este calcet√≠n derecho de color azul", "ahora el zapato izquierdo marr√≥n", "la camisa a 20 grados de inclinaci√≥n...". Es √∫til si necesitas hacer un ajuste milim√©trico y √∫nico (como colocar un broche en un lugar exacto), pero para el d√≠a a d√≠a es terriblemente ineficiente, desorganizado y una pesadilla de mantener.

üî¥ **Fundamental**: Esta es la base de un c√≥digo limpio y escalable. Gr√°bate esto a fuego: **primero clases, y `style` solo como √∫ltimo recurso para valores din√°micos.**

---

## B - `className`: El "Todo o Nada" para las Clases üü°

#### 1. **Introducci√≥n:**

`elem.className` te permite leer o escribir _toda la cadena_ de clases de un elemento como si fuera un simple texto, reemplazando todo lo que hab√≠a antes.

#### 2. **Ejemplo:**

```html
<div id="miDiv" class="alerta principal">Cuidado</div>
<script>
  let div = document.getElementById("miDiv");

  // 1. Leer todas las clases a la vez
  console.log(div.className); // Muestra en consola: "alerta principal"

  // 2. Reemplazar TODAS las clases
  div.className = "exito"; // ¬°Adi√≥s a "alerta" y "principal"!
  // Ahora el HTML se ve as√≠: <div id="miDiv" class="exito">Cuidado</div>
</script>
```

**Explicaci√≥n del ejemplo:**
Al asignar `"exito"` a `div.className`, no estamos _a√±adiendo_ una clase. Estamos arrancando la etiqueta de clases anterior y pegando una completamente nueva. Es una operaci√≥n de reemplazo total.

#### 3. **Desarrollo:**

`className` es la forma "antigua" de manejar las clases. Imagina que el atributo `class` es una pizarra. `className` te permite leer todo lo que est√° escrito en la pizarra o borrarla por completo y escribir algo nuevo. No te permite borrar solo una palabra o a√±adir una coma. Es una herramienta tosca, como un martillo. A veces necesitas un martillo, pero la mayor√≠a de las veces, para trabajos de detalle, es demasiado.

üü° **Importante**: Aunque `classList` (que veremos a continuaci√≥n) es casi siempre mejor, te topar√°s con `className` en c√≥digo m√°s antiguo o en librer√≠as. Es crucial que entiendas su comportamiento de **"reemplazo total"** para no borrar clases importantes por accidente. ¬°Es una trampa muy com√∫n!

---

## C - `classList`: El Cirujano de las Clases üî¥

#### 1. **Introducci√≥n:**

`elem.classList` es tu navaja suiza para manipular clases: te da m√©todos precisos para a√±adir, quitar, alternar o verificar clases de forma individual, sin tocar las dem√°s.

#### 2. **Ejemplo:**

```html
<button id="miBoton" class="btn">Comprar</button>
<script>
  let boton = document.getElementById("miBoton");

  // 1. A√ëADIR una clase:
  boton.classList.add("btn-primario");
  // HTML ahora: class="btn btn-primario"

  // 2. QUITAR una clase:
  boton.classList.remove("btn");
  // HTML ahora: class="btn-primario"

  // 3. ALTERNAR (toggle): si la tiene, la quita; si no, la a√±ade.
  boton.classList.toggle("activo"); // La a√±ade -> class="btn-primario activo"
  boton.classList.toggle("activo"); // La quita  -> class="btn-primario"

  // 4. COMPROBAR si tiene una clase:
  let tieneClase = boton.classList.contains("btn-primario"); // Devuelve: true
  console.log("¬øEl bot√≥n es primario?", tieneClase);
</script>
```

**Explicaci√≥n del ejemplo:**
Cada operaci√≥n con `classList` es quir√∫rgica. `add` solo a√±ade, `remove` solo quita. Las otras clases que ya estaban ni se enteran. Es seguro, predecible y claro.

#### 3. **Desarrollo:**

Si `className` era un martillo, `classList` es un bistur√≠ l√°ser. Te da un control absoluto y seguro sobre cada clase.

- `add('clase')`: A√±ade la clase. Si ya la tiene, no hace nada (¬°seguro!).
- `remove('clase')`: Quita la clase. Si no la tiene, no hace nada (¬°seguro!).
- `toggle('clase')`: El interruptor de luz. Perfecto para men√∫s, modos oscuros, etc.
- `contains('clase')`: Tu detective privado. Te dice `true` o `false`.

Adem√°s, `classList` es "iterable", lo que significa que puedes recorrer las clases una por una con un bucle `for...of`, algo muy √∫til para depurar.

üî¥ **Fundamental**: Esta es la herramienta moderna, segura y preferida. El 99% de las veces que necesites tocar las clases de un elemento, **debes usar `classList`**.

### **Comparaci√≥n CR√çTICA: `className` vs. `classList`**

Para que NUNCA m√°s te confundas:

| Caracter√≠stica       | `className` (El Martillo üî®)                                                        | `classList` (El Bistur√≠ üî™)                           |
| :------------------- | :---------------------------------------------------------------------------------- | :---------------------------------------------------- |
| **¬øQu√© manipula?**   | TODA la cadena de clases (`"clase1 clase2"`)                                        | Clases INDIVIDUALES                                   |
| **Acci√≥n principal** | REEMPLAZA todo el contenido                                                         | A√ëADE, QUITA, ALTERNA una sola clase                  |
| **Riesgo**           | **Alt√≠simo.** Puedes borrar clases importantes sin darte cuenta.                    | **Baj√≠simo.** Solo afecta a la clase que especificas. |
| **Cu√°ndo usarlo**    | Casi nunca. Solo si est√°s 100% seguro de que quieres borrar todo y empezar de cero. | **¬°CASI SIEMPRE!** Es la forma segura y moderna.      |
| **Ejemplo mental**   | Cambiar el nombre de un archivo.                                                    | A√±adir o quitar una etiqueta a un email.              |

**En resumen: A menos que un dinosaurio te persiga y la √∫nica forma de salvarte sea usando `className`, opta siempre por `classList`.**

---

## D - `elem.style`: Tu Pincel para Estilos Directos üî¥

#### 1. **Introducci√≥n:**

La propiedad `elem.style` te permite acceder y modificar los estilos CSS que est√°n escritos directamente en el atributo `style` de un elemento HTML.

#### 2. **Ejemplo:**

```html
<div id="caja">Hola Mundo</div>
<script>
  let caja = document.getElementById("caja");

  // Esto es lo mismo que escribir en HTML:
  // <div id="caja" style="background-color: cornflowerblue; color: white; padding: 20px;">
  caja.style.backgroundColor = "cornflowerblue";
  caja.style.color = "white";
  caja.style.padding = "20px";
</script>
```

**Explicaci√≥n del ejemplo:**
Cada l√≠nea de JavaScript est√° "pintando" un estilo directamente sobre el elemento. F√≠jate en `backgroundColor`: las propiedades CSS con guiones se transforman (ver siguiente concepto).

#### 3. **Desarrollo:**

`elem.style` es tu acceso directo para cambiar la apariencia de un elemento sobre la marcha. Es crucial que entiendas su limitaci√≥n m√°s importante: **solo escribe y lee los estilos que est√°n en el atributo `style="..."`**. Es ciego a los estilos que vienen de tus archivos `.css`. Es una herramienta de **escritura**, no un lector universal de estilos.

üî¥ **Fundamental**: Es la forma b√°sica de cambiar din√°micamente la apariencia de un elemento desde JavaScript, especialmente para propiedades que dependen de c√°lculos en tiempo de real (posiciones, tama√±os, colores generados al azar, etc.).

---

## E - `camelCase`: El Traductor de Nombres CSS üî¥

#### 1. **Introducci√≥n:**

Como en JavaScript los guiones (`-`) se usan para restar, las propiedades CSS de varias palabras (ej: `background-color`) se transforman a `camelCase` (ej: `backgroundColor`) para poder usarlas en `elem.style`.

#### 2. **Ejemplo:**

```javascript
// CSS: font-size         -> JS: elemento.style.fontSize
// CSS: z-index           -> JS: elemento.style.zIndex
// CSS: border-left-width -> JS: elemento.style.borderLeftWidth

let boton = document.getElementById("miBoton");
boton.style.borderLeftWidth = "5px"; // en vez de 'border-left-width'
```

**Explicaci√≥n del ejemplo:**
La regla es simple: cuando veas un guion en CSS, qu√≠talo y pon la siguiente letra en may√∫scula. `background-color` se convierte en `backgroundColor`. ¬°As√≠ de f√°cil! Esto tambi√©n aplica a propiedades con prefijos de navegador como `-moz-border-radius`, que se convertir√≠a en `style.MozBorderRadius`.

#### 3. **Desarrollo:**

Esto no es un capricho, es una necesidad t√©cnica. Si intentaras escribir `elemento.style.background-color`, JavaScript pensar√≠a que quieres restar una variable `color` de `elemento.style.background`, lo cual no tiene sentido y provocar√≠a un error. El `camelCase` resuelve esta ambig√ºedad. Acost√∫mbrate a esta traducci√≥n, la usar√°s todo el tiempo.

üî¥ **Fundamental**: No puedes usar `elem.style` correctamente si no dominas esta regla de conversi√≥n. Es un conocimiento b√°sico e indispensable.

---

## F - Reiniciar un Estilo: Volviendo a la Normalidad üü°

#### 1. **Introducci√≥n:**

Para eliminar un estilo en l√≠nea que a√±adiste con JavaScript y hacer que el elemento vuelva a usar sus estilos CSS originales, simplemente asigna una cadena vac√≠a (`""`) a esa propiedad.

#### 2. **Ejemplo:**

```javascript
let parrafo = document.getElementById("miParrafo");

// Ocultamos el p√°rrafo a√±adiendo un estilo en l√≠nea
parrafo.style.display = "none";

// Despu√©s de 2 segundos, queremos que vuelva a ser visible
setTimeout(() => {
  // ¬°Esta es la magia! Al poner "", es como si nunca hubi√©ramos tocado style.display
  parrafo.style.display = "";
}, 2000);
```

**Explicaci√≥n del ejemplo:**
Al hacer `parrafo.style.display = ""`, no le estamos diciendo "usa un display vac√≠o". Le estamos diciendo al navegador: "Olvida la regla `display` que te di en el atributo `style`. Vuelve a calcular cu√°l deber√≠a ser su `display` bas√°ndote en los archivos CSS y en tus propias reglas por defecto (por ejemplo, `block` para un `div` o `inline` para un `span`)".

#### 3. **Desarrollo:**

Tu primer instinto podr√≠a ser usar `delete parrafo.style.display`, pero eso no funciona. La forma correcta y est√°ndar es asignar una cadena vac√≠a. Tambi√©n existe un m√©todo m√°s expl√≠cito, `elem.style.removeProperty('property-name')`, que hace exactamente lo mismo (ej: `parrafo.style.removeProperty('display')`). Ambas formas son v√°lidas, pero asignar `""` es m√°s com√∫n.

üü° **Importante**: Es una t√©cnica muy com√∫n cuando manipulas la visibilidad o el estado de los elementos de forma temporal. Saber c√≥mo "deshacer" un cambio de estilo es tan importante como saber hacerlo.

---

## G - `style.cssText`: El "Formateo de Disco" de los Estilos üîµ

#### 1. **Introducci√≥n:**

La propiedad `style.cssText` te permite reemplazar _todos_ los estilos en l√≠nea de un elemento de una sola vez, usando una cadena de texto CSS normal.

#### 2. **Ejemplo:**

```html
<div id="caja" style="color: blue; font-size: 16px;">Texto original</div>
<script>
  let caja = document.getElementById("caja");

  // Esto BORRAR√Å "color: blue" y "font-size: 16px" y lo REEMPLAZAR√Å con lo nuevo.
  caja.style.cssText = `
    background-color: yellow;
    width: 200px;
    text-align: center;
  `;
</script>
```

**Explicaci√≥n del ejemplo:**
`style.cssText` no a√±ade estilos, los sobrescribe por completo. Los estilos originales (`color` y `font-size`) desaparecieron para siempre, reemplazados por el nuevo bloque de CSS.

#### 3. **Desarrollo:**

Piensa en `style.cssText` como un "borrado total" para el atributo `style`. Es una herramienta muy potente pero tambi√©n peligrosa, porque no respeta nada de lo que hab√≠a antes. Es √∫til principalmente cuando creas un elemento nuevo desde cero con JavaScript y quieres aplicarle un mont√≥n de estilos de golpe. En la mayor√≠a de los otros casos, es m√°s seguro modificar las propiedades una por una con `elem.style.propiedad` para no destruir algo sin querer.

üîµ **Espec√≠fico**: No es algo que uses todos los d√≠as. Es bueno saber que existe para situaciones muy concretas, pero para el trabajo diario, es mejor y m√°s seguro usar `elem.style.propiedad`.

---

## H - ¬°No Olvides las Unidades! (px, %, em...) üî¥

#### 1. **Introducci√≥n:**

Cuando asignas un valor num√©rico a una propiedad de estilo en JavaScript (como `width`, `margin`, `font-size`), casi siempre debes incluir la unidad CSS (`'px'`, `'%'`, `'em'`, etc.) como parte de la cadena de texto.

#### 2. **Ejemplo:**

```javascript
let caja = document.getElementById("caja");

// ‚ùå INCORRECTO: El navegador ignorar√° esto en silencio.
caja.style.width = 100;
caja.style.marginTop = 20;

// ‚úÖ CORRECTO: A√±adimos la unidad como texto.
caja.style.width = "100px";
caja.style.marginTop = "20px";
caja.style.fontSize = "1.5em";
```

**Explicaci√≥n del ejemplo:**
El navegador no es adivino. No sabe si `100` significa 100 p√≠xeles, 100 por ciento o 100 patatas. Tienes que ser expl√≠cito. Por eso, el valor que asignas debe ser un _string_ (texto entre comillas) que incluya el n√∫mero y su unidad.

#### 3. **Desarrollo:**

Este es, sin duda, uno de los errores m√°s comunes y frustrantes para principiantes. Escribes el c√≥digo, no ves ning√∫n error en la consola, pero... ¬°nada cambia en la pantalla! La raz√≥n suele ser esta: olvidaste las unidades. El navegador, al no entender el valor, simplemente lo ignora. ¬°Que no te pase a ti! Gr√°batelo a fuego: **los valores de estilo necesitan unidades**. (Hay poqu√≠simas excepciones, como `zIndex` u `opacity`, que son n√∫meros puros, pero son la minor√≠a).

üî¥ **Fundamental**: Si no sigues esta regla, tus estilos simplemente no funcionar√°n. Es un requisito absoluto para la manipulaci√≥n de estilos geom√©tricos.

---

## I - `getComputedStyle`: El Lector de Mentes del Navegador üî¥

#### 1. **Introducci√≥n:**

`getComputedStyle(elemento)` es la herramienta que necesitas para _leer_ el valor final y real de una propiedad CSS de un elemento, despu√©s de que el navegador haya aplicado todas las reglas de estilo posibles (de archivos CSS, estilos en l√≠nea, etc.).

#### 2. **Ejemplo:**

```html
<style>
  #mi-div {
    margin-top: 20px;
    color: red;
  }
</style>
<div id="mi-div" style="padding-left: 15px;">...</div>

<script>
  let div = document.getElementById("mi-div");

  // ‚ùå Intento fallido: .style es miope, solo ve el atributo "style"
  console.log(div.style.color); // Muestra "" (vac√≠o), porque "color: red" est√° en <style>.
  console.log(div.style.paddingLeft); // Muestra "15px", esto s√≠ lo ve.

  // ‚úÖ La forma correcta: getComputedStyle lo ve TODO
  let estilosCalculados = getComputedStyle(div);
  console.log(estilosCalculados.color); // Muestra "rgb(255, 0, 0)" (el valor final de 'red')
  console.log(estilosCalculados.marginTop); // Muestra "20px"
</script>
```

**Explicaci√≥n del ejemplo:**
`div.style` solo puede ver lo que est√° escrito expl√≠citamente en el atributo `style="..."`. En cambio, `getComputedStyle(div)` tiene superpoderes: lee los estilos del `<style>`, los de archivos CSS externos, los del atributo `style`, los combina, calcula los valores finales y te dice lo que el usuario realmente est√° viendo en su pantalla.

#### 3. **Desarrollo:**

- **Valores Resueltos:** `getComputedStyle` es incre√≠blemente √∫til porque te da los valores finales y absolutos. Si un `width` es del `50%`, no te devolver√° `"50%"` sino el valor en p√≠xeles que eso representa en ese momento, por ejemplo `"450.5px"`. Esto es oro puro para hacer c√°lculos precisos.
- **S√© Espec√≠fico:** Siempre pide la propiedad completa y final que buscas (`paddingLeft`, `marginTop`), no una propiedad gen√©rica como `padding`.

üî¥ **Fundamental**: Es la √∫nica forma fiable de _leer_ el estado visual de un elemento. Indispensable si tu JavaScript necesita reaccionar o basar sus c√°lculos en los estilos actuales de un elemento.

### **Comparaci√≥n CR√çTICA: `elem.style` vs. `getComputedStyle`**

Para que quede grabado en tu cerebro para siempre:

| Caracter√≠stica          | `elem.style` (El Escritor ‚úçÔ∏è)                          | `getComputedStyle` (El Lector üßê)                                    |
| :---------------------- | :----------------------------------------------------- | :------------------------------------------------------------------- |
| **Prop√≥sito Principal** | **ESCRIBIR** o **MODIFICAR** estilos.                  | **LEER** estilos. Es de solo lectura.                                |
| **¬øQu√© ve?**            | Solo lo que est√° DENTRO del atributo `style="..."`.    | **TODO:** archivos CSS, etiquetas `<style>`, `style="..."`, etc.     |
| **Analog√≠a**            | El bol√≠grafo con el que escribes notas sobre una foto. | Una lupa de alta tecnolog√≠a que te muestra c√≥mo se ve la foto final. |
| **Cu√°ndo usarlo**       | Para **CAMBIAR** el estilo de un elemento.             | Para **SABER** qu√© estilo tiene un elemento.                         |

**En resumen: ¬øQuieres cambiar algo? `elem.style`. ¬øQuieres saber algo? `getComputedStyle`. No hay m√°s.**

---

## J - El Misterio de los Estilos `:visited` üîµ

#### 1. **Introducci√≥n:**

Por motivos de privacidad, JavaScript tiene prohibido leer la mayor√≠a de los estilos que se aplican a los enlaces ya visitados a trav√©s de la pseudo-clase `:visited` de CSS.

#### 2. **Ejemplo:**

```html
<style>
  a:link {
    color: blue;
  }
  a:visited {
    color: purple;
  } /* El usuario ve esto si ya visit√≥ el enlace */
</style>
<a id="miEnlace" href="https://www.google.com">Un enlace a Google</a>
<script>
  // Supongamos que el usuario ya ha visitado Google.
  let enlace = document.getElementById("miEnlace");
  let estilos = getComputedStyle(enlace);

  // AUNQUE el enlace se vea morado en la pantalla...
  // ...JavaScript te "mentir√°" por seguridad.
  console.log(estilos.color); // Probablemente mostrar√° "rgb(0, 0, 255)" (azul), no el morado.
</script>
```

**Explicaci√≥n del ejemplo:**
Aunque el enlace se muestre morado, `getComputedStyle` te devolver√° el color del estado no visitado (`:link`). El navegador protege la privacidad del usuario.

#### 3. **Desarrollo:**

¬øPor qu√© esta regla tan rara? ¬°Para evitar el espionaje! Si una p√°gina web maliciosa pudiera crear enlaces a `tucuenta@banco.com`, `facebook.com`, etc., y luego usar JavaScript para comprobar su color, podr√≠a deducir qu√© sitios has visitado. Para evitarlo, los navegadores "mienten" a JavaScript sobre los estilos de `:visited`. Es una peque√±a limitaci√≥n con la que vivimos para proteger la privacidad de todos.

üîµ **Espec√≠fico**: Es un caso l√≠mite que solo te afectar√° si intentas hacer algo muy concreto con los estilos de enlaces visitados. Es bueno conocerlo para no volverte loco depurando, pero no afecta al 99% de tu trabajo diario con estilos.
