## A - `getElementById`: El Francotirador del DOM üî¥

#### 1. **Introducci√≥n:**

Este m√©todo es tu herramienta de m√°xima precisi√≥n: te permite encontrar un **√∫nico** elemento en toda la p√°gina usando su `id`, que es como su n√∫mero de DNI, ¬°√∫nico e irrepetible!

#### 2. **Ejemplo:**

Imagina que tienes este t√≠tulo en tu HTML:

```html
<h1 id="titulo-principal">Mi P√°gina Incre√≠ble</h1>
```

Para encontrarlo con JavaScript, har√≠as esto:

```javascript
// Le pedimos al documento entero que nos traiga el elemento con el ID "titulo-principal"
let miTitulo = document.getElementById("titulo-principal");

// Ahora que lo tenemos, ¬°podemos hacer magia! Vamos a cambiarle el color.
miTitulo.style.color = "blue";
```

**Explicaci√≥n del ejemplo:**
El c√≥digo le dice al navegador: "Oye, `document` (toda la p√°gina), b√∫scame al elemento que tiene la etiqueta de identificaci√≥n (`id`) `'titulo-principal'`". Una vez que lo encuentra, lo guarda en la variable `miTitulo` para que puedas manipularlo como quieras.

#### 3. **Desarrollo**:

- **¬°El `id` DEBE ser √∫nico!** Esto es s√∫per importante. Si tienes dos elementos con el mismo `id`, el navegador se confundir√° y `getElementById` podr√≠a devolverte cualquiera de los dos, de forma impredecible. Es como si dos personas tuvieran el mismo DNI. ¬°Un caos! Aseg√∫rate de que cada `id` se use solo una vez por p√°gina.
- **Solo funciona en `document`:** Este m√©todo solo se puede llamar desde el objeto `document`. No puedes hacer `miElemento.getElementById(...)` para buscar dentro de otro elemento. Tiene sentido, ¬øverdad? Los DNI son √∫nicos en todo el pa√≠s (la p√°gina), no solo en una ciudad (un elemento).
- **CUIDADO: Una trampa hist√≥rica:** Antiguamente, los navegadores creaban variables globales con el mismo nombre que los `id`. Por ejemplo, para `<div id="elem">`, pod√≠as acceder a √©l simplemente escribiendo `elem` en tu JavaScript. **¬°NO HAGAS ESTO!** Es una mala pr√°ctica que puede crear conflictos con tus propias variables y hacer que tu c√≥digo sea muy dif√≠cil de entender. Usa siempre `document.getElementById()`, que es claro y seguro.

üî¥ **Fundamental**: Es la forma m√°s r√°pida y directa de seleccionar un elemento espec√≠fico cuando conoces su `id`. Es tu primera opci√≥n para "ese" elemento √∫nico que necesitas.

---

## B - `querySelectorAll`: El Equipo SWAT para M√∫ltiples Elementos üî¥

#### 1. **Introducci√≥n:**

Esta es tu herramienta de b√∫squeda masiva. Encuentra **_todos_** los elementos que coinciden con un selector CSS (s√≠, ¬°los mismos que usas en tus hojas de estilo!) y te los devuelve en una lista.

#### 2. **Ejemplo:**

Supongamos que tienes una lista de tareas en tu HTML:

```html
<ul>
  <li class="tarea-pendiente">Comprar leche</li>
  <li>Estudiar JavaScript</li>
  <li class="tarea-pendiente">Pasear al perro</li>
</ul>
```

Para encontrar solo las tareas pendientes:

```javascript
// Dame una lista de TODOS los <li> que tengan la clase "tarea-pendiente"
let tareasPendientes = document.querySelectorAll("li.tarea-pendiente");

// tareasPendientes es una lista. Para trabajar con cada elemento, la recorremos.
for (let tarea of tareasPendientes) {
  // A cada tarea pendiente, le ponemos un fondo rojo para que destaque.
  tarea.style.backgroundColor = "red";
}
// Esto pintar√° "Comprar leche" y "Pasear al perro" de rojo.
```

**Explicaci√≥n del ejemplo:**
`querySelectorAll('li.tarea-pendiente')` es como dar una orden muy espec√≠fica: "Recluta a todos los soldados `<li>` que adem√°s pertenezcan al batall√≥n `.tarea-pendiente`". El resultado es un escuadr√≥n (una lista) con todos los que cumplen la orden.

#### 3. **Desarrollo**:

- **Poder y flexibilidad:** Su gran ventaja es que puedes usar cualquier selector CSS que se te ocurra: `div > p`, `input[type="checkbox"]`, `a:hover`, etc. ¬°Es incre√≠blemente potente!
- **Devuelve una lista (NodeList):** ¬°Ojo! No te devuelve un solo elemento. Te da una lista, aunque solo encuentre uno (o ninguno). Si quieres manipular los elementos, tienes que acceder a ellos por su posici√≥n (`lista[0]`, `lista[1]`, etc.) o recorrer la lista con un bucle, como en el ejemplo.
- **Es una "foto" (colecci√≥n est√°tica):** La lista que te devuelve `querySelectorAll` no se actualiza si despu√©s a√±ades m√°s elementos a la p√°gina que coincidan con el selector. Es una foto del estado del DOM en el momento exacto en que la llamaste. Hablaremos m√°s de esto en el concepto **G**.

üî¥ **Fundamental**: Es la herramienta m√°s vers√°til y poderosa para seleccionar m√∫ltiples elementos. La usar√°s constantemente. Es el est√°ndar moderno para b√∫squedas complejas.

---

## C - `querySelector`: El Detective que Encuentra al Primer Sospechoso üî¥

#### 1. **Introducci√≥n:**

Es el hermano r√°pido de `querySelectorAll`. Usa el mismo poder de los selectores CSS, pero se detiene en cuanto encuentra el **_primer_** elemento que coincide y solo te devuelve ese.

#### 2. **Ejemplo:**

Usando la misma lista de tareas de antes:

````html
<ul>
  <li class="tarea-pendiente">Comprar leche</li>
  <li>Estudiar JavaScript</li>
  <li class="tarea-pendiente">Pasear al perro</li>
</ul>
``` ```javascript // Dame SOLO EL PRIMER
<li>
  que tenga la clase "tarea-pendiente" let primeraTarea =
  document.querySelector('li.tarea-pendiente'); // primeraTarea NO es una lista,
  es el elemento directamente. // Le ponemos un borde para destacarlo.
  primeraTarea.style.border = '2px solid green'; // Esto solo afectar√° a
  "Comprar leche".
</li>
````

**Explicaci√≥n del ejemplo:**
`querySelector` empieza a buscar y, en cuanto encuentra "Comprar leche", dice "¬°Listo, lo tengo!" y te lo entrega, ignorando por completo a "Pasear al perro".

#### 3. **Desarrollo**:

- **Eficiencia:** Es m√°s r√°pido que `querySelectorAll` si solo necesitas un elemento, porque su trabajo termina mucho antes. Es como pedirle a alguien que te traiga "un l√°piz" en lugar de "todos los l√°pices".
- **¬øY si no encuentra nada?** Si ning√∫n elemento coincide con tu b√∫squeda, `querySelector` te devolver√° `null`. ¬°Esto es muy importante! Si intentas hacer algo con `null` (como `null.style.color = 'red'`), tu programa se romper√°. Una buena pr√°ctica es comprobar siempre si el resultado no es `null`:
  ```javascript
  let elemento = document.querySelector(".clase-que-no-existe");
  if (elemento) {
    // Esto previene el error si elemento es null
    elemento.style.display = "none";
  }
  ```

üî¥ **Fundamental**: Es el m√©todo moderno y preferido para seleccionar un √∫nico elemento cuando no tienes un `id` o cuando necesitas un selector m√°s espec√≠fico. Lo usar√°s tanto como a su hermano `querySelectorAll`.

---

## D - `matches`: El Verificador de Identidad üü°

#### 1. **Introducci√≥n:**

Este m√©todo no busca nada por la p√°gina. En su lugar, le preguntas a un elemento que **ya tienes**: "Oye, ¬øt√∫ cumples con este criterio (selector CSS)?". Te responder√° con `true` (s√≠) o `false` (no).

#### 2. **Ejemplo:**

Imagina que tienes varios enlaces, pero solo quieres hacer algo con el que descarga un archivo `.zip`.

```html
<a href="http://example.com/pagina.html">P√°gina normal</a>
<a href="http://example.com/archivo.zip">Descargar archivo</a>
```

```javascript
// Recorremos todos los enlaces de la p√°gina
for (let enlace of document.querySelectorAll("a")) {
  // A cada enlace le preguntamos: ¬øTu atributo 'href' termina en "zip"?
  if (enlace.matches('a[href$="zip"]')) {
    alert("¬°Encontr√© el enlace de descarga!: " + enlace.href);
  }
}
```

**Explicaci√≥n del ejemplo:**
No estamos buscando desde cero. Ya tenemos cada `enlace` en la mano gracias al bucle. Simplemente usamos `matches()` para "interrogar" a cada uno y ver si cumple el perfil del "sospechoso" que buscamos (un enlace cuyo `href` termine en `zip`).

#### 3. **Desarrollo**:

Es extremadamente √∫til cuando est√°s recorriendo una lista de elementos (o cuando recibes un elemento de un evento, como un clic) y necesitas filtrar o actuar solo sobre los que cumplen una condici√≥n espec√≠fica, sin tener que hacer una nueva b√∫squeda en toda la p√°gina.

üü° **Importante**: No lo usar√°s a diario para encontrar elementos, pero es una herramienta clave para escribir c√≥digo limpio y eficiente, especialmente en la gesti√≥n de eventos. Conocerlo te distingue de un principiante.

---

## E - `closest`: Buscando a tus Ancestros üü°

#### 1. **Introducci√≥n:**

Partiendo de un elemento, `closest` busca hacia **_arriba_** en el √°rbol del DOM (su padre, el padre del padre, el abuelo, etc.) y te devuelve el primer ancestro que coincida con un selector CSS.

#### 2. **Ejemplo:**

Imagina esta estructura de "cajas" anidadas:

```html
<div class="caja-abuelo">
  <div class="caja-padre">
    <span class="elemento-hijo">¬°Haz clic aqu√≠!</span>
  </div>
</div>
```

```javascript
let elHijo = document.querySelector(".elemento-hijo");

// Desde el "hijo", busca hacia arriba el ancestro m√°s cercano con la clase "caja-padre"
let elPadre = elHijo.closest(".caja-padre");
console.log(elPadre.className); // Muestra "caja-padre"

// Desde el "hijo", busca hacia arriba el ancestro m√°s cercano que sea un <div>
let elAbuelo = elHijo.closest("div.caja-abuelo");
console.log(elAbuelo.className); // Muestra "caja-abuelo"
```

**Explicaci√≥n del ejemplo:**
Empezamos en el `<span>`. Cuando llamamos a `elHijo.closest('.caja-padre')`, el m√©todo primero se mira a s√≠ mismo (¬øsoy `.caja-padre`? No). Luego mira a su padre directo (¬øeres `.caja-padre`? ¬°S√≠!). Lo encuentra y nos lo devuelve.

#### 3. **Desarrollo**:

- **Se incluye a s√≠ mismo:** La b√∫squeda de `closest` empieza por el propio elemento. Si √©l mismo cumple el selector, se devolver√° a s√≠ mismo.
- **El opuesto de `querySelector`:** Pi√©nsalo as√≠: `querySelector` busca hacia _abajo_ (hijos, nietos), mientras que `closest` busca hacia _arriba_ (padres, abuelos).
- **¬øY si no encuentra nada?** Al igual que `querySelector`, si sube hasta la ra√≠z del documento (`<html>`) y no encuentra ning√∫n ancestro que coincida, devuelve `null`.

üü° **Importante**: Esta herramienta es oro puro para la "delegaci√≥n de eventos". Es una t√©cnica avanzada donde escuchas clics en un contenedor grande y luego usas `closest` para saber sobre qu√© elemento interesante dentro de ese contenedor se hizo clic.

---

## F - `getElementsBy*`: Los Veteranos del DOM üîµ

#### 1. **Introducci√≥n:**

Estos son los m√©todos "cl√°sicos" para buscar elementos, mucho antes de que existiera `querySelector`. Buscan por nombre de etiqueta (`getElementsByTagName`), por clase CSS (`getElementsByClassName`) o por el atributo `name` (`getElementsByName`).

#### 2. **Ejemplo:**

```html
<p class="info">Primer p√°rrafo.</p>
<div class="info">Una caja de informaci√≥n.</div>
<p>Segundo p√°rrafo.</p>
```

```javascript
// Dame todos los elementos con la etiqueta <p>
let todosLosParrafos = document.getElementsByTagName("p");
console.log(todosLosParrafos.length); // 2

// Dame todos los elementos con la clase "info"
let todaLaInfo = document.getElementsByClassName("info");
console.log(todaLaInfo.length); // 2
```

**Explicaci√≥n del ejemplo:**
`getElementsByTagName('p')` barre el documento y te da una colecci√≥n con todos los p√°rrafos. `getElementsByClassName('info')` hace lo mismo, pero buscando elementos que tengan la clase `info`.

#### 3. **Desarrollo**:

- **¬°CUIDADO CON LA "S"!** Un error de novato muy, muy com√∫n es olvidar la "s". Se escribe `getElement**s**By...` porque devuelven una colecci√≥n (una lista) de elementos, no uno solo. La √∫nica excepci√≥n es `getElementById`. ¬°Gr√°batelo a fuego!
- **La gran diferencia (¬°y peligro!):** Estos m√©todos devuelven colecciones **_vivas_**. Esto es crucial y lo explico en detalle en el siguiente punto.
- **¬øSon √∫tiles hoy?** `querySelectorAll` es generalmente mejor porque es m√°s flexible (puedes combinar `p.info` en una sola b√∫squeda). Sin embargo, es vital que conozcas estos m√©todos porque los encontrar√°s en c√≥digo antiguo y su comportamiento "vivo" es una caracter√≠stica √∫nica que a veces puede ser √∫til (o una fuente de bugs terribles si no la entiendes).

üîµ **Espec√≠fico**: Son los precursores de `querySelectorAll`. Es bueno conocerlos para entender c√≥digo antiguo y por su caracter√≠stica de colecci√≥n "viva". Para proyectos nuevos, casi siempre preferir√°s `querySelectorAll`.

---

## G - Colecciones Vivas vs. Est√°ticas: La Foto vs. el Video en Directo üî¥

#### 1. **Introducci√≥n:**

¬°PRESTA M√ÅXIMA ATENCI√ìN! Este es uno de los conceptos m√°s importantes y que m√°s confunde a los principiantes. No todas las b√∫squedas te devuelven el mismo _tipo_ de lista. Unas te dan una "foto" est√°tica del momento y otras una "transmisi√≥n en vivo" que se actualiza sola.

#### 2. **Ejemplo Comparativo:**

Observa este c√≥digo con atenci√≥n. Haremos la misma b√∫squeda con dos m√©todos diferentes y luego cambiaremos la p√°gina para ver qu√© pasa.

```html
<div class="caja">Caja 1</div>
<div class="caja">Caja 2</div>

<script>
  // 1. La colecci√≥n EST√ÅTICA (la foto) con querySelectorAll
  const cajasEstaticas = document.querySelectorAll(".caja");
  console.log("Est√°ticas al inicio:", cajasEstaticas.length); // Muestra 2

  // 2. La colecci√≥n VIVA (el video en directo) con getElementsByClassName
  const cajasVivas = document.getElementsByClassName("caja");
  console.log("Vivas al inicio:", cajasVivas.length); // Muestra 2

  // --- Ahora, el momento de la verdad: a√±adimos una nueva caja ---
  const nuevaCaja = document.createElement("div");
  nuevaCaja.className = "caja";
  nuevaCaja.textContent = "Caja 3 ¬°NUEVA!";
  document.body.appendChild(nuevaCaja);
  console.log("--- ¬°Se ha a√±adido una nueva caja al DOM! ---");

  // 3. Volvemos a revisar las colecciones SIN volver a buscarlas
  console.log("Est√°ticas despu√©s de a√±adir:", cajasEstaticas.length); // ¬°Sigue mostrando 2!
  console.log("Vivas despu√©s de a√±adir:", cajasVivas.length); // ¬°Ahora muestra 3!
</script>
```

**Explicaci√≥n del ejemplo:**

- **Colecci√≥n Est√°tica (`querySelectorAll`):** Es como si hubieras tomado una **foto** de las cajas que hab√≠a en ese instante. La foto muestra 2 cajas. Aunque despu√©s hayas a√±adido una tercera caja a la habitaci√≥n, tu foto original no va a cambiar. Sigue mostrando 2.
- **Colecci√≥n Viva (`getElementsByClassName`):** Es como si estuvieras viendo la habitaci√≥n a trav√©s de una **c√°mara de seguridad en directo**. Al principio ve√≠as 2 cajas. En el momento en que la tercera caja entr√≥ en la habitaci√≥n, tu monitor se actualiz√≥ al instante y ahora ves 3. La lista se mantiene sincronizada con la realidad del DOM.

#### 3. **Desarrollo**:

- **¬øQui√©n devuelve qu√©?**
  - **Est√°ticas (la foto):** `querySelectorAll`.
  - **Vivas (el video):** `getElementsByTagName`, `getElementsByClassName`, `getElementsByName`.
- **¬øPor qu√© es esto una trampa?** Imagina que est√°s recorriendo una colecci√≥n _viva_ con un bucle para, por ejemplo, borrar elementos. Si borras un elemento, la colecci√≥n se achica ¬°mientras la est√°s recorriendo! Esto puede hacer que te saltes elementos o que tu bucle se rompa. Peor a√∫n, si dentro del bucle _a√±ades_ un elemento que coincide con la b√∫squeda, ¬°puedes crear un bucle infinito!
- **¬øCu√°l deber√≠a usar?** Para el 95% de los casos, la colecci√≥n **est√°tica** de `querySelectorAll` es m√°s segura, predecible y f√°cil de manejar. Usa las colecciones vivas solo cuando sepas muy bien lo que haces y necesites expl√≠citamente que tu lista de elementos se mantenga sincronizada con el DOM en tiempo real sin tener que volver a buscar.

üî¥ **Fundamental**: Entender esta diferencia no es opcional, es CR√çTICO. Te ahorrar√° horas de frustraci√≥n y depuraci√≥n. Es la diferencia entre controlar el DOM y que el DOM te controle a ti.

---

## H - `getElementsByName`: El Especialista en Formularios ‚ö™

#### 1. **Introducci√≥n:**

Busca elementos que tengan un atributo `name` espec√≠fico. Su uso est√° casi exclusivamente limitado a elementos de formulario, como los botones de radio o los checkboxes.

#### 2. **Ejemplo:**

```html
<label><input type="radio" name="edad" value="joven" /> Menos de 18</label>
<label><input type="radio" name="edad" value="adulto" /> 18 a 50</label>
<label><input type="radio" name="edad" value="senior" /> M√°s de 50</label>
```

```javascript
// Dame todos los elementos cuyo atributo name sea "edad"
let grupoEdad = document.getElementsByName("edad");
// Esto nos da una colecci√≥n viva con los 3 inputs.
console.log("Hay " + grupoEdad.length + " opciones de edad."); // Muestra 3
```

**Explicaci√≥n del ejemplo:**
Todos los botones de radio de una misma pregunta deben compartir el mismo `name` para que solo se pueda seleccionar uno. `getElementsByName` es la forma cl√°sica de obtenerlos todos juntos.

#### 3. **Desarrollo**:

Devuelve una colecci√≥n _viva_. Hoy en d√≠a, es mucho m√°s com√∫n y flexible usar `querySelectorAll('[name="edad"]')`, que hace lo mismo pero te permite ser m√°s espec√≠fico si lo necesitas (por ejemplo, `input[type="radio"][name="edad"]`).

‚ö™ **Raramente usado**: Su uso es tan espec√≠fico y existen alternativas modernas tan potentes que es muy poco probable que lo necesites en un proyecto nuevo. Es bueno saber que existe por si te topas con √©l.

---

## I - `contains`: ¬øEst√° este elemento dentro de ti? üîµ

#### 1. **Introducci√≥n:**

No es un m√©todo de b√∫squeda, sino de verificaci√≥n. Le preguntas a un elemento (A) si otro elemento (B) es un descendiente suyo (es decir, si B est√° anidado dentro de A, sin importar a qu√© profundidad).

#### 2. **Ejemplo:**

```html
<div id="contenedor">
  <p>Un texto con un <strong id="resaltado">√©nfasis</strong>.</p>
</div>
<span id="externo">Algo fuera.</span>
```

```javascript
const contenedor = document.getElementById("contenedor");
const resaltado = document.getElementById("resaltado");
const externo = document.getElementById("externo");

// ¬øEl contenedor contiene al elemento resaltado?
console.log(contenedor.contains(resaltado)); // true (porque <strong> est√° dentro de <div>)

// ¬øEl contenedor contiene al elemento externo?
console.log(contenedor.contains(externo)); // false (porque <span> est√° fuera)

// ¬øUn elemento se contiene a s√≠ mismo?
console.log(contenedor.contains(contenedor)); // true
```

**Explicaci√≥n del ejemplo:**
`contains` es como preguntar: "¬øEste elemento forma parte de tu familia de descendientes?". Es una forma muy r√°pida y eficiente de comprobar la jerarqu√≠a del DOM.

#### 3. **Desarrollo**:

Es una herramienta muy √∫til para la l√≥gica de tu aplicaci√≥n. Por ejemplo, si un usuario hace clic en alg√∫n lugar, puedes usar `miSeccion.contains(elementoClicado)` para saber si el clic ocurri√≥ dentro de `miSeccion` o fuera de ella, y actuar en consecuencia.

üîµ **Espec√≠fico**: No lo usar√°s para encontrar elementos, sino para entender la relaci√≥n entre los elementos que ya tienes. Muy √∫til en escenarios concretos, especialmente en la gesti√≥n de eventos complejos.
