## A - Bridge Pattern: Divide y vencerás en el diseño de clases

#### 1. **Definicion:**

El patrón **Bridge** es como un puente que divide una clase grande o un grupo de clases relacionadas en dos partes más pequeñas y manejables: la **Abstracción** y la **Implementación**. Piensa en ellas como dos jerarquías separadas que pueden evolucionar por su cuenta, ¡sin pisarse los pies!

![Bridge design pattern](https://refactoring.guru/images/patterns/content/bridge/bridge.png)

#### 2. **Ejemplo:**

Imagina que tienes que crear diferentes formas geométricas (`Shape`) como `Circulo` y `Cuadrado`, y también quieres darles color, como `Rojo` y `Azul`.

**Sin Bridge (Problema):**

Si lo haces de la manera tradicional, con herencia directa, terminarías con un montón de combinaciones de clases, ¡una explosión! `CirculoRojo`, `CirculoAzul`, `CuadradoRojo`, `CuadradoAzul`, y así sucesivamente. Si añades más formas o colores, ¡la cosa se complica aún más!

![Bridge pattern problem](https://refactoring.guru/images/patterns/diagrams/bridge/problem-en.png)

**Con Bridge (Solución):**

El patrón Bridge te dice: "¡Separa las cosas!". Crea una jerarquía para las **Formas** (`Shape`) y otra para los **Colores** (`Color`). La clase `Shape` tendrá una "conexión" (una referencia) a un objeto `Color`. Así, un `Circulo` _tiene un_ `Color`, en lugar de _ser un_ `CirculoRojo`.

![Solution suggested by the Bridge pattern](https://refactoring.guru/images/patterns/diagrams/bridge/solution-en.png)

**Código en Java (Simplificado):**

```java
// Jerarquía de Implementación (Color)
interface Color {
    String getColor();
}

class Rojo implements Color {
    @Override
    public String getColor() {
        return "Rojo";
    }
}

class Azul implements Color {
    @Override
    public String getColor() {
        return "Azul";
    }
}

// Jerarquía de Abstracción (Forma)
abstract class Shape {
    protected Color color; // El "puente"

    public Shape(Color color) {
        this.color = color;
    }

    abstract String dibujar();
}

class Circulo extends Shape {
    public Circulo(Color color) {
        super(color);
    }

    @Override
    String dibujar() {
        return "Dibujando un círculo " + color.getColor();
    }
}

class Cuadrado extends Shape {
    public Cuadrado(Color color) {
        super(color);
    }

    @Override
    String dibujar() {
        return "Dibujando un cuadrado " + color.getColor();
    }
}

public class Main {
    public static void main(String[] args) {
        Color rojo = new Rojo();
        Color azul = new Azul();

        Shape circuloRojo = new Circulo(rojo);
        Shape cuadradoAzul = new Cuadrado(azul);

        System.out.println(circuloRojo.dibujar()); // Output: Dibujando un círculo Rojo
        System.out.println(cuadradoAzul.dibujar()); // Output: Dibujando un cuadrado Azul
    }
}
```

**Explicación del ejemplo:**

- Tenemos dos jerarquías separadas: `Color` (Implementación) y `Shape` (Abstracción).
- `Shape` tiene una variable `color` que actúa como el puente hacia la jerarquía `Color`.
- Ahora, para crear un `CirculoRojo`, combinamos un objeto `Circulo` con un objeto `Rojo`.
- Si queremos añadir un nuevo color, como `Verde`, solo necesitamos crear una nueva clase `Verde` que implemente `Color`, ¡sin tocar las clases de `Shape`!

#### 3. **Notas o advertencias:**

- **Abstracción vs. Implementación:** Piensa en la Abstracción como la parte de "alto nivel" (qué hace algo) y la Implementación como la parte de "bajo nivel" (cómo se hace). En nuestro ejemplo, `Shape` es la Abstracción (qué forma es) y `Color` es la Implementación (qué color tiene).
- **No es herencia, es composición:** Bridge usa la **composición** (una clase contiene un objeto de otra clase) en lugar de la **herencia** (una clase _es un tipo de_ otra clase) para conectar la Abstracción y la Implementación. Esto da mucha más flexibilidad.

---

## B - Abstracción e Implementación: Los dos lados del puente

#### 1. **Definicion:**

En el patrón Bridge, los términos **Abstracción** e **Implementación** son clave. No te asustes por los nombres, ¡son más sencillos de lo que parecen!

- **Abstracción (Interfaz):** Es la parte de "control" de alto nivel. Piensa en ella como la interfaz de usuario de una aplicación. No hace el trabajo pesado directamente, sino que le dice a la **Implementación** qué hacer.
- **Implementación (Plataforma):** Es la parte que realmente hace el trabajo "sucio". Piensa en ella como el sistema operativo o la base de datos que usa una aplicación. La Abstracción le delega las tareas.

**Importante:** No confundas "Abstracción" e "Implementación" del patrón Bridge con las interfaces (`interface`) o clases abstractas (`abstract class`) de Java. Son conceptos diferentes, aunque relacionados.

#### 2. **Ejemplo:**

Imagina una aplicación que funciona en diferentes sistemas operativos (Windows, macOS, Linux).

- **Abstracción:** Sería la interfaz gráfica de usuario (GUI) de la aplicación. Da igual si estás en Windows o Linux, la GUI se ve y se usa de manera similar.
- **Implementación:** Serían las APIs (Application Programming Interfaces) específicas de cada sistema operativo. Cuando la GUI necesita abrir un archivo, le pide a la Implementación (API del sistema operativo) que lo haga de la manera correcta para Windows, macOS o Linux.

![Cross-platform architecture](https://refactoring.guru/images/patterns/content/bridge/bridge-2-en.png)

**Código en Java (Conceptual):**

```java
// Interfaz de Implementación (API del Sistema Operativo)
interface SistemaOperativoAPI {
    void abrirArchivo(String nombreArchivo);
    void cerrarArchivo(String nombreArchivo);
}

class WindowsAPI implements SistemaOperativoAPI {
    @Override
    public void abrirArchivo(String nombreArchivo) {
        System.out.println("Windows API: Abriendo archivo " + nombreArchivo);
    }
    @Override
    public void cerrarArchivo(String nombreArchivo) {
        System.out.println("Windows API: Cerrando archivo " + nombreArchivo);
    }
}

class LinuxAPI implements SistemaOperativoAPI {
    @Override
    public void abrirArchivo(String nombreArchivo) {
        System.out.println("Linux API: Abriendo archivo " + nombreArchivo);
    }
    @Override
    public void cerrarArchivo(String nombreArchivo) {
        System.out.println("Linux API: Cerrando archivo " + nombreArchivo);
    }
}

// Abstracción (Interfaz de Usuario)
abstract class InterfazUsuario {
    protected SistemaOperativoAPI api; // El puente

    public InterfazUsuario(SistemaOperativoAPI api) {
        this.api = api;
    }

    abstract void gestionarArchivo(String nombreArchivo);
}

class InterfazUsuarioBasica extends InterfazUsuario {
    public InterfazUsuarioBasica(SistemaOperativoAPI api) {
        super(api);
    }

    @Override
    void gestionarArchivo(String nombreArchivo) {
        System.out.println("Interfaz Básica: Gestionando archivo " + nombreArchivo);
        api.abrirArchivo(nombreArchivo);
        api.cerrarArchivo(nombreArchivo);
    }
}

public class Main {
    public static void main(String[] args) {
        SistemaOperativoAPI windowsAPI = new WindowsAPI();
        SistemaOperativoAPI linuxAPI = new LinuxAPI();

        InterfazUsuarioBasica interfazWindows = new InterfazUsuarioBasica(windowsAPI);
        InterfazUsuarioBasica interfazLinux = new InterfazUsuarioBasica(linuxAPI);

        interfazWindows.gestionarArchivo("documento.txt");
        // Output:
        // Interfaz Básica: Gestionando archivo documento.txt
        // Windows API: Abriendo archivo documento.txt
        // Windows API: Cerrando archivo documento.txt

        interfazLinux.gestionarArchivo("documento.txt");
        // Output:
        // Interfaz Básica: Gestionando archivo documento.txt
        // Linux API: Abriendo archivo documento.txt
        // Linux API: Cerrando archivo documento.txt
    }
}
```

**Explicación del ejemplo:**

- `SistemaOperativoAPI` es la **Implementación**, con diferentes versiones para Windows y Linux.
- `InterfazUsuario` es la **Abstracción**, que usa la `SistemaOperativoAPI` para hacer el trabajo real.
- La `InterfazUsuario` no se preocupa _cómo_ se abre un archivo en Windows o Linux, solo le pide a la `SistemaOperativoAPI` que lo haga.

#### 3. **Notas o advertencias:**

- **Independencia:** La clave del Bridge es que puedes cambiar la Abstracción o la Implementación por separado, sin afectar a la otra. Puedes crear nuevas interfaces de usuario sin cambiar las APIs del sistema operativo, y viceversa.
- **Modularidad:** Bridge ayuda a organizar código complejo en módulos más pequeños y fáciles de entender y mantener.

---

## C - Estructura del Patrón Bridge: Las piezas del puente

#### 1. **Definicion:**

El patrón Bridge tiene una estructura bien definida con varios componentes que trabajan juntos para separar la Abstracción de la Implementación.

![Bridge design pattern](https://refactoring.guru/images/patterns/diagrams/bridge/structure-en.png)![Bridge design pattern](https://refactoring.guru/images/patterns/diagrams/bridge/structure-en-indexed.png)

1.  **Abstracción:** Define la lógica de control de alto nivel. Se apoya en la Implementación para hacer el trabajo de bajo nivel.
2.  **Implementación (Interfaz):** Declara la interfaz común para todas las implementaciones concretas. La Abstracción se comunica con la Implementación solo a través de esta interfaz.
3.  **Implementaciones Concretas:** Contienen el código específico para cada plataforma o variante de implementación.
4.  **Abstracciones Refinadas:** Son extensiones de la Abstracción base que ofrecen variaciones en la lógica de control. Siguen usando la interfaz de Implementación general.
5.  **Cliente:** Es quien usa la Abstracción. Es responsable de conectar la Abstracción con una Implementación concreta.

#### 2. **Ejemplo (Diagrama simplificado):**

Imagina un control remoto universal que puede controlar diferentes tipos de dispositivos (TV, Radio, etc.).

- **Abstracción:** `ControlRemoto` (clase base) y `ControlRemotoAvanzado` (Abstracción Refinada). Definen las acciones del control remoto (encender, apagar, subir volumen, etc.).
- **Implementación (Interfaz):** `Dispositivo` (interfaz). Define las operaciones básicas que todos los dispositivos deben tener (encender, apagar, setear volumen, etc.).
- **Implementaciones Concretas:** `TV` y `Radio` (clases). Implementan la interfaz `Dispositivo` de manera específica para cada tipo de dispositivo.
- **Cliente:** El código que crea un `ControlRemoto` y lo conecta a una `TV` o `Radio`.

#### 3. **Notas o advertencias:**

- **Flexibilidad:** La estructura del Bridge permite cambiar la Implementación sin afectar la Abstracción, y viceversa. Puedes añadir nuevos tipos de `ControlRemoto` o nuevos tipos de `Dispositivo` sin problemas.
- **Cliente es clave:** El Cliente es quien decide qué Implementación usar con qué Abstracción. Esto permite configurar el sistema de manera muy flexible.

---

## D - Pseudocódigo y Ejemplo Práctico: Control Remoto y Dispositivos

#### 1. **Definicion:**

Veamos un ejemplo más concreto en pseudocódigo (y luego lo adaptamos a Java) para entender cómo funciona el Bridge en la práctica. El ejemplo del control remoto y los dispositivos es muy útil para visualizar el patrón.

![Structure of the Bridge pattern example](https://refactoring.guru/images/patterns/diagrams/bridge/example-en.png)

#### 2. **Ejemplo (Pseudocódigo adaptado a Java):**

```java
// Interfaz de Implementación (Dispositivo)
interface Dispositivo {
    boolean estaHabilitado();
    void habilitar();
    void deshabilitar();
    int getVolumen();
    void setVolumen(int porcentaje);
    int getCanal();
    void setCanal(int canal);
}

// Implementaciones Concretas (Dispositivos)
class TV implements Dispositivo {
    private boolean habilitado = false;
    private int volumen = 30;
    private int canal = 1;

    @Override
    public boolean estaHabilitado() {
        return habilitado;
    }

    @Override
    public void habilitar() {
        habilitado = true;
        System.out.println("TV: Encendido");
    }

    @Override
    public void deshabilitar() {
        habilitado = false;
        System.out.println("TV: Apagado");
    }

    @Override
    public int getVolumen() {
        return volumen;
    }

    @Override
    public void setVolumen(int porcentaje) {
        this.volumen = porcentaje;
        if (volumen < 0) volumen = 0;
        if (volumen > 100) volumen = 100;
        System.out.println("TV: Volumen seteado a " + volumen + "%");
    }

    @Override
    public int getCanal() {
        return canal;
    }

    @Override
    public void setCanal(int canal) {
        this.canal = canal;
        System.out.println("TV: Canal seteado a " + canal);
    }
}

class Radio implements Dispositivo {
    private boolean habilitado = false;
    private int volumen = 20;
    private int canal = 530; // AM Radio Frequencies

    @Override
    public boolean estaHabilitado() {
        return habilitado;
    }

    @Override
    public void habilitar() {
        habilitado = true;
        System.out.println("Radio: Encendido");
    }

    @Override
    public void deshabilitar() {
        habilitado = false;
        System.out.println("Radio: Apagado");
    }

    @Override
    public int getVolumen() {
        return volumen;
    }

    @Override
    public void setVolumen(int porcentaje) {
        this.volumen = porcentaje;
        if (volumen < 0) volumen = 0;
        if (volumen > 100) volumen = 100;
        System.out.println("Radio: Volumen seteado a " + volumen + "%");
    }

    @Override
    public int getCanal() {
        return canal;
    }

    @Override
    public void setCanal(int canal) {
        this.canal = canal;
        System.out.println("Radio: Frecuencia AM seteada a " + canal + " kHz");
    }
}


// Abstracción (Control Remoto)
class ControlRemoto {
    protected Dispositivo dispositivo; // El puente

    public ControlRemoto(Dispositivo dispositivo) {
        this.dispositivo = dispositivo;
    }

    public void togglePower() {
        if (dispositivo.estaHabilitado()) {
            dispositivo.deshabilitar();
        } else {
            dispositivo.habilitar();
        }
    }

    public void volumenAbajo() {
        dispositivo.setVolumen(dispositivo.getVolumen() - 10);
    }

    public void volumenArriba() {
        dispositivo.setVolumen(dispositivo.getVolumen() + 10);
    }

    public void canalAbajo() {
        dispositivo.setCanal(dispositivo.getCanal() - 1);
    }

    public void canalArriba() {
        dispositivo.setCanal(dispositivo.getCanal() + 1);
    }
}

// Abstracción Refinada (Control Remoto Avanzado)
class ControlRemotoAvanzado extends ControlRemoto {
    public ControlRemotoAvanzado(Dispositivo dispositivo) {
        super(dispositivo);
    }

    public void mute() {
        dispositivo.setVolumen(0);
        System.out.println("Control Remoto Avanzado: Mute activado");
    }
}

public class Main {
    public static void main(String[] args) {
        TV tv = new TV();
        ControlRemoto remotoTV = new ControlRemoto(tv);
        remotoTV.togglePower(); // Output: TV: Encendido
        remotoTV.volumenArriba(); // Output: TV: Volumen seteado a 40%

        Radio radio = new Radio();
        ControlRemotoAvanzado remotoRadio = new ControlRemotoAvanzado(radio);
        remotoRadio.volumenAbajo(); // Output: Radio: Volumen seteado a 10%
        remotoRadio.mute(); // Output: Control Remoto Avanzado: Mute activado
        // Output: Radio: Volumen seteado a 0%
    }
}
```

**Explicación del ejemplo:**

- `Dispositivo` es la **Implementación**, con `TV` y `Radio` como Implementaciones Concretas.
- `ControlRemoto` y `ControlRemotoAvanzado` son las **Abstracciones**. Usan la interfaz `Dispositivo` para controlar cualquier dispositivo.
- El `ControlRemoto` no sabe si está controlando una `TV` o una `Radio`, solo interactúa con ellos a través de la interfaz `Dispositivo`.

#### 3. **Notas o advertencias:**

- **Independencia total:** Puedes crear nuevos tipos de controles remotos (Abstracciones) o nuevos tipos de dispositivos (Implementaciones) sin modificar el código existente.
- **Reutilización:** El mismo `ControlRemoto` puede usarse para controlar diferentes `Dispositivos`, ¡reutilización en acción!

---

## E - Aplicabilidad del Patrón Bridge: ¿Cuándo usar este puente?

#### 1. **Definicion:**

El patrón Bridge es útil en ciertas situaciones específicas. No lo uses a ciegas en todos tus proyectos, ¡pero es una herramienta poderosa cuando la necesitas!

#### 2. **Cuándo usar Bridge:**

- **Clases monolíticas con muchas variantes:** Si tienes una clase que se ha vuelto gigante y difícil de manejar porque tiene muchas formas de hacer lo mismo (por ejemplo, diferentes bases de datos, diferentes sistemas operativos), Bridge puede ayudarte a dividirla.
- **Extensión en múltiples dimensiones ortogonales:** Cuando necesitas extender una clase en dos o más direcciones independientes. Como en el ejemplo de las formas y los colores, o la interfaz de usuario y el sistema operativo. "Ortogonal" significa que las dimensiones son independientes entre sí.
- **Cambio de Implementación en tiempo de ejecución:** Si necesitas poder cambiar la Implementación de una Abstracción mientras el programa está funcionando, Bridge te lo permite fácilmente. Puedes "enchufar" diferentes Implementaciones a la misma Abstracción.

#### 3. **Ejemplo de Aplicabilidad:**

- **Aplicación multiplataforma:** Como vimos antes, Bridge es ideal para aplicaciones que deben funcionar en diferentes sistemas operativos.
- **Librería de gráficos:** Una librería que soporta diferentes formatos de imagen (JPEG, PNG, GIF) y diferentes APIs de renderizado (OpenGL, DirectX). Los formatos de imagen serían la Abstracción y las APIs de renderizado la Implementación.
- **Conexión a bases de datos:** Una aplicación que puede conectarse a diferentes tipos de bases de datos (MySQL, PostgreSQL, SQL Server). La lógica de la aplicación sería la Abstracción y los drivers de base de datos la Implementación.

#### 4. **Notas o advertencias:**

- **No para clases simples:** Si tu clase es sencilla y no tiene mucha complejidad, Bridge puede ser "demasiado" patrón. Podría complicar el código innecesariamente.
- **Complejidad inicial:** Implementar Bridge puede requerir un poco más de planificación y código al principio, pero a largo plazo, ¡simplifica el mantenimiento y la extensión del sistema!

---

## F - Cómo Implementar el Patrón Bridge: Construyendo el puente paso a paso

#### 1. **Definicion:**

Implementar el patrón Bridge sigue una serie de pasos lógicos. Aquí tienes una guía para construir tu propio puente:

#### 2. **Pasos para implementar Bridge:**

1.  **Identifica las dimensiones ortogonales:** Encuentra las partes de tu clase que varían independientemente. Pregúntate: ¿Qué aspectos de esta clase pueden cambiar sin afectar a otros? (Ejemplos: Abstracción/Plataforma, Dominio/Infraestructura, Interfaz/Implementación).
2.  **Define la Abstracción:** Crea una clase base para la Abstracción. Define las operaciones de "alto nivel" que el cliente necesita.
3.  **Define la Implementación (Interfaz):** Crea una interfaz para la Implementación. Define las operaciones "primitivas" que todas las Implementaciones concretas deben soportar. La Abstracción usará estas operaciones.
4.  **Crea Implementaciones Concretas:** Para cada "plataforma" o variante de Implementación, crea una clase que implemente la interfaz de Implementación. Aquí va el código específico de cada plataforma.
5.  **Conecta Abstracción e Implementación:** En la clase de Abstracción, añade una variable de referencia al tipo de la interfaz de Implementación. La Abstracción delegará la mayor parte del trabajo a este objeto de Implementación.
6.  **Crea Abstracciones Refinadas (opcional):** Si necesitas variaciones en la lógica de la Abstracción, crea clases que hereden de la Abstracción base.
7.  **Cliente configura el puente:** En el código del cliente, crea objetos de Implementación y pásalos al constructor de la Abstracción para "conectar" el puente. A partir de ahí, el cliente solo interactúa con la Abstracción.

#### 3. **Ejemplo (Pasos aplicados al Control Remoto):**

1.  **Dimensiones:** Control Remoto (Abstracción) y Dispositivo (Implementación). Son independientes: puedes tener diferentes controles remotos para los mismos dispositivos, y viceversa.
2.  **Abstracción:** `ControlRemoto` (clase base) con métodos como `togglePower()`, `volumenArriba()`, etc.
3.  **Implementación (Interfaz):** `Dispositivo` (interfaz) con métodos como `estaHabilitado()`, `setVolumen()`, etc.
4.  **Implementaciones Concretas:** `TV`, `Radio` (clases) que implementan `Dispositivo`.
5.  **Conexión:** `ControlRemoto` tiene una variable `dispositivo` de tipo `Dispositivo`.
6.  **Abstracción Refinada:** `ControlRemotoAvanzado` (clase que hereda de `ControlRemoto`).
7.  **Cliente:** En `Main`, creamos `TV tv = new TV();` y `ControlRemoto remotoTV = new ControlRemoto(tv);`.

#### 4. **Notas o advertencias:**

- **Planificación inicial:** Es importante identificar bien las dimensiones ortogonales al principio. Un buen análisis inicial facilita mucho la implementación del Bridge.
- **Interfaz de Implementación clave:** La interfaz de Implementación debe ser lo suficientemente general para que todas las Implementaciones concretas puedan usarla, pero también lo suficientemente específica para que la Abstracción pueda hacer su trabajo.

---

## G - Pros y Contras del Patrón Bridge: ¿Vale la pena construir este puente?

#### 1. **Definicion:**

Como todo patrón de diseño, Bridge tiene sus ventajas y desventajas. Es importante conocerlas para decidir si es la mejor opción para tu problema.

#### 2. **Pros (Ventajas):**

- **Clases y aplicaciones independientes de la plataforma:** Puedes crear código que no depende de detalles específicos de la plataforma (sistema operativo, base de datos, etc.). ¡Portabilidad mejorada!
- **Cliente no expuesto a detalles de la plataforma:** El código que usa la Abstracción no necesita saber nada sobre las Implementaciones concretas. Menos acoplamiento y código más limpio.
- **Principio de Abierto/Cerrado:** Puedes añadir nuevas Abstracciones e Implementaciones sin modificar el código existente. ¡Extensible y mantenible!
- **Principio de Responsabilidad Única:** La Abstracción se centra en la lógica de alto nivel, y la Implementación en los detalles de la plataforma. Código más organizado y fácil de entender.

#### 3. **Contras (Desventajas):**

- **Puede complicar código cohesivo:** Si aplicas Bridge a una clase que ya está bien organizada y es cohesiva (hace una sola cosa bien), podrías añadir complejidad innecesaria. ¡No lo uses en exceso!

#### 4. **Notas o advertencias:**

- **Beneficios a largo plazo:** Aunque al principio pueda parecer más trabajo, Bridge suele dar sus frutos a largo plazo, especialmente en proyectos grandes y complejos que necesitan ser flexibles y mantenibles.
- **Evalúa bien la necesidad:** Antes de usar Bridge, pregúntate si realmente necesitas la separación entre Abstracción e Implementación. Si no estás seguro, ¡empieza sin Bridge y refactoriza después si es necesario!

---

## H - Relaciones con Otros Patrones: Puentes, Adaptadores y Estrategias

#### 1. **Definicion:**

El patrón Bridge se parece a otros patrones en algunos aspectos, pero tiene su propia identidad y propósito. Entender las diferencias te ayudará a elegir el patrón correcto.

#### 2. **Relaciones con otros patrones:**

- **Bridge vs. Adapter:**

  - **Bridge:** Se diseña **desde el principio** para separar Abstracción e Implementación y permitir que evolucionen independientemente.
  - **Adapter:** Se usa **después**, para hacer que clases **incompatibles** trabajen juntas. Adapta una interfaz existente a otra que se necesita.
  - **Similitud:** Ambos usan composición (delegación a otro objeto).

- **Bridge vs. State vs. Strategy:**

  - **Similitud:** Todos (Bridge, State, Strategy, y en menor medida Adapter) tienen estructuras similares basadas en la **composición**. Delegan trabajo a otros objetos.
  - **Diferencia clave:** Resuelven **problemas diferentes**. Un patrón no es solo una estructura de código, sino también la **intención** y el **problema** que resuelve.
    - **Bridge:** Separa Abstracción e Implementación para permitir variaciones independientes.
    - **State:** Permite que un objeto cambie su comportamiento cuando su estado interno cambia.
    - **Strategy:** Define una familia de algoritmos, los encapsula y los hace intercambiables.

- **Bridge + Abstract Factory:**

  - **Combinación útil:** Puedes usar Abstract Factory junto con Bridge.
  - **Cuándo:** Cuando ciertas Abstracciones de Bridge solo funcionan con Implementaciones específicas.
  - **Abstract Factory:** Puede encapsular estas relaciones y ocultar la complejidad al cliente. Crea familias de objetos relacionados.

- **Bridge + Builder:**
  - **Combinación posible:** Puedes combinar Builder con Bridge.
  - **Builder:** Puede actuar como la Implementación.
  - **Abstracción:** El "director" de Builder podría ser la Abstracción en Bridge. Diferentes Builders (Implementaciones) construyen diferentes representaciones.

#### 3. **Notas o advertencias:**

- **Intención es clave:** No te centres solo en la estructura del código. Entiende la **intención** de cada patrón y el **problema** que resuelve. Esto te ayudará a elegir el patrón adecuado.
- **Patrones se complementan:** Los patrones de diseño a menudo se usan juntos para resolver problemas complejos. ¡No tengas miedo de combinar patrones!
