## A - Patrón Builder: Construcción Paso a Paso

#### 1. **Definición:**

El patrón **Builder** es como un constructor de Lego para objetos complejos. En lugar de construir un objeto complicado de una sola vez, te permite hacerlo **paso a paso**. Imagina que tienes un manual de instrucciones (el Builder) que te guía para ensamblar las piezas (partes del objeto) hasta obtener el producto final. Lo genial es que puedes usar el mismo manual para construir diferentes versiones del mismo objeto.

#### 2. **Ejemplo:**

Imagina que estás construyendo una hamburguesa. En lugar de pedir una hamburguesa "completa" y esperar que te la den como sea, con Builder, tú decides cada paso:

```java
public class Hamburguesa {
    private String pan;
    private String carne;
    private String salsa;
    private boolean queso;
    private boolean tomate;

    // Constructor privado para forzar el uso del Builder
    private Hamburguesa(String pan, String carne, String salsa, boolean queso, boolean tomate) {
        this.pan = pan;
        this.carne = carne;
        this.salsa = salsa;
        this.queso = queso;
        this.tomate = tomate;
    }

    // Getters para los ingredientes (solo para mostrar el resultado)
    public String getPan() { return pan; }
    public String getCarne() { return carne; }
    public String getSalsa() { return salsa; }
    public boolean tieneQueso() { return queso; }
    public boolean tieneTomate() { return tomate; }

    @Override
    public String toString() {
        return "Hamburguesa con:\n" +
               "Pan: " + pan + "\n" +
               "Carne: " + carne + "\n" +
               "Salsa: " + salsa + "\n" +
               (queso ? "Con queso\n" : "Sin queso\n") +
               (tomate ? "Con tomate\n" : "Sin tomate\n");
    }

    // Clase Builder ANIDADA dentro de Hamburguesa
    public static class Builder {
        private String pan = "Pan normal"; // Valores por defecto
        private String carne = "Res";
        private String salsa = "Ketchup";
        private boolean queso = true;
        private boolean tomate = false;

        public Builder setPan(String pan) {
            this.pan = pan;
            return this; // Para encadenar llamadas
        }

        public Builder setCarne(String carne) {
            this.carne = carne;
            return this;
        }

        public Builder setSalsa(String salsa) {
            this.salsa = salsa;
            return this;
        }

        public Builder setQueso(boolean queso) {
            this.queso = queso;
            return this;
        }

        public Builder setTomate(boolean tomate) {
            this.tomate = tomate;
            return this;
        }

        public Hamburguesa build() {
            return new Hamburguesa(pan, carne, salsa, queso, tomate);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Hamburguesa hamburguesaVegetariana = new Hamburguesa.Builder()
                .setCarne("Vegetal")
                .setSalsa("Mayonesa vegana")
                .setQueso(false)
                .setTomate(true)
                .build();

        System.out.println(hamburguesaVegetariana);

        Hamburguesa hamburguesaClasica = new Hamburguesa.Builder()
                .build(); // Usa los valores por defecto

        System.out.println(hamburguesaClasica);
    }
}
```

**Resultado del ejemplo:**

```
Hamburguesa con:
Pan: Pan normal
Carne: Vegetal
Salsa: Mayonesa vegana
Sin queso
Con tomate

Hamburguesa con:
Pan: Pan normal
Carne: Res
Salsa: Ketchup
Con queso
Sin tomate
```

**Explicación del ejemplo:**

- Creamos una clase `Hamburguesa` que representa nuestro objeto complejo.
- Dentro de `Hamburguesa`, anidamos una clase `Builder`. Esta clase `Builder` tiene métodos para configurar cada parte de la hamburguesa (`setPan`, `setCarne`, etc.).
- El método `build()` en `Builder` es el que finalmente crea el objeto `Hamburguesa` con todas las partes configuradas.
- En `Main`, usamos el `Builder` para crear diferentes tipos de hamburguesas, ¡solo especificando lo que necesitamos!

#### 3. **Notas o advertencias:**

- El Builder es genial cuando tienes objetos con **muchas partes opcionales** o configuraciones posibles.
- Ayuda a evitar constructores gigantes con mil parámetros, que son difíciles de leer y usar.
- Hace el código más **legible y mantenible**, porque la lógica de construcción está separada del objeto en sí.

---

## B - El Problema que Resuelve Builder: Constructores Telescópicos y Complejidad

#### 1. **Definición:**

Imagina que quieres crear un objeto `Casa`. Una casa puede tener muchas cosas: paredes, puertas, ventanas, techo, jardín, piscina, calefacción... Si intentas crear un constructor para `Casa` que acepte todas estas opciones, ¡tendrías un constructor larguísimo y confuso! Esto se llama **constructor telescópico**, porque tienes que ir añadiendo parámetros como si extendieras un telescopio.

![The telescoping constructor](https://refactoring.guru/images/patterns/diagrams/builder/problem2.png)

#### 2. **Ejemplo:**

Piensa en un constructor de `Casa` que intente cubrir todas las opciones:

```java
public class CasaMala { // Mala práctica, ¡no uses esto!
    private int paredes;
    private int ventanas;
    private boolean tienePuerta;
    private boolean tieneTejado;
    private boolean tienePiscina;
    private boolean tieneJardin;

    public CasaMala(int paredes, int ventanas, boolean tienePuerta, boolean tieneTejado, boolean tienePiscina, boolean tieneJardin) {
        this.paredes = paredes;
        this.ventanas = ventanas;
        this.tienePuerta = tienePuerta;
        this.tieneTejado = tieneTejado;
        this.tienePiscina = tienePiscina;
        this.tieneJardin = tieneJardin;
    }

    // ... (más constructores para diferentes combinaciones) ...
}

public class MainMala {
    public static void main(String[] args) {
        // ¡Uf, qué difícil de leer y entender!
        CasaMala casaConPiscina = new CasaMala(4, 5, true, true, true, false);
        CasaMala casaSimple = new CasaMala(4, 2, true, true, false, false);
    }
}
```

**Explicación del ejemplo:**

- El constructor de `CasaMala` tiene demasiados parámetros.
- Es difícil recordar el orden de los parámetros y qué significa cada uno.
- Si solo quieres una casa simple, tienes que pasar valores `false` o `0` para muchas opciones que no te interesan.
- ¡Esto es un constructor telescópico y es muy poco práctico!

#### 3. **Notas o advertencias:**

- Los constructores telescópicos hacen el código **difícil de leer y mantener**.
- Aumentan la posibilidad de errores al llamar al constructor con los parámetros en el orden incorrecto.
- El Builder es una solución mucho mejor para este tipo de problemas.

---

## C - La Solución Builder: Pasos de Construcción y Flexibilidad

#### 1. **Definición:**

El patrón Builder te propone dividir la construcción de un objeto complejo en **pasos individuales**. En lugar de un constructor gigante, creas un objeto **Builder** que tiene métodos para cada paso de la construcción (por ejemplo, `construirParedes()`, `construirPuerta()`, `construirTejado()`). Tú decides qué pasos quieres ejecutar y en qué orden.

![Applying the Builder pattern](https://refactoring.guru/images/patterns/diagrams/builder/solution1.png)

#### 2. **Ejemplo:**

Ahora, vamos a construir la `Casa` usando el patrón Builder:

```java
public class Casa { // Ahora con Builder
    private int paredes;
    private int ventanas;
    private boolean tienePuerta;
    private boolean tieneTejado;
    private boolean tienePiscina;
    private boolean tieneJardin;

    // Constructor privado, solo se construye con Builder
    private Casa(int paredes, int ventanas, boolean tienePuerta, boolean tieneTejado, boolean tienePiscina, boolean tieneJardin) {
        this.paredes = paredes;
        this.ventanas = ventanas;
        this.tienePuerta = tienePuerta;
        this.tieneTejado = tieneTejado;
        this.tienePiscina = tienePiscina;
        this.tieneJardin = tieneJardin;
    }

    // Getters (para mostrar el resultado)
    public int getParedes() { return paredes; }
    public int getVentanas() { return ventanas; }
    public boolean tienePuerta() { return tienePuerta; }
    public boolean tieneTejado() { return tieneTejado; }
    public boolean tienePiscina() { return tienePiscina; }
    public boolean tieneJardin() { return tieneJardin; }

    @Override
    public String toString() {
        return "Casa con:\n" +
               "Paredes: " + paredes + "\n" +
               "Ventanas: " + ventanas + "\n" +
               (tienePuerta ? "Tiene puerta\n" : "No tiene puerta\n") +
               (tieneTejado ? "Tiene tejado\n" : "No tiene tejado\n") +
               (tienePiscina ? "Tiene piscina\n" : "No tiene piscina\n") +
               (tieneJardin ? "Tiene jardín\n" : "No tiene jardín\n");
    }


    // Clase Builder para Casa
    public static class Builder {
        private int paredes = 4; // Valores por defecto
        private int ventanas = 2;
        private boolean tienePuerta = true;
        private boolean tieneTejado = true;
        private boolean tienePiscina = false;
        private boolean tieneJardin = false;

        public Builder setParedes(int paredes) {
            this.paredes = paredes;
            return this;
        }

        public Builder setVentanas(int ventanas) {
            this.ventanas = ventanas;
            return this;
        }

        public Builder setTienePuerta(boolean tienePuerta) {
            this.tienePuerta = tienePuerta;
            return this;
        }

        public Builder setTieneTejado(boolean tieneTejado) {
            this.tieneTejado = tieneTejado;
            return this;
        }

        public Builder setTienePiscina(boolean tienePiscina) {
            this.tienePiscina = tienePiscina;
            return this;
        }

        public Builder setTieneJardin(boolean tieneJardin) {
            this.tieneJardin = tieneJardin;
            return this;
        }

        public Casa build() {
            return new Casa(paredes, ventanas, tienePuerta, tieneTejado, tienePiscina, tieneJardin);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Casa casaDeCampo = new Casa.Builder()
                .setTieneJardin(true)
                .setTienePiscina(true)
                .setVentanas(8)
                .build();

        System.out.println(casaDeCampo);

        Casa casaMinimalista = new Casa.Builder()
                .setParedes(3) // ¡Casa moderna!
                .setVentanas(1)
                .build();

        System.out.println(casaMinimalista);
    }
}
```

**Resultado del ejemplo:**

```
Casa con:
Paredes: 4
Ventanas: 8
Tiene puerta
Tiene tejado
Tiene piscina
Tiene jardín

Casa con:
Paredes: 3
Ventanas: 1
Tiene puerta
Tiene tejado
No tiene piscina
No tiene jardín
```

**Explicación del ejemplo:**

- Ahora `Casa` tiene un `Builder` interno.
- Usamos métodos como `setTieneJardin()` o `setVentanas()` para configurar la casa paso a paso.
- Solo llamamos a los métodos que necesitamos, ¡la casa minimalista no necesita `setTieneJardin()`!
- El código es mucho más **claro y fácil de entender**.

#### 3. **Notas o advertencias:**

- El Builder hace que la creación de objetos complejos sea más **flexible y legible**.
- Puedes crear diferentes representaciones del mismo objeto (casa de campo, casa minimalista) usando el mismo proceso de construcción.
- Es ideal cuando el orden de los pasos de construcción no es fijo o cuando algunos pasos son opcionales.

---

## D - Director: Orquestando la Construcción

#### 1. **Definición:**

El **Director** es como un "jefe de obra" que sabe **cómo usar un Builder** para construir un tipo específico de objeto. El Director no construye el objeto directamente, sino que le dice al Builder qué pasos seguir y en qué orden. El Director es opcional, pero útil para definir "recetas" de construcción que puedes reutilizar.

![The director knows which building steps to execute to get a working product.](https://refactoring.guru/images/patterns/content/builder/builder-comic-2-en.png)

#### 2. **Ejemplo:**

Vamos a crear un `DirectorDeCasas` que sepa cómo construir dos tipos de casas: "Casa Normal" y "Casa con Piscina".

```java
// Director
public class DirectorDeCasas {

    public void construirCasaNormal(Casa.Builder builder) {
        builder.setParedes(4)
               .setVentanas(4)
               .setTienePuerta(true)
               .setTieneTejado(true)
               .setTienePiscina(false)
               .setTieneJardin(false);
        // No necesitamos llamar a build() aquí, el cliente lo hará
    }

    public void construirCasaConPiscina(Casa.Builder builder) {
        builder.setParedes(4)
               .setVentanas(6)
               .setTienePuerta(true)
               .setTieneTejado(true)
               .setTienePiscina(true)
               .setTieneJardin(true);
        // Tampoco build() aquí
    }
}

public class Main {
    public static void main(String[] args) {
        DirectorDeCasas director = new DirectorDeCasas();
        Casa.Builder builder = new Casa.Builder(); // Creamos el Builder

        director.construirCasaNormal(builder); // El Director configura el Builder para una casa normal
        Casa casaNormal = builder.build(); // Construimos la casa con el Builder configurado

        System.out.println("Casa Normal:\n" + casaNormal);

        Casa.Builder builderPiscina = new Casa.Builder(); // ¡Nuevo Builder para la casa con piscina!
        director.construirCasaConPiscina(builderPiscina); // Director configura para casa con piscina
        Casa casaConPiscina = builderPiscina.build(); // Construimos la casa con piscina

        System.out.println("\nCasa con Piscina:\n" + casaConPiscina);
    }
}
```

**Resultado del ejemplo:**

```
Casa Normal:
Casa con:
Paredes: 4
Ventanas: 4
Tiene puerta
Tiene tejado
No tiene piscina
No tiene jardín

Casa con Piscina:
Casa con:
Paredes: 4
Ventanas: 6
Tiene puerta
Tiene tejado
Tiene piscina
Tiene jardín
```

**Explicación del ejemplo:**

- Creamos `DirectorDeCasas` con métodos como `construirCasaNormal()` y `construirCasaConPiscina()`.
- El Director recibe un objeto `Casa.Builder` y lo configura con los pasos necesarios para cada tipo de casa.
- El `Main` usa el Director para "darle instrucciones" al Builder, y luego llama a `build()` para obtener la casa final.

#### 3. **Notas o advertencias:**

- El Director **simplifica el código del cliente**, que no tiene que saber todos los pasos de construcción.
- Permite **reutilizar "recetas" de construcción** definidas en el Director.
- Si solo tienes una forma de construir el objeto, o si el cliente necesita mucho control sobre los pasos, el Director puede ser **innecesario**.

---

## E - Estructura del Patrón Builder: Los Componentes Clave

#### 1. **Definición:**

El patrón Builder tiene varios componentes que trabajan juntos:

![Structure of the Builder design pattern](https://refactoring.guru/images/patterns/diagrams/builder/structure.png)![Structure of the Builder design pattern](https://refactoring.guru/images/patterns/diagrams/builder/structure-indexed.png)

1.  **Builder (Interfaz):** Define los pasos básicos para construir el objeto. Todos los Builders concretos deben seguir esta interfaz. En nuestro ejemplo, sería la clase `Casa.Builder` (aunque en Java no es una interfaz explícita, actúa como tal conceptualmente).
2.  **Concrete Builders (Builders Concretos):** Son las clases que implementan la interfaz Builder y saben cómo construir diferentes partes del objeto. En nuestro ejemplo, también es `Casa.Builder`, pero podrías tener `CasaDeMaderaBuilder`, `CasaDePiedraBuilder`, etc., si quisieras construir casas con diferentes materiales.
3.  **Product (Producto):** Es el objeto complejo que se está construyendo. En nuestro ejemplo, es la clase `Casa` o `Hamburguesa`.
4.  **Director (Director):** (Opcional) Sabe cómo usar un Builder para construir un tipo específico de producto. En nuestro ejemplo, es `DirectorDeCasas`.
5.  **Client (Cliente):** Es la parte del código que quiere construir el objeto complejo. Crea un Builder y (opcionalmente) un Director, y los usa para construir el producto final. En nuestros ejemplos, es la clase `Main`.

#### 2. **Ejemplo:**

Ya hemos visto ejemplos de todos estos componentes en las secciones anteriores con la `Casa` y la `Hamburguesa`.

#### 3. **Notas o advertencias:**

- Entender la estructura te ayuda a implementar el patrón Builder correctamente.
- Recuerda que el Director es opcional, pero puede ser muy útil para organizar la construcción.
- Los Builders concretos pueden crear diferentes representaciones del producto, ¡esa es la magia del patrón!

---

## F - Seudo-código del Patrón Builder: Ejemplo de Coche y Manual

#### 1. **Definición:**

El texto original te da un ejemplo en seudo-código para construir coches y manuales de coche. La idea es que puedes usar el mismo proceso de construcción (los mismos pasos) para crear cosas diferentes (un coche real y un manual de papel).

![The structure of the Builder pattern example](https://refactoring.guru/images/patterns/diagrams/builder/example-en.png)

#### 2. **Ejemplo (Adaptado a Java):**

Vamos a simplificar un poco el ejemplo del coche y el manual en Java:

```java
// Producto: Coche
class Coche {
    private String motor;
    private int asientos;
    private boolean tieneGPS;

    // ... (constructor, getters, toString) ...
    private Coche(String motor, int asientos, boolean tieneGPS) {
        this.motor = motor;
        this.asientos = asientos;
        this.tieneGPS = tieneGPS;
    }

    public static class Builder {
        private String motor = "Gasolina";
        private int asientos = 4;
        private boolean tieneGPS = false;

        public Builder setMotor(String motor) { this.motor = motor; return this; }
        public Builder setAsientos(int asientos) { this.asientos = asientos; return this; }
        public Builder setTieneGPS(boolean tieneGPS) { this.tieneGPS = tieneGPS; return this; }
        public Coche build() { return new Coche(motor, asientos, tieneGPS); }
    }

    @Override
    public String toString() {
        return "Coche con:\nMotor: " + motor + "\nAsientos: " + asientos + (tieneGPS ? "\nTiene GPS" : "\nNo tiene GPS");
    }
}

// Producto: Manual de Coche
class ManualCoche {
    private String descripcionMotor;
    private String descripcionAsientos;
    private String descripcionGPS;

    // ... (constructor, getters, toString) ...
    private ManualCoche(String descripcionMotor, String descripcionAsientos, String descripcionGPS) {
        this.descripcionMotor = descripcionMotor;
        this.descripcionAsientos = descripcionAsientos;
        this.descripcionGPS = descripcionGPS;
    }


    public static class Builder {
        private String descripcionMotor = "Motor estándar";
        private String descripcionAsientos = "Asientos de tela";
        private String descripcionGPS = "Sin GPS";

        public Builder setDescripcionMotor(String descripcionMotor) { this.descripcionMotor = descripcionMotor; return this; }
        public Builder setDescripcionAsientos(String descripcionAsientos) { this.descripcionAsientos = descripcionAsientos; return this; }
        public Builder setDescripcionGPS(String descripcionGPS) { this.descripcionGPS = descripcionGPS; return this; }
        public ManualCoche build() { return new ManualCoche(descripcionMotor, descripcionAsientos, descripcionGPS); }
    }

    @Override
    public String toString() {
        return "Manual de Coche:\nDescripción Motor: " + descripcionMotor + "\nDescripción Asientos: " + descripcionAsientos + "\nDescripción GPS: " + descripcionGPS;
    }
}


// Interfaz Builder (más formal ahora)
interface Builder {
    void reset();
    void setAsientos(int asientos);
    void setMotor(String motor);
    void setGPS(boolean gps);
}

// Builder Concreto para Coches
class CocheBuilder implements Builder {
    private Coche coche;

    public CocheBuilder() { reset(); }
    public void reset() { this.coche = new Coche.Builder().build(); } // Empezamos con un coche "vacío"
    public void setAsientos(int asientos) { coche = new Coche.Builder().setAsientos(asientos).build(); } // Reconstruimos con la nueva parte
    public void setMotor(String motor) { coche = new Coche.Builder().setMotor(motor).build(); }
    public void setGPS(boolean gps) { coche = new Coche.Builder().setTieneGPS(gps).build(); }
    public Coche getProduct() {
        Coche producto = this.coche;
        reset(); // Preparado para construir otro coche
        return producto;
    }
}

// Builder Concreto para Manuales de Coche
class ManualCocheBuilder implements Builder {
    private ManualCoche manual;

    public ManualCocheBuilder() { reset(); }
    public void reset() { this.manual = new ManualCoche.Builder().build(); } // Manual "vacío"
    public void setAsientos(int asientos) { manual = new ManualCoche.Builder().setDescripcionAsientos("Asientos descritos para " + asientos + " pasajeros").build(); }
    public void setMotor(String motor) { manual = new ManualCoche.Builder().setDescripcionMotor("Motor tipo " + motor).build(); }
    public void setGPS(boolean gps) { manual = new ManualCoche.Builder().setDescripcionGPS(gps ? "GPS incluido" : "GPS opcional").build(); }
    public ManualCoche getProduct() {
        ManualCoche producto = this.manual;
        reset();
        return producto;
    }
}

// Director (similar al anterior)
class DirectorDeCoches {
    public void construirCocheDeportivo(Builder builder) {
        builder.reset();
        builder.setAsientos(2);
        builder.setMotor("Deportivo");
        builder.setGPS(true);
    }

    public void construirCocheFamiliar(Builder builder) {
        builder.reset();
        builder.setAsientos(5);
        builder.setMotor("Familiar");
        builder.setGPS(false);
    }
}


public class Main {
    public static void main(String[] args) {
        DirectorDeCoches directorCoches = new DirectorDeCoches();

        CocheBuilder cocheBuilder = new CocheBuilder();
        ManualCocheBuilder manualBuilder = new ManualCocheBuilder();

        directorCoches.construirCocheDeportivo(cocheBuilder);
        Coche cocheDeportivo = cocheBuilder.getProduct();

        directorCoches.construirCocheDeportivo(manualBuilder); // ¡Mismo director, diferente builder!
        ManualCoche manualDeportivo = manualBuilder.getProduct();

        System.out.println("Coche Deportivo:\n" + cocheDeportivo);
        System.out.println("\nManual de Coche Deportivo:\n" + manualDeportivo);

        System.out.println("\n--- Coche Familiar y su Manual ---");

        directorCoches.construirCocheFamiliar(cocheBuilder); // Reutilizamos cocheBuilder
        Coche cocheFamiliar = cocheBuilder.getProduct();

        directorCoches.construirCocheFamiliar(manualBuilder); // Reutilizamos manualBuilder
        ManualCoche manualFamiliar = manualBuilder.getProduct();

        System.out.println("\nCoche Familiar:\n" + cocheFamiliar);
        System.out.println("\nManual de Coche Familiar:\n" + manualFamiliar);
    }
}
```

**Resultado del ejemplo:**

```
Coche Deportivo:
Coche con:
Motor: Deportivo
Asientos: 2
Tiene GPS

Manual de Coche Deportivo:
Manual de Coche:
Descripción Motor: Motor tipo Deportivo
Descripción Asientos: Asientos descritos para 2 pasajeros
Descripción GPS: GPS incluido

--- Coche Familiar y su Manual ---

Coche Familiar:
Coche con:
Motor: Familiar
Asientos: 5
No tiene GPS

Manual de Coche Familiar:
Manual de Coche:
Descripción Motor: Motor tipo Familiar
Descripción Asientos: Asientos descritos para 5 pasajeros
Descripción GPS: GPS opcional
```

**Explicación del ejemplo:**

- Tenemos dos productos diferentes: `Coche` y `ManualCoche`.
- Creamos una interfaz `Builder` para definir los pasos comunes de construcción (`setAsientos`, `setMotor`, `setGPS`).
- `CocheBuilder` y `ManualCocheBuilder` son Builders concretos que implementan la interfaz `Builder` pero construyen cosas diferentes (coches y manuales).
- `DirectorDeCoches` usa la misma lógica (`construirCocheDeportivo`, `construirCocheFamiliar`) pero puede trabajar con `CocheBuilder` para construir coches o con `ManualCocheBuilder` para construir manuales.
- ¡Usamos el mismo Director y los mismos pasos para construir productos relacionados pero diferentes!

#### 3. **Notas o advertencias:**

- Este ejemplo muestra cómo el Builder permite **reutilizar la lógica de construcción** para diferentes tipos de productos.
- La interfaz `Builder` es clave para que el Director pueda trabajar con diferentes Builders concretos.
- Aunque los productos (`Coche` y `ManualCoche`) son diferentes, comparten una lógica de construcción similar, lo que hace que el Builder sea útil.

---

## G - Aplicabilidad: ¿Cuándo Usar el Patrón Builder?

#### 1. **Definición:**

Usa el patrón Builder cuando:

- **Constructores Telescópicos:** Tienes constructores con demasiados parámetros opcionales. El Builder te ayuda a evitar esto.
- **Representaciones Múltiples:** Quieres crear diferentes versiones de un objeto usando los mismos pasos de construcción, pero con detalles diferentes (como el ejemplo del coche y el manual, o casas de diferentes materiales).
- **Construcción Paso a Paso:** Necesitas construir objetos complejos paso a paso, y el orden de los pasos puede variar.
- **Objetos Compuestos:** Quieres construir árboles de objetos complejos (como en el patrón Composite). El Builder te permite construir los nodos del árbol de forma recursiva.
- **Ocultar Construcción Compleja:** Quieres separar la lógica de construcción del objeto en sí, para que el código del cliente sea más limpio y sencillo.

#### 2. **Ejemplo:**

- **Creación de informes:** Puedes usar un Builder para crear informes en diferentes formatos (HTML, PDF, texto plano) a partir de los mismos datos.
- **Configuración de software:** Un Builder puede ayudar a configurar una aplicación con muchas opciones, permitiendo al usuario elegir solo las que necesita.
- **Juegos de construcción:** En un juego, podrías usar un Builder para crear diferentes tipos de edificios o personajes con diferentes atributos.

#### 3. **Notas o advertencias:**

- El Builder es muy útil para objetos **complejos**, pero puede ser **exagerado para objetos simples**.
- Si tu objeto tiene un constructor sencillo y pocas opciones, quizás no necesites el Builder.
- Piensa si realmente necesitas la flexibilidad y la separación que ofrece el Builder antes de implementarlo.

---

## H - Cómo Implementar el Patrón Builder: Paso a Paso

#### 1. **Definición:**

Aquí tienes los pasos para implementar el patrón Builder:

1.  **Identifica los Pasos de Construcción:** Define claramente los pasos comunes para construir todas las versiones de tu objeto. Por ejemplo, para un coche: `setMotor()`, `setAsientos()`, `setGPS()`.
2.  **Crea la Interfaz Builder:** Define una interfaz (o clase abstracta) `Builder` que declare estos pasos de construcción.
3.  **Crea Builders Concretos:** Para cada representación diferente del producto, crea una clase `Builder` concreta que implemente la interfaz `Builder` y defina cómo se realizan los pasos para esa representación específica.
4.  **Crea el Director (Opcional):** Si quieres, crea una clase `Director` que sepa cómo usar un Builder para construir tipos específicos de productos. El Director tiene métodos que llaman a los pasos del Builder en un orden determinado.
5.  **Cliente:** El código del cliente crea un Builder concreto (y opcionalmente un Director), configura el Builder llamando a los métodos de construcción, y finalmente llama a `build()` (o `getProduct()`) para obtener el objeto construido.

#### 2. **Ejemplo:**

Ya hemos visto ejemplos de implementación en las secciones anteriores con la `Casa`, la `Hamburguesa` y el `Coche/Manual`.

#### 3. **Notas o advertencias:**

- Empieza por definir bien los **pasos de construcción**. Si no tienes claros los pasos, será difícil implementar el Builder.
- Decide si necesitas un **Director**. Si solo tienes una forma principal de construir el objeto, o si el cliente necesita mucho control, quizás no sea necesario.
- Asegúrate de que los Builders concretos **devuelvan el producto correcto** al final de la construcción.

---

## I - Pros y Contras del Patrón Builder

#### 1. **Definición:**

**Pros (Ventajas):**

- **Construcción Paso a Paso:** Permite construir objetos complejos de forma controlada, paso a paso.
- **Reutilización de Código:** Puedes reutilizar la lógica de construcción para diferentes representaciones del producto.
- **Principio de Responsabilidad Única:** Separa la lógica de construcción del objeto en sí, haciendo el código más organizado.
- **Flexibilidad:** Permite construir diferentes configuraciones de objetos fácilmente.

**Cons (Desventajas):**

- **Aumento de la Complejidad:** Introduce más clases (Builder, Concrete Builders, Director), lo que puede hacer el código más complejo, especialmente para proyectos pequeños.
- **Puede ser Exagerado:** Para objetos simples, el Builder puede ser una solución demasiado compleja.

#### 2. **Ejemplo:**

Piensa en los ejemplos que hemos visto: la flexibilidad para crear diferentes tipos de casas o hamburguesas es una ventaja. Pero si solo necesitas un tipo de casa muy simple, usar Builder podría ser más complicado de lo necesario.

#### 3. **Notas o advertencias:**

- Evalúa si las ventajas del Builder **justifican la complejidad adicional** en tu proyecto.
- No uses Builder "por usar". Úsalo cuando realmente te aporte valor para manejar la complejidad de la construcción de objetos.

---

## J - Relación con Otros Patrones

#### 1. **Definición:**

El patrón Builder se relaciona con otros patrones de diseño:

- **Factory Method, Abstract Factory, Prototype:** Muchos diseños empiezan con Factory Method (más simple) y pueden evolucionar hacia Abstract Factory, Prototype o Builder (más flexibles pero más complejos).
- **Abstract Factory vs. Builder:** Abstract Factory crea familias de objetos relacionados "de una vez", mientras que Builder construye objetos complejos paso a paso. Abstract Factory devuelve el producto inmediatamente, Builder te permite hacer más pasos antes de obtener el producto final.
- **Composite:** Puedes usar Builder para construir árboles Composite complejos, ya que puedes llamar a los pasos de construcción de forma recursiva.
- **Bridge:** Puedes combinar Builder con Bridge. El Director podría actuar como la Abstracción en Bridge, y los diferentes Builders como las Implementaciones.
- **Singleton:** Abstract Factory, Builder y Prototype pueden implementarse como Singletons si necesitas una única instancia de la fábrica, builder o prototipo.

#### 2. **Ejemplo:**

Imagina que tienes una Abstract Factory para crear diferentes tipos de "Vehículos" (Coche, Moto, Camión). Dentro de la fábrica de "Coches", podrías usar un Builder para construir coches complejos con muchas opciones (motor, asientos, GPS, etc.).

#### 3. **Notas o advertencias:**

- Entender las relaciones entre patrones te ayuda a elegir el patrón adecuado para cada situación.
- A veces, puedes combinar varios patrones para resolver problemas más complejos.
- Elige el patrón que mejor se adapte a la complejidad de tu problema y a las necesidades de tu diseño.
