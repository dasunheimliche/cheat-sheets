## A - Proxy

#### 1. **Definición:**

El patrón **Proxy** es como tener un **representante** o **sustituto** para otro objeto. Imagina que tienes un objeto original que es muy pesado o costoso de crear o usar directamente. Un Proxy se pone en medio, actuando como ese objeto original, pero controlando cuándo y cómo se accede al objeto real. Es como un **intermediario** que decide si te conecta o no con el objeto verdadero, y puede hacer cosas útiles antes o después de que uses el objeto real.

#### 2. **Ejemplo:**

Imagina que tienes una clase `ServidorDescarga` que descarga archivos grandes, pero tarda mucho en iniciar y consume muchos recursos. No quieres que se inicie siempre, solo cuando realmente se necesite descargar algo.

```java
interface Descargable {
    void descargarArchivo(String url);
}

class ServidorDescarga implements Descargable {
    public ServidorDescarga() {
        System.out.println("ServidorDescarga inicializado (¡esto tarda!)");
        // Simula una inicialización costosa
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void descargarArchivo(String url) {
        System.out.println("Descargando archivo desde: " + url);
        // Simula la descarga
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("Archivo descargado.");
    }
}

class ProxyDescarga implements Descargable {
    private ServidorDescarga servidorReal;

    @Override
    public void descargarArchivo(String url) {
        System.out.println("ProxyDescarga: Comprobando si el servidor real ya está listo...");
        if (servidorReal == null) {
            System.out.println("ProxyDescarga: El servidor real no está listo, inicializándolo ahora.");
            servidorReal = new ServidorDescarga(); // Inicialización perezosa (lazy)
        }
        System.out.println("ProxyDescarga: Delegando la descarga al servidor real.");
        servidorReal.descargarArchivo(url);
    }
}

public class Cliente {
    public static void main(String[] args) {
        Descargable descargador = new ProxyDescarga(); // Usamos el Proxy en lugar del ServidorDescarga directamente

        descargador.descargarArchivo("http://ejemplo.com/archivo1.zip"); // Primera descarga, inicializa el servidor real
        System.out.println("---");
        descargador.descargarArchivo("http://ejemplo.com/archivo2.zip"); // Segunda descarga, el servidor real ya está inicializado
    }
}
```

**Output del código:**

```
ProxyDescarga: Comprobando si el servidor real ya está listo...
ProxyDescarga: El servidor real no está listo, inicializándolo ahora.
ServidorDescarga inicializado (¡esto tarda!)
ProxyDescarga: Delegando la descarga al servidor real.
Descargando archivo desde: http://ejemplo.com/archivo1.zip
Archivo descargado.
---
ProxyDescarga: Comprobando si el servidor real ya está listo...
ProxyDescarga: Delegando la descarga al servidor real.
Descargando archivo desde: http://ejemplo.com/archivo2.zip
Archivo descargado.
```

**Explicación del ejemplo:**

En este ejemplo, `ServidorDescarga` es nuestro objeto "pesado" que tarda en inicializarse. `ProxyDescarga` actúa como el Proxy.

- El `Cliente` no sabe si está usando el `ServidorDescarga` real o el `ProxyDescarga`, porque ambos implementan la interfaz `Descargable`.
- La primera vez que el `Cliente` llama a `descargarArchivo()`, el `ProxyDescarga` se da cuenta de que `servidorReal` (el `ServidorDescarga`) aún no se ha creado. Entonces, **inicializa** `servidorReal` (la parte que tarda).
- En las siguientes llamadas a `descargarArchivo()`, `servidorReal` ya está inicializado, por lo que el `ProxyDescarga` simplemente delega la llamada al `ServidorDescarga` real directamente.

Esto se llama **inicialización perezosa** o **lazy initialization**: el objeto costoso solo se crea cuando realmente se necesita, ahorrando recursos si no se usa.

#### 3. **Notas o advertencias:**

- El Proxy **no cambia la interfaz** del objeto original. El cliente sigue interactuando con la misma interfaz, sin saber que hay un Proxy en medio.
- El Proxy puede hacer muchas cosas además de la inicialización perezosa, como **control de acceso**, **registro (logging)**, **caché**, etc. (veremos más adelante en "Aplicabilidad").
- Usar Proxies puede añadir una pequeña **sobrecarga** de tiempo, ya que hay un paso extra (el Proxy) en la llamada. Pero en muchos casos, los beneficios (como la inicialización perezosa o el control de acceso) superan esta pequeña desventaja.

---

## B - Problema que resuelve el Proxy

#### 1. **Definición:**

El patrón Proxy se usa cuando necesitas **controlar el acceso** a un objeto, o cuando la **creación o uso** del objeto original es **costoso** o **complejo**. Imagina estas situaciones:

- **Objeto Costoso:** Tienes un objeto que consume muchos recursos (memoria, tiempo de CPU, conexiones de red, etc.) y no siempre lo necesitas. No quieres crearlo y mantenerlo activo todo el tiempo si no se está usando.
- **Control de Acceso:** Quieres restringir quién puede acceder a ciertas operaciones de un objeto. Por ejemplo, solo ciertos usuarios o roles deberían poder eliminar datos, pero todos pueden verlos.
- **Objeto Remoto:** El objeto real está en otro lugar (en otro servidor, por ejemplo). Necesitas una forma de interactuar con él como si estuviera localmente, manejando la comunicación de red por ti.
- **Funcionalidad Adicional:** Quieres añadir funcionalidad extra **antes** o **después** de que se ejecuten las operaciones del objeto original, sin modificar el objeto original en sí. Por ejemplo, registrar todas las llamadas a un método, o añadir caché a los resultados.

![Problem solved by Proxy pattern](https://refactoring.guru/images/patterns/diagrams/proxy/problem-en.png)

#### 2. **Ejemplo:**

**Problema del objeto costoso:** Consultas a una base de datos pueden ser lentas y consumir muchos recursos. Si tienes que hacer muchas consultas similares, pero no siempre, crear la conexión a la base de datos y ejecutar la consulta cada vez puede ser ineficiente.

**Ejemplo de código (continuación del ejemplo anterior, ahora con caché):**

```java
import java.util.HashMap;
import java.util.Map;

interface ServicioDatos {
    String obtenerDato(int id);
}

class ServicioDatosRemoto implements ServicioDatos {
    public ServicioDatosRemoto() {
        System.out.println("ServicioDatosRemoto: Conectando a un servicio remoto (¡esto puede tardar!)");
        // Simula conexión remota costosa
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    @Override
    public String obtenerDato(int id) {
        System.out.println("ServicioDatosRemoto: Obteniendo dato con ID: " + id + " desde el servicio remoto.");
        // Simula consulta remota
        try {
            Thread.sleep(1500);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "Dato para ID " + id + " desde el servicio remoto.";
    }
}

class ProxyServicioDatos implements ServicioDatos {
    private ServicioDatosRemoto servicioReal;
    private Map<Integer, String> cache = new HashMap<>();

    @Override
    public String obtenerDato(int id) {
        System.out.println("ProxyServicioDatos: Buscando dato con ID: " + id + " en caché...");
        if (cache.containsKey(id)) {
            System.out.println("ProxyServicioDatos: Dato encontrado en caché.");
            return cache.get(id); // Dato encontrado en caché, lo devolvemos directamente
        }

        System.out.println("ProxyServicioDatos: Dato no encontrado en caché. Obteniendo del servicio real...");
        if (servicioReal == null) {
            servicioReal = new ServicioDatosRemoto(); // Inicialización perezosa del servicio remoto
        }
        String dato = servicioReal.obtenerDato(id);
        cache.put(id, dato); // Guardamos el dato en caché para futuras peticiones
        return dato;
    }
}

public class ClienteDatos {
    public static void main(String[] args) {
        ServicioDatos servicio = new ProxyServicioDatos(); // Usamos el Proxy

        System.out.println("--- Primera petición ---");
        System.out.println(servicio.obtenerDato(1)); // Primera vez, se conecta al servicio remoto y guarda en caché
        System.out.println("--- Segunda petición (misma ID) ---");
        System.out.println(servicio.obtenerDato(1)); // Segunda vez con la misma ID, usa la caché
        System.out.println("--- Tercera petición (nueva ID) ---");
        System.out.println(servicio.obtenerDato(2)); // Nueva ID, se conecta al servicio remoto (si no estaba ya conectado) y guarda en caché
    }
}
```

**Output del código:**

```
--- Primera petición ---
ProxyServicioDatos: Buscando dato con ID: 1 en caché...
ProxyServicioDatos: Dato no encontrado en caché. Obteniendo del servicio real...
ServicioDatosRemoto: Conectando a un servicio remoto (¡esto puede tardar!)
ServicioDatosRemoto: Obteniendo dato con ID: 1 desde el servicio remoto.
Dato para ID 1 desde el servicio remoto.
--- Segunda petición (misma ID) ---
ProxyServicioDatos: Buscando dato con ID: 1 en caché...
ProxyServicioDatos: Dato encontrado en caché.
Dato para ID 1 desde el servicio remoto.
--- Tercera petición (nueva ID) ---
ProxyServicioDatos: Buscando dato con ID: 2 en caché...
ProxyServicioDatos: Dato no encontrado en caché. Obteniendo del servicio real...
ServicioDatosRemoto: Obteniendo dato con ID: 2 desde el servicio remoto.
Dato para ID 2 desde el servicio remoto.
```

**Explicación del ejemplo:**

Aquí, `ServicioDatosRemoto` simula un servicio de datos que es lento de conectar y consultar. `ProxyServicioDatos` añade **caché** para mejorar el rendimiento.

- La primera vez que se pide un dato con un `id` específico, el `ProxyServicioDatos` no lo encuentra en su `cache`. Entonces, crea (si no existe ya) y usa el `ServicioDatosRemoto` para obtener el dato, y **guarda el dato en la `cache`**.
- La segunda vez que se pide el **mismo dato** (misma `id`), el `ProxyServicioDatos` **encuentra el dato en la `cache`** y lo devuelve **directamente**, sin tener que volver a contactar con el `ServicioDatosRemoto`.

Esto demuestra cómo un Proxy puede añadir **caché** para optimizar el acceso a un servicio costoso, haciendo que las peticiones repetidas sean mucho más rápidas.

#### 3. **Notas o advertencias:**

- El Proxy **oculta la complejidad** del objeto real al cliente. El cliente solo ve la interfaz simple del Proxy.
- El Proxy puede **mejorar el rendimiento** (como en el ejemplo del caché) o **añadir seguridad** (control de acceso), **registro de actividad (logging)**, etc., sin cambiar el código del objeto original.
- Es importante que el Proxy implemente la **misma interfaz** que el objeto real para que el cliente pueda usar el Proxy **sin darse cuenta** del cambio.

---

## C - Solución con el patrón Proxy

#### 1. **Definición:**

La solución que ofrece el patrón Proxy es crear una nueva clase, el **Proxy**, que tiene la **misma interfaz** que el objeto original, llamado **Servicio**. En lugar de usar directamente el Servicio, el cliente usa el Proxy. El Proxy se encarga de crear y controlar el acceso al Servicio, y puede realizar acciones adicionales antes o después de pasar la petición al Servicio real.

![Solution with the Proxy pattern](https://refactoring.guru/images/patterns/diagrams/proxy/solution-en.png)

#### 2. **Ejemplo:**

Volviendo al ejemplo del `ServicioDatosRemoto` y `ProxyServicioDatos`.

- `ServicioDatos` es la **interfaz** que define cómo interactuar con los datos.
- `ServicioDatosRemoto` es el **Servicio real**, que accede a los datos de forma remota (y costosa).
- `ProxyServicioDatos` es el **Proxy**. Implementa la misma interfaz `ServicioDatos`, y dentro, tiene una referencia al `ServicioDatosRemoto` (el servicio real).
- El `ClienteDatos` (cliente) usa la interfaz `ServicioDatos`. No sabe si está usando directamente `ServicioDatosRemoto` o el `ProxyServicioDatos`.

El Proxy, `ProxyServicioDatos`, se encarga de:

1.  **Inicialización perezosa** del `ServicioDatosRemoto`: Solo crea el `ServicioDatosRemoto` cuando realmente se necesita por primera vez.
2.  **Caché**: Guarda los resultados de las peticiones en una `cache`. Si se pide el mismo dato de nuevo, lo devuelve desde la `cache` en lugar de volver a pedirlo al `ServicioDatosRemoto`.
3.  **Delegación**: Después de hacer su trabajo (caché, inicialización, etc.), el Proxy **delega** la petición al `ServicioDatosRemoto` real para que haga el trabajo "de verdad" si es necesario.

#### 3. **Notas o advertencias:**

- El Proxy se **disfraza** como el objeto real (Servicio). Desde el punto de vista del cliente, el Proxy **es** el Servicio.
- El Proxy puede añadir funcionalidades como **inicialización perezosa**, **caché**, **control de acceso**, **registro (logging)**, etc., **sin modificar** el Servicio real.
- El cliente puede usar el Proxy y el Servicio de forma **intercambiable**, ya que ambos implementan la misma interfaz. Esto hace que sea fácil cambiar de usar el Servicio directamente a usar un Proxy, o viceversa, sin cambiar mucho código del cliente.

---

## D - Analogía del mundo real

#### 1. **Definición:**

Una buena analogía para entender el patrón Proxy es una **tarjeta de crédito**.

![A credit card is a proxy for a bundle of cash](https://refactoring.guru/images/patterns/diagrams/proxy/live-example.png)

#### 2. **Ejemplo:**

- **Efectivo:** El efectivo es como el **Servicio real**, el recurso fundamental para hacer pagos.
- **Tarjeta de Crédito:** La tarjeta de crédito es el **Proxy**. La usas para pagar en tiendas, restaurantes, etc., **en lugar de usar efectivo directamente**.

**¿Cómo funciona la tarjeta de crédito como Proxy?**

1.  **Interfaz común:** Tanto el efectivo como la tarjeta de crédito sirven para **hacer pagos**. Ambos "implementan la misma interfaz" desde el punto de vista del comercio y del cliente.
2.  **Acceso controlado:** La tarjeta de crédito **controla el acceso** a tu cuenta bancaria (que a su vez es un "proxy" del efectivo que tienes en el banco). No estás dando acceso directo a tu cuenta bancaria cada vez que pagas.
3.  **Funcionalidad adicional:** La tarjeta de crédito ofrece **funcionalidades extra** que el efectivo no tiene:
    - **Conveniencia:** No tienes que llevar mucho efectivo encima.
    - **Seguridad:** Menos riesgo de perder grandes cantidades de dinero en efectivo.
    - **Registro:** Tienes un registro de todas tus transacciones.
    - **Crédito:** En algunos casos, puedes gastar dinero que aún no tienes (crédito).

#### 3. **Notas o advertencias:**

- La tarjeta de crédito es un **intermediario** entre tú y tu dinero en el banco. Simplifica y controla el acceso a ese dinero.
- Al igual que un Proxy en programación, la tarjeta de crédito **no cambia la forma básica de hacer un pago** (la "interfaz"). Simplemente añade una capa de **control** y **funcionalidad adicional**.
- Tanto el cliente (tú) como el comercio están contentos con la tarjeta de crédito (Proxy): tú por la comodidad, y el comercio porque recibe el pago electrónicamente en su cuenta bancaria, sin el riesgo de manejar grandes cantidades de efectivo.

---

## E - Estructura del Proxy

#### 1. **Definición:**

La estructura del patrón Proxy se compone de los siguientes elementos principales:

![Structure of the Proxy design pattern](https://refactoring.guru/images/patterns/diagrams/proxy/structure.png)![Structure of the Proxy design pattern](https://refactoring.guru/images/patterns/diagrams/proxy/structure-indexed.png)

1.  **Interfaz del Servicio (Service Interface):** Define la interfaz que tanto el `Servicio` real como el `Proxy` deben implementar. Esto permite que el cliente interactúe con ambos de la misma manera.
2.  **Servicio (Service):** Es la clase que contiene la lógica de negocio real, el objeto "original" al que queremos controlar el acceso.
3.  **Proxy:** Es la clase que actúa como sustituto del `Servicio`. Implementa la misma interfaz que el `Servicio`, tiene una referencia al `Servicio` real, y controla el acceso a él. Puede realizar acciones adicionales antes o después de delegar la petición al `Servicio`.
4.  **Cliente (Client):** Es la clase que usa el `Servicio` a través de la interfaz del Servicio. No necesita saber si está interactuando directamente con el `Servicio` o con un `Proxy`.

#### 2. **Ejemplo (relacionado con el ejemplo de código anterior):**

En el ejemplo del `ProxyServicioDatos`:

1.  **Interfaz del Servicio:** `ServicioDatos`
2.  **Servicio:** `ServicioDatosRemoto`
3.  **Proxy:** `ProxyServicioDatos`
4.  **Cliente:** `ClienteDatos`

El `ClienteDatos` siempre interactúa con objetos de tipo `ServicioDatos` (a través de la interfaz). En el ejemplo, le pasamos un `ProxyServicioDatos`, pero podríamos haberle pasado un `ServicioDatosRemoto` directamente y el código del cliente seguiría funcionando igual (aunque sin la funcionalidad de caché del Proxy).

#### 3. **Notas o advertencias:**

- La **interfaz del Servicio** es clave. Permite la **intercambiabilidad** entre el `Servicio` real y el `Proxy`.
- El `Proxy` **gestiona el ciclo de vida** del `Servicio` en muchos casos. Por ejemplo, en la inicialización perezosa, el Proxy crea el `Servicio` cuando es necesario.
- El `Cliente` no debe depender de la implementación concreta del `Servicio` o del `Proxy`, sino solo de la **interfaz del Servicio**. Esto hace que el sistema sea más flexible y fácil de mantener.

---

## F - Seudocódigo (Adaptado a Java)

#### 1. **Definición:**

Este seudocódigo (adaptado a Java) ilustra cómo el patrón Proxy puede añadir **inicialización perezosa** y **caché** a una librería externa de YouTube (simulada).

![Structure of the Proxy pattern example](https://refactoring.guru/images/patterns/diagrams/proxy/example.png)

#### 2. **Ejemplo (Código Java):**

```java
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Arrays;

// Interfaz para la librería de YouTube (simulada)
interface LibreriaYouTube {
    List<String> listarVideos();
    String obtenerInfoVideo(int id);
    void descargarVideo(int id);
}

// Implementación concreta de la librería de YouTube (simulada)
class LibreriaYouTubeTerceros implements LibreriaYouTube {
    @Override
    public List<String> listarVideos() {
        System.out.println("LibreriaYouTubeTerceros: Obteniendo lista de videos de YouTube...");
        // Simula petición a la API de YouTube
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return Arrays.asList("Video 1", "Video 2", "Video 3"); // Lista de videos simulada
    }

    @Override
    public String obtenerInfoVideo(int id) {
        System.out.println("LibreriaYouTubeTerceros: Obteniendo información del video con ID: " + id + "...");
        // Simula petición a la API de YouTube
        try {
            Thread.sleep(800);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return "Información del video con ID " + id + " desde YouTube."; // Información simulada
    }

    @Override
    public void descargarVideo(int id) {
        System.out.println("LibreriaYouTubeTerceros: Descargando video con ID: " + id + " desde YouTube...");
        // Simula descarga de video
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("LibreriaYouTubeTerceros: Video con ID " + id + " descargado.");
    }
}

// Proxy con caché para la librería de YouTube
class ProxyYouTubeConCache implements LibreriaYouTube {
    private LibreriaYouTube servicioYouTube;
    private List<String> cacheListaVideos;
    private Map<Integer, String> cacheInfoVideos = new HashMap<>();

    public ProxyYouTubeConCache(LibreriaYouTube servicioYouTube) {
        this.servicioYouTube = servicioYouTube;
    }

    @Override
    public List<String> listarVideos() {
        System.out.println("ProxyYouTubeConCache: Comprobando caché de lista de videos...");
        if (cacheListaVideos == null) {
            System.out.println("ProxyYouTubeConCache: Lista de videos no en caché. Obteniendo del servicio real...");
            cacheListaVideos = servicioYouTube.listarVideos();
        } else {
            System.out.println("ProxyYouTubeConCache: Lista de videos encontrada en caché.");
        }
        return cacheListaVideos;
    }

    @Override
    public String obtenerInfoVideo(int id) {
        System.out.println("ProxyYouTubeConCache: Comprobando caché de información del video ID: " + id + "...");
        if (!cacheInfoVideos.containsKey(id)) {
            System.out.println("ProxyYouTubeConCache: Información del video ID: " + id + " no en caché. Obteniendo del servicio real...");
            cacheInfoVideos.put(id, servicioYouTube.obtenerInfoVideo(id));
        } else {
            System.out.println("ProxyYouTubeConCache: Información del video ID: " + id + " encontrada en caché.");
        }
        return cacheInfoVideos.get(id);
    }

    @Override
    public void descargarVideo(int id) {
        System.out.println("ProxyYouTubeConCache: Descargando video ID: " + id + " (sin caché para descargas en este ejemplo).");
        servicioYouTube.descargarVideo(id); // No se implementa caché para descargas en este ejemplo
    }
}

// Clase cliente que usa la librería de YouTube a través de la interfaz
class GestorYouTube {
    private LibreriaYouTube servicioYouTube;

    public GestorYouTube(LibreriaYouTube servicioYouTube) {
        this.servicioYouTube = servicioYouTube;
    }

    public void mostrarPaginaVideo(int id) {
        String info = servicioYouTube.obtenerInfoVideo(id);
        System.out.println("GestorYouTube: Mostrando página del video con información: " + info);
    }

    public void mostrarPanelListaVideos() {
        List<String> videos = servicioYouTube.listarVideos();
        System.out.println("GestorYouTube: Mostrando panel con lista de videos: " + videos);
    }

    public void reaccionarInputUsuario() {
        mostrarPaginaVideo(1);
        mostrarPanelListaVideos();
    }
}

// Aplicación principal
public class AplicacionYouTube {
    public static void main(String[] args) {
        LibreriaYouTube servicioYouTubeReal = new LibreriaYouTubeTerceros();
        LibreriaYouTube servicioYouTubeProxyConCache = new ProxyYouTubeConCache(servicioYouTubeReal);
        GestorYouTube gestor = new GestorYouTube(servicioYouTubeProxyConCache); // Usamos el Proxy en el gestor

        System.out.println("--- Primera interacción ---");
        gestor.reaccionarInputUsuario();
        System.out.println("--- Segunda interacción (mismas peticiones) ---");
        gestor.reaccionarInputUsuario(); // Las segundas peticiones deberían usar la caché
    }
}
```

**Output del código:**

```
--- Primera interacción ---
ProxyYouTubeConCache: Comprobando caché de información del video ID: 1...
ProxyYouTubeConCache: Información del video ID: 1 no en caché. Obteniendo del servicio real...
LibreriaYouTubeTerceros: Obteniendo información del video con ID: 1...
GestorYouTube: Mostrando página del video con información: Información del video con ID 1 desde YouTube.
ProxyYouTubeConCache: Comprobando caché de lista de videos...
ProxyYouTubeConCache: Lista de videos no en caché. Obteniendo del servicio real...
LibreriaYouTubeTerceros: Obteniendo lista de videos de YouTube...
GestorYouTube: Mostrando panel con lista de videos: [Video 1, Video 2, Video 3]
--- Segunda interacción (mismas peticiones) ---
ProxyYouTubeConCache: Comprobando caché de información del video ID: 1...
ProxyYouTubeConCache: Información del video ID: 1 encontrada en caché.
GestorYouTube: Mostrando página del video con información: Información del video con ID 1 desde YouTube.
ProxyYouTubeConCache: Comprobando caché de lista de videos...
ProxyYouTubeConCache: Lista de videos encontrada en caché.
GestorYouTube: Mostrando panel con lista de videos: [Video 1, Video 2, Video 3]
```

**Explicación del ejemplo:**

- `LibreriaYouTube` es la **interfaz** para interactuar con la librería de YouTube (simulada).
- `LibreriaYouTubeTerceros` es la **implementación real** (el "Servicio"), que simula las llamadas a la API de YouTube.
- `ProxyYouTubeConCache` es el **Proxy**. Implementa `LibreriaYouTube` y añade **caché** para la lista de videos y la información de los videos.
- `GestorYouTube` (el "Cliente") usa la `LibreriaYouTube` a través de la interfaz. No sabe si está usando la librería real o el Proxy.

En la **primera interacción**, el Proxy no tiene nada en caché, así que llama a la librería real para obtener la información y la lista de videos, y guarda los resultados en la caché.

En la **segunda interacción**, cuando se piden la información del video y la lista de videos de nuevo, el Proxy **encuentra los resultados en la caché** y los devuelve directamente, **sin tener que volver a llamar a la librería real**, ahorrando tiempo y recursos.

#### 3. **Notas o advertencias:**

- Este ejemplo muestra cómo un Proxy puede añadir **caché** para mejorar el rendimiento de una librería externa, **sin modificar la librería original**.
- El Proxy implementa la **misma interfaz** que la librería original, lo que permite usar el Proxy de forma **transparente** en el código cliente.
- En este ejemplo, solo se implementa caché para `listarVideos()` y `obtenerInfoVideo()`. La descarga de videos (`descargarVideo()`) no se guarda en caché (podría hacerse, pero se omite por simplicidad).

---

## G - Aplicabilidad del Proxy

#### 1. **Definición:**

El patrón Proxy es muy versátil y se puede usar en muchas situaciones. Aquí están los usos más comunes:

- **Inicialización Perezosa (Virtual Proxy):** Retrasar la creación de un objeto costoso hasta que realmente se necesite. (Ejemplo: `ProxyDescarga`, `ProxyServicioDatos`, `ProxyYouTubeConCache` en los ejemplos anteriores).

- **Control de Acceso (Protection Proxy):** Permitir el acceso al objeto real solo a ciertos clientes, basándose en permisos o credenciales. (Ejemplo: Imagina un Proxy que verifica si el usuario tiene permiso para eliminar un archivo antes de permitir la operación en el objeto real que gestiona los archivos).

- **Ejecución Local de Servicio Remoto (Remote Proxy):** Representar un objeto que está en un servidor remoto. El Proxy se encarga de la comunicación de red, haciendo que parezca que el objeto remoto está localmente. (Ejemplo: Un "stub" en RMI o gRPC es un tipo de Remote Proxy).

- **Registro de Peticiones (Logging Proxy):** Registrar todas las peticiones que se hacen al objeto real. Útil para auditoría, depuración o monitorización. (Ejemplo: Un Proxy que escribe en un log cada vez que se llama a un método del objeto real).

- **Caché de Resultados (Caching Proxy):** Guardar en caché los resultados de las peticiones al objeto real, especialmente si los resultados son grandes o tardan en obtenerse. (Ejemplo: `ProxyServicioDatos`, `ProxyYouTubeConCache` con la caché de datos y videos).

- **Referencia Inteligente (Smart Reference):** Gestionar la vida útil de un objeto costoso. El Proxy puede contar cuántos clientes están usando el objeto real, y destruirlo (liberar recursos) cuando ya no lo necesite nadie. También puede gestionar la compartición de objetos entre clientes.

#### 2. **Ejemplo (Control de Acceso - Protection Proxy):**

Imagina un sistema de archivos donde solo los administradores pueden eliminar archivos.

```java
interface SistemaArchivos {
    void leerArchivo(String nombreArchivo);
    void escribirArchivo(String nombreArchivo, String contenido);
    void eliminarArchivo(String nombreArchivo); // Solo para administradores
}

class SistemaArchivosReal implements SistemaArchivos {
    @Override
    public void leerArchivo(String nombreArchivo) {
        System.out.println("SistemaArchivosReal: Leyendo archivo: " + nombreArchivo);
        // Lógica real para leer el archivo
    }

    @Override
    public void escribirArchivo(String nombreArchivo, String contenido) {
        System.out.println("SistemaArchivosReal: Escribiendo en archivo: " + nombreArchivo);
        // Lógica real para escribir en el archivo
    }

    @Override
    public void eliminarArchivo(String nombreArchivo) {
        System.out.println("SistemaArchivosReal: Eliminando archivo: " + nombreArchivo);
        // Lógica real para eliminar el archivo
    }
}

class ProxySistemaArchivos implements SistemaArchivos {
    private SistemaArchivosReal sistemaReal;
    private String rolUsuario; // Rol del usuario actual ("admin" o "usuario")

    public ProxySistemaArchivos(String rolUsuario) {
        this.sistemaReal = new SistemaArchivosReal();
        this.rolUsuario = rolUsuario;
    }

    @Override
    public void leerArchivo(String nombreArchivo) {
        sistemaReal.leerArchivo(nombreArchivo); // Todos pueden leer
    }

    @Override
    public void escribirArchivo(String nombreArchivo, String contenido) {
        sistemaReal.escribirArchivo(nombreArchivo, contenido); // Todos pueden escribir (en este ejemplo)
    }

    @Override
    public void eliminarArchivo(String nombreArchivo) {
        if ("admin".equals(rolUsuario)) {
            sistemaReal.eliminarArchivo(nombreArchivo); // Solo administradores pueden eliminar
        } else {
            System.out.println("ProxySistemaArchivos: Permiso denegado. Solo administradores pueden eliminar archivos.");
        }
    }
}

public class ClienteSistemaArchivos {
    public static void main(String[] args) {
        SistemaArchivos sistemaUsuario = new ProxySistemaArchivos("usuario"); // Usuario normal
        SistemaArchivos sistemaAdmin = new ProxySistemaArchivos("admin");     // Administrador

        sistemaUsuario.leerArchivo("documento.txt"); // Usuario puede leer
        sistemaUsuario.eliminarArchivo("documento.txt"); // Usuario NO puede eliminar
        System.out.println("---");
        sistemaAdmin.leerArchivo("config.ini"); // Admin puede leer
        sistemaAdmin.eliminarArchivo("config.ini"); // Admin SI puede eliminar
    }
}
```

**Output del código:**

```
SistemaArchivosReal: Leyendo archivo: documento.txt
ProxySistemaArchivos: Permiso denegado. Solo administradores pueden eliminar archivos.
---
SistemaArchivosReal: Leyendo archivo: config.ini
SistemaArchivosReal: Eliminando archivo: config.ini
```

**Explicación del ejemplo:**

- `SistemaArchivos` es la interfaz para el sistema de archivos.
- `SistemaArchivosReal` es la implementación real del sistema de archivos.
- `ProxySistemaArchivos` es el Proxy de **control de acceso**. Verifica el `rolUsuario` antes de permitir ciertas operaciones.
- Solo si el `rolUsuario` es "admin", el Proxy permite la operación `eliminarArchivo()`. Para otros roles, deniega el acceso.

#### 3. **Notas o advertencias:**

- El Proxy permite **centralizar el control de acceso** a un objeto, sin tener que modificar el objeto real.
- Se pueden implementar diferentes tipos de control de acceso en el Proxy: basado en roles, permisos, credenciales, etc.
- El Proxy **añade una capa de seguridad** al sistema, asegurando que solo los usuarios autorizados puedan realizar ciertas acciones.

---

## H - Cómo implementar el Proxy

#### 1. **Pasos para implementar:**

1.  **Crear la Interfaz del Servicio (si no existe):** Define una interfaz que describa las operaciones que el Servicio y el Proxy deben ofrecer. Si ya existe una clase Servicio y no quieres modificar sus clientes, puedes hacer que el Proxy sea una subclase del Servicio (heredando su interfaz).

2.  **Crear la clase Proxy:** Crea la clase Proxy. Debe:

    - Implementar la **misma interfaz** que el Servicio.
    - Tener un **campo** para guardar una **referencia al objeto Servicio**.
    - En muchos casos, el Proxy se encarga de **crear y gestionar el ciclo de vida** del Servicio. A veces, el Servicio se pasa al Proxy a través del constructor.

3.  **Implementar los métodos del Proxy:** Implementa cada método de la interfaz del Servicio en la clase Proxy. Dentro de cada método del Proxy:

    - Realiza las **operaciones adicionales** que necesites (inicialización perezosa, control de acceso, logging, caché, etc.).
    - **Delega la llamada al objeto Servicio** para que realice el trabajo real. En la mayoría de los casos, después de que el Proxy hace su parte, llama al método correspondiente del objeto Servicio.

4.  **Considerar un método de creación (Factory):** Piensa en crear un método (puede ser estático en la clase Proxy o un Factory Method separado) que decida si el cliente debe obtener un Proxy o un Servicio real directamente. Esto da más flexibilidad para configurar el sistema.

5.  **Implementar la Inicialización Perezosa (si es necesario):** Si el Proxy se usa para la inicialización perezosa, asegúrate de que el objeto Servicio se cree **solo cuando se necesite por primera vez**, dentro del Proxy, en el momento de la primera llamada a uno de sus métodos.

#### 2. **Ejemplo (Resumen de pasos en el ejemplo de Caché de YouTube):**

En el ejemplo de `ProxyYouTubeConCache`:

1.  **Interfaz del Servicio:** `LibreriaYouTube` (ya existía).
2.  **Crear la clase Proxy:** `ProxyYouTubeConCache` implementa `LibreriaYouTube` y tiene un campo `servicioYouTube` (de tipo `LibreriaYouTube`).
3.  **Implementar los métodos del Proxy:** En `listarVideos()`, `obtenerInfoVideo()`, `descargarVideo()` de `ProxyYouTubeConCache`, se implementa la lógica de caché y se delega la llamada al `servicioYouTube` real cuando es necesario.
4.  **Método de creación (opcional):** En el `AplicacionYouTube`, se decide crear un `ProxyYouTubeConCache` pasando un `LibreriaYouTubeTerceros` real. Podríamos haber creado un método factory para esto si fuera más complejo.
5.  **Inicialización Perezosa:** En `ProxyYouTubeConCache`, la inicialización del `servicioYouTube` (aunque en el ejemplo se pasa por constructor) podría haberse hecho perezosa dentro de los métodos del Proxy si fuera necesario.

#### 3. **Notas o advertencias:**

- La **interfaz** es fundamental para la flexibilidad del patrón Proxy.
- Decide **qué tipo de Proxy** necesitas implementar (inicialización perezosa, control de acceso, caché, etc.) y enfócate en esa funcionalidad en los métodos del Proxy.
- Piensa en cómo se va a **crear y configurar** el Proxy y el Servicio en tu aplicación. Un método factory puede simplificar esto.

---

## I - Pros y Contras del Proxy

#### 1. **Pros (Ventajas):**

- **Control sobre el objeto Servicio sin que el cliente lo sepa:** Puedes añadir funcionalidades (caché, control de acceso, logging, etc.) al objeto Servicio **sin que el cliente se dé cuenta** o tenga que cambiar su código. El cliente sigue usando la misma interfaz.
- **Gestión del ciclo de vida del Servicio:** El Proxy puede encargarse de crear, inicializar, y destruir el objeto Servicio, liberando al cliente de esta responsabilidad. Esto es útil para la inicialización perezosa o para gestionar recursos costosos.
- **Funciona incluso si el Servicio no está listo o no está disponible:** En el caso de Remote Proxy o Virtual Proxy, el Proxy puede actuar como un marcador de posición para un Servicio que aún no existe o que está en otro lugar. Puede retrasar la creación del Servicio o manejar la conexión remota.
- **Principio Abierto/Cerrado (Open/Closed Principle):** Puedes introducir nuevos tipos de Proxies (por ejemplo, un Proxy con logging, un Proxy con caché, etc.) **sin tener que modificar el Servicio real ni el código del cliente**. Extiendes la funcionalidad añadiendo Proxies, sin modificar el código existente.

#### 2. **Contras (Desventajas):**

- **Complejidad del código:** Añadir Proxies puede **aumentar el número de clases** en tu proyecto, haciendo que el código sea un poco más complejo de entender y mantener, especialmente si usas muchos tipos de Proxies.
- **Posible retraso en la respuesta del Servicio:** Como el Proxy se interpone entre el cliente y el Servicio, puede añadir una **pequeña sobrecarga de tiempo** a las peticiones. Aunque en muchos casos, las ventajas (como la caché) compensan este pequeño retraso, en situaciones donde el rendimiento es crítico, hay que tenerlo en cuenta.

#### 3. **Notas o advertencias:**

- Evalúa si los **beneficios** de usar el patrón Proxy (control, gestión del ciclo de vida, flexibilidad) **superan la posible complejidad** añadida al código.
- Considera si la **sobrecarga de rendimiento** introducida por el Proxy es aceptable para tu aplicación. En muchos casos, la sobrecarga es mínima y los beneficios son mayores.
- Usa el Proxy cuando realmente necesites **controlar o extender la funcionalidad** de un objeto Servicio de forma **transparente** para el cliente. Si no necesitas este control o extensión, puede que el patrón Proxy sea innecesario.

---

## J - Relaciones con otros patrones

#### 1. **Relaciones con otros patrones de diseño:**

- **Adapter vs. Proxy vs. Decorator:**

  - **Adapter:** Permite acceder a un objeto existente a través de una **interfaz diferente**. **Cambia la interfaz**.
  - **Proxy:** Mantiene la **misma interfaz** que el objeto original (Servicio). **Controla el acceso** al objeto.
  - **Decorator:** Añade **funcionalidad extra** a un objeto **dinámicamente**, a través de una **interfaz mejorada** (aunque a menudo mantiene la interfaz original, añadiendo métodos o comportamiento).

- **Facade vs. Proxy:**

  - **Facade:** Proporciona una **interfaz simplificada** a un sistema complejo. **Oculta la complejidad** del sistema.
  - **Proxy:** Representa a **un objeto específico** (Servicio) y **controla el acceso** a él. No necesariamente simplifica un sistema complejo, sino que controla el acceso a un objeto en particular.
  - **Similitud:** Ambos (Facade y Proxy) pueden **ocultar la complejidad** y **gestionar la inicialización** de objetos.
  - **Diferencia clave:** El Proxy tiene la **misma interfaz** que el Servicio, lo que los hace **intercambiables**. Facade suele ofrecer una interfaz **diferente y más simple**.

- **Decorator vs. Proxy:**
  - **Similitud estructural:** Ambos (Decorator y Proxy) usan **composición**. Un objeto delega parte del trabajo a otro.
  - **Diferencia de intención:**
    - **Proxy:** **Controla el acceso** al objeto Servicio y **gestiona su ciclo de vida**. El Proxy suele crear y gestionar el Servicio por sí mismo.
    - **Decorator:** Añade **funcionalidad adicional** al objeto. La composición de Decorators suele ser **controlada por el cliente**. El cliente decide cómo y cuándo se aplican los Decorators.

#### 2. **Ejemplo (Diferencias clave):**

Imagina una puerta:

- **Proxy:** Un **guarda de seguridad** en la puerta. Verifica tu identificación antes de dejarte pasar (control de acceso). La puerta sigue siendo una puerta, con la misma función básica.
- **Decorator:** Una **puerta blindada**. Añade **seguridad extra** a la puerta (funcionalidad adicional). Sigue siendo una puerta, pero con características mejoradas.
- **Adapter:** Una **puerta giratoria**. Es una forma **diferente de entrar** en el edificio (interfaz diferente). Sigue cumpliendo la función de permitir el acceso, pero de una manera distinta.
- **Facade:** El **botón de apertura automática** de la puerta. Simplifica la forma de abrir la puerta (interfaz simplificada) ocultando el mecanismo complejo de apertura.

#### 3. **Notas o advertencias:**

- Es importante entender la **intención principal** de cada patrón para elegir el más adecuado.
- Aunque algunos patrones pueden parecer similares en estructura, sus **propósitos** y **casos de uso** son diferentes.
- A veces, se pueden **combinar patrones**. Por ejemplo, podrías usar un Proxy y un Decorator juntos para controlar el acceso a un objeto y, al mismo tiempo, añadirle funcionalidad extra.
