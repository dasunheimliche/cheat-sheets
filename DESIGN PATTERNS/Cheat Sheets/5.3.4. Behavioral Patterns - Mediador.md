## A - Mediator

#### 1. **Definición:**

El patrón **Mediator** es como un pacificador para tus objetos. Imagina que tienes un grupo de amigos que siempre se pelean entre ellos. En lugar de dejar que se griten directamente, pones a un mediador en medio. El mediador se encarga de que se comuniquen de forma ordenada, sin tanto lío. En programación, Mediator reduce el caos de dependencias entre objetos, obligándolos a hablar solo a través de un objeto mediador.

#### 2. **Ejemplo:**

Imagina una interfaz de usuario con un botón y un campo de texto. Normalmente, el botón podría interactuar directamente con el campo de texto. Con Mediator, ambos hablan con un "mediador" que decide qué hacer.

```java
// Componente: Botón
class Boton {
    Mediator dialogo;

    public Boton(Mediator dialogo) {
        this.dialogo = dialogo;
    }

    public void hacerClic() {
        dialogo.notificar(this, "clic");
    }
}

// Componente: Campo de Texto
class CampoTexto {
    Mediator dialogo;

    public CampoTexto(Mediator dialogo) {
        this.dialogo = dialogo;
    }

    public void escribirTexto(String texto) {
        dialogo.notificar(this, "textoCambiado");
    }
}

// Interfaz Mediador
interface Mediator {
    void notificar(Object componente, String evento);
}

// Mediador Concreto: Dialogo
class DialogoAutenticacion implements Mediator {
    Boton botonOk;
    CampoTexto usuario;
    CampoTexto contrasena;

    public DialogoAutenticacion() {
        botonOk = new Boton(this);
        usuario = new CampoTexto(this);
        contrasena = new CampoTexto(this);
    }

    public void notificar(Object componente, String evento) {
        if (componente == botonOk && evento.equals("clic")) {
            System.out.println("Botón OK clicado. Validando usuario y contraseña...");
            // Aquí iría la lógica de validación, en lugar de que el botón lo haga directamente.
        }
        if (componente == usuario && evento.equals("textoCambiado")) {
            System.out.println("Campo de usuario cambiado.");
            // Podríamos reaccionar a cambios en el campo de usuario aquí.
        }
    }

    public Boton getBotonOk() {
        return botonOk;
    }

    public CampoTexto getUsuario() {
        return usuario;
    }

    public CampoTexto getContrasena() {
        return contrasena;
    }
}

public class Main {
    public static void main(String[] args) {
        DialogoAutenticacion dialogo = new DialogoAutenticacion();
        dialogo.getBotonOk().hacerClic(); // El botón notifica al diálogo (mediador)
        dialogo.getUsuario().escribirTexto("UsuarioEjemplo"); // El campo de texto notifica al diálogo
    }
}
```

**Explicación del ejemplo:**

En este ejemplo, `Boton` y `CampoTexto` son componentes. En lugar de que el `Boton` valide directamente el `CampoTexto`, ambos notifican al `DialogoAutenticacion` (el mediador) cuando ocurre algo (un clic en el botón, texto cambiado en el campo). El `DialogoAutenticacion` decide qué hacer en respuesta a estas notificaciones. Así, los componentes no se conocen entre sí, solo conocen al mediador.

#### 3. **Notas o advertencias:**

- **Menos lío, más orden:** Mediator ayuda a organizar las relaciones complejas entre objetos, haciendo el código más fácil de entender y mantener.
- **Un mediador central:** Toda la comunicación pasa por el mediador, lo que puede convertirlo en un punto central de control. Si el mediador se vuelve demasiado complejo, puede convertirse en un "objeto dios" (un anti-patrón).
- **Reutilización:** Los componentes se vuelven más fáciles de reutilizar porque no están atados a otros componentes específicos, solo al mediador.

---

## B - Problema: Dependencias Caóticas

#### 1. **Definición:**

Imagina que tienes muchos objetos en tu programa que necesitan hablar entre sí para funcionar. Si cada objeto habla directamente con muchos otros, se crea una red enredada de conexiones. Esto es lo que llamamos **dependencias caóticas**. Es como un plato de espaguetis: todo está mezclado y es difícil desenredar. Cuando hay dependencias caóticas, cambiar una cosa puede romper muchas otras, y entender cómo funciona todo se vuelve muy complicado.

#### 2. **Ejemplo:**

Piensa en un formulario web con varios campos (nombre, email, contraseña) y un botón de "Enviar".

![Relaciones caóticas entre elementos de la interfaz de usuario](https://refactoring.guru/images/patterns/diagrams/mediator/problem1-en.png)

- **Sin Mediator:** El botón "Enviar" necesita saber de todos los campos para validar que estén correctos antes de enviar el formulario. Si añades un nuevo campo, ¡tienes que cambiar el botón! El campo de "contraseña" podría tener lógica para mostrar un mensaje de "contraseña débil" que interactúa directamente con otro elemento de la interfaz. Todo se conecta con todo.

![Los elementos de la interfaz de usuario son interdependientes](https://refactoring.guru/images/patterns/diagrams/mediator/problem2.png)

**Explicación del ejemplo:**

En este escenario, cada elemento del formulario (botones, campos de texto, checkboxes) conoce y depende de muchos otros. Si quieres cambiar algo, como la forma en que se valida el formulario, tienes que tocar muchos lugares diferentes. Esto hace que el código sea frágil y difícil de mantener.

#### 3. **Notas o advertencias:**

- **Código espagueti:** Las dependencias caóticas llevan a un código difícil de seguir y modificar, como un plato de espagueti enredado.
- **Reutilización difícil:** Componentes que dependen mucho de otros son difíciles de usar en otros proyectos o partes del mismo proyecto.
- **Mantenimiento complicado:** Hacer cambios o arreglar errores se vuelve una pesadilla porque no sabes qué más vas a romper al cambiar algo.

---

## C - Solución: El Mediador al Rescate

#### 1. **Definición:**

El patrón Mediator propone una solución sencilla: **dejar de que los objetos se hablen directamente**. En lugar de eso, introduces un objeto **Mediador**. Todos los objetos "componentes" solo hablan con el Mediador. Si un componente necesita "decirle" algo a otro, se lo dice al Mediador, y el Mediador se encarga de pasárselo al componente correcto. Es como si todos los amigos peleones ahora solo hablaran con el pacificador.

#### 2. **Ejemplo:**

Volviendo al formulario web, ahora usamos un Mediador (por ejemplo, la clase `FormularioDialogo`).

![Los elementos de la interfaz de usuario deben comunicarse a través del mediador.](https://refactoring.guru/images/patterns/diagrams/mediator/solution1-en.png)

- **Con Mediator:** El botón "Enviar" ya no necesita saber nada sobre los campos. Cuando se hace clic, simplemente notifica al `FormularioDialogo`. El `FormularioDialogo` es quien sabe sobre todos los campos y se encarga de validar la información. Si añades un nuevo campo, solo tienes que actualizar el `FormularioDialogo`, ¡no el botón!

**Explicación del ejemplo:**

Ahora, cada componente (botón, campo de texto) solo conoce al `FormularioDialogo` (el mediador). Cuando ocurre un evento (clic, cambio de texto), el componente notifica al mediador. El mediador decide qué otros componentes deben ser notificados o qué acciones tomar. La comunicación se vuelve indirecta y centralizada.

#### 3. **Notas o advertencias:**

- **Comunicación indirecta:** Los componentes ya no se comunican directamente, lo hacen a través del mediador.
- **Centralización del control:** El mediador se convierte en el punto central para la lógica de comunicación y coordinación.
- **Componentes desacoplados:** Los componentes se vuelven más independientes y menos dependientes entre sí.

---

## D - Analogía del Mundo Real: Torre de Control Aéreo

#### 1. **Definición:**

Para entender mejor Mediator, piensa en una **torre de control aéreo**.

![Torre de control aéreo](https://refactoring.guru/images/patterns/diagrams/mediator/live-example.png)

En un aeropuerto, muchos aviones quieren aterrizar y despegar. Si los pilotos hablaran directamente entre ellos para decidir quién va primero, ¡sería un caos total! En lugar de eso, todos los pilotos se comunican con la torre de control. La torre de control (el mediador) coordina todo: dice a qué avión aterrizar, a cuál esperar, etc. Los pilotos (los componentes) solo hablan con la torre, no entre ellos.

#### 2. **Ejemplo:**

- **Pilotos (Componentes):** Cada piloto quiere aterrizar o despegar.
- **Torre de Control (Mediador):** Coordina los aterrizajes y despegues, evitando colisiones y caos.
- **Comunicación:** Los pilotos no hablan entre ellos directamente. Todos se comunican con la torre de control.

**Explicación de la analogía:**

La torre de control es el mediador que gestiona la comunicación entre los pilotos. Cada piloto solo necesita saber cómo comunicarse con la torre, no con los otros pilotos. Esto simplifica mucho la gestión del tráfico aéreo y evita problemas. En programación, Mediator hace lo mismo: simplifica la comunicación entre objetos.

#### 3. **Notas o advertencias:**

- **Orden en el caos:** La torre de control pone orden en un sistema potencialmente caótico.
- **Comunicación centralizada:** Toda la comunicación pasa por la torre de control.
- **Evita colisiones:** El mediador evita "colisiones" o conflictos entre componentes al coordinar sus interacciones.

---

## E - Estructura del Patrón Mediator

#### 1. **Definición:**

El patrón Mediator tiene varios elementos clave que trabajan juntos:

![Estructura del patrón de diseño Mediator](https://refactoring.guru/images/patterns/diagrams/mediator/structure.png)![Estructura del patrón de diseño Mediator](https://refactoring.guru/images/patterns/diagrams/mediator/structure-indexed.png)

1.  **Componentes:** Son los objetos que hacen el trabajo real en tu programa (como los pilotos en la analogía). Cada componente conoce al Mediador.
2.  **Interfaz Mediator:** Define cómo los componentes se comunican con el Mediador. Normalmente, tiene un método como `notificar(componente, evento)`.
3.  **Mediador Concreto:** Es la clase que implementa la interfaz Mediator. Conoce a todos los componentes y decide qué hacer cuando un componente notifica un evento.

#### 2. **Ejemplo (en términos de la estructura):**

- **Componentes:** `Boton`, `CampoTexto`, `Checkbox` (en el ejemplo del formulario).
- **Interfaz Mediator:** `Mediator` (la interfaz Java del ejemplo).
- **Mediador Concreto:** `DialogoAutenticacion` (la clase Java del ejemplo).

**Explicación de la estructura:**

Los componentes no se conocen entre sí. Cada componente tiene una referencia al `Mediator`. Cuando un componente necesita interactuar con otros, llama al método `notificar()` del Mediador, diciéndole qué evento ha ocurrido. El Mediador Concreto recibe la notificación y decide qué otros componentes deben reaccionar.

#### 3. **Notas o advertencias:**

- **Componentes ignorantes:** Los componentes no saben nada de otros componentes. Solo conocen al Mediador.
- **Mediador orquestador:** El Mediador es como un director de orquesta, coordinando a todos los componentes.
- **Flexibilidad:** Puedes cambiar el Mediador sin cambiar los componentes, siempre que el nuevo Mediador implemente la misma interfaz.

---

## F - Seudocódigo de Ejemplo (Adaptado a Java)

#### 1. **Definición:**

Este es un ejemplo más detallado en pseudocódigo (adaptado a la sintaxis de Java para que sea más claro) que muestra cómo funciona Mediator en un diálogo de autenticación.

![Estructura del ejemplo del patrón Mediator](https://refactoring.guru/images/patterns/diagrams/mediator/example.png)

#### 2. **Ejemplo (Pseudocódigo Java):**

```java
// Interfaz Mediador
interface Mediator {
    void notificar(Componente sender, String evento);
}

// Mediador Concreto
class DialogoAutenticacion implements Mediator {
    String titulo;
    Checkbox checkboxLoginRegistro;
    Textbox campoUsuarioLogin, campoContrasenaLogin;
    Textbox campoUsuarioRegistro, campoContrasenaRegistro, campoEmailRegistro;
    Boton botonOk, botonCancelar;

    public DialogoAutenticacion() {
        // Crear componentes, pasando 'this' (el mediador) a cada uno
        checkboxLoginRegistro = new Checkbox(this);
        campoUsuarioLogin = new Textbox(this);
        // ... (crear todos los demás componentes)
        botonOk = new Boton(this);
        botonCancelar = new Boton(this);
    }

    public void notificar(Componente sender, String evento) {
        if (sender == checkboxLoginRegistro && evento.equals("check")) {
            if (checkboxLoginRegistro.estaChequeado()) {
                titulo = "Iniciar Sesión";
                // Mostrar formulario de login, ocultar registro
            } else {
                titulo = "Registrarse";
                // Mostrar formulario de registro, ocultar login
            }
        }

        if (sender == botonOk && evento.equals("click")) {
            if (checkboxLoginRegistro.estaChequeado()) {
                // Validar login
                // ...
            } else {
                // Validar registro
                // ...
            }
        }
    }
}

// Clase base Componente
class Componente {
    Mediator dialogo;

    public Componente(Mediator dialogo) {
        this.dialogo = dialogo;
    }

    public void clic() {
        dialogo.notificar(this, "click");
    }

    public void teclaPresionada() {
        dialogo.notificar(this, "keypress");
    }
}

// Componentes Concretos
class Boton extends Componente {
    // ...
    public Boton(Mediator dialogo) { super(dialogo); }
}

class Textbox extends Componente {
    // ...
    public Textbox(Mediator dialogo) { super(dialogo); }
}

class Checkbox extends Componente {
    // ...
    public Checkbox(Mediator dialogo) { super(dialogo); }
    public void chequear() { dialogo.notificar(this, "check"); }
}
```

**Explicación del ejemplo:**

Este pseudocódigo muestra cómo un diálogo de autenticación actúa como mediador. Cuando el usuario interactúa con un componente (checkbox, botón), el componente notifica al diálogo. El diálogo decide qué hacer, como mostrar u ocultar campos, o validar la información. Los componentes en sí no saben qué otros componentes existen ni cómo interactúan entre sí.

#### 3. **Notas o advertencias:**

- **Ejemplo de UI:** Este ejemplo se centra en interfaces de usuario, donde Mediator es muy útil para gestionar interacciones complejas.
- **Notificaciones:** La clave es el método `notificar()` en el Mediador, que es cómo los componentes le informan de los eventos.
- **Lógica en el Mediador:** La lógica de coordinación y reacción a eventos se concentra en el Mediador Concreto.

---

## G - Aplicabilidad del Patrón Mediator

#### 1. **Definición:**

¿Cuándo deberías usar el patrón Mediator? Es útil en estas situaciones:

- **Clases muy acopladas:** Cuando tienes muchas clases que dependen fuertemente unas de otras y es difícil hacer cambios sin romper algo.
- **Reutilización difícil:** Cuando no puedes reutilizar un componente en otro programa porque está demasiado atado a otros componentes específicos.
- **Muchas subclases:** Cuando estás creando muchas subclases de componentes solo para cambiar cómo interactúan en diferentes contextos.

#### 2. **Ejemplos de cuándo usar Mediator:**

- **Interfaces de usuario complejas:** Formularios con muchas interacciones entre campos, botones, etc.
- **Sistemas de chat:** Un mediador puede gestionar la comunicación entre usuarios en un chat.
- **Sistemas de control de tráfico aéreo (¡como vimos antes!):** Coordinar diferentes partes del sistema.

**Explicación de la aplicabilidad:**

Mediator es genial cuando tienes un grupo de objetos que necesitan trabajar juntos, pero no quieres que se enreden en dependencias directas. Ayuda a simplificar las relaciones complejas y a hacer el código más flexible y fácil de mantener.

#### 3. **Notas o advertencias:**

- **No para todo:** No uses Mediator si las interacciones entre objetos son simples y directas. A veces, añadir un mediador puede ser exagerado.
- **Complejidad movida:** Mediator no elimina la complejidad, la mueve al objeto mediador. Si el mediador se vuelve demasiado complejo, puede ser un problema.
- **Beneficios a largo plazo:** La inversión en Mediator suele valer la pena a largo plazo, especialmente en sistemas grandes y complejos que cambian con el tiempo.

---

## H - Cómo Implementar el Patrón Mediator

#### 1. **Definición:**

Implementar Mediator tiene varios pasos:

1.  **Identifica las clases acopladas:** Encuentra los grupos de clases que están muy conectadas y que se beneficiarían de ser más independientes.
2.  **Define la interfaz Mediator:** Crea una interfaz que defina cómo los componentes se comunicarán con el mediador. Normalmente, un método `notificar()` es suficiente.
3.  **Implementa el Mediador Concreto:** Crea una clase que implemente la interfaz Mediator. Esta clase tendrá referencias a todos los componentes que gestiona.
4.  **Opcional: Gestión del ciclo de vida:** El mediador puede encargarse de crear y destruir los componentes.
5.  **Componentes conocen al Mediador:** Cada componente debe tener una referencia al objeto mediador. Esto suele hacerse en el constructor del componente.
6.  **Componentes notifican al Mediador:** Cambia el código de los componentes para que llamen al método `notificar()` del mediador en lugar de llamar directamente a otros componentes. Mueve la lógica de interacción al mediador.

#### 2. **Ejemplo (Pasos en el ejemplo del formulario):**

1.  **Clases acopladas:** `Boton`, `CampoTexto`, `Checkbox` (en un formulario sin Mediator).
2.  **Interfaz Mediator:** `Mediator` (interfaz Java con `notificar()`).
3.  **Mediador Concreto:** `DialogoAutenticacion` (clase Java que implementa `Mediator`).
4.  **Gestión del ciclo de vida (opcional):** En el ejemplo, `DialogoAutenticacion` crea los componentes en su constructor.
5.  **Componentes conocen al Mediador:** Cada componente (ej. `Boton`) recibe el `Mediator` en su constructor.
6.  **Componentes notifican al Mediador:** `Boton.hacerClic()` llama a `dialogo.notificar(this, "clic")` en lugar de interactuar directamente con otros componentes.

**Explicación de la implementación:**

La clave es mover la lógica de coordinación de los componentes a la clase Mediador. Los componentes se vuelven más simples y solo se preocupan por notificar eventos al mediador.

#### 3. **Notas o advertencias:**

- **Iterativo:** Implementar Mediator puede ser un proceso iterativo. Puede que necesites refinar la interfaz Mediator y la lógica del Mediador Concreto a medida que avanzas.
- **Refactorización:** A menudo, aplicar Mediator implica refactorizar código existente para desacoplar componentes.
- **Pruebas:** Asegúrate de probar bien tu código después de aplicar Mediator para verificar que las interacciones siguen funcionando correctamente a través del mediador.

---

## I - Pros y Contras del Patrón Mediator

#### 1. **Definición:**

Como todo patrón, Mediator tiene ventajas y desventajas:

**Pros (Ventajas):**

- **Principio de Responsabilidad Única:** La comunicación entre componentes se centraliza en el mediador, haciendo el código más fácil de entender y mantener.
- **Principio Abierto/Cerrado:** Puedes añadir nuevos mediadores sin cambiar los componentes existentes.
- **Reducción del Acoplamiento:** Disminuye las dependencias directas entre componentes.
- **Reutilización de Componentes:** Los componentes se vuelven más fáciles de reutilizar en diferentes contextos.

**Contras (Desventajas):**

- **Mediador como Objeto Dios:** El mediador puede volverse demasiado grande y complejo, convirtiéndose en un "objeto dios" que lo sabe y lo hace todo.

#### 2. **Ejemplos de Pros y Contras:**

- **Pro: Facilidad de mantenimiento:** Si necesitas cambiar la lógica de cómo interactúan los componentes, solo tienes que modificar el mediador, no todos los componentes.
- **Pro: Reutilización:** Puedes usar el mismo componente `Boton` en diferentes diálogos (mediadores) con comportamientos diferentes.
- **Contra: Mediador complejo:** Si el mediador gestiona demasiadas cosas, puede volverse difícil de entender y mantener él mismo.

**Explicación de Pros y Contras:**

Mediator es una herramienta poderosa para organizar sistemas complejos, pero hay que usarlo con cuidado. Si el mediador se vuelve demasiado grande, puede anular algunos de los beneficios del patrón.

#### 3. **Notas o advertencias:**

- **Equilibrio:** Busca un equilibrio. No hagas el mediador demasiado simple (que no coordine lo suficiente) ni demasiado complejo (que se convierta en un objeto dios).
- **Refactorización gradual:** Aplica Mediator de forma gradual, refactorizando partes de tu sistema poco a poco.
- **Vigila la complejidad del mediador:** Si ves que tu mediador se está volviendo demasiado grande, considera dividirlo en mediadores más pequeños o usar otros patrones para gestionar la complejidad.

---

## J - Relación con Otros Patrones

#### 1. **Definición:**

Mediator se relaciona con otros patrones de diseño que también se centran en la comunicación entre objetos:

- **Chain of Responsibility, Command, Observer:** Estos patrones, junto con Mediator, abordan diferentes formas de conectar emisores y receptores de solicitudes.
  - **Chain of Responsibility:** Pasa una solicitud a través de una cadena de posibles receptores hasta que uno la maneja.
  - **Command:** Establece conexiones unidireccionales entre emisores y receptores.
  - **Mediator:** Elimina conexiones directas, forzando la comunicación a través de un mediador.
  - **Observer:** Permite a los receptores suscribirse y desuscribirse dinámicamente para recibir solicitudes.
- **Facade:** Facade y Mediator buscan organizar la colaboración entre muchas clases acopladas.
  - **Facade:** Proporciona una interfaz simplificada a un subsistema, pero no añade nueva funcionalidad. El subsistema no conoce la fachada.
  - **Mediator:** Centraliza la comunicación entre componentes. Los componentes solo conocen al mediador y no se comunican directamente.
- **Observer (Relación cercana):** A veces, Mediator y Observer pueden parecer similares, e incluso se pueden usar juntos. Un mediador puede usar Observer internamente para notificar a los componentes.

#### 2. **Ejemplos de Relaciones:**

- **Mediator vs. Observer:** Imagina un sistema de noticias. Con **Observer**, cada periódico (observador) se suscribe a una agencia de noticias (sujeto) y recibe noticias directamente. Con **Mediator**, habría un "editor" (mediador) que recibe noticias de varias fuentes y decide qué periódicos reciben qué noticias.
- **Mediator vs. Facade:** **Facade** es como la "cara bonita" de un sistema complejo, simplificando su uso. **Mediator** es como el "cerebro" detrás de escena, gestionando las interacciones internas.

**Explicación de las Relaciones:**

Es importante entender las diferencias y similitudes entre Mediator y otros patrones para elegir el más adecuado para cada situación. A veces, incluso puedes combinar patrones para resolver problemas más complejos.

#### 3. **Notas o advertencias:**

- **Elige el patrón correcto:** No todos los patrones son iguales. Piensa en el problema que estás resolviendo y elige el patrón que mejor se adapte.
- **Combinación de patrones:** A veces, la mejor solución es usar una combinación de patrones. Por ejemplo, puedes usar Mediator para la coordinación general y Observer para notificaciones específicas dentro del sistema mediado.
- **Comprende las diferencias sutiles:** Las diferencias entre Mediator, Observer, etc., pueden ser sutiles, pero entenderlas te ayudará a diseñar sistemas más robustos y flexibles.
