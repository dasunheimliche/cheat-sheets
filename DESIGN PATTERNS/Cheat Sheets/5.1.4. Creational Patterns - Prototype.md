## A - Prototype

#### 1. **Definición:**

El patrón **Prototype** es como tener un "molde mágico" para crear copias exactas de objetos. Imagina que tienes una figura de plastilina muy chula y quieres hacer copias idénticas sin tener que modelar cada una desde cero. Prototype te permite hacer esto en programación. En lugar de depender de las clases concretas de los objetos que quieres copiar, **Prototype delega la responsabilidad de la copia a los propios objetos**.

![Prototype Design Pattern](https://refactoring.guru/images/patterns/content/prototype/prototype.png)

#### 2. **Ejemplo:**

Imagina que estamos creando un juego y necesitamos muchos enemigos que son casi iguales, pero con pequeñas diferencias. En lugar de crear cada enemigo desde cero, podemos tener un "enemigo prototipo" y clonarlo para crear nuevos enemigos rápidamente.

```java
// 1. Interfaz Prototype
interface EnemigoPrototype {
    EnemigoPrototype clonar();
    void mostrarInfo();
}

// 2. Prototype Concreto
class EnemigoBase implements EnemigoPrototype {
    private String tipo;
    private int vida;

    public EnemigoBase(String tipo, int vida) {
        this.tipo = tipo;
        this.vida = vida;
    }

    // Constructor de copia (para el clon)
    public EnemigoBase(EnemigoBase fuente) {
        this.tipo = fuente.tipo;
        this.vida = fuente.vida;
    }

    @Override
    public EnemigoPrototype clonar() {
        // Usamos el constructor de copia para crear un nuevo objeto
        return new EnemigoBase(this);
    }

    @Override
    public void mostrarInfo() {
        System.out.println("Tipo de enemigo: " + tipo + ", Vida: " + vida);
    }
}

// 3. Cliente
public class Juego {
    public static void main(String[] args) {
        // Crear un prototipo
        EnemigoBase prototipoGoblin = new EnemigoBase("Goblin", 50);

        // Clonar el prototipo para crear nuevos enemigos
        EnemigoPrototype enemigo1 = prototipoGoblin.clonar();
        EnemigoPrototype enemigo2 = prototipoGoblin.clonar();

        System.out.println("Enemigo 1:");
        enemigo1.mostrarInfo(); // Output: Tipo de enemigo: Goblin, Vida: 50
        System.out.println("Enemigo 2:");
        enemigo2.mostrarInfo(); // Output: Tipo de enemigo: Goblin, Vida: 50
    }
}
```

**Explicación del ejemplo:**

- **`EnemigoPrototype` (Interfaz Prototype):** Define la operación `clonar()`. Cualquier clase que quiera ser un prototipo debe implementar esta interfaz.
- **`EnemigoBase` (Prototype Concreto):** Es una clase concreta que implementa `EnemigoPrototype`. Tiene un constructor normal y un **constructor de copia** que se usa para crear clones. El método `clonar()` crea y devuelve una nueva instancia de `EnemigoBase` usando el constructor de copia.
- **`Juego` (Cliente):** Crea un `prototipoGoblin` y luego usa el método `clonar()` para crear `enemigo1` y `enemigo2`. ¡Ahora tenemos dos goblins idénticos sin crear cada uno desde cero!

#### 3. **Notas o advertencias:**

- **Constructor de copia:** La clave aquí es el constructor de copia. Este constructor toma un objeto de la misma clase como argumento y copia todos sus valores a la nueva instancia.
- **Clonado superficial vs. profundo:** En este ejemplo, hacemos un clonado "superficial", lo que significa que si nuestro objeto prototipo tuviera otros objetos dentro (como listas u otros objetos complejos), solo copiaríamos la _referencia_ a esos objetos, no los objetos en sí mismos. Si necesitas copiar también los objetos internos, necesitarías un "clonado profundo", que es un poco más complicado. Para este ejemplo sencillo, el clonado superficial es suficiente.

## B - Intención del Prototype

#### 1. **Definición:**

La **intención** principal del patrón Prototype es permitirte **copiar objetos existentes sin que tu código dependa de sus clases concretas**. Esto es súper útil cuando no sabes de qué clase exacta es un objeto, pero necesitas hacer una copia de él.

#### 2. **Ejemplo:**

Imagina que tienes una función que recibe objetos de diferentes tipos, todos implementando una interfaz común llamada `Dibujable`. No sabes si te van a pasar un `Circulo`, un `Rectangulo` o un `Triangulo`, pero necesitas duplicar el objeto que te pasen. Con Prototype, puedes hacerlo sin importar la clase concreta.

```java
interface DibujablePrototype {
    DibujablePrototype clonar();
    void dibujar();
}

class Circulo implements DibujablePrototype {
    private int radio;

    public Circulo(int radio) {
        this.radio = radio;
    }
    public Circulo(Circulo fuente) { // Constructor de copia
        this.radio = fuente.radio;
    }

    @Override
    public DibujablePrototype clonar() {
        return new Circulo(this);
    }
    @Override
    public void dibujar() {
        System.out.println("Dibujando un círculo de radio " + radio);
    }
}
// ... (Rectangulo y Triangulo implementando DibujablePrototype de forma similar) ...


public class ClienteDibujo {
    public static void main(String[] args) {
        Circulo circuloOriginal = new Circulo(10);
        DibujablePrototype copiaCirculo = circuloOriginal.clonar(); // No importa que sea Circulo!

        copiaCirculo.dibujar(); // Output: Dibujando un círculo de radio 10
    }

    public static DibujablePrototype duplicarObjeto(DibujablePrototype objeto) {
        return objeto.clonar(); // ¡Funciona con cualquier DibujablePrototype!
    }
}
```

**Explicación del ejemplo:**

La función `duplicarObjeto` puede recibir cualquier objeto que implemente `DibujablePrototype` y clonarlo sin saber si es un `Circulo`, `Rectangulo` o `Triangulo`. ¡Esto es genial porque desacoplamos nuestro código de las clases concretas!

#### 3. **Notas o advertencias:**

- **Desacoplamiento:** Prototype promueve el desacoplamiento. Tu código cliente no necesita conocer las clases específicas de los objetos que clona. Solo necesita saber que implementan la interfaz `Prototype`.
- **Flexibilidad:** Puedes añadir nuevas clases de objetos clonables sin modificar el código cliente que los utiliza.

## C - Problema que resuelve Prototype

#### 1. **Definición:**

El problema principal que Prototype soluciona es la **dificultad de crear copias exactas de objetos, especialmente cuando no conoces su clase concreta o cuando los objetos tienen partes privadas que no puedes acceder desde fuera.**

![What can go wrong when copying things “from the outside"?” width=](https://refactoring.guru/images/patterns/content/prototype/prototype-comic-1-en.png)

#### 2. **Ejemplo:**

Imagina que estás trabajando con una librería externa que te devuelve objetos de diferentes tipos, todos bajo una interfaz común `Documento`. Quieres hacer copias de estos documentos para modificarlos sin alterar los originales. Si intentas crear copias "a mano" desde fuera, te encontrarás con problemas:

- **Campos privados:** No puedes acceder a los campos privados de los objetos `Documento` para copiarlos.
- **Dependencia de la clase concreta:** Si intentas crear una copia, necesitas saber la clase concreta del `Documento` (¿es un `DocumentoTexto`, `DocumentoImagen`, etc.?) para poder instanciar un nuevo objeto de la misma clase. Esto hace que tu código dependa de esas clases concretas, lo cual es malo si la librería cambia o si quieres añadir nuevos tipos de `Documento`.

```java
interface Documento {
    Documento clonar();
    void mostrarInfo();
}

class DocumentoTexto implements Documento {
    private String contenido; // Campo privado!

    public DocumentoTexto(String contenido) {
        this.contenido = contenido;
    }
    public DocumentoTexto(DocumentoTexto fuente) { // Constructor de copia
        this.contenido = fuente.contenido;
    }

    @Override
    public Documento clonar() {
        return new DocumentoTexto(this);
    }
    @Override
    public void mostrarInfo() {
        System.out.println("Documento de texto: " + contenido);
    }
}

public class ProcesadorDocumentos {
    public static void main(String[] args) {
        Documento documentoOriginal = new DocumentoTexto("Este es el documento original.");

        // Intentar copiar "a mano" desde fuera (¡IMPOSIBLE por campos privados!)
        // Documento copiaDocumento = new DocumentoTexto(documentoOriginal.contenido); // ¡Error! contenido es privado

        // Usando Prototype (¡SOLUCIÓN!)
        Documento copiaDocumento = documentoOriginal.clonar();

        System.out.println("Documento Original:");
        documentoOriginal.mostrarInfo();
        System.out.println("Copia del Documento:");
        copiaDocumento.mostrarInfo();
    }
}
```

**Explicación del ejemplo:**

Intentar copiar `DocumentoTexto` desde fuera es imposible porque `contenido` es privado. Pero con Prototype, el objeto `DocumentoTexto` _se copia a sí mismo_ desde dentro, teniendo acceso a sus propios campos privados. ¡Problema resuelto!

#### 3. **Notas o advertencias:**

- **Encapsulamiento:** Prototype respeta el principio de encapsulamiento. La copia se realiza dentro del objeto, que tiene acceso a sus partes internas.
- **Independencia de la clase:** El código cliente no necesita saber la clase concreta de `DocumentoTexto` para clonarlo. Solo necesita llamar al método `clonar()`.

## D - Solución que ofrece Prototype

#### 1. **Definición:**

La **solución** que ofrece el patrón Prototype es **delegar el proceso de clonación a los propios objetos que se van a clonar.** Esto se hace definiendo una interfaz común (`Prototype`) con un método `clonar()`. Cada clase concreta que quiera ser clonable implementa esta interfaz y proporciona su propia lógica de clonación dentro del método `clonar()`.

#### 2. **Ejemplo:**

Volvamos al ejemplo de las formas geométricas. Con Prototype, cada forma (Círculo, Rectángulo) sabe cómo clonarse a sí misma.

```java
// 1. Interfaz Prototype
interface FormaPrototype {
    FormaPrototype clonar();
    void dibujar();
}

// 2. Prototypes Concretos
class Rectangulo implements FormaPrototype {
    private int ancho;
    private int alto;

    public Rectangulo(int ancho, int alto) {
        this.ancho = ancho;
        this.alto = alto;
    }
    public Rectangulo(Rectangulo fuente) { // Constructor de copia
        this.ancho = fuente.ancho;
        this.alto = fuente.alto;
    }

    @Override
    public FormaPrototype clonar() {
        return new Rectangulo(this);
    }
    @Override
    public void dibujar() {
        System.out.println("Dibujando un rectángulo de " + ancho + "x" + alto);
    }
}

class CirculoForma implements FormaPrototype { // Renombrado para evitar conflicto con ejemplo anterior
    private int radio;

    public CirculoForma(int radio) {
        this.radio = radio;
    }
    public CirculoForma(CirculoForma fuente) { // Constructor de copia
        this.radio = fuente.radio;
    }

    @Override
    public FormaPrototype clonar() {
        return new CirculoForma(this);
    }
    @Override
    public void dibujar() {
        System.out.println("Dibujando un círculo de radio " + radio);
    }
}


// 3. Cliente
public class ClienteFormas {
    public static void main(String[] args) {
        Rectangulo rectanguloOriginal = new Rectangulo(10, 20);
        FormaPrototype copiaRectangulo = rectanguloOriginal.clonar(); // ¡Rectangulo sabe clonarse!

        CirculoForma circuloOriginal = new CirculoForma(5);
        FormaPrototype copiaCirculo = circuloOriginal.clonar(); // ¡Circulo sabe clonarse!

        copiaRectangulo.dibujar(); // Output: Dibujando un rectángulo de 10x20
        copiaCirculo.dibujar();   // Output: Dibujando un círculo de radio 5
    }
}
```

**Explicación del ejemplo:**

Cada clase `Rectangulo` y `CirculoForma` implementa `FormaPrototype` y define su propio método `clonar()`. Cuando el cliente llama a `clonar()`, cada objeto sabe cómo crear una copia de sí mismo correctamente.

#### 3. **Notas o advertencias:**

- **Interfaz `Prototype`:** La interfaz `Prototype` (en este caso `FormaPrototype`) es clave. Define el contrato para la clonación.
- **Método `clonar()`:** Cada clase concreta implementa el método `clonar()` de forma específica para crear una copia de sí misma. Normalmente, esto implica usar el constructor de copia.

## E - Analogía del mundo real

#### 1. **Definición:**

Una buena **analogía del mundo real** para el patrón Prototype es la **división celular mitótica**. En la mitosis, una célula original (el prototipo) se divide para crear dos células hijas idénticas. La célula original participa activamente en la creación de la copia.

![The cell division](https://refactoring.guru/images/patterns/content/prototype/prototype-comic-3-en.png)

#### 2. **Ejemplo:**

Piensa en una célula madre que se divide para crear dos células hijas idénticas. La célula madre es el prototipo, y el proceso de división es como el método `clonar()`. Las células hijas son las copias, y son independientes de la célula madre después de la división.

#### 3. **Notas o advertencias:**

- **No prototipos industriales:** Aunque a veces se habla de "prototipos" en la industria, esos prototipos suelen ser modelos de prueba y no se copian a sí mismos. La analogía de la división celular es más precisa para el patrón Prototype en programación.
- **Prototipo activo:** En el patrón Prototype, el objeto prototipo juega un papel activo en la creación de las copias, a través del método `clonar()`.

## F - Estructura del Prototype

#### 1. **Definición:**

La estructura del patrón Prototype se compone de los siguientes elementos principales:

**Implementación básica:**

![The structure of the Prototype design pattern](https://refactoring.guru/images/patterns/diagrams/prototype/structure.png)

1.  **Prototype (Interfaz):** Declara el método `clonar()`. En nuestros ejemplos, `EnemigoPrototype`, `DibujablePrototype`, `Documento`, `FormaPrototype` son interfaces Prototype.
2.  **Concrete Prototype (Prototipos Concretos):** Implementan la interfaz `Prototype` y el método `clonar()`. `EnemigoBase`, `Circulo`, `Rectangulo`, `DocumentoTexto`, `Rectangulo`, `CirculoForma` son ejemplos de Prototypes Concretos. Aquí es donde se define la lógica de clonación.
3.  **Client (Cliente):** Crea copias de los Prototypes llamando al método `clonar()`. Las clases `Juego`, `ClienteDibujo`, `ProcesadorDocumentos`, `ClienteFormas` son ejemplos de Clientes.

**Implementación con registro de Prototypes (Prototype Registry):**

![The prototype registry](https://refactoring.guru/images/patterns/diagrams/prototype/structure-prototype-cache.png)

1.  **Prototype Registry (Registro de Prototypes):** Es un lugar centralizado para almacenar y acceder a Prototypes pre-configurados. Piensa en él como una "biblioteca" de Prototypes listos para ser clonados. Puede ser un mapa (nombre -> prototipo) o algo más complejo.

#### 2. **Ejemplo (Registro de Prototypes):**

Imagina que en nuestro juego tenemos varios tipos de enemigos prototipo pre-configurados (Goblin, Orco, Troll). Podemos usar un Registro de Prototypes para gestionarlos.

```java
import java.util.HashMap;
import java.util.Map;

// ... (EnemigoPrototype y EnemigoBase como antes) ...

// 4. Prototype Registry
class RegistroEnemigos {
    private Map<String, EnemigoPrototype> prototipos = new HashMap<>();

    public void registrarPrototipo(String nombre, EnemigoPrototype prototipo) {
        prototipos.put(nombre, prototipo);
    }

    public EnemigoPrototype obtenerPrototipo(String nombre) {
        return prototipos.get(nombre).clonar(); // Clonamos el prototipo registrado
    }
}

public class JuegoRegistro {
    public static void main(String[] args) {
        RegistroEnemigos registro = new RegistroEnemigos();

        // Crear y registrar prototipos
        EnemigoBase prototipoGoblin = new EnemigoBase("Goblin", 50);
        registro.registrarPrototipo("goblin", prototipoGoblin);

        EnemigoBase prototipoOrco = new EnemigoBase("Orco", 100);
        registro.registrarPrototipo("orco", prototipoOrco);

        // Obtener y clonar prototipos desde el registro
        EnemigoPrototype enemigoGoblin1 = registro.obtenerPrototipo("goblin");
        EnemigoPrototype enemigoOrco1 = registro.obtenerPrototipo("orco");

        System.out.println("Enemigo Goblin 1:");
        enemigoGoblin1.mostrarInfo(); // Output: Tipo de enemigo: Goblin, Vida: 50
        System.out.println("Enemigo Orco 1:");
        enemigoOrco1.mostrarInfo();   // Output: Tipo de enemigo: Orco, Vida: 100
    }
}
```

**Explicación del ejemplo (Registro de Prototypes):**

- **`RegistroEnemigos`:** Es nuestro Prototype Registry. Almacena Prototypes en un `HashMap` usando nombres como clave.
- **`registrarPrototipo()`:** Añade un Prototype al registro.
- **`obtenerPrototipo()`:** Obtiene un Prototype del registro por nombre y lo clona antes de devolverlo.
- **`JuegoRegistro`:** Usa el `RegistroEnemigos` para obtener y clonar Prototypes. Esto hace que la creación de enemigos sea más organizada y centralizada.

#### 3. **Notas o advertencias:**

- **Registro opcional:** El Prototype Registry es opcional. Puedes usar Prototype sin él, especialmente si solo tienes unos pocos Prototypes o si no necesitas gestionarlos centralizadamente.
- **Centralización:** El Registro centraliza la creación de objetos, lo que puede ser útil para la gestión y configuración de Prototypes.

## G - Seudocódigo (Adaptado a Java)

#### 1. **Definición:**

Este es un ejemplo en pseudocódigo adaptado a Java para mostrar cómo funciona el patrón Prototype con una jerarquía de clases de formas geométricas.

![The structure of the Prototype pattern example](https://refactoring.guru/images/patterns/diagrams/prototype/example.png)

#### 2. **Ejemplo:**

```java
// 1. Prototype Base (Abstract Class en Java)
abstract class FormaAbstracta implements FormaPrototype {
    private int x;
    private int y;
    private String color;

    public FormaAbstracta() {} // Constructor por defecto necesario para la copia

    public FormaAbstracta(FormaAbstracta fuente) { // Constructor de copia para la clase base
        this.x = fuente.x;
        this.y = fuente.y;
        this.color = fuente.color;
    }

    // Getters y Setters (para simplificar el ejemplo)
    public int getX() { return x; }
    public void setX(int x) { this.x = x; }
    public int getY() { return y; }
    public void setY(int y) { this.y = y; }
    public String getColor() { return color; }
    public void setColor(String color) { this.color = color; }


    @Override
    public abstract FormaPrototype clonar(); // Método clonar abstracto

    @Override
    public void dibujar() { // Método dibujar común
        System.out.println("Dibujando forma en (" + x + ", " + y + ") con color " + color);
    }
}

// 2. Prototypes Concretos (Clases que extienden la clase abstracta)
class RectanguloFormaAbs extends FormaAbstracta {
    private int ancho;
    private int alto;

    public RectanguloFormaAbs() {} // Constructor por defecto necesario para la copia

    public RectanguloFormaAbs(RectanguloFormaAbs fuente) { // Constructor de copia
        super(fuente); // Llama al constructor de copia de la clase base para copiar x, y, color
        this.ancho = fuente.ancho;
        this.alto = fuente.alto;
    }

    public int getAncho() { return ancho; }
    public void setAncho(int ancho) { this.ancho = ancho; }
    public int getAlto() { return alto; }
    public void setAlto(int alto) { this.alto = alto; }


    @Override
    public FormaPrototype clonar() {
        return new RectanguloFormaAbs(this); // Crea un nuevo Rectangulo usando el constructor de copia
    }

    @Override
    public void dibujar() {
        super.dibujar(); // Llama al método dibujar de la clase base
        System.out.println("  -> Rectángulo de " + ancho + "x" + alto);
    }
}

class CirculoFormaAbs extends FormaAbstracta { // Renombrado para evitar conflicto
    private int radio;

    public CirculoFormaAbs() {} // Constructor por defecto necesario para la copia
    public CirculoFormaAbs(CirculoFormaAbs fuente) { // Constructor de copia
        super(fuente); // Llama al constructor de copia de la clase base
        this.radio = fuente.radio;
    }

    public int getRadio() { return radio; }
    public void setRadio(int radio) { this.radio = radio; }


    @Override
    public FormaPrototype clonar() {
        return new CirculoFormaAbs(this); // Crea un nuevo Circulo usando el constructor de copia
    }

    @Override
    public void dibujar() {
        super.dibujar(); // Llama al método dibujar de la clase base
        System.out.println("  -> Círculo de radio " + radio);
    }
}


// 3. Cliente
import java.util.ArrayList;
import java.util.List;

public class AplicacionFormas {
    private List<FormaPrototype> formas = new ArrayList<>();

    public AplicacionFormas() {
        CirculoFormaAbs circulo = new CirculoFormaAbs();
        circulo.setX(10);
        circulo.setY(10);
        circulo.setColor("rojo");
        circulo.setRadio(20);
        formas.add(circulo);

        CirculoFormaAbs otroCirculo = (CirculoFormaAbs) circulo.clonar(); // Clonamos el círculo
        formas.add(otroCirculo);

        RectanguloFormaAbs rectangulo = new RectanguloFormaAbs();
        rectangulo.setAncho(10);
        rectangulo.setAlto(20);
        rectangulo.setColor("azul");
        formas.add(rectangulo);
    }

    public void procesarFormas() {
        List<FormaPrototype> copiasFormas = new ArrayList<>();

        for (FormaPrototype forma : formas) {
            copiasFormas.add(forma.clonar()); // Clonamos cada forma sin saber su tipo concreto
        }

        System.out.println("Formas Originales:");
        for (FormaPrototype forma : formas) {
            forma.dibujar();
        }

        System.out.println("\nCopias de las Formas:");
        for (FormaPrototype copia : copiasFormas) {
            copia.dibujar();
        }
    }

    public static void main(String[] args) {
        AplicacionFormas app = new AplicacionFormas();
        app.procesarFormas();
    }
}
```

**Explicación del ejemplo:**

- **`FormaAbstracta` (Prototype Base):** Es una clase abstracta que implementa `FormaPrototype`. Define propiedades comunes (x, y, color) y un constructor de copia para la clase base. El método `clonar()` es abstracto, obligando a las subclases a implementarlo.
- **`RectanguloFormaAbs` y `CirculoFormaAbs` (Prototypes Concretos):** Extienden `FormaAbstracta` e implementan `clonar()`. Cada uno tiene su propio constructor de copia y llama al constructor de copia de la clase base (`super(fuente)`) para copiar las propiedades de la clase padre.
- **`AplicacionFormas` (Cliente):** Crea una lista de `FormaPrototype` (que pueden ser `CirculoFormaAbs` o `RectanguloFormaAbs`). Luego, itera sobre la lista y clona cada forma usando `forma.clonar()`, sin importar el tipo concreto de forma.

#### 3. **Notas o advertencias:**

- **Jerarquía de clases:** Este ejemplo muestra cómo usar Prototype en una jerarquía de clases. El constructor de copia y la llamada a `super(fuente)` son importantes para copiar correctamente las propiedades de la clase base y las subclases.
- **Polimorfismo:** Gracias al polimorfismo, podemos llamar a `forma.clonar()` en cualquier objeto `FormaPrototype` y se ejecutará el método `clonar()` correcto de la clase concreta del objeto.

## H - Aplicabilidad del Prototype

#### 1. **Definición:**

Usa el patrón Prototype cuando:

- **No quieres que tu código dependa de las clases concretas de los objetos que necesitas copiar.** Esto es común cuando trabajas con código de terceros o cuando solo conoces la interfaz de los objetos.
- **Quieres reducir el número de subclases que solo se diferencian en cómo inicializan sus objetos.** En lugar de crear muchas subclases para diferentes configuraciones, puedes usar Prototypes pre-configurados y clonarlos.
- **Quieres crear objetos complejos de forma más conveniente.** Clonar un Prototype pre-configurado puede ser más fácil que construir un objeto complejo desde cero.
- **Quieres una alternativa a la herencia para manejar configuraciones predefinidas de objetos complejos.** En lugar de usar herencia para crear variaciones de un objeto, puedes usar Prototypes con diferentes configuraciones.

#### 2. **Ejemplo (Reducción de subclases):**

Imagina que tienes una clase `ConfiguracionServidor` que puede tener muchas configuraciones diferentes (puerto, protocolo, seguridad, etc.). En lugar de crear subclases para cada configuración (ej. `ConfiguracionServidorHTTP`, `ConfiguracionServidorFTP`, etc.), puedes crear Prototypes de `ConfiguracionServidor` con diferentes configuraciones y clonarlos.

```java
class ConfiguracionServidor implements FormaPrototype { // Reutilizando FormaPrototype por simplicidad
    private int puerto;
    private String protocolo;
    private boolean seguridadHabilitada;

    public ConfiguracionServidor() {} // Constructor por defecto para la copia

    public ConfiguracionServidor(ConfiguracionServidor fuente) { // Constructor de copia
        this.puerto = fuente.puerto;
        this.protocolo = fuente.protocolo;
        this.seguridadHabilitada = fuente.seguridadHabilitada;
    }

    // Getters y Setters
    public int getPuerto() { return puerto; }
    public void setPuerto(int puerto) { this.puerto = puerto; }
    public String getProtocolo() { return protocolo; }
    public void setProtocolo(String protocolo) { this.protocolo = protocolo; }
    public boolean isSeguridadHabilitada() { return seguridadHabilitada; }
    public void setSeguridadHabilitada(boolean seguridadHabilitada) { this.seguridadHabilitada = seguridadHabilitada; }


    @Override
    public FormaPrototype clonar() {
        return new ConfiguracionServidor(this);
    }

    public void mostrarConfiguracion() {
        System.out.println("Configuración del Servidor:");
        System.out.println("  Puerto: " + puerto);
        System.out.println("  Protocolo: " + protocolo);
        System.out.println("  Seguridad Habilitada: " + seguridadHabilitada);
    }
}

public class GestorServidores {
    public static void main(String[] args) {
        // Crear Prototypes pre-configurados
        ConfiguracionServidor prototipoHTTP = new ConfiguracionServidor();
        prototipoHTTP.setPuerto(80);
        prototipoHTTP.setProtocolo("HTTP");
        prototipoHTTP.setSeguridadHabilitada(false);

        ConfiguracionServidor prototipoHTTPS = new ConfiguracionServidor();
        prototipoHTTPS.setPuerto(443);
        prototipoHTTPS.setProtocolo("HTTPS");
        prototipoHTTPS.setSeguridadHabilitada(true);

        // Clonar Prototypes para crear configuraciones específicas
        ConfiguracionServidor servidorWeb1 = (ConfiguracionServidor) prototipoHTTP.clonar();
        ConfiguracionServidor servidorWeb2 = (ConfiguracionServidor) prototipoHTTPS.clonar();

        servidorWeb1.mostrarConfiguracion();
        servidorWeb2.mostrarConfiguracion();
    }
}
```

**Explicación del ejemplo:**

En lugar de crear subclases como `ConfiguracionServidorHTTP` y `ConfiguracionServidorHTTPS`, creamos Prototypes `prototipoHTTP` y `prototipoHTTPS` con las configuraciones deseadas. Luego, clonamos estos Prototypes para crear instancias de `ConfiguracionServidor` con esas configuraciones. ¡Menos subclases y más flexibilidad!

#### 3. **Notas o advertencias:**

- **Alternativa a la herencia:** Prototype puede ser una alternativa más flexible a la herencia en algunos casos, especialmente cuando se trata de configuraciones.
- **Configuraciones predefinidas:** Los Prototypes son ideales para crear y gestionar configuraciones predefinidas de objetos.

## I - Cómo implementar Prototype

#### 1. **Definición:**

Aquí tienes los pasos para implementar el patrón Prototype:

1.  **Crea la interfaz Prototype:** Define una interfaz (o clase abstracta) que declare el método `clonar()`. En Java, puedes usar una interfaz como `FormaPrototype` o `EnemigoPrototype`.
2.  **Implementa el método `clonar()` en las clases concretas (Prototypes Concretos):** Cada clase concreta que quieras que sea clonable debe implementar la interfaz Prototype y proporcionar su propia implementación del método `clonar()`. Normalmente, esto implica:
    - **Constructor de copia:** Crea un constructor de copia en la clase concreta que tome un objeto de la misma clase como argumento y copie todos sus campos.
    - **Método `clonar()`:** En el método `clonar()`, crea una nueva instancia de la clase concreta usando el constructor de copia y devuélvela.
3.  **Opcionalmente, crea un Registro de Prototypes:** Si necesitas gestionar muchos Prototypes pre-configurados, crea un Registro de Prototypes (como `RegistroEnemigos`) para almacenarlos y acceder a ellos fácilmente.
4.  **Usa el método `clonar()` en el código cliente:** En lugar de crear objetos directamente con `new ClaseConcreta()`, usa el método `clonar()` de un Prototype existente para crear copias. Si usas un Registro, obtén el Prototype del registro y luego clónalo.

#### 2. **Ejemplo (Pasos resumidos):**

Volviendo al ejemplo de `RectanguloFormaAbs`:

```java
// 1. Interfaz Prototype (ya definida como FormaPrototype)

// 2. Prototype Concreto (RectanguloFormaAbs)
class RectanguloFormaAbs implements FormaPrototype {
    // ... (campos, getters/setters) ...

    public RectanguloFormaAbs() {} // Constructor por defecto

    public RectanguloFormaAbs(RectanguloFormaAbs fuente) { // Constructor de copia
        // ... (copia de campos) ...
    }

    @Override
    public FormaPrototype clonar() { // Método clonar
        return new RectanguloFormaAbs(this); // Usa el constructor de copia
    }

    // ... (dibujar() y otros métodos) ...
}

// 3. Registro de Prototypes (opcional, ya visto en ejemplo anterior)

// 4. Cliente (AplicacionFormas)
public class AplicacionFormas {
    public static void main(String[] args) {
        RectanguloFormaAbs prototipoRectangulo = new RectanguloFormaAbs();
        prototipoRectangulo.setAncho(20);
        prototipoRectangulo.setAlto(30);

        FormaPrototype copiaRectangulo = prototipoRectangulo.clonar(); // ¡Clonando el prototipo!
        copiaRectangulo.dibujar();
    }
}
```

**Explicación del ejemplo (Pasos resumidos):**

El ejemplo muestra cómo se implementa el método `clonar()` en `RectanguloFormaAbs` usando el constructor de copia. El cliente `AplicacionFormas` usa `prototipoRectangulo.clonar()` para crear una copia.

#### 3. **Notas o advertencias:**

- **Constructor de copia es clave:** Asegúrate de implementar correctamente el constructor de copia en cada clase concreta. Es fundamental para que la clonación funcione correctamente.
- **Sobreescribir `clone()` en Java (alternativa):** En Java, también puedes usar la interfaz `Cloneable` y sobreescribir el método `clone()` de `Object`. Sin embargo, el enfoque del constructor de copia es a menudo más claro y seguro, especialmente para principiantes. Este cheat sheet se centra en el constructor de copia para mayor claridad pedagógica.

## J - Pros y Contras del Prototype

#### 1. **Definición:**

**Pros (Ventajas):**

- **Desacoplamiento de clases concretas:** Puedes clonar objetos sin depender de sus clases concretas. Tu código cliente solo interactúa con la interfaz Prototype.
- **Eliminación de código de inicialización repetitivo:** En lugar de repetir código de inicialización para crear objetos similares, puedes clonar Prototypes pre-configurados.
- **Creación de objetos complejos más fácil:** Clonar un Prototype puede ser más sencillo que construir un objeto complejo desde cero.
- **Alternativa a la herencia para configuraciones:** Prototype ofrece una alternativa a la herencia para manejar diferentes configuraciones de objetos complejos.

**Cons (Desventajas):**

- **Clonación de objetos complejos con referencias circulares puede ser difícil:** Si tus objetos tienen referencias a otros objetos y esas referencias forman ciclos (A referencia a B, y B referencia a A), la clonación profunda puede volverse complicada y requerir lógica adicional para evitar bucles infinitos o copias incorrectas.

#### 2. **Ejemplo (Ventajas resumidas):**

- **Desacoplamiento:** Ya hemos visto ejemplos de cómo Prototype desacopla el código cliente de las clases concretas.
- **Menos código repetitivo:** El ejemplo de `ConfiguracionServidor` muestra cómo los Prototypes pre-configurados evitan repetir la configuración en cada creación de servidor.
- **Creación fácil de objetos complejos:** Imagina un objeto `Documento` con muchas partes (texto, imágenes, tablas). Clonar un Prototype de `Documento` pre-formateado es más fácil que crear un `Documento` vacío y añadir todas las partes manualmente.

#### 3. **Notas o advertencias:**

- **Complejidad de la clonación profunda:** La principal desventaja es la complejidad potencial de la clonación profunda en objetos complejos. Debes tener cuidado al clonar objetos con referencias a otros objetos, especialmente si hay referencias circulares. Para ejemplos sencillos como los que hemos visto, la clonación superficial (copiando solo los valores de los campos) suele ser suficiente.

## K - Relaciones con otros patrones

#### 1. **Definición:**

El patrón Prototype se relaciona con otros patrones de diseño de las siguientes maneras:

- **Factory Method, Abstract Factory, Builder:** Muchos diseños comienzan con Factory Method (más simple) y pueden evolucionar hacia Abstract Factory, Prototype o Builder (más flexibles pero más complejos). Prototype es una alternativa a estos patrones para crear objetos, especialmente cuando la creación implica copiar objetos existentes.
- **Abstract Factory:** Las clases Abstract Factory a menudo se basan en Factory Methods, pero también pueden usar Prototype para componer los métodos en estas clases.
- **Command:** Prototype puede ser útil para guardar copias de objetos Command en el historial de comandos (para deshacer/rehacer operaciones).
- **Composite, Decorator:** Diseños que usan Composite y Decorator pueden beneficiarse de Prototype para clonar estructuras complejas en lugar de reconstruirlas desde cero.
- **Memento:** En algunos casos, Prototype puede ser una alternativa más simple a Memento para guardar el estado de un objeto, especialmente si el objeto es sencillo y no tiene dependencias externas complejas.
- **Singleton:** Abstract Factory, Builder y Prototype pueden implementarse como Singletons si solo necesitas una instancia de la fábrica, constructor o registro de prototypes.

#### 2. **Ejemplo (Relación con Factory Method):**

Imagina que inicialmente usaste Factory Method para crear diferentes tipos de `Enemigo`. Luego, te das cuenta de que muchos enemigos son muy similares, solo varían en algunos detalles. Podrías refactorizar tu diseño para usar Prototype en lugar de Factory Method. En lugar de tener una fábrica que _crea_ enemigos desde cero, tendrías un registro de Prototypes de enemigos pre-configurados, y la "fábrica" simplemente _clonaría_ esos Prototypes.

#### 3. **Notas o advertencias:**

- **Patrones complementarios:** Prototype a menudo se usa en combinación con otros patrones para resolver problemas de diseño más complejos.
- **Elección del patrón:** La elección entre Prototype y otros patrones (como Factory Method o Abstract Factory) depende de las necesidades específicas de tu diseño. Prototype es especialmente útil cuando la copia de objetos existentes es una operación clave.
