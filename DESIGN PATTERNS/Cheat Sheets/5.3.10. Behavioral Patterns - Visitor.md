## A - Intención del Patrón Visitor

#### 1. **Definición:**

El patrón **Visitor** es como un superpoder que te permite separar algoritmos (acciones) de los objetos sobre los que actúan. Imagina que tienes un grupo de objetos diferentes y quieres realizar varias operaciones sobre ellos, pero sin cambiar la estructura de esos objetos. ¡Visitor es tu solución!

#### 2. **Ejemplo:**

Imagina que tienes diferentes tipos de figuras geométricas (Círculo, Rectángulo, Triángulo) y quieres poder realizar diferentes acciones sobre ellas, como calcular el área, el perímetro o dibujarlas en pantalla, sin modificar las clases de las figuras.

**Explicación del ejemplo:**
Con Visitor, puedes crear "visitantes" que sepan cómo calcular el área, el perímetro o dibujar cada tipo de figura. Así, cada vez que quieras una nueva acción, solo creas un nuevo visitante, ¡sin tocar las clases de las figuras!

#### 3. **Notas o advertencias:**

- Ideal cuando tienes muchas operaciones que quieres hacer sobre un conjunto de objetos, pero no quieres que las clases de esos objetos se llenen de código de esas operaciones.
- Útil cuando la estructura de los objetos es estable, pero las operaciones que quieres realizar sobre ellos cambian con frecuencia.

## B - Problema que Resuelve el Patrón Visitor

#### 1. **Definición:**

El problema principal es cómo añadir nuevas operaciones a un conjunto de objetos de diferentes clases **sin modificar esas clases**. Imagina que las clases ya están hechas, probadas y funcionando perfectamente, ¡no quieres romper nada! Además, puede que estas operaciones no encajen bien dentro de la responsabilidad principal de esas clases.

#### 2. **Ejemplo:**

Piensa en el ejemplo del texto sobre el grafo geográfico. Tenías nodos (Ciudades, Industrias, Lugares Turísticos) y querías exportar ese grafo a XML. Si añadieras la lógica de exportación XML directamente a las clases de nodos, contaminarías esas clases con código que no tiene que ver con su función principal (gestionar datos geográficos). Además, si luego quisieras exportar a JSON, ¡tendrías que volver a modificar esas clases!

![Exporting the graph into XML](https://refactoring.guru/images/patterns/diagrams/visitor/problem1.png)

**Explicación del ejemplo:**
El problema es que modificar las clases existentes para cada nueva operación (como exportar a diferentes formatos) es arriesgado, desorganizado y poco flexible.

#### 3. **Notas o advertencias:**

- Modificar clases existentes puede introducir errores y romper funcionalidades ya probadas.
- Añadir comportamientos ajenos a la responsabilidad principal de una clase la hace más compleja y difícil de mantener.
- Necesitas una forma de extender la funcionalidad sin modificar el código existente.

## C - Solución con el Patrón Visitor

#### 1. **Definición:**

La solución del patrón Visitor es **mover el nuevo comportamiento a una clase separada llamada "Visitor"**. En lugar de añadir métodos a las clases de los objetos, creas una clase Visitor que tiene métodos específicos para cada tipo de objeto. Los objetos "aceptan" al Visitor y le dicen qué método debe ejecutar.

#### 2. **Ejemplo:**

Volviendo al ejemplo del grafo, creas un `ExportVisitor` que sabe cómo exportar cada tipo de nodo a XML. Cada clase de nodo (Ciudad, Industria, etc.) tiene un método `accept(Visitor v)` que llama al método correcto del Visitor (`v.doForCity(this)`, `v.doForIndustry(this)`, etc.).

```java
// Interfaz Visitor
interface Visitor {
    void visitCity(City city);
    void visitIndustry(Industry industry);
    void visitSightSeeing(SightSeeing sightSeeing);
}

// Implementación concreta del Visitor para exportar a XML
class XMLExportVisitor implements Visitor {
    @Override
    public void visitCity(City city) {
        System.out.println("Exportando Ciudad a XML: " + city.getName());
        // Lógica para exportar ciudad a XML
    }

    @Override
    public void visitIndustry(Industry industry) {
        System.out.println("Exportando Industria a XML: " + industry.getName());
        // Lógica para exportar industria a XML
    }

    @Override
    public void visitSightSeeing(SightSeeing sightSeeing) {
        System.out.println("Exportando Lugar Turístico a XML: " + sightSeeing.getName());
        // Lógica para exportar lugar turístico a XML
    }
}

// Interfaz Elemento (Nodo en este caso)
interface Node {
    String getName();
    void accept(Visitor visitor);
}

// Implementación concreta de Elemento (Ciudad)
class City implements Node {
    private String name;

    public City(String name) {
        this.name = name;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visitCity(this); // Llama al método visitCity del Visitor
    }
}

// Implementación concreta de Elemento (Industria)
class Industry implements Node {
    private String name;

    public Industry(String name) {
        this.name = name;
    }

    @Override
    public String getName() {
        return name;
    }
    @Override
    public void accept(Visitor visitor) {
        visitor.visitIndustry(this); // Llama al método visitIndustry del Visitor
    }
}

// Cliente
public class Client {
    public static void main(String[] args) {
        Node city = new City("Barcelona");
        Node industry = new Industry("Fábrica de Coches");

        Visitor xmlVisitor = new XMLExportVisitor();

        city.accept(xmlVisitor);     // Barcelona "acepta" al XMLVisitor y se exporta como Ciudad
        industry.accept(xmlVisitor); // Fábrica "acepta" al XMLVisitor y se exporta como Industria
    }
}
```

**Output del código:**

```
Exportando Ciudad a XML: Barcelona
Exportando Industria a XML: Fábrica de Coches
```

**Explicación del ejemplo:**
Cada clase de nodo (`City`, `Industry`) implementa el método `accept()`. Cuando llamas a `city.accept(xmlVisitor)`, la ciudad "acepta" al `xmlVisitor` y llama a `xmlVisitor.visitCity(this)`. ¡Así, el Visitor sabe exactamente qué tipo de nodo está visitando y puede aplicar la lógica de exportación XML correcta!

#### 3. **Notas o advertencias:**

- El patrón Visitor utiliza una técnica llamada **Doble Despacho** (Double Dispatch) para que el objeto visitado (el Nodo) decida qué método del Visitor se debe ejecutar.
- Aunque se modifica ligeramente las clases de los objetos (añadiendo el método `accept`), este cambio es mínimo y permite añadir muchas nuevas operaciones sin volver a modificarlas.

## D - Doble Despacho (Double Dispatch)

#### 1. **Definición:**

El **Doble Despacho** es la magia detrás del patrón Visitor. Es una técnica que permite que la **decisión de qué método ejecutar se base en el tipo de dos objetos**: el objeto que realiza la acción (el Visitor) y el objeto sobre el que se realiza la acción (el Elemento). En lugar de que el código cliente decida qué método del Visitor llamar, ¡el propio Elemento lo hace!

#### 2. **Ejemplo:**

En el ejemplo anterior, cuando llamas a `city.accept(xmlVisitor)`, no estás diciendo explícitamente "llama a `xmlVisitor.visitCity(city)`". En cambio, la clase `City` **internamente** decide llamar a `xmlVisitor.visitCity(this)` dentro de su método `accept()`. ¡La decisión de qué método `visit...` llamar se "despacha" dos veces: primero al método `accept()` del Elemento, y luego al método `visit...()` del Visitor!

**Explicación del ejemplo:**
El Doble Despacho elimina la necesidad de usar `if` o `instanceof` para verificar el tipo de objeto y llamar al método correcto del Visitor. Cada Elemento sabe su propio tipo y redirige la llamada al método Visitor adecuado.

#### 3. **Notas o advertencias:**

- El Doble Despacho hace que el código sea más limpio y fácil de mantener, especialmente cuando tienes muchos tipos de objetos y muchas operaciones.
- Es la clave para que el patrón Visitor funcione de forma elegante y eficiente.
- Si quieres profundizar más, el texto original te proporciona un enlace a un artículo sobre Doble Despacho.

## E - Estructura del Patrón Visitor

#### 1. **Definición:**

El patrón Visitor tiene varios componentes clave que trabajan juntos:

1.  **Visitor (Interfaz):** Define la interfaz con métodos `visit...()` para cada tipo de `ConcreteElement`.
2.  **ConcreteVisitor (Clase):** Implementa la interfaz `Visitor` y define la lógica específica para cada tipo de `ConcreteElement`.
3.  **Element (Interfaz):** Define el método `accept(Visitor v)` que deben implementar los `ConcreteElement`.
4.  **ConcreteElement (Clase):** Implementa la interfaz `Element` y el método `accept(Visitor v)`, que llama al método `visit...()` correspondiente del `Visitor`.
5.  **Client (Cliente):** Utiliza los `Element` y los `Visitor` para realizar operaciones.

![Structure of the Visitor design pattern](https://refactoring.guru/images/patterns/diagrams/visitor/structure-en.png)

**Explicación de la imagen:**
La imagen muestra cómo interactúan los componentes del patrón Visitor. El `Client` trabaja con `ConcreteElement` a través de la interfaz `Element`. Cuando quiere aplicar una operación, crea un `ConcreteVisitor` y lo pasa al `accept()` del `ConcreteElement`. El `ConcreteElement` llama al método `visit...()` correcto del `ConcreteVisitor`.

#### 3. **Notas o advertencias:**

- Entender la estructura es clave para implementar correctamente el patrón Visitor.
- Cada componente tiene un papel específico y trabaja en conjunto para lograr la separación de algoritmos y objetos.

## F - Analogía del Mundo Real: Agente de Seguros

#### 1. **Definición:**

Imagina un agente de seguros que visita diferentes tipos de edificios para ofrecer pólizas de seguro.

- **Edificio Residencial:** Ofrece seguro médico.
- **Banco:** Ofrece seguro contra robos.
- **Cafetería:** Ofrece seguro contra incendios e inundaciones.

![Insurance agent](https://refactoring.guru/images/patterns/content/visitor/visitor-comic-1.png)

**Explicación de la analogía:**
El agente de seguros es como el **Visitor**. Tiene diferentes "métodos de visita" (ofrecer diferentes pólizas) para cada tipo de "Elemento" (tipo de edificio). Cada edificio "acepta" al agente y le permite ofrecer la póliza adecuada a su tipo.

#### 3. **Notas o advertencias:**

- Esta analogía ayuda a visualizar cómo el Visitor adapta su comportamiento según el tipo de objeto que visita.
- El agente de seguros no cambia la estructura de los edificios, ¡solo les ofrece diferentes servicios!

## G - Seudocódigo de Ejemplo: Figuras Geométricas y Exportación XML

#### 1. **Definición:**

El texto proporciona un ejemplo en pseudocódigo para exportar figuras geométricas (Punto, Círculo, Rectángulo, FiguraCompuesta) a XML usando el patrón Visitor.

![Structure of the Visitor pattern example](https://refactoring.guru/images/patterns/diagrams/visitor/example.png)

**Explicación del pseudocódigo:**

- **Shape (Interfaz):** Interfaz para todas las figuras, define `move()`, `draw()` y `accept(Visitor v)`.
- **Dot, Circle, Rectangle, CompoundShape (Clases):** Implementaciones concretas de `Shape`. Cada una implementa `accept(Visitor v)` llamando al método `visit...()` correspondiente del Visitor (`v.visitDot(this)`, `v.visitCircle(this)`, etc.).
- **Visitor (Interfaz):** Define métodos `visitDot(d: Dot)`, `visitCircle(c: Circle)`, `visitRectangle(r: Rectangle)`, `visitCompoundShape(cs: CompoundShape)`.
- **XMLExportVisitor (Clase):** Implementa `Visitor` y define la lógica para exportar cada tipo de figura a XML en cada método `visit...()`.
- **Application (Cliente):** Crea un `XMLExportVisitor` y lo pasa al método `accept()` de cada figura en la lista `allShapes`.

**Explicación del ejemplo:**
Este ejemplo muestra cómo el Visitor separa la lógica de exportación XML de las clases de figuras geométricas. Puedes añadir nuevos formatos de exportación (JSON, SVG, etc.) creando nuevos `ConcreteVisitor` sin modificar las clases de las figuras.

#### 3. **Notas o advertencias:**

- El pseudocódigo ilustra claramente la implementación del patrón Visitor.
- Presta atención a cómo cada `ConcreteElement` llama al método `visit...()` correcto en su método `accept()`.

## H - Aplicabilidad del Patrón Visitor

#### 1. **Definición:**

¿Cuándo deberías usar el patrón Visitor?

- **Operaciones sobre estructuras complejas:** Cuando necesitas realizar operaciones sobre todos los elementos de una estructura de objetos compleja (como un árbol).
- **Lógica de negocio auxiliar:** Para limpiar la lógica de negocio de comportamientos secundarios, moviéndolos a clases Visitor.
- **Comportamientos específicos a ciertas clases:** Cuando un comportamiento solo tiene sentido para algunas clases de una jerarquía, pero no para otras.

#### 2. **Ejemplo:**

- **Compiladores:** Un compilador puede usar Visitor para recorrer el árbol de sintaxis abstracta (AST) y realizar diferentes operaciones como análisis semántico, generación de código, optimización, etc. Cada operación sería un Visitor diferente.
- **Procesamiento de documentos:** Puedes usar Visitor para procesar diferentes tipos de elementos en un documento (texto, imágenes, tablas) y realizar operaciones como formateo, validación, extracción de información, etc.

#### 3. **Notas o advertencias:**

- Visitor es muy útil cuando tienes una estructura de objetos estable y quieres añadir muchas operaciones diferentes sobre ella.
- Si la estructura de objetos cambia con frecuencia, puede que Visitor no sea la mejor opción, ya que tendrías que modificar todos los Visitors cada vez.

## I - Cómo Implementar el Patrón Visitor

#### 1. **Definición:**

Pasos para implementar el patrón Visitor:

1.  **Crea la interfaz Visitor:** Define métodos `visit...()` para cada `ConcreteElement`.
2.  **Crea la interfaz Element:** Define el método `accept(Visitor v)`. Si ya tienes una jerarquía de clases Element, añade `accept()` a la clase base.
3.  **Implementa `accept()` en `ConcreteElement`:** Cada clase `ConcreteElement` implementa `accept(Visitor v)` llamando a `v.visit...(this)`.
4.  **Los Elementos solo usan la interfaz Visitor:** Los Elementos solo interactúan con Visitors a través de la interfaz `Visitor`.
5.  **Crea `ConcreteVisitor` para cada comportamiento:** Para cada nueva operación, crea una clase `ConcreteVisitor` que implemente la interfaz `Visitor`.
6.  **El Cliente crea y usa Visitors:** El código cliente crea instancias de `ConcreteVisitor` y las pasa a los métodos `accept()` de los `ConcreteElement`.

#### 3. **Notas o advertencias:**

- Sigue estos pasos para asegurarte de implementar correctamente el patrón Visitor.
- Recuerda que el método `accept()` en los `ConcreteElement` es crucial para el Doble Despacho.

## J - Pros y Contras del Patrón Visitor

#### 1. **Definición:**

**Pros:**

- **Principio Abierto/Cerrado:** Puedes añadir nuevos comportamientos sin modificar las clases de los objetos.
- **Principio de Responsabilidad Única:** Reúnes comportamientos relacionados en clases Visitor, separándolos de las clases de los objetos.
- **Acumulación de información:** Un Visitor puede acumular información útil mientras visita diferentes objetos.

**Contras:**

- **Modificación de Visitors al añadir/eliminar Elementos:** Si añades o eliminas clases `ConcreteElement`, debes modificar todas las interfaces `Visitor` y `ConcreteVisitor`.
- **Acceso a miembros privados:** Los Visitors pueden tener dificultades para acceder a miembros privados de los `ConcreteElement`.

#### 3. **Notas o advertencias:**

- Considera los pros y contras antes de decidir usar el patrón Visitor.
- Es una buena opción si la estructura de objetos es estable y necesitas añadir muchas operaciones.
- Si la estructura de objetos cambia mucho, puede que no sea la mejor opción.

## K - Relación con Otros Patrones

#### 1. **Definición:**

El patrón Visitor se relaciona con otros patrones:

- **Command:** Visitor puede verse como una versión más potente de Command, ya que puede ejecutar operaciones sobre objetos de diferentes clases.
- **Composite:** Visitor se usa a menudo con Composite para recorrer árboles de objetos y aplicar operaciones a cada nodo.
- **Iterator:** Visitor puede combinarse con Iterator para recorrer estructuras de datos complejas y aplicar operaciones a los elementos, incluso si son de diferentes clases.

#### 3. **Notas o advertencias:**

- Entender las relaciones con otros patrones te ayuda a ver el Visitor en un contexto más amplio.
- Puedes combinar Visitor con otros patrones para resolver problemas más complejos.
