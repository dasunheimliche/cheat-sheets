## A - Command Pattern

#### 1. **Definición:**

El patrón **Command** es como darle superpoderes a tus peticiones en código. Imagina que tienes una acción que quieres realizar (como copiar texto, abrir un archivo, etc.). En lugar de ejecutarla directamente, el patrón Command te permite envolver esa acción en un objeto llamado "comando". Este objeto contiene toda la información necesaria para realizar la acción más tarde. Es como poner una tarea en una cajita para ejecutarla cuando quieras.

#### 2. **Ejemplo:**

Imagina un botón en un programa de dibujo que dibuja un círculo.

```java
// Interfaz Comando
interface Command {
    void execute();
}

// Receptor: el objeto que realmente realiza la acción (dibujar)
class Dibujo {
    public void dibujarCirculo() {
        System.out.println("¡Dibujando un círculo!");
    }
}

// Comando Concreto: DibujaCirculoCommand
class DibujaCirculoCommand implements Command {
    private Dibujo dibujo;

    public DibujaCirculoCommand(Dibujo dibujo) {
        this.dibujo = dibujo;
    }

    @Override
    public void execute() {
        dibujo.dibujarCirculo();
    }
}

// Invocador: el botón que ejecuta el comando
class Boton {
    Command comando;

    public void setComando(Command comando) {
        this.comando = comando;
    }

    public void presionar() {
        comando.execute();
    }
}

// Cliente: Configura todo
public class Main {
    public static void main(String[] args) {
        Dibujo miDibujo = new Dibujo();
        DibujaCirculoCommand comandoCirculo = new DibujaCirculoCommand(miDibujo);

        Boton botonCirculo = new Boton();
        botonCirculo.setComando(comandoCirculo);

        botonCirculo.presionar(); // ¡Dibujando un círculo!
    }
}
```

**Explicación del ejemplo:**

- Tenemos una interfaz `Command` que define la acción `execute()`.
- `Dibujo` es el **Receptor**, quien realmente sabe cómo dibujar un círculo.
- `DibujaCirculoCommand` es un **Comando Concreto**. Encapsula la acción de dibujar un círculo en un objeto. Cuando se ejecuta, le dice al `Dibujo` que dibuje.
- `Boton` es el **Invocador**. No sabe _qué_ acción se realizará, solo sabe que tiene un `Command` y puede `presionar()` para `execute()` el comando.
- En `Main` (el **Cliente**), creamos los objetos, conectamos el comando al botón y ¡listo! Al presionar el botón, se dibuja el círculo.

#### 3. **Notas o advertencias:**

- Piensa en "Command" como una **orden** o **instrucción** que puedes pasar alrededor como un objeto.
- El patrón Command ayuda a **desacoplar** quién pide la acción (el botón) de quién realmente la realiza (el `Dibujo`).
- Esto hace que tu código sea más **flexible** y **fácil de mantener**.

---

## B - Intención del Command Pattern

#### 1. **Definición:**

La **intención** principal del patrón Command es **convertir una solicitud en un objeto independiente**. Esto te abre un mundo de posibilidades:

- **Pasar solicitudes como argumentos:** Puedes enviar comandos a funciones o métodos como cualquier otro objeto.
- **Retrasar o encolar la ejecución:** Puedes guardar comandos en una lista y ejecutarlos más tarde, o incluso programarlos para que se ejecuten en un momento específico.
- **Soportar operaciones que se pueden deshacer (undo):** Si guardas un historial de comandos, puedes "deshacer" acciones ejecutando comandos inversos o restaurando estados previos.

#### 2. **Ejemplo:**

Imagina un sistema de procesamiento de pedidos online.

```java
interface Command {
    void execute();
    void undo(); // Para deshacer la acción
}

class Pedido {
    private String producto;
    private int cantidad;

    public Pedido(String producto, int cantidad) {
        this.producto = producto;
        this.cantidad = cantidad;
    }

    public void procesar() {
        System.out.println("Procesando pedido de " + cantidad + " " + producto + ".");
    }

    public void cancelar() {
        System.out.println("Pedido de " + cantidad + " " + producto + " cancelado.");
    }
}

class ProcesarPedidoCommand implements Command {
    private Pedido pedido;

    public ProcesarPedidoCommand(Pedido pedido) {
        this.pedido = pedido;
    }

    @Override
    public void execute() {
        pedido.procesar();
    }

    @Override
    public void undo() {
        pedido.cancelar();
    }
}

class SistemaPedidos {
    private List<Command> historialComandos = new ArrayList<>();

    public void tomarPedido(Pedido pedido) {
        ProcesarPedidoCommand comando = new ProcesarPedidoCommand(pedido);
        comando.execute(); // Ejecutar el comando inmediatamente
        historialComandos.add(comando); // Guardar en el historial
    }

    public void deshacerUltimoPedido() {
        if (!historialComandos.isEmpty()) {
            Command ultimoComando = historialComandos.remove(historialComandos.size() - 1);
            ultimoComando.undo(); // Deshacer el último comando
        } else {
            System.out.println("No hay pedidos para deshacer.");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        SistemaPedidos sistema = new SistemaPedidos();

        Pedido pedido1 = new Pedido("Laptop", 1);
        sistema.tomarPedido(pedido1); // Procesando pedido de 1 Laptop.

        Pedido pedido2 = new Pedido("Mouse", 2);
        sistema.tomarPedido(pedido2); // Procesando pedido de 2 Mouse.

        sistema.deshacerUltimoPedido(); // Pedido de 2 Mouse cancelado.
        sistema.deshacerUltimoPedido(); // Pedido de 1 Laptop cancelado.
        sistema.deshacerUltimoPedido(); // No hay pedidos para deshacer.
    }
}
```

**Explicación del ejemplo:**

- Ahora la interfaz `Command` tiene `execute()` y `undo()`.
- `Pedido` representa un pedido y sabe cómo `procesar()` y `cancelar()`.
- `ProcesarPedidoCommand` encapsula la acción de procesar un pedido y también sabe cómo `undo()` (cancelar).
- `SistemaPedidos` actúa como **Invocador** y también gestiona el **historial de comandos**.
- Podemos `tomarPedido()` y `deshacerUltimoPedido()`, demostrando la capacidad de deshacer acciones gracias al patrón Command.

#### 3. **Notas o advertencias:**

- El patrón Command es genial para implementar **funcionalidades de deshacer/rehacer**.
- También es útil para sistemas que necesitan **procesar tareas en segundo plano** o **encolar acciones**.
- Piensa en la intención del Command Pattern como **darle más control y flexibilidad a tus acciones en el código**.

---

## C - Problema que resuelve el Command Pattern

#### 1. **Definición:**

El problema principal que el patrón Command resuelve es el **acoplamiento fuerte** entre objetos que solicitan una acción y objetos que la ejecutan. Imagina que tienes botones en una interfaz gráfica (GUI) que deben realizar diferentes acciones. Si cada botón conoce directamente la lógica para realizar su acción, se vuelve un lío:

- **Muchas subclases de botones:** Tendrías que crear una subclase de botón para cada acción diferente (BotónCopiar, BotónPegar, BotónGuardar, etc.).
- **Código duplicado:** Si la misma acción (como copiar) se puede realizar desde varios lugares (botón, menú, atajo de teclado), tendrías que repetir el código de "copiar" en varios sitios.
- **Dependencia entre GUI y lógica de negocio:** La interfaz gráfica se vuelve muy dependiente de la lógica interna de la aplicación, haciendo que los cambios sean más difíciles y arriesgados.

![Problem solved by the Command pattern](https://refactoring.guru/images/patterns/diagrams/command/problem1.png)

#### 2. **Ejemplo:**

Piensa en un editor de texto simple con botones para "Copiar" y "Pegar".

**Sin Command Pattern (Problema):**

```java
// Clase Boton (sin Command Pattern - ¡PROBLEMA!)
class BotonCopiar {
    private EditorTexto editor;

    public BotonCopiar(EditorTexto editor) {
        this.editor = editor;
    }

    public void onClick() {
        editor.copiarTexto(); // Botón sabe DIRECTAMENTE cómo copiar
    }
}

class BotonPegar {
    private EditorTexto editor;

    public BotonPegar(EditorTexto editor) {
        this.editor = editor;
    }

    public void onClick() {
        editor.pegarTexto(); // Botón sabe DIRECTAMENTE cómo pegar
    }
}

class EditorTexto {
    public void copiarTexto() {
        System.out.println("Texto copiado al portapapeles.");
    }

    public void pegarTexto() {
        System.out.println("Texto pegado desde el portapapeles.");
    }
}

public class Main {
    public static void main(String[] args) {
        EditorTexto editor = new EditorTexto();
        BotonCopiar botonCopiar = new BotonCopiar(editor);
        BotonPegar botonPegar = new BotonPegar(editor);

        botonCopiar.onClick(); // Texto copiado al portapapeles.
        botonPegar.onClick(); // Texto pegado desde el portapapeles.
    }
}
```

**Explicación del problema en el ejemplo:**

- `BotonCopiar` y `BotonPegar` están **fuertemente acoplados** a `EditorTexto`. Cada botón _sabe_ exactamente qué método llamar en `EditorTexto`.
- Si quisieras agregar otra forma de copiar (menú, teclado), tendrías que **duplicar** la lógica de "copiar" o hacer cosas raras para reutilizar el código.
- Cambiar la forma en que se copia el texto en `EditorTexto` podría **romper** los botones.

#### 3. **Notas o advertencias:**

- El problema del acoplamiento fuerte hace que el código sea **rígido**, **difícil de cambiar** y **propenso a errores**.
- El patrón Command **rompe este acoplamiento** al introducir una capa de **indirección** (el objeto Command).
- Piensa en el problema como: "¿Cómo puedo hacer que mis botones hagan cosas sin que sepan _exactamente_ cómo se hacen esas cosas?" ¡La respuesta es el Command Pattern!

---

## D - Solución con el Command Pattern

#### 1. **Definición:**

El patrón Command **soluciona el problema de acoplamiento** separando la solicitud de la acción. En lugar de que el objeto que _pide_ la acción (el **Invocador**, como un botón) sepa _cómo_ realizarla, delega esa responsabilidad a un objeto **Command**. El Command encapsula toda la información sobre la acción a realizar, incluyendo:

- **Qué acción realizar:** Copiar, pegar, guardar, etc.
- **Quién debe realizar la acción:** El **Receptor** (por ejemplo, el `EditorTexto`).
- **Cualquier parámetro necesario:** Texto a copiar, nombre del archivo a guardar, etc.

El Invocador solo necesita saber _cómo ejecutar_ un Command, no los detalles de la acción en sí.

![Accessing the business logic layer via a command.](https://refactoring.guru/images/patterns/diagrams/command/solution2-en.png)

#### 2. **Ejemplo:**

Volvamos al editor de texto, ahora con el Command Pattern.

**Con Command Pattern (Solución):**

```java
// Interfaz Command
interface Command {
    void execute();
}

// Receptor: Editor de Texto
class EditorTexto {
    public void copiarTexto() {
        System.out.println("Texto copiado al portapapeles (Command Pattern).");
    }

    public void pegarTexto() {
        System.out.println("Texto pegado desde el portapapeles (Command Pattern).");
    }
}

// Comandos Concretos
class CopiarCommand implements Command {
    private EditorTexto editor;

    public CopiarCommand(EditorTexto editor) {
        this.editor = editor;
    }

    @Override
    public void execute() {
        editor.copiarTexto();
    }
}

class PegarCommand implements Command {
    private EditorTexto editor;

    public PegarCommand(EditorTexto editor) {
        this.editor = editor;
    }

    @Override
    public void execute() {
        editor.pegarTexto();
    }
}

// Invocador: Boton (ahora genérico)
class Boton {
    private Command comando;

    public void setComando(Command comando) {
        this.comando = comando;
    }

    public void onClick() {
        comando.execute(); // Botón solo ejecuta el Command, no sabe qué hace
    }
}

public class Main {
    public static void main(String[] args) {
        EditorTexto editor = new EditorTexto();
        CopiarCommand comandoCopiar = new CopiarCommand(editor);
        PegarCommand comandoPegar = new PegarCommand(editor);

        Boton botonCopiar = new Boton();
        botonCopiar.setComando(comandoCopiar);

        Boton botonPegar = new Boton();
        botonPegar.setComando(comandoPegar);

        botonCopiar.onClick(); // Texto copiado al portapapeles (Command Pattern).
        botonPegar.onClick(); // Texto pegado desde el portapapeles (Command Pattern).
    }
}
```

**Explicación de la solución:**

- Ahora tenemos una interfaz `Command`.
- `CopiarCommand` y `PegarCommand` son **Comandos Concretos** que encapsulan las acciones de copiar y pegar. Cada uno sabe _cómo_ decirle al `EditorTexto` que realice su acción.
- `Boton` ahora es una clase **genérica**. No sabe si va a copiar o pegar. Solo sabe que tiene un `Command` y puede `onClick()` para `execute()` ese Command.
- En `Main`, **configuramos** los botones con los comandos específicos.

**Beneficios de la solución:**

- **Desacoplamiento:** `Boton` ya no está acoplado a `EditorTexto` directamente. Depende de la interfaz `Command`.
- **Reutilización:** Puedes reutilizar los comandos en diferentes partes de la GUI (menús, atajos, etc.) sin duplicar código.
- **Extensibilidad:** Es fácil agregar nuevos comandos (Guardar, Imprimir, etc.) sin modificar la clase `Boton`.
- **Mantenibilidad:** Los cambios en la lógica de `EditorTexto` son menos propensos a afectar la GUI, y viceversa.

#### 3. **Notas o advertencias:**

- El Command Pattern introduce una **capa extra de abstracción**, pero a cambio, obtienes un código mucho más **flexible** y **robusto**.
- Piensa en la solución como: "Delegar la responsabilidad de _cómo hacer_ a los objetos Command, y dejar que los Invocadores solo se preocupen por _cuándo ejecutar_ los Commands".

---

## E - Analogía del Mundo Real: Pedido en un Restaurante

#### 1. **Definición:**

La analogía del **pedido en un restaurante** ilustra muy bien el patrón Command.

![Making an order in a restaurant](https://refactoring.guru/images/patterns/content/command/command-comic-1.png)

#### 2. **Analogía:**

- **Cliente (Tú):** Eres el **Cliente** que crea y configura el comando (el pedido).
- **Camarero:** El **Camarero** es el **Invocador**. Toma tu pedido (comando) y lo pasa al siguiente en la cadena. No sabe _cómo_ se cocina la comida, solo _cómo tomar y entregar_ el pedido.
- **Pedido (la nota del camarero):** El **Pedido** en papel es el **Command**. Es un objeto que encapsula la solicitud: qué comida quieres, instrucciones especiales, etc.
- **Chef (Cocinero):** El **Chef** es el **Receptor**. Él es quien realmente _ejecuta_ la acción (cocinar la comida) basada en la información del pedido.
- **Cocina:** La **Cocina** es el sistema de **Lógica de Negocio** que realiza las acciones.

**Flujo:**

1.  **Tú (Cliente)** decides qué quieres comer y se lo dices al **Camarero (Invocador)**.
2.  El **Camarero** escribe tu **Pedido (Command)** en un papel.
3.  El **Camarero** lleva el **Pedido** a la **Cocina**.
4.  El **Chef (Receptor)** lee el **Pedido** y **cocina** la comida.
5.  El **Camarero** recoge la comida y te la entrega.

#### 3. **Notas o advertencias:**

- El **Pedido (Command)** es independiente de quién lo hace (Camarero) y quién lo ejecuta (Chef).
- El **Camarero (Invocador)** no necesita saber _cómo_ cocinar, solo _cómo manejar pedidos_.
- Esta analogía muestra cómo el Command Pattern **desacopla** quién pide la acción de quién la realiza, y cómo el Command en sí mismo es un objeto que contiene toda la información necesaria.

---

## F - Estructura del Command Pattern

#### 1. **Definición:**

La estructura del patrón Command define las partes clave y cómo interactúan entre sí.

![Structure of the Command design pattern](https://refactoring.guru/images/patterns/diagrams/command/structure.png)
![Structure of the Command design pattern](https://refactoring.guru/images/patterns/diagrams/command/structure-indexed.png)

#### 2. **Componentes:**

1.  **Cliente (Client):**

    - Crea los objetos `Command` concretos.
    - Configura los comandos, incluyendo el `Receptor`.
    - Asocia los comandos con los `Invocadores`.
    - En el ejemplo del editor, `Main` es el Cliente.

2.  **Comando (Command Interface):**

    - Declara la interfaz para todos los comandos concretos.
    - Generalmente tiene un solo método: `execute()`.
    - En los ejemplos, `interface Command` es la interfaz Comando.

3.  **Comandos Concretos (Concrete Commands):**

    - Implementan la interfaz `Command`.
    - Asocian una acción a un `Receptor`.
    - Pueden almacenar parámetros necesarios para la acción.
    - Implementan el método `execute()` para invocar la acción en el `Receptor`.
    - `CopiarCommand`, `PegarCommand`, `DibujaCirculoCommand`, `ProcesarPedidoCommand` son Comandos Concretos.

4.  **Receptor (Receiver):**

    - Sabe cómo realizar las operaciones necesarias para cumplir la solicitud.
    - Es la "lógica de negocio" real.
    - `EditorTexto`, `Dibujo`, `Pedido` son Receptores.

5.  **Invocador (Invoker):**
    - Pide al comando que se ejecute.
    - No sabe nada sobre la implementación del comando concreto.
    - Solo trabaja con la interfaz `Command`.
    - Puede tener un método para establecer el comando a ejecutar.
    - `Boton`, `SistemaPedidos` son Invocadores.

#### 3. **Notas o advertencias:**

- El **Cliente** es responsable de **conectar todas las piezas**.
- El **Invocador** solo **ejecuta** comandos, no los crea ni sabe qué hacen.
- Los **Comandos Concretos** son el **puente** entre el Invocador y el Receptor.
- El **Receptor** es quien **hace el trabajo real**.
- La **interfaz `Command`** permite que el Invocador trabaje con cualquier tipo de comando de forma genérica.

---

## G - Seudocódigo del Command Pattern (Undo/Redo)

#### 1. **Definición:**

El seudocódigo muestra cómo implementar el patrón Command para soportar operaciones de **deshacer (undo)** en un editor de texto. La clave es guardar un **historial de comandos** y el **estado del editor** antes de cada operación.

![Structure of the Command pattern example](https://refactoring.guru/images/patterns/diagrams/command/example.png)

#### 2. **Seudocódigo (Adaptado a Java):**

```java
// Comando Abstracto
abstract class Command {
    protected Application app;
    protected Editor editor;
    protected String backup; // Para deshacer

    public Command(Application app, Editor editor) {
        this.app = app;
        this.editor = editor;
    }

    // Guarda el estado del editor para poder deshacer
    public void saveBackup() {
        backup = editor.getText();
    }

    // Restaura el estado guardado (deshacer)
    public void undo() {
        editor.setText(backup);
    }

    // Método abstracto para ejecutar el comando concreto
    abstract boolean execute(); // Devuelve true si cambia el estado (para historial)
}

// Comandos Concretos
class CopiarCommand extends Command {
    public CopiarCommand(Application app, Editor editor) { super(app, editor); }
    @Override
    public boolean execute() {
        app.setClipboard(editor.getSelection());
        return false; // No cambia el estado del editor
    }
    @Override
    public void undo() { /* No se necesita deshacer para copiar */ }
}

class CortarCommand extends Command {
    public CortarCommand(Application app, Editor editor) { super(app, editor); }
    @Override
    public boolean execute() {
        saveBackup(); // Guarda estado ANTES de cortar
        app.setClipboard(editor.getSelection());
        editor.deleteSelection();
        return true; // Cambia el estado del editor
    }
}

class PegarCommand extends Command {
    public PegarCommand(Application app, Editor editor) { super(app, editor); }
    @Override
    public boolean execute() {
        saveBackup(); // Guarda estado ANTES de pegar
        editor.replaceSelection(app.getClipboard());
        return true; // Cambia el estado del editor
    }
}

class UndoCommand extends Command {
    public UndoCommand(Application app, Editor editor) { super(app, editor); }
    @Override
    public boolean execute() {
        app.undo(); // Llama al método undo de la aplicación
        return false; // No se guarda en el historial de deshacer
    }
    @Override
    public void undo() { /* No se puede deshacer el deshacer */ }
}

// Historial de Comandos
class CommandHistory {
    private Stack<Command> history = new Stack<>();

    public void push(Command c) {
        history.push(c);
    }

    public Command pop() {
        if (!history.isEmpty()) {
            return history.pop();
        }
        return null;
    }
}

// Receptor: Editor
class Editor {
    private String text = "";

    public String getText() { return text; }
    public void setText(String text) { this.text = text; }
    public String getSelection() { return "Texto Seleccionado"; /* Simulación */ }
    public void deleteSelection() { text = ""; System.out.println("Texto seleccionado borrado."); }
    public void replaceSelection(String clipboard) { text += clipboard; System.out.println("Texto pegado: " + clipboard); }
}

// Invocador y Cliente: Aplicación
class Application {
    private String clipboard = "";
    private Editor activeEditor = new Editor();
    private CommandHistory history = new CommandHistory();

    public String getClipboard() { return clipboard; }
    public void setClipboard(String clipboard) { this.clipboard = clipboard; }

    public void createUI() {
        Boton botonCopiar = new Boton();
        botonCopiar.setComando(new CopiarCommand(this, activeEditor)); // Asigna comando Copiar

        Boton botonCortar = new Boton();
        botonCortar.setComando(new CortarCommand(this, activeEditor)); // Asigna comando Cortar

        Boton botonPegar = new Boton();
        botonPegar.setComando(new PegarCommand(this, activeEditor)); // Asigna comando Pegar

        Boton botonUndo = new Boton();
        botonUndo.setComando(new UndoCommand(this, activeEditor)); // Asigna comando Undo

        botonCopiar.presionar();
        botonCortar.presionar();
        botonPegar.presionar();
        botonUndo.presionar(); // Deshace la última acción
    }

    public void executeCommand(Command command) {
        if (command.execute()) { // Si el comando cambia el estado...
            history.push(command); // ...guárdalo en el historial
        }
    }

    public void undo() {
        Command command = history.pop();
        if (command != null) {
            command.undo(); // Deshace el comando
        } else {
            System.out.println("Nada que deshacer.");
        }
    }

    public static void main(String[] args) {
        Application app = new Application();
        app.createUI();
        app.undo(); // Deshacer desde fuera también funciona
    }
}

// Boton (Invocador Genérico - ya definido antes, reutilizado aquí)
class Boton {
    private Command comando;
    public void setComando(Command comando) { this.comando = comando; }
    public void presionar() { comando.execute(); }
}
```

**Explicación del seudocódigo:**

- `Command` es la clase abstracta base para todos los comandos. Tiene métodos para `saveBackup()`, `undo()`, y `execute()`.
- `CopiarCommand`, `CortarCommand`, `PegarCommand`, `UndoCommand` son comandos concretos.
- `CommandHistory` es una pila que guarda los comandos ejecutados para poder deshacerlos.
- `Editor` es el Receptor, con operaciones de edición de texto.
- `Application` es el Invocador y Cliente. Crea los comandos, los asigna a los botones, gestiona el historial y la operación de deshacer.
- `executeCommand()` ejecuta un comando y lo añade al historial si `execute()` devuelve `true` (indicando que cambió el estado).
- `undo()` saca el último comando del historial y llama a su método `undo()`.

#### 3. **Notas o advertencias:**

- Este ejemplo muestra cómo el Command Pattern facilita la implementación de **undo/redo**.
- La clave es **guardar el estado** antes de ejecutar un comando que modifica el estado.
- El `CommandHistory` actúa como una pila de "acciones pasadas" que se pueden revertir.

---

## H - Aplicabilidad del Command Pattern

#### 1. **Definición:**

¿Cuándo es útil usar el patrón Command? Aquí tienes algunas situaciones clave:

- **Parametrizar objetos con operaciones:** Cuando quieres que los objetos puedan ser configurados para realizar diferentes acciones. Como los botones que pueden ejecutar diferentes comandos.
- **Encolar o programar operaciones:** Si necesitas ejecutar operaciones más tarde, o en un orden específico, o incluso de forma remota. Puedes guardar comandos en una cola y procesarlos cuando sea necesario.
- **Implementar operaciones reversibles (undo/redo):** Como vimos en el ejemplo del editor de texto, el Command Pattern es ideal para deshacer y rehacer acciones.
- **Operaciones basadas en transacciones:** Cuando necesitas asegurar que una serie de operaciones se ejecuten como una unidad, y poder revertir todo si algo falla.
- **Sistemas basados en menús, botones, etc.:** En interfaces gráficas, para desacoplar los elementos de la interfaz de las acciones que realizan.

#### 2. **Ejemplos de uso:**

- **Editores de texto/gráficos:** Operaciones de edición (copiar, pegar, cortar, dibujar, etc.) y funcionalidades de undo/redo.
- **Sistemas de gestión de bases de datos:** Transacciones, comandos SQL.
- **Sistemas de control remoto:** Enviar comandos a dispositivos remotos.
- **Sistemas de workflow:** Definir y ejecutar flujos de trabajo como secuencias de comandos.
- **Juegos:** Acciones del jugador, comandos de la IA.

#### 3. **Notas o advertencias:**

- Usa el Command Pattern cuando necesites **flexibilidad** y **control** sobre la ejecución de acciones.
- Si solo necesitas una forma simple de llamar a un método, quizás el Command Pattern sea **excesivo**. Pero si necesitas las ventajas que ofrece (desacoplamiento, undo, encolamiento, etc.), es una excelente opción.
- Piensa en la aplicabilidad como: "¿Necesito tratar las acciones como **objetos de primera clase** en mi sistema?" Si la respuesta es sí, considera el Command Pattern.

---

## I - Cómo Implementar el Command Pattern

#### 1. **Pasos para la implementación:**

1.  **Crea la interfaz `Command`:** Define un método `execute()` (y opcionalmente `undo()`).
2.  **Crea Comandos Concretos:** Para cada acción que quieras encapsular, crea una clase que implemente `Command`. Cada comando debe:
    - Tener una referencia al **Receptor** que realizará la acción.
    - Almacenar cualquier **parámetro** necesario para la acción.
    - Implementar `execute()` para llamar al método apropiado en el Receptor.
    - (Opcional) Implementar `undo()` para deshacer la acción.
3.  **Identifica los Invocadores:** Determina qué clases **invocarán** los comandos (botones, menús, etc.). Añade un campo para guardar un objeto `Command`.
4.  **Modifica los Invocadores:** En lugar de llamar directamente a la lógica de negocio, haz que los Invocadores llamen al método `execute()` del `Command` que tienen asignado.
5.  **Cliente Configura:** En el código del cliente (por ejemplo, en la inicialización):
    - Crea los **Receptores**.
    - Crea los **Comandos Concretos**, pasando los Receptores necesarios a sus constructores.
    - Crea los **Invocadores** y **asocia** cada Invocador con un Comando Concreto específico usando un método `setCommand()` o similar.

#### 2. **Orden de Inicialización:**

Es importante seguir este orden al crear los objetos:

1.  **Receptores:** Primero crea los objetos que realizarán las acciones (la lógica de negocio).
2.  **Comandos:** Luego crea los comandos, pasándoles los Receptores que necesitan.
3.  **Invocadores:** Finalmente, crea los Invocadores y asígnales los comandos ya creados.

#### 3. **Notas o advertencias:**

- La implementación del Command Pattern implica **crear más clases**, pero mejora la **organización** y **flexibilidad** del código.
- Empieza por identificar las **acciones** que quieres encapsular como comandos.
- Piensa en **quién** realizará cada acción (el Receptor) y **quién** la invocará (el Invocador).
- La clave es la **separación de responsabilidades** y la **abstracción** a través de la interfaz `Command`.

---

## J - Pros y Contras del Command Pattern

#### 1. **Pros (Ventajas):**

- **Principio de Responsabilidad Única:** Desacopla las clases que invocan operaciones de las que las realizan. Cada clase tiene una responsabilidad clara.
- **Principio Abierto/Cerrado:** Puedes añadir nuevos comandos sin modificar el código existente del Invocador o del Receptor. Extensible sin romper lo existente.
- **Implementación de Undo/Redo:** Facilita la creación de funcionalidades de deshacer y rehacer.
- **Ejecución Diferida:** Permite encolar, programar o ejecutar operaciones en diferentes momentos o contextos.
- **Comandos Complejos:** Puedes combinar comandos simples para crear operaciones más complejas (macros, transacciones).

#### 2. **Contras (Desventajas):**

- **Mayor Complejidad del Código:** Introduce una capa adicional de abstracción (las clases Command), lo que puede hacer que el código sea inicialmente más difícil de entender para principiantes.
- **Puede ser Excesivo para Casos Simples:** Si solo necesitas una llamada a un método directo, el Command Pattern puede ser una solución demasiado elaborada.

#### 3. **Notas o advertencias:**

- Evalúa si las **ventajas** del Command Pattern (flexibilidad, extensibilidad, undo/redo, etc.) **justifican la complejidad adicional** en tu proyecto.
- No uses el Command Pattern **solo por usarlo**. Úsalo cuando realmente resuelva un problema de acoplamiento, extensibilidad o necesites las funcionalidades que ofrece.
- En proyectos grandes y complejos, las ventajas del Command Pattern suelen **superar con creces** la pequeña complejidad adicional.

---

## K - Relación con Otros Patrones

#### 1. **Relaciones con otros patrones de diseño:**

El Command Pattern se relaciona con otros patrones que también se centran en la comunicación entre objetos y la gestión de solicitudes.

- **Chain of Responsibility, Command, Mediator, Observer:** Estos patrones abordan diferentes formas de conectar emisores (senders) y receptores (receivers) de solicitudes.

  - **Chain of Responsibility:** Pasa una solicitud a lo largo de una cadena dinámica de posibles receptores hasta que uno la maneja. _Similar a una cadena de mando, donde la solicitud "sube" hasta encontrar a alguien que pueda responder._
  - **Command:** Establece conexiones unidireccionales entre emisores y receptores a través de objetos Command. _El emisor "ordena" al receptor a través del Command._
  - **Mediator:** Elimina las conexiones directas entre emisores y receptores, obligándolos a comunicarse indirectamente a través de un objeto mediador. _Un "intermediario" gestiona la comunicación entre muchos objetos._
  - **Observer:** Permite a los receptores suscribirse y desuscribirse dinámicamente para recibir solicitudes. _Un receptor se "suscribe" para ser notificado de ciertos eventos._

- **Chain of Responsibility y Command:** Los manejadores en Chain of Responsibility pueden implementarse como Commands. Puedes ejecutar diferentes operaciones (Commands) sobre el mismo contexto (la solicitud en la cadena). O, la solicitud en sí puede ser un Command, y se ejecuta la misma operación en diferentes contextos en la cadena. _Puedes combinar ambos patrones para crear sistemas de procesamiento de solicitudes muy flexibles._

- **Command y Memento:** Se usan juntos para implementar "undo". Commands realizan las operaciones, y Mementos guardan el estado del objeto antes de ejecutar un Command. _Memento guarda "instantáneas" del estado para poder volver atrás en el tiempo._

- **Command y Strategy:** Ambos pueden usarse para parametrizar un objeto con una acción. Pero tienen intenciones diferentes.

  - **Command:** Convierte _cualquier_ operación en un objeto. Permite diferir la ejecución, encolar, historial, etc. _Se centra en la acción como objeto y su gestión._
  - **Strategy:** Define _diferentes formas_ de hacer _lo mismo_. Permite intercambiar algoritmos dentro de un contexto. _Se centra en algoritmos intercambiables para una tarea específica._

- **Prototype y Command:** Prototype puede ayudar a crear copias de Commands para guardarlos en el historial (undo/redo). _Prototype facilita la creación de copias de objetos Command._

- **Visitor y Command:** Visitor puede verse como una versión más poderosa de Command. Puede ejecutar operaciones sobre objetos de _diferentes clases_. _Visitor permite definir operaciones que se aplican a una estructura de objetos heterogénea._

#### 2. **Notas o advertencias:**

- Comprender las relaciones entre patrones ayuda a elegir el patrón **más adecuado** para cada situación.
- A menudo, los patrones se **combinan** para resolver problemas más complejos.
- El Command Pattern es una herramienta **versátil** que puede integrarse con otros patrones para crear soluciones robustas y flexibles.
