## A - Principio de Abierto/Cerrado (Open/Closed Principle)

#### 1. **Definición:**

Imagina que tienes una caja (una clase) que hace algo específico. El Principio de Abierto/Cerrado dice que deberías poder **añadir nuevas funcionalidades** a esa caja **sin tener que cambiar cómo funciona por dentro**. Es como si pudieras ponerle nuevos accesorios a un juguete sin tener que desmontarlo y cambiar sus piezas internas.

#### 2. **Ejemplo:**

**Situación Inicial (Antes - Violando el principio):**

Imagina una clase `Pedido` que calcula el costo de envío. Si quieres añadir un nuevo tipo de envío (por ejemplo, "urgente"), ¡tienes que meterte dentro de la clase `Pedido` y modificarla!

![image](https://i.ibb.co/HpYjQmyf/image.png)

```java
class Pedido {
    String shipping;

    public double calcularCostoEnvio(double totalPeso) {
        if (shipping.equals("ground")) {
            // Envío terrestre
            if (getTotal() > 100) {
                return 0; // Gratis para pedidos grandes
            }
            return Math.max(10, totalPeso * 1.5); // $1.5 por kilo, mínimo $10
        }
        if (shipping.equals("air")) {
            // Envío aéreo
            return Math.max(20, totalPeso * 3); // $3 por kilo, mínimo $20
        }
        return 0; // Por defecto
    }

    private double getTotal() {
        // ... (calcula el total del pedido)
        return 150; // Ejemplo
    }

    private double getTotalWeight() {
        // ... (calcula el peso total)
        return 5; // Ejemplo
    }

    public void setShippingType(String shipping) {
        this.shipping = shipping;
    }
}

public class Main {
    public static void main(String[] args) {
        Pedido pedido = new Pedido();
        pedido.setShippingType("ground");
        double costoTerrestre = pedido.calcularCostoEnvio(pedido.getTotalWeight());
        System.out.println("Costo envío terrestre: $" + costoTerrestre); // Output: Costo envío terrestre: $10.0

        pedido.setShippingType("air");
        double costoAereo = pedido.calcularCostoEnvio(pedido.getTotalWeight());
        System.out.println("Costo envío aéreo: $" + costoAereo); // Output: Costo envío aéreo: $20.0
    }
}
```

**Explicación del ejemplo:**

En este código, la clase `Pedido` decide el costo de envío directamente dentro de su método `calcularCostoEnvio`. Si queremos añadir un nuevo tipo de envío, como "express", ¡tendríamos que modificar la clase `Pedido` y añadir otro `if` o `else if`! Esto es justo lo que el Principio de Abierto/Cerrado quiere evitar.

#### 3. **Notas o advertencias:**

- **Riesgo al modificar:** Cambiar código que ya funciona puede introducir errores inesperados en otras partes de tu programa. ¡Es como tocar una pieza de dominó que tumba otras sin querer!
- **No para todo cambio:** Si encuentras un error en la clase, ¡claro que tienes que modificarla para arreglarlo! El principio se refiere a añadir _nuevas funcionalidades_, no a corregir errores.

---

## B - Abierto a la Extensión, Cerrado a la Modificación

#### 1. **Definición:**

Estas palabras "abierto" y "cerrado" pueden sonar confusas al principio, ¡pero no te preocupes!

- **Abierto a la Extensión:** Significa que puedes **ampliar** la funcionalidad de la clase. Puedes crear nuevas clases que añadan cosas a la clase original, como si fueran extensiones o complementos.
- **Cerrado a la Modificación:** Significa que una vez que la clase está lista y funcionando bien, **no deberías modificar su código interno directamente** para añadir nuevas funcionalidades. Deberías extenderla en lugar de cambiarla.

En resumen, puedes hacer que la clase haga más cosas (extensión), pero sin cambiar lo que ya hace (modificación).

#### 2. **Ejemplo:**

Piensa en una aplicación de dibujo.

- **Abierta a la extensión:** Puedes añadir nuevas herramientas de dibujo (lápiz, pincel, aerógrafo) sin cambiar el código base de la aplicación. Cada herramienta sería una "extensión".
- **Cerrada a la modificación:** El código principal que maneja la ventana de dibujo, los menús, etc., no necesita ser modificado cada vez que añades una nueva herramienta.

#### 3. **Notas o advertencias:**

- **No son mutuamente excluyentes:** Una clase puede ser ambas cosas al mismo tiempo: abierta a la extensión y cerrada a la modificación. ¡Esa es la magia del principio!
- **Estabilidad:** El objetivo es hacer que tu código sea más estable y menos propenso a errores cuando añades nuevas características.

---

## C - Solución con el Patrón Estrategia (Strategy Pattern)

#### 1. **Definición:**

El Patrón Estrategia es una forma elegante de aplicar el Principio de Abierto/Cerrado. La idea es **separar las diferentes formas de hacer algo** (las "estrategias") en clases separadas. Luego, la clase principal (como `Pedido`) puede elegir qué estrategia usar sin tener que saber _cómo_ funciona cada estrategia por dentro.

#### 2. **Ejemplo:**

**Situación Mejorada (Después - Aplicando el principio):**

En lugar de tener la lógica de envío dentro de `Pedido`, creamos una **interfaz** llamada `Envio` (o `Shipping` en inglés). Esta interfaz define qué debe hacer cualquier tipo de envío (por ejemplo, calcular el costo). Luego, creamos clases separadas para cada tipo de envío (`EnvioTerrestre`, `EnvioAereo`, etc.) que implementan la interfaz `Envio`.

![image](https://i.ibb.co/3n13W1S/image.png)

```java
// Interfaz para los tipos de envío
interface Envio {
    double calcularCosto(Pedido pedido);
}

// Estrategia para envío terrestre
class EnvioTerrestre implements Envio {
    @Override
    public double calcularCosto(Pedido pedido) {
        if (pedido.getTotal() > 100) {
            return 0; // Gratis para pedidos grandes
        }
        return Math.max(10, pedido.getTotalWeight() * 1.5); // $1.5 por kilo, mínimo $10
    }
}

// Estrategia para envío aéreo
class EnvioAereo implements Envio {
    @Override
    public double calcularCosto(Pedido pedido) {
        return Math.max(20, pedido.getTotalWeight() * 3); // $3 por kilo, mínimo $20
    }
}

class Pedido {
    private Envio envio; // Ahora Pedido "tiene un" Envio

    public Pedido(Envio envio) {
        this.envio = envio;
    }

    public double calcularCostoEnvio() {
        return envio.calcularCosto(this); // Delega el cálculo al objeto Envio
    }

    private double getTotal() {
        // ... (calcula el total del pedido)
        return 150; // Ejemplo
    }

    private double getTotalWeight() {
        // ... (calcula el peso total)
        return 5; // Ejemplo
    }

    public void setTipoEnvio(Envio envio) {
        this.envio = envio;
    }
}


public class Main {
    public static void main(String[] args) {
        // Usando envío terrestre
        Pedido pedidoTerrestre = new Pedido(new EnvioTerrestre());
        double costoTerrestre = pedidoTerrestre.calcularCostoEnvio();
        System.out.println("Costo envío terrestre: $" + costoTerrestre); // Output: Costo envío terrestre: $10.0

        // Usando envío aéreo
        Pedido pedidoAereo = new Pedido(new EnvioAereo());
        double costoAereo = pedidoAereo.calcularCostoEnvio();
        System.out.println("Costo envío aéreo: $" + costoAereo); // Output: Costo envío aéreo: $20.0

        // Cambiando el tipo de envío dinámicamente
        pedidoTerrestre.setTipoEnvio(new EnvioAereo());
        double nuevoCostoAereo = pedidoTerrestre.calcularCostoEnvio();
        System.out.println("Nuevo costo aéreo (cambiando el tipo en tiempo de ejecución): $" + nuevoCostoAereo); // Output: Nuevo costo aéreo (cambiando el tipo en tiempo de ejecución): $20.0
    }
}
```

**Explicación del ejemplo:**

1.  **Interfaz `Envio`:** Define el contrato para cualquier tipo de envío. Todas las clases de envío deben seguir este contrato.
2.  **Clases de Estrategia (`EnvioTerrestre`, `EnvioAereo`):** Cada clase implementa la interfaz `Envio` y contiene la lógica específica para calcular el costo de ese tipo de envío.
3.  **Clase `Pedido`:** Ahora, `Pedido` ya no se preocupa _cómo_ se calcula el envío. Simplemente **tiene un objeto `Envio`** y le pide que calcule el costo. Podemos cambiar el tipo de `Envio` que usa `Pedido` sin modificar la clase `Pedido` en sí.

#### 3. **Notas o advertencias:**

- **Añadir nuevos envíos es fácil:** Si quieres añadir un nuevo tipo de envío (por ejemplo, "envío en bicicleta"), solo tienes que crear una nueva clase (`EnvioBicicleta`) que implemente la interfaz `Envio`. ¡No tienes que tocar la clase `Pedido`!
- **Código más organizado:** Cada tipo de envío tiene su propia clase, lo que hace que el código sea más fácil de entender y mantener.
- **Principio de Responsabilidad Única:** Cada clase de envío se encarga solo de calcular su propio costo, siguiendo otro principio importante de diseño.

---

## D - Beneficios de Aplicar el Principio de Abierto/Cerrado

#### 1. **Definición:**

Aplicar el Principio de Abierto/Cerrado, especialmente usando patrones como Estrategia, trae muchas ventajas a tu código.

#### 2. **Beneficios Clave:**

- **Menos Riesgo de Romper Código Existente:** Al no modificar clases que ya funcionan, reduces la posibilidad de introducir errores en partes del programa que ya estaban probadas y funcionando bien.
- **Mayor Facilidad para Añadir Nuevas Funcionalidades:** Extender el sistema con nuevas características se vuelve más sencillo y seguro. Solo creas nuevas clases en lugar de cambiar las viejas.
- **Código Más Mantenible:** Un código que sigue este principio es más fácil de entender, modificar y mantener a largo plazo. Las clases son más pequeñas y tienen responsabilidades más claras.
- **Reutilización de Código:** Las clases de estrategia (como `EnvioTerrestre`, `EnvioAereo`) pueden ser reutilizadas en otras partes de tu programa si necesitas calcular costos de envío en otros contextos.

#### 3. **Notas o advertencias:**

- **No es "bala de plata":** Aplicar el Principio de Abierto/Cerrado no siempre es necesario o la mejor solución para _todos_ los problemas. A veces, la modificación directa de una clase es más simple y adecuada.
- **Complejidad inicial:** Al principio, puede parecer que aplicar este principio añade un poco de complejidad al código (más clases, interfaces, etc.). Sin embargo, a largo plazo, esta complejidad se traduce en un código más robusto y fácil de mantener.

---

## E - Cuándo NO Aplicar el Principio de Abierto/Cerrado

#### 1. **Definición:**

Aunque el Principio de Abierto/Cerrado es muy útil, hay situaciones en las que **no es necesario o incluso no es recomendable** aplicarlo.

#### 2. **Situaciones donde NO aplicar:**

- **Corrección de Errores (Bugs):** Si encuentras un error en una clase, **debes modificar la clase directamente para corregirlo**. No crees una subclase o uses una estrategia para "parchear" el error. Una clase hija no debe ser responsable de los problemas de la clase padre.
- **Cambios Muy Pequeños y Aislados:** Si necesitas hacer un cambio muy pequeño y que sabes que no afectará a otras partes del sistema, y que no se espera que la clase se extienda mucho en el futuro, puede ser más sencillo modificar la clase directamente. No siempre es necesario "sobre-ingenierizar" la solución.
- **Fases Iniciales de Desarrollo:** En las primeras etapas de un proyecto, cuando el código está en constante cambio y evolución, puede ser prematuro preocuparse demasiado por el Principio de Abierto/Cerrado. Es más importante tener algo funcionando rápidamente. Puedes refactorizar y aplicar el principio más adelante cuando la aplicación se estabilice.

#### 3. **Notas o advertencias:**

- **Sentido común:** Usa el sentido común y el juicio. El Principio de Abierto/Cerrado es una guía, no una regla estricta. Piensa en los beneficios a largo plazo y en la complejidad que introduces al aplicarlo.
- **Refactorización:** Si al principio no aplicaste el principio, pero luego ves que tu clase se está volviendo difícil de mantener o extender, siempre puedes refactorizar tu código y aplicarlo más tarde. ¡La refactorización es una herramienta poderosa!
