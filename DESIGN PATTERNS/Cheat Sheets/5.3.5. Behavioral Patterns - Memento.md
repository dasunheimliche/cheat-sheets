## A - Memento

#### 1. **Definición:**

Memento es un patrón de diseño de comportamiento que te permite guardar y restaurar el estado previo de un objeto sin revelar los detalles de su implementación interna. Imagina que es como tomar una "foto" del estado de un objeto para poder volver a ese estado más tarde, sin importar cómo esté hecho el objeto por dentro.

#### 2. **Ejemplo:**

Imagina que tienes una clase `Editor` que guarda el texto y la posición del cursor.

```java
class Editor {
    private String text;
    private int cursorX;
    private int cursorY;

    public void setText(String text) {
        this.text = text;
    }

    public void setCursorPosition(int x, int y) {
        this.cursorX = x;
        this.cursorY = y;
    }

    public String getText() {
        return this.text;
    }

    public String showState() {
        return "Texto: " + text + ", Cursor: [" + cursorX + "," + cursorY + "]";
    }

    // Método para crear un Memento (snapshot del estado actual)
    public EditorMemento guardarEstado() {
        return new EditorMemento(text, cursorX, cursorY);
    }

    // Método para restaurar el estado desde un Memento
    public void restaurarEstado(EditorMemento memento) {
        this.text = memento.getTextoGuardado();
        this.cursorX = memento.getCursorXGuardado();
        this.cursorY = memento.getCursorYGuardado();
    }

    // Clase interna Memento
    public static class EditorMemento {
        private final String textoGuardado;
        private final int cursorXGuardado;
        private final int cursorYGuardado;

        public EditorMemento(String texto, int cursorX, int cursorY) {
            this.textoGuardado = texto;
            this.cursorXGuardado = cursorX;
            this.cursorYGuardado = cursorY;
        }

        // Getters para acceder al estado guardado (solo lectura)
        public String getTextoGuardado() {
            return textoGuardado;
        }

        public int getCursorXGuardado() {
            return cursorXGuardado;
        }

        public int getCursorYGuardado() {
            return cursorYGuardado;
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Editor editor = new Editor();
        editor.setText("Hola mundo");
        editor.setCursorPosition(5, 0);
        System.out.println("Estado inicial: " + editor.showState()); // Estado inicial: Texto: Hola mundo, Cursor: [5,0]

        // Guardar el estado actual
        Editor.EditorMemento memento1 = editor.guardarEstado();

        editor.setText("Hola mundo editado");
        editor.setCursorPosition(10, 2);
        System.out.println("Estado modificado: " + editor.showState()); // Estado modificado: Texto: Hola mundo editado, Cursor: [10,2]

        // Restaurar al estado guardado
        editor.restaurarEstado(memento1);
        System.out.println("Estado restaurado: " + editor.showState()); // Estado restaurado: Texto: Hola mundo, Cursor: [5,0]
    }
}
```

**Explicación del ejemplo:**

En este ejemplo, la clase `Editor` es el "Originador". `EditorMemento` es la clase "Memento" interna.

- `guardarEstado()` crea un objeto `EditorMemento` que guarda una copia del estado actual del `Editor` (texto y posición del cursor).
- `restaurarEstado(EditorMemento memento)` usa un objeto `EditorMemento` para restaurar el `Editor` a un estado previo.
- La clase `EditorMemento` es como una "caja negra" que guarda el estado. Solo el `Editor` (el Originador) puede crear y usar un `EditorMemento` para restaurar su propio estado. Nadie más puede meterse dentro del `EditorMemento` para cambiar el estado guardado.

#### 3. **Notas o advertencias:**

- Memento ayuda a mantener la **encapsulación**. El estado interno del objeto `Editor` (variables `text`, `cursorX`, `cursorY`) se mantiene privado. Otros objetos (como `Main` en el ejemplo) no pueden acceder directamente a él ni modificarlo a través del Memento.
- El Memento en sí mismo suele ser **inmutable** una vez creado. Esto asegura que el estado guardado no se modifique accidentalmente.

## B - Intención del patrón Memento

#### 1. **Definición:**

La intención principal del patrón Memento es permitirte **guardar el estado interno de un objeto en un momento dado, para poder restaurarlo a ese mismo estado más tarde, todo esto sin romper la encapsulación del objeto.** Es como tener un "punto de guardado" en un videojuego al que puedes volver cuando quieras.

#### 2. **Ejemplo:**

Piensa en la función "deshacer" (undo) en un editor de texto. Cada vez que haces un cambio (escribes, borras, formateas), el editor guarda un "memento" del estado anterior del documento. Si pulsas "deshacer", el editor usa el memento más reciente para volver al estado anterior.

```java
// Ejemplo simplificado de un "Caretaker" que gestiona una lista de Mementos para "deshacer"
import java.util.ArrayList;
import java.util.List;

class HistorialEditor {
    private List<Editor.EditorMemento> mementos = new ArrayList<>();
    private Editor editor;

    public HistorialEditor(Editor editor) {
        this.editor = editor;
    }

    public void guardarEstado() {
        mementos.add(editor.guardarEstado());
    }

    public void deshacer() {
        if (!mementos.isEmpty()) {
            Editor.EditorMemento ultimoMemento = mementos.remove(mementos.size() - 1);
            editor.restaurarEstado(ultimoMemento);
        } else {
            System.out.println("No hay estados para deshacer.");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Editor editor = new Editor();
        HistorialEditor historial = new HistorialEditor(editor);

        editor.setText("Texto inicial");
        historial.guardarEstado(); // Guardar estado 1
        System.out.println("Estado 1: " + editor.showState());

        editor.setText("Texto modificado 1");
        historial.guardarEstado(); // Guardar estado 2
        System.out.println("Estado 2: " + editor.showState());

        editor.setText("Texto modificado 2");
        System.out.println("Estado actual: " + editor.showState());

        historial.deshacer(); // Volver al estado 2
        System.out.println("Deshacer 1: " + editor.showState());

        historial.deshacer(); // Volver al estado 1
        System.out.println("Deshacer 2: " + editor.showState());

        historial.deshacer(); // No hay más estados para deshacer
    }
}
```

**Explicación del ejemplo:**

- `HistorialEditor` actúa como el "Caretaker". Guarda una lista de `EditorMemento` (los "mementos").
- `guardarEstado()` le pide al `Editor` que cree un memento y lo añade a la lista del historial.
- `deshacer()` saca el último memento del historial y le dice al `Editor` que restaure su estado usando ese memento.

#### 3. **Notas o advertencias:**

- Memento es muy útil para implementar funcionalidades de **deshacer/rehacer**, **transacciones** (volver atrás si algo falla) o **restauración de estados previos**.
- Sin Memento, para guardar y restaurar el estado de un objeto, tendrías que acceder directamente a sus atributos internos, rompiendo la encapsulación y haciendo el código más frágil y difícil de mantener.

## C - Problema que resuelve Memento

#### 1. **Definición:**

El problema principal que Memento resuelve es cómo **guardar y restaurar el estado de un objeto sin exponer su estructura interna privada.** Imagina que quieres implementar la función "deshacer" en un editor de texto. Si intentas hacerlo directamente, te encontrarás con dos problemas:

1.  **Encapsulación rota:** Para guardar el estado, necesitarías acceder a los detalles internos del objeto (variables privadas, etc.). Esto rompe la encapsulación y hace que el código sea más difícil de cambiar y mantener.
2.  **Fragilidad:** Si cambias la estructura interna del objeto (añades o eliminas variables), el código que guarda y restaura el estado también tendría que cambiar, haciendo el sistema muy frágil.

#### 2. **Ejemplo:**

Imagina que intentas guardar el estado del `Editor` (del ejemplo anterior) desde fuera, sin usar Memento.

```java
// Intento INCORRECTO de guardar y restaurar el estado del Editor SIN Memento (rompe encapsulación)

class EditorIncorrecto {
    public String textoPublico; // ¡Atributo público! Rompe encapsulación
    public int cursorXPublico; // ¡Atributo público! Rompe encapsulación
    public int cursorYPublico; // ¡Atributo público! Rompe encapsulación

    public EditorIncorrecto(String texto, int cursorX, int cursorY) {
        this.textoPublico = texto;
        this.cursorXPublico = cursorX;
        this.cursorYPublico = cursorY;
    }

    public String mostrarEstado() {
        return "Texto: " + textoPublico + ", Cursor: [" + cursorXPublico + "," + cursorYPublico + "]";
    }
}

class HistorialIncorrecto {
    private List<EditorIncorrecto> estados = new ArrayList<>(); // Guarda objetos Editor directamente
    private EditorIncorrecto editor;

    public HistorialIncorrecto(EditorIncorrecto editor) {
        this.editor = editor;
    }

    public void guardarEstado() {
        estados.add(new EditorIncorrecto(editor.textoPublico, editor.cursorXPublico, editor.cursorYPublico)); // Acceso directo a atributos públicos
    }

    public void deshacer() {
        if (!estados.isEmpty()) {
            EditorIncorrecto estadoAnterior = estados.remove(estados.size() - 1);
            editor.textoPublico = estadoAnterior.textoPublico; // Acceso directo a atributos públicos para restaurar
            editor.cursorXPublico = estadoAnterior.cursorXPublico;
            editor.cursorYPublico = estadoAnterior.cursorYPublico;
        } else {
            System.out.println("No hay estados para deshacer.");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        EditorIncorrecto editor = new EditorIncorrecto("Texto inicial", 0, 0);
        HistorialIncorrecto historial = new HistorialIncorrecto(editor);

        historial.guardarEstado();
        editor.textoPublico = "Texto modificado";
        editor.cursorXPublico = 10;
        editor.cursorYPublico = 5;
        System.out.println("Estado modificado: " + editor.mostrarEstado());

        historial.deshacer();
        System.out.println("Estado restaurado: " + editor.mostrarEstado());
    }
}
```

**Explicación del ejemplo:**

- En `EditorIncorrecto`, los atributos `textoPublico`, `cursorXPublico`, `cursorYPublico` son **públicos**. Esto rompe la encapsulación.
- `HistorialIncorrecto` guarda directamente objetos `EditorIncorrecto` y accede a sus atributos públicos para guardar y restaurar el estado.
- **Problema:** Si decidieras cambiar la implementación interna de `EditorIncorrecto` (por ejemplo, cambiar el nombre de las variables o usar una estructura de datos diferente), tendrías que cambiar también `HistorialIncorrecto`. Además, ¡cualquier parte del código podría modificar directamente los atributos públicos de `EditorIncorrecto`!

#### 3. **Notas o advertencias:**

- El ejemplo `EditorIncorrecto` muestra **lo que NO hay que hacer**. Romper la encapsulación lleva a código frágil y difícil de mantener.
- Memento evita este problema permitiendo que el **propio objeto** (el Originador) gestione la creación y restauración de su estado, sin exponer los detalles internos a otros objetos.

## D - Solución que ofrece Memento

#### 1. **Definición:**

La solución que ofrece el patrón Memento es **delegar la creación de las "instantáneas" del estado al propio objeto que posee ese estado**, llamado **Originador**. En lugar de que otros objetos intenten "espiar" dentro del Originador para copiar su estado, el Originador se encarga de crear su propio "Memento" (la instantánea).

El Memento es un objeto especial que **guarda una copia del estado del Originador**. La clave es que **solo el Originador tiene acceso completo al contenido del Memento**. Otros objetos, llamados **Caretakers**, solo pueden interactuar con el Memento de forma limitada, generalmente solo para guardarlo y pedirle al Originador que restaure su estado desde él.

![The originator has full access to the memento, whereas the caretaker can only access the metadata](https://refactoring.guru/images/patterns/diagrams/memento/solution-en.png)

#### 2. **Ejemplo:**

Volviendo al ejemplo del `Editor` y `HistorialEditor` (del concepto B), vemos cómo se aplica la solución Memento:

- **Originator:** La clase `Editor` es el Originador. Es quien sabe cómo guardar y restaurar su propio estado.
- **Memento:** La clase interna `EditorMemento` es el Memento. Guarda el estado del `Editor` (texto, cursor). Es inmutable y solo el `Editor` puede acceder a su contenido completo.
- **Caretaker:** La clase `HistorialEditor` es el Caretaker. Guarda una lista de Mementos, pero no sabe ni le importa qué hay dentro de ellos. Simplemente le pide al Originator que cree Mementos y que se restaure desde ellos.

```java
// (Código del ejemplo del concepto B - HistorialEditor y Editor con Memento)
// ... (mismo código que en el concepto B) ...
```

**Explicación del ejemplo:**

- El `HistorialEditor` (Caretaker) no necesita saber cómo está implementado internamente el `Editor` (Originator). Solo interactúa con él a través de los métodos `guardarEstado()` y `restaurarEstado()`.
- El `EditorMemento` (Memento) encapsula el estado del `Editor`. El `HistorialEditor` solo guarda y gestiona los `EditorMemento`, pero no puede acceder directamente al texto o la posición del cursor guardados dentro de ellos.
- La encapsulación del `Editor` se mantiene intacta.

#### 3. **Notas o advertencias:**

- Memento **restaura la encapsulación** al hacer que el Originator sea responsable de su propio estado.
- El Caretaker se convierte en un **gestor de Mementos**, sin necesidad de conocer los detalles internos del Originator.
- Esta separación de responsabilidades hace que el código sea más **flexible, mantenible y menos frágil**.

## E - Estructura del patrón Memento

#### 1. **Definición:**

El patrón Memento tiene tres roles principales:

1.  **Originator (Originador):** Es el objeto cuyo estado interno necesita ser guardado.

    - Crea un Memento que captura su estado actual.
    - Puede usar un Memento para restaurar su estado anterior.

2.  **Memento (Recuerdo/Instantánea):** Es un objeto que almacena el estado interno del Originator en un momento específico.

    - Es como una "foto" del estado del Originator.
    - Debe ser **inmutable** (una vez creado, no se puede modificar).
    - Solo el Originator que lo creó debería tener acceso completo a su contenido.

3.  **Caretaker (Cuidador/Gestor):** Es el objeto que se encarga de guardar y gestionar los Mementos.
    - No inspecciona ni modifica el contenido de los Mementos.
    - Sabe cuándo pedirle al Originator que cree un Memento y cuándo pedirle que se restaure desde un Memento.
    - Puede almacenar varios Mementos para implementar funcionalidades como "deshacer" (historial de estados).

![Memento design pattern](https://refactoring.guru/images/patterns/content/memento/memento-en.png)

#### 2. **Ejemplo:**

En el contexto del editor de texto:

- **Originator:** La clase `Editor`.
- **Memento:** La clase interna `EditorMemento`.
- **Caretaker:** La clase `HistorialEditor` (o podría ser un objeto Command en un sistema más complejo de "deshacer/rehacer" basado en comandos).

#### 3. **Notas o advertencias:**

- La estructura de Memento promueve la **separación de responsabilidades**. El Originator se centra en su lógica de negocio y en gestionar su estado. El Caretaker se centra en la gestión del historial de estados.
- Existen diferentes formas de implementar la relación entre Originator y Memento, como se verá en los siguientes conceptos (clases anidadas, interfaces, etc.).

## F - Implementación con clases anidadas

#### 1. **Definición:**

Una forma común de implementar Memento, especialmente en lenguajes como Java, C++ y C#, es usar **clases anidadas** (nested classes). En este enfoque, la clase Memento se define **dentro** de la clase Originator.

![Memento based on nested classes](https://refactoring.guru/images/patterns/diagrams/memento/structure1.png)

#### 2. **Características principales:**

1.  **Encapsulación fuerte:** Al ser una clase anidada privada dentro del Originator, la clase Memento está **oculta** para el resto del código. Solo la clase Originator puede crear instancias de Memento y acceder a sus miembros (incluso si son privados).
2.  **Acceso privilegiado:** El Originator tiene **acceso completo** a los miembros del Memento (atributos y métodos), incluso si son declarados como `private`. Esto permite al Originator guardar y restaurar su estado fácilmente.
3.  **Caretaker limitado:** El Caretaker (que está fuera del Originator) solo interactúa con el Memento a través de una **interfaz muy limitada** (generalmente, no tiene interfaz pública en este tipo de implementación, simplemente guarda el objeto Memento opaco). El Caretaker no puede inspeccionar ni modificar el estado guardado dentro del Memento.

#### 3. **Ejemplo (Java):**

El ejemplo del `Editor` y `EditorMemento` que hemos estado usando (conceptos A, B, D) es precisamente un ejemplo de implementación con clases anidadas.

```java
// (Código del ejemplo del concepto A - Editor con clase interna EditorMemento)
// ... (mismo código que en el concepto A) ...
```

**Explicación del ejemplo:**

- `EditorMemento` es una **clase interna** dentro de `Editor`. Es `public static` para poder ser referenciada desde fuera de `Editor` como tipo de dato (ej: `Editor.EditorMemento`). Podría ser `private static` si solo se usara internamente en `Editor`, pero para el patrón Memento, generalmente se necesita que el Caretaker pueda guardar y pasar objetos Memento.
- El constructor de `EditorMemento` y los getters (`getTextoGuardado`, etc.) son `public`, pero los atributos (`textoGuardado`, etc.) son `private final`. Esto asegura que el Memento sea **inmutable** desde fuera y que solo el `Editor` pueda "llenarlo" al crearlo.
- El `HistorialEditor` (Caretaker) guarda objetos `Editor.EditorMemento` pero no sabe nada sobre su contenido interno.

#### 4. **Notas o advertencias:**

- La implementación con clases anidadas es **muy común y recomendada** en lenguajes que las soportan bien.
- Ofrece un **alto nivel de encapsulación** y control de acceso.
- Es **sencilla de entender e implementar**.

## G - Implementación con interfaz intermedia

#### 1. **Definición:**

En lenguajes que no soportan clases anidadas (como PHP o algunos dialectos de JavaScript más antiguos), o si se prefiere una separación más clara, se puede usar una **interfaz intermedia** para restringir el acceso al Memento.

![Memento without nested classes](https://refactoring.guru/images/patterns/diagrams/memento/structure2.png)

#### 2. **Características principales:**

1.  **Interfaz Memento:** Se define una interfaz (ej: `MementoInterface`) que declara **solo métodos para acceder a metadatos** del Memento (ej: fecha de creación, nombre de la operación guardada), pero **no métodos para acceder al estado interno** del Originator.
2.  **Clase Memento concreta:** La clase Memento concreta (ej: `EditorMementoConcreto`) implementa la interfaz `MementoInterface` y además contiene los atributos con el estado interno del Originator.
3.  **Acceso diferenciado:**
    - El **Caretaker** solo conoce y trabaja con la **interfaz `MementoInterface`**. Solo puede acceder a los metadatos del Memento a través de los métodos definidos en la interfaz.
    - El **Originator** conoce y trabaja directamente con la **clase `EditorMementoConcreto`**. Tiene acceso completo a todos sus atributos y métodos (incluyendo los que no están en la interfaz).

#### 3. **Ejemplo (Java - simulando interfaz intermedia):**

Aunque Java soporta clases anidadas, podemos simular el enfoque de interfaz intermedia para ilustrar el concepto.

```java
// Interfaz Memento (solo metadatos - en este ejemplo, vacía, pero podría tener métodos para metadatos)
interface MementoInterface {
    // Podría tener métodos para obtener metadatos como fecha de creación, etc.
}

// Clase Memento concreta (implementa la interfaz)
class EditorMementoConcreto implements MementoInterface {
    private final String textoGuardado;
    private final int cursorXGuardado;
    private final int cursorYGuardado;

    public EditorMementoConcreto(String texto, int cursorX, int cursorY) {
        this.textoGuardado = texto;
        this.cursorXGuardado = cursorX;
        this.cursorYGuardado = cursorY;
    }

    // Getters para el Originator (acceso completo)
    public String getTextoGuardado() {
        return textoGuardado;
    }

    public int getCursorXGuardado() {
        return cursorXGuardado;
    }

    public int getCursorYGuardado() {
        return cursorYGuardado;
    }
}

class EditorInterfaz {
    private String text;
    private int cursorX;
    private int cursorY;

    // ... (métodos setText, setCursorPosition, showState - iguales al ejemplo anterior) ...

    public MementoInterface guardarEstado() {
        return new EditorMementoConcreto(text, cursorX, cursorY); // Devuelve la interfaz Memento
    }

    public void restaurarEstado(MementoInterface mementoInterfaz) {
        // Necesitamos "castear" a la clase concreta para acceder a los getters completos
        EditorMementoConcreto mementoConcreto = (EditorMementoConcreto) mementoInterfaz;
        this.text = mementoConcreto.getTextoGuardado();
        this.cursorX = mementoConcreto.getCursorXGuardado();
        this.cursorY = mementoConcreto.getCursorYGuardado();
    }
}

class HistorialEditorInterfaz {
    private List<MementoInterface> mementos = new ArrayList<>(); // Lista de interfaz Memento
    private EditorInterfaz editor;

    public HistorialEditorInterfaz(EditorInterfaz editor) {
        this.editor = editor;
    }

    public void guardarEstado() {
        mementos.add(editor.guardarEstado()); // Guarda la interfaz Memento
    }

    public void deshacer() {
        if (!mementos.isEmpty()) {
            MementoInterface ultimoMemento = mementos.remove(mementos.size() - 1);
            editor.restaurarEstado(ultimoMemento); // Pasa la interfaz Memento para restaurar
        } else {
            System.out.println("No hay estados para deshacer.");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        EditorInterfaz editor = new EditorInterfaz();
        HistorialEditorInterfaz historial = new HistorialEditorInterfaz(editor);
        // ... (resto del código de prueba similar al ejemplo anterior) ...
    }
}
```

**Explicación del ejemplo:**

- `MementoInterface` es la interfaz intermedia. En este ejemplo está vacía, pero en un caso real podría tener métodos como `getFechaCreacion()`, `getOperacionRealizada()`, etc., para que el Caretaker tenga información básica sobre el Memento sin acceder al estado interno.
- `EditorMementoConcreto` implementa `MementoInterface` y contiene el estado.
- `EditorInterfaz.guardarEstado()` devuelve un objeto que implementa `MementoInterface`.
- `HistorialEditorInterfaz` guarda una lista de `MementoInterface`.
- En `EditorInterfaz.restaurarEstado()`, se necesita un **cast** a `EditorMementoConcreto` para poder acceder a los getters que devuelven el estado interno.

#### 4. **Notas o advertencias:**

- La implementación con interfaz intermedia ofrece una **separación más explícita** entre la interfaz pública del Memento (para el Caretaker) y la implementación concreta (para el Originator).
- Puede ser útil en situaciones donde se quiere **reducir el acoplamiento** entre el Originator y el Caretaker, o en lenguajes sin clases anidadas.
- Introduce un poco más de **complejidad** en comparación con las clases anidadas, debido a la interfaz y el casting.

## H - Implementación con encapsulación estricta

#### 1. **Definición:**

Existe una implementación aún más estricta del patrón Memento, que busca **evitar cualquier posibilidad de que otras clases accedan al estado del Originator a través del Memento**, incluso a través de getters o interfaces.

![Memento with strict encapsulation](https://refactoring.guru/images/patterns/diagrams/memento/structure3.png)

#### 2. **Características principales:**

1.  **Múltiples tipos de Originator y Memento:** Se permite tener diferentes clases Originator y clases Memento correspondientes. Cada Originator trabaja con su propio tipo de Memento.
2.  **Memento "activo":** El Memento ya no es solo un contenedor pasivo de datos. Ahora tiene un método `restore()` que **él mismo se encarga de restaurar el estado del Originator** al que está asociado.
3.  **Relación Originator-Memento:** Cada Memento se crea con una **referencia al Originator** que lo creó. Cuando se llama al método `restore()` del Memento, este usa esa referencia para decirle al Originator que restaure su estado.
4.  **Caretaker aún más limitado:** El Caretaker se vuelve aún más "ciego" al contenido del Memento. Simplemente guarda Mementos y luego les pide que se restauren a sí mismos (`memento.restore()`).

#### 3. **Ejemplo (Pseudocódigo - adaptado del texto):**

El pseudocódigo del texto ilustra bien esta implementación. Lo adaptaremos a Java para dar una idea más concreta.

```java
// Originator
class EditorEstricto {
    private String text;
    private int cursorX;
    private int cursorY;
    private int selectionWidth;

    // Setters para que el Memento pueda restaurar el estado
    public void setText(String text) {
        this.text = text;
    }

    public void setCursor(int x, int y) {
        this.cursorX = x;
        this.cursorY = y;
    }

    public void setSelectionWidth(int width) {
        this.selectionWidth = width;
    }

    public String showState() {
        return "Texto: " + text + ", Cursor: [" + cursorX + "," + cursorY + "], Selección: " + selectionWidth;
    }

    // Crea un Memento y le pasa el Originator actual (this)
    public SnapshotEstricto createSnapshot() {
        return new SnapshotEstricto(this, text, cursorX, cursorY, selectionWidth);
    }
}

// Memento (ahora "activo" - tiene método restore)
class SnapshotEstricto {
    private final EditorEstricto editor; // Referencia al Originator
    private final String text;
    private final int cursorX;
    private final int cursorY;
    private final int selectionWidth;

    public SnapshotEstricto(EditorEstricto editor, String text, int cursorX, int cursorY, int selectionWidth) {
        this.editor = editor; // Guarda la referencia al Originator
        this.text = text;
        this.cursorX = cursorX;
        this.cursorY = cursorY;
        this.selectionWidth = selectionWidth;
    }

    // Método para restaurar el estado del Originator asociado
    public void restore() {
        editor.setText(text); // Usa setters del Originator para restaurar
        editor.setCursor(cursorX, cursorY);
        editor.setSelectionWidth(selectionWidth);
    }
}

// Caretaker (Command en este ejemplo - como en el pseudocódigo)
class CommandEstricto {
    private SnapshotEstricto backup;

    private EditorEstricto editor; // Necesita referencia al Editor para crear snapshots

    public CommandEstricto(EditorEstricto editor) {
        this.editor = editor;
    }

    public void makeBackup() {
        backup = editor.createSnapshot(); // Pide al Editor que cree un Snapshot
    }

    public void undo() {
        if (backup != null) {
            backup.restore(); // Le pide al Memento que se restaure a sí mismo
        }
    }
    // ... (métodos para ejecutar la "command" que modifica el Editor) ...
}

public class Main {
    public static void main(String[] args) {
        EditorEstricto editor = new EditorEstricto();
        CommandEstricto comando = new CommandEstricto(editor);

        editor.setText("Texto inicial");
        editor.setCursor(0, 0);
        editor.setSelectionWidth(0);
        comando.makeBackup(); // Guardar estado 1
        System.out.println("Estado 1: " + editor.showState());

        editor.setText("Texto modificado");
        editor.setCursor(10, 2);
        editor.setSelectionWidth(5);
        comando.makeBackup(); // Guardar estado 2
        System.out.println("Estado 2: " + editor.showState());

        editor.setText("Texto final");
        System.out.println("Estado actual: " + editor.showState());

        comando.undo(); // Volver al estado 2 (usando Memento "activo")
        System.out.println("Deshacer 1: " + editor.showState());

        comando.undo(); // Volver al estado 1
        System.out.println("Deshacer 2: " + editor.showState());
    }
}
```

**Explicación del ejemplo:**

- `EditorEstricto` es el Originator. Tiene **setters** para que el Memento pueda restaurar su estado.
- `SnapshotEstricto` es el Memento. Guarda una **referencia al `EditorEstricto`** que lo creó. El método `restore()` **llama a los setters del `EditorEstricto`** para restaurar el estado.
- `CommandEstricto` es el Caretaker (en este caso, un Command). Cuando se llama a `undo()`, simplemente llama a `backup.restore()`. El Caretaker no sabe cómo se restaura el estado, solo le pide al Memento que lo haga.

#### 4. **Notas o advertencias:**

- Esta implementación ofrece la **máxima encapsulación**. Ni siquiera el Caretaker necesita saber nada sobre la estructura interna del Originator o del Memento.
- Hace que el Memento sea más "inteligente" (activo), delegando la lógica de restauración al propio Memento.
- Puede ser útil en sistemas complejos donde se busca una **separación muy estricta** entre componentes y se quiere minimizar el acoplamiento.
- Requiere que el Originator proporcione **setters** para que el Memento pueda restaurar el estado.

## I - Aplicabilidad del patrón Memento

#### 1. **Definición:**

El patrón Memento es útil en las siguientes situaciones:

1.  **Funcionalidad "deshacer/rehacer":** Es el caso de uso más común. Cuando necesitas permitir a los usuarios deshacer operaciones y volver a estados previos de un objeto.
2.  **Transacciones:** Cuando necesitas realizar una operación compleja que puede fallar, y en caso de fallo, necesitas **volver al estado anterior** al inicio de la operación (rollback).
3.  **Puntos de control (checkpoints):** En sistemas que necesitan guardar el estado en ciertos momentos para poder **restaurar a un punto anterior** en caso de problemas o para análisis.
4.  **Encapsulación:** Cuando necesitas guardar el estado de un objeto, pero **acceder directamente a sus atributos internos rompería la encapsulación**. Memento permite guardar el estado sin violar la privacidad del objeto.

#### 2. **Ejemplos concretos:**

- **Editores de texto/gráficos:** Funciones de "deshacer" y "rehacer".
- **Bases de datos:** Mecanismos de transacción y rollback.
- **Máquinas virtuales/emuladores:** Guardar y restaurar el estado de la máquina virtual.
- **Juegos:** Guardar el progreso del juego (puntos de guardado).
- **Sistemas de configuración:** Volver a configuraciones previas.

#### 3. **Notas o advertencias:**

- Memento es especialmente valioso cuando el estado que necesitas guardar es **complejo** o contiene **datos privados**.
- Si el estado es muy simple y no hay problemas de encapsulación, a veces un simple **clonado del objeto** (usando el patrón Prototype, como se menciona en "Relaciones con otros patrones") puede ser una alternativa más sencilla.
- Considera el **coste de memoria** de guardar muchos Mementos, especialmente si el estado es grande. En algunos casos, puede ser necesario implementar estrategias para limitar el número de Mementos guardados o para optimizar el tamaño de los Mementos.

## J - Cómo implementar el patrón Memento

#### 1. **Pasos para la implementación:**

1.  **Identificar el Originator:** Determina qué clase será el Originator, es decir, el objeto cuyo estado necesitas guardar. Decide si habrá un solo Originator central o múltiples objetos Originator más pequeños.
2.  **Crear la clase Memento:** Crea la clase Memento. Define atributos en el Memento que **reflejen los atributos del Originator** que necesitas guardar.
3.  **Memento inmutable:** Haz que la clase Memento sea **inmutable**. Debe recibir los datos del estado solo en el constructor y no tener setters.
4.  **Anidación o interfaz:**
    - **Clases anidadas (recomendado si el lenguaje lo soporta):** Anida la clase Memento dentro de la clase Originator.
    - **Interfaz intermedia (si no hay clases anidadas o se prefiere separación):** Define una interfaz Memento y haz que la clase Memento concreta la implemente. Usa la interfaz para la comunicación con el Caretaker.
5.  **Método `createMemento()` en Originator:** Añade un método en el Originator (ej: `createMemento()`, `guardarEstado()`, `createSnapshot()`) que **cree una instancia de Memento y le pase el estado actual del Originator** a través del constructor del Memento. El método debe devolver un objeto Memento (o la interfaz Memento si usas interfaz intermedia).
6.  **Método `restoreFromMemento()` en Originator:** Añade un método en el Originator (ej: `restoreFromMemento()`, `restaurarEstado()`) que **reciba un objeto Memento como argumento**. Dentro de este método, el Originator debe **extraer el estado del Memento y usarlo para restaurar su propio estado**. Si usas interfaz intermedia, necesitarás hacer un cast a la clase Memento concreta dentro de este método.
7.  **Caretaker:** Crea la clase Caretaker (o usa una clase existente como Caretaker, como un Command). El Caretaker debe:
    - **Saber cuándo pedir un Memento** al Originator (ej: antes de ejecutar una operación).
    - **Guardar los Mementos** (ej: en una lista o pila para implementar "deshacer").
    - **Saber cuándo pedir al Originator que se restaure** desde un Memento (ej: cuando el usuario pide "deshacer").
8.  **Opcional: Memento "activo" (encapsulación estricta):** Si quieres la máxima encapsulación, puedes hacer que el Memento tenga un método `restore()` que él mismo se encargue de restaurar el estado del Originator asociado (necesitarás pasar una referencia al Originator al Memento en el constructor).

#### 2. **Consideraciones:**

- **Inmutabilidad del Memento:** Es crucial que el Memento sea inmutable para asegurar la integridad del estado guardado.
- **Gestión de memoria:** Si se crean muchos Mementos, considera la gestión de memoria para evitar consumir demasiada RAM. Podrías limitar el número de Mementos guardados o usar técnicas de optimización.
- **Nivel de encapsulación:** Elige la implementación (clases anidadas, interfaz, encapsulación estricta) que mejor se adapte a tus necesidades de encapsulación y complejidad del sistema.

## K - Pros y Contras del patrón Memento

#### 1. **Pros (Ventajas):**

- **Preserva la encapsulación:** Permite guardar y restaurar el estado de un objeto sin violar su encapsulación. El estado interno del Originator se mantiene privado.
- **Simplifica el Originator:** El Originator solo se encarga de crear y restaurar Mementos. La gestión del historial de estados se delega al Caretaker, simplificando el código del Originator.
- **Flexibilidad:** Permite implementar diferentes tipos de "historial" o gestión de estados (ej: undo/redo, transacciones, checkpoints) de forma flexible.

#### 2. **Contras (Desventajas):**

- **Consumo de memoria:** Si se crean Mementos con mucha frecuencia o si el estado guardado es grande, puede consumir mucha memoria RAM.
- **Gestión del ciclo de vida de los Mementos:** El Caretaker debe gestionar el ciclo de vida de los Mementos. Debe saber cuándo eliminar Mementos obsoletos para liberar memoria.
- **Posible complejidad en lenguajes dinámicos:** En lenguajes muy dinámicos (como PHP, Python, JavaScript), puede ser más difícil garantizar que el estado dentro del Memento se mantenga completamente inalterado (aunque se puede lograr con buenas prácticas).

#### 3. **Notas o advertencias:**

- Evalúa cuidadosamente si el patrón Memento es realmente necesario. Para estados muy simples, otras soluciones (como clonar objetos) podrían ser más sencillas.
- Considera el **trade-off entre encapsulación y consumo de memoria**. Un mayor nivel de encapsulación (como en la implementación estricta) puede añadir complejidad.
- En sistemas con restricciones de memoria, implementa estrategias para **gestionar eficientemente los Mementos** y evitar fugas de memoria.

## L - Relaciones con otros patrones

#### 1. **Relación con Command:**

- **Memento y Command juntos para "deshacer":** Memento se usa frecuentemente junto con el patrón Command para implementar la funcionalidad "deshacer/rehacer".
  - Los **Commands** representan las operaciones que se realizan sobre un objeto (el Originator).
  - **Antes de ejecutar un Command**, se crea un **Memento** del estado actual del Originator y se guarda en el Command.
  - Cuando se pide "deshacer", el Command usa el **Memento guardado para restaurar el Originator** a su estado previo.

![Structure of the Memento example](https://refactoring.guru/images/patterns/diagrams/memento/example.png)

#### 2. **Relación con Iterator:**

- **Memento e Iterator para guardar el estado de iteración:** Memento se puede usar con el patrón Iterator para guardar el estado actual de una iteración y poder volver a ese punto si es necesario. Por ejemplo, si estás iterando sobre una estructura de datos compleja y necesitas "deshacer" algunos pasos de la iteración.

#### 3. **Relación con Prototype:**

- **Prototype como alternativa más simple a Memento (en casos sencillos):** En algunos casos, si el objeto cuyo estado quieres guardar es **simple** y no tiene dependencias complejas o recursos externos, el patrón Prototype (clonar el objeto) puede ser una alternativa más sencilla a Memento.
  - **Prototype (clonación):** Simplemente creas una copia completa del objeto actual.
  - **Memento:** Crea un objeto Memento separado que guarda el estado.
  - **Cuándo usar Prototype en lugar de Memento:** Si el objeto es fácil de clonar, no hay problemas de encapsulación y no necesitas un historial complejo de estados, Prototype puede ser suficiente y más simple. Pero si necesitas encapsulación fuerte, un historial de estados o el objeto es difícil de clonar, Memento es la mejor opción.

#### 4. **Notas o advertencias:**

- La combinación de Memento y Command es un patrón muy poderoso para implementar sistemas con "deshacer/rehacer" robustos y bien encapsulados.
- Considera Prototype como una alternativa más simple a Memento solo en casos muy específicos donde la complejidad de Memento no esté justificada. En la mayoría de los casos donde se necesita guardar y restaurar el estado de forma segura y encapsulada, Memento es la solución más adecuada.
