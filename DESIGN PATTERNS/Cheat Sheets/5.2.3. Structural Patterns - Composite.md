## A - **Intención del Patrón Composite**

#### 1. **Definición:**

El patrón **Composite** te permite organizar objetos en estructuras de árbol para tratarlos de manera uniforme, ya sean objetos individuales u objetos compuestos. Imagina que construyes algo con bloques de Lego: puedes tener bloques individuales o combinaciones de bloques que forman estructuras más grandes. Composite te ayuda a trabajar con ambos de la misma forma.

#### 2. **Ejemplo:**

Imagina que estás construyendo un programa para dibujar formas geométricas. Puedes tener formas simples como `Puntos` y `Círculos`, y también formas compuestas como `Grupos` que contienen otras formas (puntos, círculos, ¡o incluso otros grupos!). Con Composite, puedes tratar un `Grupo` como si fuera una forma individual, permitiéndote mover, dibujar o cambiar el color de todo el grupo como si fuera una sola entidad.

#### 3. **Notas o advertencias:**

- Este patrón es ideal cuando tu problema se puede representar como un árbol, donde tienes partes dentro de partes.
- Facilita la manipulación de estructuras complejas porque no necesitas saber si estás tratando con un objeto simple o uno compuesto.

## B - **Problema que resuelve Composite**

#### 1. **Definición:**

El problema surge cuando tienes objetos que pueden contener otros objetos, creando una jerarquía o árbol. Piensa en cajas dentro de cajas, o carpetas dentro de carpetas en tu ordenador. Si quieres realizar una operación en toda la estructura (por ejemplo, calcular el precio total de una orden con cajas y productos), lidiar con cada tipo de objeto de forma diferente puede ser complicado y confuso.

#### 2. **Ejemplo:**

Imagina un sistema de pedidos online. Tienes `Productos` individuales y `Cajas`. Una `Caja` puede contener `Productos` y también otras `Cajas` más pequeñas. Si quieres calcular el precio total de un pedido, que puede contener productos sueltos y cajas llenas de productos (y cajas dentro de cajas), necesitas una forma sencilla de tratar tanto productos como cajas de manera uniforme para calcular el precio total sin volverte loco con bucles y condicionales complejos.

![Structure of a complex order](https://refactoring.guru/images/patterns/diagrams/composite/problem-en.png)

**Explicación del ejemplo:**

La imagen muestra un pedido complejo. Vemos productos individuales (triángulos) y cajas (rectángulos). Algunas cajas contienen productos, otras contienen cajas más pequeñas, y así sucesivamente. Calcular el precio total de este pedido puede ser un lío si tratamos cada tipo de objeto de forma diferente.

#### 3. **Notas o advertencias:**

- Sin Composite, terminarías escribiendo código muy específico para cada tipo de objeto y nivel de anidamiento, lo que hace que el código sea difícil de mantener y extender.
- El problema clave es la necesidad de tratar objetos individuales y colecciones de objetos de manera uniforme.

## C - **Solución con Composite**

#### 1. **Definición:**

Composite propone usar una **interfaz común** para todos los objetos, tanto simples (hojas) como compuestos (contenedores). Esta interfaz define operaciones que tienen sentido para ambos tipos de objetos. Para los objetos compuestos, estas operaciones se delegan a sus "hijos" (los objetos que contienen), y así sucesivamente, de forma recursiva, hasta llegar a los objetos simples.

#### 2. **Ejemplo:**

Volviendo al ejemplo del pedido, creamos una interfaz llamada `ComponentePedido` con un método `calcularPrecio()`. Tanto `Producto` como `Caja` implementan esta interfaz.

- Para un `Producto`, `calcularPrecio()` simplemente devuelve el precio del producto.
- Para una `Caja`, `calcularPrecio()` recorre los elementos que contiene (productos y/o cajas), llama a `calcularPrecio()` para cada uno de ellos y suma los resultados. ¡Si un elemento dentro de la caja es otra caja, esta caja también hará lo mismo recursivamente!

![Solution suggested by the Composite pattern](https://refactoring.guru/images/patterns/content/composite/composite-comic-1-en.png)

**Explicación del ejemplo:**

La imagen muestra cómo el patrón Composite resuelve el problema. Cuando le pides a una caja que calcule su precio, ella pregunta a cada uno de sus componentes (sean productos o cajas más pequeñas) que calculen su precio también. Este proceso se repite hasta que se llega a los productos individuales, y al final, se obtiene el precio total de toda la estructura.

#### 3. **Notas o advertencias:**

- La clave está en la interfaz común que permite tratar todos los objetos de la misma manera.
- La recursión es fundamental para que la operación se propague a través de toda la estructura de árbol.
- No necesitas saber si estás trabajando con un objeto simple o compuesto, ¡simplemente llamas al método en la interfaz común!

## D - **Analogía del Mundo Real: Estructura Militar**

#### 1. **Definición:**

Una buena analogía para entender Composite es una estructura militar jerárquica. Piensa en cómo se organiza un ejército.

#### 2. **Ejemplo:**

Un ejército se compone de divisiones, una división de brigadas, una brigada de batallones, un batallón de compañías, y así sucesivamente hasta llegar a los soldados individuales. Las órdenes se dan en la cima de la jerarquía (el general) y se transmiten hacia abajo a través de cada nivel hasta que cada soldado recibe su instrucción.

![An example of a military structure](https://refactoring.guru/images/patterns/diagrams/composite/live-example.png)

**Explicación del ejemplo:**

La imagen muestra una estructura militar. El "General" representa el componente raíz, las "Divisiones" y "Brigadas" son contenedores (composites), y los "Soldados" son las hojas. Una orden dada al General se propaga a través de la jerarquía, de forma similar a cómo una operación en un objeto compuesto se propaga a sus componentes en el patrón Composite.

#### 3. **Notas o advertencias:**

- La estructura militar muestra claramente la jerarquía y cómo las órdenes (operaciones) se delegan hacia abajo.
- Cada nivel de la jerarquía (excepto el soldado individual) actúa como un contenedor que gestiona a sus subordinados.

## E - **Estructura del Patrón Composite**

#### 1. **Definición:**

El patrón Composite se compone de los siguientes elementos principales:

1.  **Componente:** Define la interfaz común para objetos simples y compuestos. Declara las operaciones que todos los objetos en la estructura de árbol deben soportar.
2.  **Hoja (Leaf):** Representa los objetos simples, que son los nodos finales del árbol. No tienen hijos. Son los que realizan el "trabajo real".
3.  **Contenedor (Composite):** Representa los objetos compuestos, que pueden contener hojas u otros contenedores. Implementa la interfaz del Componente y gestiona una lista de sus hijos. Delega las operaciones a sus hijos y puede realizar operaciones adicionales (como sumar resultados).
4.  **Cliente:** Es la parte del código que interactúa con la estructura de árbol a través de la interfaz del Componente. No necesita saber si está trabajando con una Hoja o un Contenedor.

![Structure of the Composite design pattern](https://refactoring.guru/images/patterns/diagrams/composite/structure-en.png)
![Structure of the Composite design pattern](https://refactoring.guru/images/patterns/diagrams/composite/structure-en-indexed.png)

**Explicación del ejemplo:**

Las imágenes muestran la estructura del patrón Composite.

- **Component (1):** La interfaz `Componente`.
- **Leaf (2):** La clase `Hoja`, que implementa `Componente` y representa objetos simples.
- **Composite (3):** La clase `Contenedor`, que también implementa `Componente`, contiene una lista de `Componentes` (hijos) y delega operaciones a ellos.
- **Client (4):** El `Cliente` que usa la interfaz `Componente` para interactuar con toda la estructura.

#### 3. **Notas o advertencias:**

- La interfaz `Componente` es crucial para la uniformidad.
- Las `Hojas` son los objetos básicos, los `Contenedores` construyen estructuras más complejas.
- El `Cliente` se mantiene simple al interactuar solo con la interfaz `Componente`.

## F - **Pseudocódigo de Ejemplo: Editor Gráfico**

#### 1. **Definición:**

Este pseudocódigo muestra cómo usar Composite para crear un editor gráfico que permite agrupar formas geométricas.

#### 2. **Ejemplo:**

```java
// Interfaz Componente: Operaciones comunes para objetos simples y compuestos
interface Graphic {
    void move(int x, int y);
    void draw();
}

// Clase Hoja: Objeto simple (Punto)
class Dot implements Graphic {
    int x, y;

    public Dot(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public void move(int x, int y) {
        this.x += x;
        this.y += y;
    }

    @Override
    public void draw() {
        // Dibujar un punto en (x, y)
        System.out.println("Dibujando punto en (" + x + ", " + y + ")");
    }
}

// Clase Hoja: Objeto simple (Círculo)
class Circle extends Dot {
    int radius;

    public Circle(int x, int y, int radius) {
        super(x, y);
        this.radius = radius;
    }

    @Override
    public void draw() {
        // Dibujar un círculo en (x, y) con radio
        System.out.println("Dibujando círculo en (" + x + ", " + y + ") con radio " + radius);
    }
}

// Clase Contenedor: Objeto compuesto (Grupo de Gráficos)
class CompoundGraphic implements Graphic {
    List<Graphic> children = new ArrayList<>();

    public void add(Graphic child) {
        children.add(child);
    }

    public void remove(Graphic child) {
        children.remove(child);
    }

    @Override
    public void move(int x, int y) {
        for (Graphic child : children) {
            child.move(x, y);
        }
    }

    @Override
    public void draw() {
        // 1. Para cada hijo:
        //    - Dibujar el hijo
        //    - Actualizar el rectángulo delimitador (opcional en este ejemplo)
        System.out.println("Dibujando grupo:");
        for (Graphic child : children) {
            child.draw();
        }
        // 2. Dibujar un rectángulo punteado alrededor del grupo (opcional)
        System.out.println("--- Fin del grupo ---");
    }
}

// Cliente: Editor de Imágenes
class ImageEditor {
    private CompoundGraphic all;

    public void load() {
        all = new CompoundGraphic();
        all.add(new Dot(1, 2));
        all.add(new Circle(5, 3, 10));
    }

    public void groupSelected(List<Graphic> components) {
        CompoundGraphic group = new CompoundGraphic();
        for (Graphic component : components) {
            group.add(component);
            all.remove(component); // Suponiendo que 'all' contiene los componentes seleccionados
        }
        all.add(group);
        all.draw(); // Dibujar todo, incluyendo el nuevo grupo
    }

    public void drawAll() {
        all.draw();
    }
}

public class Main {
    public static void main(String[] args) {
        ImageEditor editor = new ImageEditor();
        editor.load();
        editor.drawAll();

        System.out.println("\nAgrupando un punto y un círculo:");
        List<Graphic> selected = new ArrayList<>();
        selected.add(editor.all.children.get(0)); // Punto
        selected.add(editor.all.children.get(1)); // Círculo
        editor.groupSelected(selected);

        System.out.println("\nDibujando todo de nuevo:");
        editor.drawAll();
    }
}
```

**Salida del código:**

```
Dibujando grupo:
Dibujando punto en (1, 2)
Dibujando círculo en (5, 3) con radio 10
--- Fin del grupo ---

Agrupando un punto y un círculo:
Dibujando grupo:
Dibujando grupo:
Dibujando punto en (1, 2)
Dibujando círculo en (5, 3) con radio 10
--- Fin del grupo ---
--- Fin del grupo ---

Dibujando todo de nuevo:
Dibujando grupo:
Dibujando grupo:
Dibujando punto en (1, 2)
Dibujando círculo en (5, 3) con radio 10
--- Fin del grupo ---
--- Fin del grupo ---
```

![Structure of the Composite example](https://refactoring.guru/images/patterns/diagrams/composite/example.png)

**Explicación del ejemplo:**

- `Graphic` es la interfaz **Componente**. Define las operaciones `move()` y `draw()`.
- `Dot` y `Circle` son clases **Hoja**. Implementan `Graphic` y representan formas simples.
- `CompoundGraphic` es la clase **Contenedor (Composite)**. También implementa `Graphic`, pero además contiene una lista de objetos `Graphic` (hijos). Cuando se llama a `draw()` en `CompoundGraphic`, delega la llamada a `draw()` a todos sus hijos.
- `ImageEditor` es el **Cliente**. Utiliza la interfaz `Graphic` para trabajar con formas, sin importar si son simples o compuestas. Puede agrupar formas seleccionadas en un `CompoundGraphic` y tratarlas como una sola entidad.

#### 3. **Notas o advertencias:**

- El ejemplo muestra cómo el cliente puede tratar objetos `Dot`, `Circle` y `CompoundGraphic` de manera uniforme a través de la interfaz `Graphic`.
- La recursión en el método `draw()` de `CompoundGraphic` permite que la operación se propague a través de toda la estructura de grupos anidados.

## G - **Aplicabilidad del Patrón Composite**

#### 1. **Definición:**

Usa el patrón Composite cuando:

1.  **Necesitas representar jerarquías de objetos parte-todo:** Cuando tu modelo de datos se puede organizar como un árbol, donde los objetos pueden contener otros objetos.
2.  **Quieres que el cliente trate objetos simples y compuestos de manera uniforme:** Cuando necesitas que el código cliente funcione igual con objetos individuales (hojas) y con colecciones de objetos (contenedores).

#### 2. **Ejemplo:**

- **Sistemas de archivos:** Carpetas (contenedores) que contienen archivos y otras carpetas (hojas y contenedores). Operaciones como copiar, eliminar o calcular el tamaño se aplican tanto a archivos individuales como a carpetas completas.
- **Interfaces de usuario:** Componentes de UI como ventanas, paneles, botones, etc., pueden contener otros componentes. El manejo de eventos o el redibujado se puede propagar a través de la jerarquía de componentes.
- **Organizaciones:** Departamentos que contienen empleados y otros departamentos. Cálculos presupuestarios o asignación de recursos pueden realizarse a nivel de departamento o para toda la organización.

#### 3. **Notas o advertencias:**

- Composite es ideal para estructuras de árbol recursivas.
- Si no necesitas tratar objetos simples y compuestos de la misma manera, quizás Composite no sea necesario.

## H - **Cómo Implementar el Patrón Composite**

#### 1. **Definición:**

Pasos para implementar Composite:

1.  **Identifica la estructura de árbol:** Asegúrate de que tu problema se puede modelar como un árbol de objetos.
2.  **Define la interfaz Componente:** Crea una interfaz que declare las operaciones comunes para hojas y contenedores.
3.  **Crea las clases Hoja:** Implementa las clases para los objetos simples (hojas) que no tienen hijos.
4.  **Crea la clase Contenedor:** Implementa la clase para los objetos compuestos (contenedores). Debe:
    - Implementar la interfaz Componente.
    - Mantener una lista de hijos (de tipo Componente).
    - Delegar las operaciones de la interfaz a sus hijos.
    - Proporcionar métodos para añadir y eliminar hijos.
5.  **Cliente usa la interfaz:** El código cliente debe interactuar con los objetos a través de la interfaz Componente.

#### 2. **Ejemplo:**

(Ver el ejemplo de pseudocódigo del editor gráfico en la sección **F** para una implementación detallada).

#### 3. **Notas o advertencias:**

- Decide si los métodos para añadir/eliminar hijos deben estar en la interfaz Componente. Si los pones ahí, las hojas tendrán métodos vacíos, lo cual puede violar el Principio de Segregación de la Interfaz, pero simplifica el manejo uniforme de todos los componentes. Si no los pones en la interfaz, el cliente tendrá que tratar contenedores y hojas de forma ligeramente diferente al construir el árbol.

## I - **Pros y Contras del Patrón Composite**

#### 1. **Definición:**

**Pros:**

- **Simplifica el manejo de estructuras complejas:** Permite trabajar con estructuras de árbol de forma más sencilla y uniforme, usando polimorfismo y recursión.
- **Principio Abierto/Cerrado:** Puedes añadir nuevos tipos de componentes (hojas o contenedores) sin modificar el código cliente existente.

**Contras:**

- **Dificultad para interfaces comunes:** Puede ser difícil definir una interfaz Componente que sea lo suficientemente general para todos los tipos de componentes, especialmente si las funcionalidades de hojas y contenedores son muy diferentes. Esto puede llevar a interfaces demasiado genéricas y menos claras.

#### 2. **Ejemplo:**

**Pros:** En el editor gráfico, añadir una nueva forma (ej. un triángulo) es fácil: solo necesitas crear una nueva clase Hoja que implemente la interfaz `Graphic`. El código que maneja grupos no necesita cambiar.

**Contras:** Si quisieras añadir una operación muy específica solo para `CompoundGraphic` (ej. "alinear todos los hijos"), no encajaría bien en la interfaz `Graphic` común, y tendrías que hacer un "casting" o añadir métodos específicos, perdiendo parte de la uniformidad del patrón.

#### 3. **Notas o advertencias:**

- Evalúa si los beneficios de la uniformidad y la extensibilidad superan la posible complejidad de definir una interfaz común adecuada.
- Considera si la interfaz común se vuelve demasiado genérica y difícil de entender.

## J - **Relaciones con Otros Patrones**

#### 1. **Definición:**

Composite a menudo se usa en combinación con otros patrones:

- **Builder:** Se puede usar Builder para construir árboles Composite complejos de forma paso a paso y controlada.
- **Chain of Responsibility:** En un árbol Composite, si una hoja no puede manejar una petición, puede pasarla a su contenedor padre en una cadena de responsabilidad.
- **Iterator:** Se pueden usar Iterators para recorrer las estructuras de árbol Composite de manera eficiente.
- **Visitor:** Visitor permite definir nuevas operaciones que se pueden aplicar a todos los elementos de un árbol Composite sin modificar las clases de los componentes.
- **Flyweight:** Las hojas compartidas en un árbol Composite se pueden implementar como Flyweights para ahorrar memoria.
- **Decorator:** Decorator y Composite tienen estructuras similares (composición recursiva), pero Decorator añade responsabilidades a un objeto individual, mientras que Composite compone objetos para formar una estructura. Se pueden usar juntos: Decorator para extender el comportamiento de objetos dentro de un árbol Composite.
- **Prototype:** Prototype puede ser útil para clonar estructuras Composite complejas en lugar de reconstruirlas desde cero.

#### 2. **Ejemplo:**

- **Builder + Composite:** Podrías usar un Builder para construir un árbol de componentes de interfaz de usuario (Composite) de forma declarativa a partir de una configuración.
- **Visitor + Composite:** Podrías usar Visitor para implementar operaciones como "exportar a XML" o "validar" en un árbol de objetos que representa un documento (Composite).

#### 3. **Notas o advertencias:**

- Entender cómo Composite se relaciona con otros patrones te ayuda a usarlo de forma más efectiva y a resolver problemas de diseño más complejos.
- La elección de usar o combinar patrones depende del contexto específico de tu problema.
