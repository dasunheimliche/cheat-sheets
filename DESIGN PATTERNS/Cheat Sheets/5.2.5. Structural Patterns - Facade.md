## A - Fachada (Facade)

#### 1. **Definición:**

La **Fachada** es como un "recepcionista" para un sistema complejo. Imagina que tienes un montón de clases trabajando juntas para hacer algo complicado. En lugar de que tengas que hablar directamente con cada una de esas clases y entender cómo funcionan todas juntas, la Fachada te da una **interfaz sencilla y fácil de usar**. Es como un atajo para usar las funciones más importantes de ese sistema complejo, sin que te líes con los detalles internos.

![Patrón de diseño Fachada](https://refactoring.guru/images/patterns/content/facade/facade.png)

#### 2. **Ejemplo:**

Imagina que tienes un sistema complejo para encender un ordenador. En lugar de interactuar directamente con la CPU, la memoria, el disco duro, etc., creamos una Fachada llamada `Computadora`.

```java
// Subsistema complejo: Componentes del ordenador
class CPU {
    public void arrancar() {
        System.out.println("CPU arrancando");
    }
}

class Memoria {
    public void cargarPrograma() {
        System.out.println("Memoria cargando programa");
    }
}

class DiscoDuro {
    public void leerDatos() {
        System.out.println("Disco Duro leyendo datos");
    }
}

// Fachada: Simplifica el encendido del ordenador
class Computadora {
    private CPU cpu;
    private Memoria memoria;
    private DiscoDuro discoDuro;

    public Computadora() {
        this.cpu = new CPU();
        this.memoria = new Memoria();
        this.discoDuro = new DiscoDuro();
    }

    public void encender() {
        System.out.println("Encendiendo Computadora...");
        cpu.arrancar();
        memoria.cargarPrograma();
        discoDuro.leerDatos();
        System.out.println("Computadora lista para usar!");
    }
}

// Cliente: Usa la Fachada para encender el ordenador
public class Main {
    public static void main(String[] args) {
        Computadora computadora = new Computadora();
        computadora.encender();
    }
}
```

**Explicación del ejemplo:**

- Tenemos un **subsistema complejo** representado por las clases `CPU`, `Memoria` y `DiscoDuro`. Cada una hace una parte del proceso de arranque.
- La clase `Computadora` actúa como la **Fachada**. En lugar de que el `Main` (el cliente) tenga que llamar a `cpu.arrancar()`, `memoria.cargarPrograma()`, etc., simplemente llama a `computadora.encender()`.
- La Fachada **oculta la complejidad** del proceso de encendido y proporciona una interfaz mucho más sencilla (`encender()`).

#### 3. **Notas o advertencias:**

- La Fachada **no añade nuevas funcionalidades**, simplemente simplifica el acceso a las funcionalidades existentes del subsistema.
- Es útil cuando tienes una **librería o framework complejo** y solo necesitas usar unas pocas funciones de forma sencilla.
- Si la Fachada se vuelve demasiado grande y compleja, considera dividirla en **fachadas más pequeñas** para diferentes partes del subsistema.

## B - Intención del patrón Fachada

#### 1. **Definición:**

La **intención** principal del patrón Fachada es proporcionar una **interfaz simplificada** a un conjunto de clases complejo (un subsistema). Esto hace que el subsistema sea más fácil de usar y entender, especialmente cuando solo necesitas una parte de su funcionalidad.

#### 2. **Ejemplo:**

Volviendo al ejemplo de la `Computadora`, la intención es que el usuario (el `Main` en nuestro ejemplo) no tenga que preocuparse por los detalles de cómo arranca la CPU, la memoria, etc. Solo quiere una forma sencilla de **encender la computadora**. La Fachada `Computadora` cumple esa intención.

```java
// (Código del ejemplo anterior de la Computadora)

public class Main {
    public static void main(String[] args) {
        // El cliente solo se preocupa por "encender" la computadora,
        // no por los detalles internos del arranque.
        Computadora computadora = new Computadora();
        computadora.encender();
    }
}
```

**Explicación del ejemplo:**

El código cliente (`Main`) se enfoca en la **intención** de "encender la computadora". La Fachada `Computadora` se encarga de los detalles de **cómo** se logra esa intención, ocultando la complejidad del subsistema.

#### 3. **Notas o advertencias:**

- La Fachada se centra en **simplificar el uso**, no en cambiar la funcionalidad del subsistema.
- Piensa en la Fachada como un **punto de entrada único** y fácil de usar para un sistema complejo.

## C - Problema que resuelve Fachada

#### 1. **Definición:**

El patrón Fachada se usa para resolver el problema de la **complejidad al interactuar con un subsistema**. Cuando tienes un conjunto grande de clases interconectadas, entender cómo usarlas directamente puede ser muy difícil. Además, tu código se puede volver **muy dependiente** de los detalles internos de ese subsistema, haciendo que sea difícil de mantener y cambiar.

#### 2. **Ejemplo:**

Imagina que estás creando un programa que usa una **librería de conversión de video** muy potente. Esta librería tiene muchísimas clases para manejar diferentes formatos de video, codecs, audio, etc. Si tu programa tuviera que usar directamente todas esas clases, el código sería muy complicado y difícil de entender.

```java
// Imaginemos que estas clases son parte de una librería compleja de video
class VideoFile { /* ... */ }
class CodecFactory { /* ... */ }
class MPEG4Codec { /* ... */ }
class AudioMixer { /* ... */ }
// ... muchas más clases ...


public class ProgramaDeVideo {
    public static void main(String[] args) {
        // Sin Fachada, el código sería muy complejo y dependiente de la librería
        VideoFile video = new VideoFile("video.ogg");
        CodecFactory factory = new CodecFactory();
        MPEG4Codec codec = factory.createMPEG4Codec();
        AudioMixer mixer = new AudioMixer();
        // ... y mucho más código para usar la librería directamente ...
    }
}
```

**Explicación del ejemplo:**

En este ejemplo (simplificado), vemos que usar la librería de video directamente implica crear muchas instancias de clases y entender cómo interactúan entre sí. Esto hace que el código de `ProgramaDeVideo` sea **complejo y dependiente** de la estructura interna de la librería. Si la librería cambia, `ProgramaDeVideo` también tendría que cambiar mucho.

#### 3. **Notas o advertencias:**

- Sin Fachada, el código se vuelve **difícil de leer, mantener y reutilizar** debido a la complejidad y la dependencia del subsistema.
- La Fachada ayuda a **desacoplar** tu código de los detalles internos del subsistema.

## D - Solución que ofrece Fachada

#### 1. **Definición:**

La Fachada **crea una clase nueva** que actúa como una interfaz simplificada para el subsistema complejo. Esta clase Fachada conoce cómo interactuar con las clases del subsistema y ofrece **métodos más sencillos** para realizar las tareas más comunes. El cliente (tu código) solo necesita interactuar con la Fachada, sin preocuparse por el subsistema interno.

#### 2. **Ejemplo:**

Usando el ejemplo de la librería de video, creamos una Fachada llamada `ConvertidorDeVideo`.

```java
// Clases del subsistema de video (simplificadas)
class VideoFile {  /* ... */ }
class CodecFactory { /* ... */ }
class MPEG4Codec { /* ... */ }
class OggCodec { /* ... */ }
class BitrateReader {
    public static VideoFile convertir(VideoFile archivo, Codec codec) {
        System.out.println("BitrateReader: Leyendo y convirtiendo archivo.");
        return archivo; // Simulación de conversión
    }
}
class AudioMixer {
    public VideoFile corregirAudio(VideoFile archivo) {
        System.out.println("AudioMixer: Corrigiendo audio.");
        return archivo; // Simulación de corrección de audio
    }
}


// Fachada: ConvertidorDeVideo
class ConvertidorDeVideo {
    public VideoFile convertirVideo(String nombreArchivo, String formatoDeseado) {
        System.out.println("ConvertidorDeVideo: Convirtiendo video...");
        VideoFile archivo = new VideoFile(); // Simula cargar el archivo
        CodecFactory factory = new CodecFactory();
        Codec codecDestino;

        if (formatoDeseado.equalsIgnoreCase("mp4")) {
            codecDestino = new MPEG4Codec();
        } else {
            codecDestino = new OggCodec();
        }

        VideoFile archivoIntermedio = BitrateReader.convertir(archivo, codecDestino);
        VideoFile archivoFinal = new AudioMixer().corregirAudio(archivoIntermedio);
        System.out.println("ConvertidorDeVideo: Conversión completada.");
        return archivoFinal;
    }
}


// Cliente: ProgramaDeVideo usando la Fachada
public class ProgramaDeVideo {
    public static void main(String[] args) {
        ConvertidorDeVideo convertidor = new ConvertidorDeVideo();
        VideoFile videoMP4 = convertidor.convertirVideo("mi_video.ogg", "mp4");
        System.out.println("Video convertido a MP4: " + videoMP4); // Imprime la referencia al objeto VideoFile
    }
}

// Interfaces y clases Codec (simuladas)
interface Codec {}
class MPEG4Codec implements Codec {}
class OggCodec implements Codec {}
```

**Explicación del ejemplo:**

- Creamos la Fachada `ConvertidorDeVideo` con un método sencillo: `convertirVideo(nombreArchivo, formatoDeseado)`.
- Dentro de `convertirVideo`, la Fachada **se encarga de usar las clases complejas** del subsistema (`CodecFactory`, `BitrateReader`, `AudioMixer`, etc.) para realizar la conversión.
- El `ProgramaDeVideo` (cliente) solo necesita llamar a `convertidor.convertirVideo()` y **no tiene que saber nada** sobre las clases internas de la librería de video.

#### 3. **Notas o advertencias:**

- La Fachada **simplifica la interacción** con el subsistema, haciendo que el código cliente sea más limpio y fácil de entender.
- Si en el futuro cambias la librería de video, solo tendrás que **modificar la Fachada**, sin afectar al código cliente (`ProgramaDeVideo`).

## E - Analogía del mundo real para Fachada

#### 1. **Definición:**

Una buena analogía para entender la Fachada es un **operador telefónico** o un **recepcionista**. Cuando llamas a una empresa, no hablas directamente con cada departamento (ventas, facturación, soporte técnico, etc.). En lugar de eso, hablas con el operador (la Fachada). El operador **recibe tu petición** y se encarga de **dirigirla al departamento correcto**. Tú solo necesitas comunicarte con el operador, sin conocer la estructura interna de la empresa.

![Un ejemplo de tomar un pedido por teléfono](https://refactoring.guru/images/patterns/diagrams/facade/live-example-en.png)

#### 2. **Ejemplo:**

- **Tú (Cliente):** Quieres hacer un pedido a una tienda.
- **Operador telefónico (Fachada):** Recibe tu llamada y te pregunta qué quieres pedir.
- **Departamentos de la tienda (Subsistema):** Departamento de pedidos, departamento de pago, departamento de envío, etc.

Tú solo interactúas con el **operador (Fachada)**, que se encarga de coordinar con los **departamentos (Subsistema)** para procesar tu pedido.

#### 3. **Notas o advertencias:**

- La Fachada es como un **intermediario** que simplifica la comunicación con un sistema complejo.
- Te da una **vista simplificada** de un sistema que por dentro es mucho más complicado.

## F - Estructura del patrón Fachada

#### 1. **Definición:**

La estructura del patrón Fachada se compone de los siguientes elementos principales:

1.  **Fachada (Facade):** La clase que proporciona la interfaz simplificada. Conoce el subsistema y cómo dirigir las peticiones del cliente.
2.  **Subsistema Complejo (Complex Subsystem):** El conjunto de clases complejas que realizan el trabajo real. Las clases del subsistema no conocen la Fachada y trabajan entre sí directamente.
3.  **Cliente (Client):** El código que usa la Fachada para interactuar con el subsistema. El cliente solo conoce la Fachada y no interactúa directamente con las clases del subsistema.
4.  **Fachada Adicional (Additional Facade) (Opcional):** Si la Fachada principal se vuelve demasiado compleja, se pueden crear fachadas adicionales para dividir la responsabilidad.

![Estructura del patrón de diseño Fachada](https://refactoring.guru/images/patterns/diagrams/facade/structure.png)
![Estructura del patrón de diseño Fachada](https://refactoring.guru/images/patterns/diagrams/facade/structure-indexed.png)

#### 2. **Ejemplo:**

En nuestro ejemplo del `ConvertidorDeVideo`:

1.  **Fachada:** `ConvertidorDeVideo`
2.  **Subsistema Complejo:** `VideoFile`, `CodecFactory`, `MPEG4Codec`, `OggCodec`, `BitrateReader`, `AudioMixer`
3.  **Cliente:** `ProgramaDeVideo`

#### 3. **Notas o advertencias:**

- La Fachada es el **punto central de interacción** entre el cliente y el subsistema.
- El subsistema permanece **independiente** de la Fachada.
- La Fachada puede **simplificar mucho** la forma en que se usa un sistema complejo.

## G - Seudocódigo del patrón Fachada

#### 1. **Definición:**

El seudocódigo muestra de forma general cómo se implementa el patrón Fachada, sin entrar en detalles específicos de un lenguaje de programación. En el ejemplo del seudocódigo, se muestra cómo una Fachada `VideoConverter` simplifica el uso de un framework complejo de conversión de video.

![La estructura del ejemplo del patrón Fachada](https://refactoring.guru/images/patterns/diagrams/facade/example.png)

#### 2. **Ejemplo (Adaptación a Java):**

El seudocódigo original se puede adaptar a Java de la siguiente manera (simplificado y basado en el ejemplo anterior):

```java
// Clases del subsistema (simuladas)
class VideoFile { /* ... */ }
class CodecFactory {
    public Codec extraer(VideoFile file) {
        System.out.println("CodecFactory: Extrayendo codec del archivo.");
        return new Codec() {}; // Simula la extracción
    }
}
interface Codec {}
class MPEG4CompressionCodec implements Codec {}
class OggCompressionCodec implements Codec {}
class BitrateReader {
    public static VideoFile leer(String filename, Codec sourceCodec) {
        System.out.println("BitrateReader: Leyendo archivo.");
        return new VideoFile(); // Simula la lectura
    }
    public static VideoFile convertir(VideoFile buffer, Codec destinationCodec) {
        System.out.println("BitrateReader: Convirtiendo buffer.");
        return buffer; // Simula la conversión
    }
}
class AudioMixer {
    public VideoFile fix(VideoFile result) {
        System.out.println("AudioMixer: Corrigiendo audio.");
        return result; // Simula la corrección
    }
}


// Fachada: VideoConverter
class VideoConverter {
    public VideoFile convertir(String filename, String format) {
        VideoFile file = new VideoFile(); // Simula cargar el archivo
        Codec sourceCodec = new CodecFactory().extraer(file);
        Codec destinationCodec;
        if (format.equalsIgnoreCase("mp4")) {
            destinationCodec = new MPEG4CompressionCodec();
        } else {
            destinationCodec = new OggCompressionCodec();
        }
        VideoFile buffer = BitrateReader.leer(filename, sourceCodec);
        VideoFile result = BitrateReader.convertir(buffer, destinationCodec);
        result = new AudioMixer().fix(result);
        return result;
    }
}


// Cliente: Application
public class Application {
    public static void main(String[] args) {
        VideoConverter converter = new VideoConverter();
        VideoFile mp4Video = converter.convertir("video.ogg", "mp4");
        System.out.println("Video convertido: " + mp4Video); // Imprime la referencia al objeto VideoFile
    }
}
```

**Explicación del ejemplo:**

Este código Java es una adaptación del seudocódigo. Muestra cómo la Fachada `VideoConverter` usa las clases del subsistema (`CodecFactory`, `BitrateReader`, `AudioMixer`, etc.) para realizar la conversión de video, pero ofrece una interfaz simple al cliente (`Application`).

#### 3. **Notas o advertencias:**

- El seudocódigo y este ejemplo Java ilustran la **idea principal** de la Fachada: simplificar el acceso a un subsistema complejo.
- En un sistema real, las clases del subsistema y la Fachada serían mucho más elaboradas.

## H - Aplicabilidad del patrón Fachada

#### 1. **Definición:**

Usa el patrón Fachada en las siguientes situaciones:

1.  **Interfaz simple para subsistema complejo:** Cuando necesitas una interfaz **sencilla pero limitada** para un subsistema que es muy complejo. La Fachada te da un "atajo" a las funciones más usadas.
2.  **Estructurar un subsistema en capas:** Para definir **puntos de entrada** a cada capa de un subsistema. Puedes reducir la dependencia entre subsistemas haciendo que se comuniquen solo a través de Fachadas.
3.  **Reducir la dependencia de un subsistema:** Cuando quieres que tu código sea **independiente** de los detalles internos de un subsistema, para que los cambios en el subsistema no afecten a tu código cliente.

#### 2. **Ejemplo:**

- **Ejemplo 1 (Interfaz simple):** La Fachada `ConvertidorDeVideo` simplifica el uso de una librería de video compleja para la tarea común de convertir videos.
- **Ejemplo 2 (Estructurar en capas):** En un sistema de comercio electrónico, podrías tener una Fachada para la capa de "pedidos", otra para la capa de "pagos" y otra para la capa de "envíos". Cada Fachada simplifica el acceso a su capa correspondiente.
- **Ejemplo 3 (Reducir dependencia):** Si usas una Fachada para acceder a una base de datos, tu código no dependerá directamente de la implementación específica de la base de datos (MySQL, PostgreSQL, etc.). Si cambias de base de datos, solo tendrás que modificar la Fachada.

#### 3. **Notas o advertencias:**

- La Fachada es útil cuando un subsistema se vuelve **demasiado complejo** con el tiempo.
- Ayuda a mantener el código **organizado y fácil de mantener**.

## I - Cómo implementar el patrón Fachada

#### 1. **Definición:**

Pasos para implementar el patrón Fachada:

1.  **Identifica la interfaz simplificada:** Piensa en qué **interfaz más sencilla** puedes ofrecer para el subsistema. Debe ser independiente de muchas clases internas del subsistema.
2.  **Crea la clase Fachada:** Declara e implementa la clase Fachada con la interfaz simplificada. La Fachada debe **redirigir las llamadas** del cliente a los objetos correctos del subsistema.
3.  **Inicializa y gestiona el subsistema (si es necesario):** La Fachada puede ser responsable de **inicializar el subsistema** y gestionarlo, a menos que el cliente ya lo haga.
4.  **Usa la Fachada en el código cliente:** Haz que todo el código cliente se comunique con el subsistema **solo a través de la Fachada**.
5.  **Refina la Fachada (si es necesario):** Si la Fachada se vuelve demasiado grande, considera **dividirla en fachadas más pequeñas**.

#### 2. **Ejemplo:**

En el ejemplo del `ConvertidorDeVideo`:

1.  **Interfaz simplificada:** `convertirVideo(nombreArchivo, formatoDeseado)`
2.  **Clase Fachada:** `ConvertidorDeVideo`
3.  **Inicialización:** La Fachada crea instancias de `CodecFactory`, `AudioMixer`, etc. dentro de sus métodos.
4.  **Uso en cliente:** `ProgramaDeVideo` usa `ConvertidorDeVideo` para convertir videos.
5.  **Refinamiento (opcional):** Si la Fachada tuviera muchas más funciones (ej. convertir audio, editar video), podríamos crear fachadas separadas para cada tipo de función.

#### 3. **Notas o advertencias:**

- El objetivo principal es **ocultar la complejidad** del subsistema al cliente.
- Asegúrate de que la Fachada ofrezca una interfaz que sea **realmente más sencilla** de usar.

## J - Pros y Contras del patrón Fachada

#### 1. **Definición:**

**Pros (Ventajas):**

- **Aísla el código de la complejidad del subsistema:** El código cliente se vuelve más sencillo y fácil de entender.
- **Reduce la dependencia entre el cliente y el subsistema:** Los cambios en el subsistema tienen menos impacto en el código cliente.
- **Simplifica el uso del subsistema:** Ofrece una interfaz más amigable para las tareas comunes.

**Contras (Desventajas):**

- **Puede convertirse en un "objeto dios" (god object):** Si la Fachada acumula demasiadas responsabilidades y se acopla a muchas clases de la aplicación.
- **No siempre ofrece todas las funcionalidades del subsistema:** La Fachada se centra en simplificar, por lo que puede que no exponga todas las opciones y funciones del subsistema.

#### 2. **Ejemplo:**

- **Pro:** El `ProgramaDeVideo` es mucho más simple y fácil de entender gracias a la Fachada `ConvertidorDeVideo`.
- **Pro:** Si cambiamos la librería de video, solo tenemos que modificar `ConvertidorDeVideo`, no `ProgramaDeVideo`.
- **Contra:** Si la Fachada `ConvertidorDeVideo` empieza a manejar también la edición de video, la subida a redes sociales, etc., se volverá demasiado grande y compleja.
- **Contra:** Si necesitas una función muy específica de la librería de video que no está expuesta por la Fachada, tendrás que "saltarte" la Fachada y usar la librería directamente (perdiendo las ventajas de la Fachada).

#### 3. **Notas o advertencias:**

- Usa la Fachada con **moderación**. No la uses si el subsistema no es realmente complejo o si necesitas acceso completo a todas sus funciones.
- Vigila que la Fachada **no se convierta en un "objeto dios"**. Si crece demasiado, divídela.

## K - Relaciones con otros patrones

#### 1. **Definición:**

El patrón Fachada se relaciona con otros patrones de diseño de las siguientes maneras:

- **Fachada vs. Adaptador (Adapter):**

  - **Fachada:** Define una **nueva interfaz simplificada** para un subsistema existente.
  - **Adaptador:** Hace que una **interfaz existente sea usable** con otra interfaz diferente.
  - **Diferencia clave:** Fachada simplifica, Adaptador adapta. Fachada trabaja con un subsistema, Adaptador suele envolver un solo objeto.

- **Fachada vs. Fábrica Abstracta (Abstract Factory):**

  - **Fábrica Abstracta:** Puede ser una alternativa a Fachada cuando solo quieres **ocultar cómo se crean los objetos** del subsistema.
  - **Diferencia clave:** Fachada simplifica la interfaz de uso, Fábrica Abstracta simplifica la creación de objetos.

- **Fachada vs. Peso Mosca (Flyweight):**

  - **Peso Mosca:** Muestra cómo crear **muchos objetos pequeños** de forma eficiente.
  - **Fachada:** Muestra cómo crear **un solo objeto** que representa un subsistema entero.
  - **Diferencia clave:** Propósitos opuestos. Peso Mosca optimiza la creación de muchos objetos, Fachada simplifica el uso de un subsistema.

- **Fachada vs. Mediador (Mediator):**

  - **Similitud:** Ambos organizan la colaboración entre muchas clases acopladas.
  - **Fachada:** Interfaz simplificada, el subsistema no conoce la Fachada, los objetos del subsistema se comunican directamente.
  - **Mediador:** Centraliza la comunicación, los componentes solo conocen al Mediador y no se comunican directamente entre sí.
  - **Diferencia clave:** Fachada simplifica la interfaz, Mediador centraliza la comunicación.

- **Fachada vs. Singleton:**

  - Una Fachada a menudo puede convertirse en un **Singleton**, ya que normalmente solo necesitas una instancia de la Fachada.

- **Fachada vs. Proxy:**
  - **Similitud:** Ambos "amortiguan" una entidad compleja y la inicializan por sí solos.
  - **Proxy:** Tiene la **misma interfaz** que el objeto de servicio, lo que los hace intercambiables.
  - **Fachada:** Tiene una **interfaz diferente** y simplificada.
  - **Diferencia clave:** Proxy mantiene la misma interfaz, Fachada la simplifica.

#### 2. **Ejemplo:**

- **Adaptador:** Si tuvieras una librería antigua de video con una interfaz muy diferente a la que necesitas, usarías un Adaptador para "traducir" la interfaz antigua a la nueva.
- **Fábrica Abstracta:** Si solo te preocupara cómo se crean los codecs de video (MPEG4, Ogg, etc.), podrías usar una Fábrica Abstracta para ocultar los detalles de creación.
- **Mediador:** Si tuvieras un sistema de edición de video muy complejo donde muchos componentes necesitan comunicarse entre sí, podrías usar un Mediador para centralizar la comunicación en lugar de que se comuniquen directamente.

#### 3. **Notas o advertencias:**

- Entender las diferencias y similitudes entre patrones te ayuda a elegir el **patrón más adecuado** para cada situación.
- A veces, puedes usar **combinaciones de patrones** para resolver problemas más complejos.
