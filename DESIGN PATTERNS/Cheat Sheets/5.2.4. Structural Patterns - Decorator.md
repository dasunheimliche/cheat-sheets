## A - Intención del Patrón Decorador

#### 1. **Definición:**

El patrón Decorador es como un envoltorio mágico que te **permite añadir nuevas funcionalidades a objetos existentes sin modificar su estructura original**. Imagina que tienes un objeto base y quieres ponerle "capas" de características extra, como si lo estuvieras decorando.

#### 2. **Ejemplo:**

Piensa en un café. Tienes un café base (¡rico, pero simple!). Ahora, puedes "decorarlo" añadiéndole leche, azúcar, crema batida, ¡lo que quieras! Cada añadido es como un "decorador" que le da nuevas características al café base sin cambiar lo que es fundamentalmente: café.

#### 3. **Notas o advertencias:**

- Es ideal cuando quieres añadir funcionalidades de forma **dinámica**, es decir, en tiempo de ejecución, sin tener que crear un montón de subclases.
- Úsalo cuando la **herencia** se queda corta para añadir comportamientos, especialmente si no quieres o no puedes modificar la clase original.

---

## B - El Problema que Resuelve el Decorador

#### 1. **Definición:**

Imagina que tienes una clase base, por ejemplo, `Notificador`, que envía emails. Ahora, necesitas que también envíe SMS, notificaciones de Facebook, Slack, etc. Si usas solo herencia, terminarás con un montón de subclases y combinaciones, ¡un lío total!

#### 2. **Ejemplo:**

**Problema sin Decorador:**

```java
class NotificadorEmail {
    public void enviar(String mensaje, String email) {
        System.out.println("Enviando email a " + email + ": " + mensaje);
    }
}

class NotificadorSMS extends NotificadorEmail { // Herencia para SMS
    public void enviarSMS(String mensaje, String telefono) {
        System.out.println("Enviando SMS a " + telefono + ": " + mensaje);
    }
}

class NotificadorFacebook extends NotificadorEmail { // Herencia para Facebook
    public void enviarFacebook(String mensaje, String usuario) {
        System.out.println("Enviando Facebook a " + usuario + ": " + mensaje);
    }
}

// ... ¡Y así para cada tipo de notificación! ...

public class EjemploProblema {
    public static void main(String[] args) {
        NotificadorSMS notificadorSMS = new NotificadorSMS();
        notificadorSMS.enviarSMS("¡Hola!", "123456789");

        NotificadorFacebook notificadorFacebook = new NotificadorFacebook();
        notificadorFacebook.enviarFacebook("¡Evento!", "usuarioFacebook");
    }
}
```

**Explicación del ejemplo:**
Aquí, si queremos añadir cada vez más métodos de notificación, la jerarquía de clases se vuelve muy compleja y difícil de mantener. Además, ¿qué pasa si queremos enviar un email **y** un SMS? ¡Necesitaríamos más subclases combinadas!

#### 3. **Notas o advertencias:**

- La herencia por sí sola no es flexible para añadir funcionalidades **opcionales** o **combinables**.
- Crear subclases para cada combinación de funcionalidades lleva a la "explosión combinatoria de clases", ¡un dolor de cabeza!

---

## C - La Solución con el Patrón Decorador

#### 1. **Definición:**

El Decorador usa la **composición** en lugar de la herencia. Creamos "decoradores" que envuelven al objeto original. Cada decorador añade una funcionalidad extra. ¡Puedes combinar varios decoradores para obtener múltiples funcionalidades!

#### 2. **Ejemplo:**

**Solución con Decorador:**

```java
// 1. Interfaz Componente (Notificador Base)
interface Notificador {
    void enviar(String mensaje);
}

// 2. Componente Concreto (Notificador Email Base)
class NotificadorEmail implements Notificador {
    private String email;

    public NotificadorEmail(String email) {
        this.email = email;
    }

    @Override
    public void enviar(String mensaje) {
        System.out.println("Enviando email a " + email + ": " + mensaje);
    }
}

// 3. Decorador Base
abstract class DecoradorNotificador implements Notificador {
    protected Notificador wrappee; // Referencia al objeto envuelto

    public DecoradorNotificador(Notificador source) {
        this.wrappee = source;
    }

    @Override
    public void enviar(String mensaje) {
        wrappee.enviar(mensaje); // Delega la tarea al objeto envuelto
    }
}

// 4. Decoradores Concretos (SMS, Facebook)
class DecoradorSMS extends DecoradorNotificador {
    private String telefono;

    public DecoradorSMS(Notificador source, String telefono) {
        super(source);
        this.telefono = telefono;
    }

    @Override
    public void enviar(String mensaje) {
        super.enviar(mensaje); // Primero, la funcionalidad base (email)
        System.out.println("Enviando SMS a " + telefono + ": " + mensaje); // Luego, la funcionalidad extra (SMS)
    }
}

class DecoradorFacebook extends DecoradorNotificador {
    private String usuarioFacebook;

    public DecoradorFacebook(Notificador source, String usuarioFacebook) {
        super(source);
        this.usuarioFacebook = usuarioFacebook;
    }

    @Override
    public void enviar(String mensaje) {
        super.enviar(mensaje); // Primero, la funcionalidad base (email y/o SMS si hay decoradores anteriores)
        System.out.println("Enviando Facebook a " + usuarioFacebook + ": " + mensaje); // Luego, la funcionalidad extra (Facebook)
    }
}


public class EjemploDecorador {
    public static void main(String[] args) {
        Notificador notificadorBase = new NotificadorEmail("usuario@email.com"); // Notificador base: Email

        Notificador notificadorConSMS = new DecoradorSMS(notificadorBase, "123456789"); // Decorador SMS sobre el base
        notificadorConSMS.enviar("¡Alerta!"); // Envía email y SMS

        Notificador notificadorCompleto = new DecoradorFacebook(notificadorConSMS, "usuarioFacebook"); // Decorador Facebook sobre el de SMS
        notificadorCompleto.enviar("¡Urgente!"); // Envía email, SMS y Facebook
    }
}
```

**Explicación del ejemplo:**

- **`Notificador` (Interfaz Componente):** Define la operación común: `enviar(mensaje)`.
- **`NotificadorEmail` (Componente Concreto):** Implementación base que envía emails.
- **`DecoradorNotificador` (Decorador Base):** Clase abstracta que "envuelve" un `Notificador` y delega la llamada a `enviar()`.
- **`DecoradorSMS`, `DecoradorFacebook` (Decoradores Concretos):** Añaden funcionalidades extra (SMS, Facebook) **después** de llamar al método `enviar()` del objeto envuelto (`wrappee`).

Ahora, podemos combinar decoradores fácilmente. ¡La clave es que todos implementan la misma interfaz `Notificador`, así que el cliente no se entera si está trabajando con un objeto base o uno decorado!

#### 3. **Notas o advertencias:**

- Usamos **composición**: el decorador "tiene un" objeto `Notificador` en lugar de "ser un" tipo de `Notificador` (como en la herencia).
- Los decoradores se pueden **apilar**, creando una cadena de responsabilidades.
- El cliente trabaja con la interfaz `Notificador`, sin importar cuántos decoradores haya.

---

## D - Analogía del Mundo Real

#### 1. **Definición:**

Piensa en la ropa. Tú eres el "componente base". Un suéter es un decorador que te añade calor. Una chaqueta es otro decorador que te protege del viento. Un impermeable te protege de la lluvia. Puedes ponerte varios decoradores (suéter + chaqueta + impermeable) para obtener una protección combinada. ¡Y puedes quitarte capas cuando ya no las necesitas!

#### 2. **Ejemplo:**

![Ejemplo del patrón Decorador](https://refactoring.guru/images/patterns/content/decorator/decorator-comic-1.png)

**Explicación del ejemplo:**
Cada prenda de vestir (decorador) añade una funcionalidad (calor, protección contra el viento, lluvia) sin cambiar tu "yo" básico (componente base). Puedes combinar varias prendas para obtener el efecto deseado.

#### 3. **Notas o advertencias:**

- Los decoradores son **opcionales** y se pueden añadir o quitar **dinámicamente**.
- Cada decorador añade una **responsabilidad** específica.

---

## E - Estructura del Patrón Decorador

#### 1. **Definición:**

Aquí tienes el esquema visual del patrón Decorador:

![Estructura del patrón de diseño Decorador](https://refactoring.guru/images/patterns/diagrams/decorator/structure.png)
![Estructura del patrón de diseño Decorador](https://refactoring.guru/images/patterns/diagrams/decorator/structure-indexed.png)

**Componentes clave:**

1.  **Componente (Component):** Define la interfaz común para objetos base y decoradores. En nuestro ejemplo, es `Notificador`.
2.  **Componente Concreto (Concrete Component):** La clase base que se va a decorar. En nuestro ejemplo, `NotificadorEmail`.
3.  **Decorador Base (Base Decorator):** Clase abstracta que implementa la interfaz del Componente y tiene una referencia al Componente que envuelve (`wrappee`). Delega la mayoría de las operaciones al `wrappee`. En nuestro ejemplo, `DecoradorNotificador`.
4.  **Decoradores Concretos (Concrete Decorators):** Clases que extienden el Decorador Base y añaden funcionalidades específicas **antes** o **después** de llamar al método del `wrappee`. En nuestro ejemplo, `DecoradorSMS` y `DecoradorFacebook`.
5.  **Cliente (Client):** Crea y compone los objetos decorados. En nuestro ejemplo, la clase `EjemploDecorador`.

#### 2. **Ejemplo:**

En el código de ejemplo anterior, puedes ver cómo cada parte del diagrama se corresponde con las clases que creamos.

#### 3. **Notas o advertencias:**

- La clave es la **interfaz común** (Componente) que permite tratar objetos decorados y no decorados de la misma manera.
- El Decorador Base facilita la creación de decoradores concretos al manejar la delegación al `wrappee`.

---

## F - Seudocódigo y Ejemplo Práctico (Compresión y Encriptación)

#### 1. **Definición:**

El texto nos da un ejemplo de seudocódigo para comprimir y encriptar datos. Vamos a simplificarlo y adaptarlo a Java para que lo veas más claro.

![Estructura del ejemplo del patrón Decorador](https://refactoring.guru/images/patterns/diagrams/decorator/example.png)

#### 2. **Ejemplo:**

```java
// 1. Interfaz Componente: DataSource
interface DataSource {
    void escribirDatos(String datos);
    String leerDatos();
}

// 2. Componente Concreto: FileDataSource
class FileDataSource implements DataSource {
    private String nombreArchivo;

    public FileDataSource(String nombreArchivo) {
        this.nombreArchivo = nombreArchivo;
    }

    @Override
    public void escribirDatos(String datos) {
        System.out.println("Escribiendo datos en archivo: " + nombreArchivo + ": " + datos);
        // Aquí iría la lógica real para escribir en el archivo
    }

    @Override
    public String leerDatos() {
        System.out.println("Leyendo datos de archivo: " + nombreArchivo);
        // Aquí iría la lógica real para leer del archivo
        return "Datos del archivo " + nombreArchivo;
    }
}

// 3. Decorador Base: DataSourceDecorator
abstract class DataSourceDecorator implements DataSource {
    protected DataSource wrappee;

    public DataSourceDecorator(DataSource source) {
        this.wrappee = source;
    }

    @Override
    public void escribirDatos(String datos) {
        wrappee.escribirDatos(datos); // Delega al objeto envuelto
    }

    @Override
    public String leerDatos() {
        return wrappee.leerDatos(); // Delega al objeto envuelto
    }
}

// 4. Decoradores Concretos: Encriptacion y Compresion
class EncriptacionDecorator extends DataSourceDecorator {
    public EncriptacionDecorator(DataSource source) {
        super(source);
    }

    @Override
    public void escribirDatos(String datos) {
        String datosEncriptados = encriptar(datos); // Encripta los datos
        System.out.println("Datos encriptados antes de escribir.");
        super.escribirDatos(datosEncriptados); // Escribe los datos encriptados
    }

    @Override
    public String leerDatos() {
        String datos = super.leerDatos(); // Lee los datos (posiblemente encriptados)
        String datosDesencriptados = desencriptar(datos); // Desencripta los datos
        System.out.println("Datos desencriptados después de leer.");
        return datosDesencriptados;
    }

    private String encriptar(String datos) {
        return "¡ENCRIPTADO! " + datos + " ¡ENCRIPTADO!"; // Simulación de encriptación
    }

    private String desencriptar(String datos) {
        return datos.replace("¡ENCRIPTADO! ", "").replace(" ¡ENCRIPTADO!", ""); // Simulación de desencriptación
    }
}

class CompresionDecorator extends DataSourceDecorator {
    public CompresionDecorator(DataSource source) {
        super(source);
    }

    @Override
    public void escribirDatos(String datos) {
        String datosComprimidos = comprimir(datos); // Comprime los datos
        System.out.println("Datos comprimidos antes de escribir.");
        super.escribirDatos(datosComprimidos); // Escribe los datos comprimidos
    }

    @Override
    public String leerDatos() {
        String datos = super.leerDatos(); // Lee los datos (posiblemente comprimidos)
        String datosDescomprimidos = descomprimir(datos); // Descomprime los datos
        System.out.println("Datos descomprimidos después de leer.");
        return datosDescomprimidos;
    }

    private String comprimir(String datos) {
        return "¡COMPRIMIDO! " + datos + " ¡COMPRIMIDO!"; // Simulación de compresión
    }

    private String descomprimir(String datos) {
        return datos.replace("¡COMPRIMIDO! ", "").replace(" ¡COMPRIMIDO!", ""); // Simulación de descompresión
    }
}


public class EjemploCompresionEncriptacion {
    public static void main(String[] args) {
        DataSource fuenteDatos = new FileDataSource("mi_archivo.txt"); // Fuente de datos base

        fuenteDatos.escribirDatos("Datos sin procesar"); // Escribe datos sin procesar

        DataSource fuenteDatosComprimida = new CompresionDecorator(fuenteDatos); // Decora con compresión
        fuenteDatosComprimida.escribirDatos("Datos para comprimir"); // Escribe datos comprimidos

        DataSource fuenteDatosCompleta = new EncriptacionDecorator(fuenteDatosComprimida); // Decora con encriptación (¡sobre la compresión!)
        fuenteDatosCompleta.escribirDatos("Datos secretos"); // Escribe datos encriptados y comprimidos

        System.out.println("\nLeyendo datos (desencriptados y descomprimidos):");
        System.out.println(fuenteDatosCompleta.leerDatos()); // Lee datos, se desencriptan y descomprimen automáticamente
    }
}
```

**Explicación del ejemplo:**

- **`DataSource`:** Interfaz para leer y escribir datos.
- **`FileDataSource`:** Implementación que trabaja con archivos.
- **`EncriptacionDecorator`, `CompresionDecorator`:** Decoradores que añaden encriptación y compresión respectivamente.

Observa cómo podemos **apilar** los decoradores: `EncriptacionDecorator` envuelve a `CompresionDecorator`, que a su vez envuelve a `FileDataSource`. Cuando llamamos a `escribirDatos()` en `fuenteDatosCompleta`, los datos pasan por la encriptación **y luego** por la compresión antes de llegar a `FileDataSource`. ¡Al leer, el proceso se invierte!

#### 3. **Notas o advertencias:**

- Los decoradores permiten añadir funcionalidades de **forma modular** y **reutilizable**.
- El orden de los decoradores **puede importar**, dependiendo de la funcionalidad que implementen (como en este caso, primero comprimimos y luego encriptamos, o viceversa).

---

## G - Aplicabilidad del Patrón Decorador

#### 1. **Definición:**

Usa el Decorador cuando:

- Necesitas añadir funcionalidades a objetos **dinámicamente** en tiempo de ejecución.
- Quieres evitar crear **subclases** para cada combinación de funcionalidades.
- La herencia no es práctica o posible (por ejemplo, si la clase base es `final`).
- Quieres dividir una clase compleja en **clases más pequeñas** y **especializadas** (decoradores).

#### 2. **Ejemplo:**

- **Interfaces gráficas (GUI):** Añadir bordes, sombras, scrollbars a componentes visuales.
- **Streams de entrada/salida:** Comprimir, encriptar, buffering de datos en streams.
- **Validación de datos:** Añadir reglas de validación a objetos de entrada.
- **Autorización y autenticación:** Añadir capas de seguridad a objetos.

#### 3. **Notas o advertencias:**

- Es útil cuando tienes **muchas funcionalidades opcionales** que se pueden combinar de diferentes maneras.
- Ayuda a seguir el **Principio de Responsabilidad Única**: cada decorador se encarga de una funcionalidad específica.

---

## H - Cómo Implementar el Patrón Decorador (Paso a Paso)

#### 1. **Definición:**

Sigue estos pasos para implementar el patrón Decorador:

1.  **Identifica el "componente" base:** ¿Qué objeto quieres decorar? Define su interfaz común (Componente).
2.  **Crea el Componente Concreto:** Implementa la clase base que se va a decorar.
3.  **Crea el Decorador Base:** Crea una clase abstracta que implemente la interfaz del Componente y tenga una referencia al Componente (`wrappee`). Delega las operaciones al `wrappee`.
4.  **Crea Decoradores Concretos:** Para cada funcionalidad extra, crea una clase que extienda el Decorador Base. En cada decorador, añade la funcionalidad extra **antes** o **después** de llamar al método del `wrappee`.
5.  **Usa los Decoradores en el Cliente:** En el código cliente, crea objetos Componente y envuélvelos en los decoradores que necesites.

#### 2. **Ejemplo:**

Hemos visto ejemplos de implementación en los apartados C y F. ¡Revisa esos ejemplos para ver los pasos en acción!

#### 3. **Notas o advertencias:**

- Asegúrate de que todos los decoradores y el componente base implementen la **misma interfaz**.
- Piensa en el **orden** en que se aplicarán los decoradores si el orden es importante para tu caso.

---

## I - Pros y Contras del Patrón Decorador

#### 1. **Definición:**

**Pros (Ventajas):**

- **Extensión sin subclases:** Añade funcionalidades sin crear nuevas subclases.
- **Funcionalidad dinámica:** Añade o quita funcionalidades en tiempo de ejecución.
- **Combinación de funcionalidades:** Combina múltiples decoradores para obtener diferentes comportamientos.
- **Principio de Responsabilidad Única:** Divide clases complejas en decoradores más pequeños y especializados.

**Contras (Desventajas):**

- **Eliminar decoradores:** Puede ser complicado quitar un decorador específico de una pila de decoradores.
- **Orden de decoradores:** El comportamiento puede depender del orden en que se aplican los decoradores (¡ojo con esto!).
- **Configuración inicial compleja:** La creación de la pila de decoradores puede ser un poco verbosa en la configuración inicial.

#### 2. **Ejemplo:**

Piensa en el ejemplo del café: es genial poder añadir leche, azúcar, etc. dinámicamente (pros). Pero si quieres quitar solo la crema batida de un café con leche y crema batida, ¡no es tan fácil! (contra).

#### 3. **Notas o advertencias:**

- Evalúa si los **pros superan los contras** para tu caso específico.
- Considera si la **complejidad** añadida por el patrón Decorador se justifica por la flexibilidad que ofrece.

---

## J - Relación con Otros Patrones

#### 1. **Definición:**

El Decorador se parece a otros patrones, pero tiene sus diferencias clave:

- **Adaptador (Adapter):** El Adaptador cambia la interfaz de un objeto. El Decorador **mantiene la interfaz** o la extiende, pero añade funcionalidades.
- **Proxy:** El Proxy controla el acceso a un objeto. El Decorador **añade funcionalidades** a un objeto.
- **Cadena de Responsabilidad (Chain of Responsibility):** Ambos usan composición, pero la Cadena de Responsabilidad pasa una petición a través de una cadena de objetos hasta que uno la maneja. El Decorador **siempre pasa la petición** al objeto envuelto y añade funcionalidad antes o después.
- **Composite:** Ambos usan composición recursiva. El Composite crea estructuras de árbol de objetos. El Decorador **envuelve un solo objeto** y le añade funcionalidades. ¡Pero se pueden usar juntos! Puedes decorar objetos dentro de un Composite.
- **Prototype:** Útil con Decorador y Composite para clonar estructuras complejas en lugar de reconstruirlas desde cero.
- **Strategy:** Strategy te permite cambiar el "algoritmo" de un objeto. Decorator te permite cambiar la "apariencia" o añadir funcionalidades a un objeto.

#### 2. **Ejemplo:**

Imagina que tienes un enchufe europeo (Adaptador) para conectar un aparato americano. Un guardaespaldas (Proxy) que controla quién puede entrar a un edificio. Una línea de montaje (Cadena de Responsabilidad) donde cada estación hace una tarea. Un árbol genealógico (Composite) que organiza personas en jerarquías. Una fotocopiadora (Prototype) que crea copias de documentos. Diferentes estrategias para ordenar una lista (Strategy). ¡Y tú con tu ropa (Decorator) añadiendo capas!

#### 3. **Notas o advertencias:**

- Entender las **diferencias** entre patrones te ayuda a elegir el más adecuado para cada situación.
- A veces, los patrones se pueden **combinar** para resolver problemas más complejos.
