## A - Template Method

#### 1. **Definición:**

El **Template Method** es un patrón de diseño de comportamiento que define la estructura general de un algoritmo en una clase base (superclase), pero permite que las clases hijas (subclases) redefinan pasos específicos de ese algoritmo sin cambiar la estructura del algoritmo en sí.

Imagina que tienes una receta de cocina para hacer una tarta. La receta tiene pasos generales como "preparar la masa", "hacer el relleno", "hornear" y "decorar". El Template Method es como esa receta general. Tú puedes tener diferentes tipos de tartas (manzana, fresa, chocolate) que siguen la misma estructura de pasos (masa, relleno, hornear, decorar), pero cada tipo de tarta tiene su propia forma de hacer el relleno o la decoración.

#### 2. **Ejemplo:**

```java
// Clase abstracta que define la estructura del algoritmo (Template Method)
abstract class ProcesadorDeDocumentos {

    // Este es el "Template Method". Define el orden de los pasos.
    public final void procesarDocumento(String rutaArchivo) {
        abrirDocumento(rutaArchivo);
        extraerDatos();
        analizarDatos();
        generarReporte();
        cerrarDocumento();
    }

    // Métodos abstractos que las subclases deben implementar
    protected abstract void abrirDocumento(String rutaArchivo);
    protected abstract void extraerDatos();

    // Métodos concretos con implementación por defecto (opcionales de redefinir)
    protected void analizarDatos() {
        System.out.println("Procesamiento de datos genérico.");
        // Lógica de análisis de datos por defecto
    }

    protected void generarReporte() {
        System.out.println("Generando reporte genérico.");
        // Lógica de generación de reporte por defecto
    }

    protected void cerrarDocumento() {
        System.out.println("Cerrando documento genéricamente.");
        // Lógica para cerrar el documento por defecto
    }
}

// Clase concreta para procesar documentos PDF
class ProcesadorPDF extends ProcesadorDeDocumentos {

    @Override
    protected void abrirDocumento(String rutaArchivo) {
        System.out.println("Abriendo documento PDF: " + rutaArchivo);
        // Lógica específica para abrir un PDF
    }

    @Override
    protected void extraerDatos() {
        System.out.println("Extrayendo datos de PDF.");
        // Lógica específica para extraer datos de un PDF
    }

    // Podemos redefinir el método de análisis para PDFs si es necesario
    @Override
    protected void analizarDatos() {
        System.out.println("Analizando datos de PDF de forma especializada.");
        // Lógica de análisis de datos específica para PDF
    }
}

// Clase concreta para procesar documentos CSV
class ProcesadorCSV extends ProcesadorDeDocumentos {

    @Override
    protected void abrirDocumento(String rutaArchivo) {
        System.out.println("Abriendo documento CSV: " + rutaArchivo);
        // Lógica específica para abrir un CSV
    }

    @Override
    protected void extraerDatos() {
        System.out.println("Extrayendo datos de CSV.");
        // Lógica específica para extraer datos de un CSV
    }
}

public class Main {
    public static void main(String[] args) {
        ProcesadorDeDocumentos pdfProcessor = new ProcesadorPDF();
        pdfProcessor.procesarDocumento("documento.pdf");

        ProcesadorDeDocumentos csvProcessor = new ProcesadorCSV();
        csvProcessor.procesarDocumento("datos.csv");
    }
}
```

**Explicación del ejemplo:**

En este ejemplo, `ProcesadorDeDocumentos` es la clase abstracta que define el Template Method `procesarDocumento()`. Este método define los pasos generales para procesar cualquier tipo de documento: abrir, extraer datos, analizar, generar reporte y cerrar.

- `abrirDocumento()` y `extraerDatos()` son **métodos abstractos**. Esto significa que cada subclase (como `ProcesadorPDF` y `ProcesadorCSV`) _debe_ implementar su propia versión de estos métodos, ya que la forma de abrir y extraer datos es diferente para cada tipo de documento.
- `analizarDatos()`, `generarReporte()` y `cerrarDocumento()` son **métodos concretos** con una implementación por defecto. Las subclases _pueden_ redefinir estos métodos si necesitan un comportamiento específico, pero no es obligatorio. `ProcesadorPDF` redefine `analizarDatos()` para un análisis especializado de PDFs, mientras que `ProcesadorCSV` usa la implementación por defecto.

El `Template Method` `procesarDocumento()` asegura que el proceso general de procesamiento de documentos se mantenga consistente, pero permite flexibilidad en los pasos específicos.

#### 3. **Notas o advertencias:**

- El Template Method es ideal cuando tienes un algoritmo con pasos comunes pero con variaciones en algunos de ellos.
- Asegúrate de que el "esqueleto" del algoritmo (el Template Method) sea realmente común a todas las subclases. Si las variaciones son demasiado grandes, quizás otro patrón de diseño sea más adecuado.
- Puedes usar métodos "hook" (gancho) en la clase abstracta. Son métodos opcionales con una implementación vacía o por defecto que las subclases pueden redefinir para "enganchar" lógica adicional en puntos específicos del algoritmo.

---

## B - Intención del Template Method

#### 1. **Definición:**

La **intención** principal del patrón Template Method es definir la estructura de un algoritmo, permitiendo que las subclases proporcionen la implementación concreta de algunos pasos. En otras palabras, se busca crear un "esqueleto" de algoritmo que sea reutilizable, pero flexible a la vez.

#### 2. **Ejemplo:**

Imagina que estás creando un juego con diferentes tipos de personajes (magos, guerreros, arqueros). Todos los personajes tienen un proceso similar para atacar:

1.  Acercarse al enemigo.
2.  Preparar el ataque (cargar magia, desenfundar espada, tensar arco).
3.  Ejecutar el ataque.
4.  Retirarse (opcional).

El Template Method te permite definir este proceso general de ataque en una clase base `Personaje`, y luego cada tipo de personaje (Mago, Guerrero, Arquero) puede implementar de forma diferente los pasos de "preparar el ataque" y "ejecutar el ataque", que son específicos de cada clase. El paso de "acercarse al enemigo" y "retirarse" podrían ser comunes o tener implementaciones por defecto en la clase base.

#### 3. **Notas o advertencias:**

- El Template Method se centra en la **estructura del algoritmo**, no en los datos. Si lo que varía principalmente son los datos que usa un algoritmo, otros patrones como Strategy o State podrían ser más apropiados.
- Piensa en el Template Method como una forma de **factorizar el comportamiento común** de varios algoritmos similares, dejando las partes variables a las subclases.

---

## C - Problema que resuelve el Template Method

#### 1. **Definición:**

El Template Method se utiliza para resolver problemas de **duplicación de código** y **rigidez en algoritmos** cuando tienes varios algoritmos que comparten una estructura similar pero difieren en algunos pasos.

**Problemas comunes:**

- **Código duplicado:** Si tienes varias clases que realizan tareas similares con pequeñas variaciones, es probable que tengas mucho código duplicado. Cambiar la lógica común en todos esos lugares se vuelve tedioso y propenso a errores.
- **Algoritmos inflexibles:** Si un algoritmo está "hardcodeado" dentro de una clase, es difícil modificar o extender partes específicas del algoritmo sin cambiar toda la clase.

#### 2. **Ejemplo:**

Volviendo al ejemplo del procesamiento de documentos: Imagina que inicialmente solo tenías una clase `ProcesadorDOC`. Luego necesitas procesar CSV y PDF. Sin el Template Method, podrías terminar creando clases `ProcesadorCSV` y `ProcesadorPDF`, cada una con su propio código para abrir, extraer, analizar, etc. ¡Mucha duplicación! Especialmente en los pasos de análisis y generación de reportes que podrían ser muy similares.

![Data mining classes contained a lot of duplicate code](https://refactoring.guru/images/patterns/diagrams/template-method/problem.png)

El Template Method te permite evitar esta duplicación moviendo la estructura común del algoritmo a una clase base, y dejando que las subclases se encarguen solo de las partes que varían (como la forma de abrir y extraer datos según el formato del archivo).

#### 3. **Notas o advertencias:**

- Si no tienes duplicación de código o si tus algoritmos son completamente diferentes, el Template Method podría no ser necesario.
- A veces, la duplicación de código no es obvia al principio. Puede que descubras que necesitas el Template Method a medida que tu sistema evoluciona y empiezas a ver patrones repetitivos en tu código.

---

## D - Solución que ofrece el Template Method

#### 1. **Definición:**

El Template Method **soluciona** los problemas de duplicación y rigidez al:

- **Definir un algoritmo "esqueleto"** en una clase abstracta, llamado el "Template Method". Este esqueleto define la secuencia de pasos del algoritmo.
- **Delegar la implementación de pasos específicos** a las subclases. Algunos pasos pueden ser abstractos (obligatorios de implementar en las subclases) y otros pueden tener una implementación por defecto en la clase base (opcionales de redefinir).
- **Promover la reutilización de código** al mover la lógica común a la clase base.
- **Aumentar la flexibilidad** al permitir que las subclases personalicen partes del algoritmo sin cambiar su estructura general.

#### 2. **Ejemplo:**

En el ejemplo del procesamiento de documentos, el Template Method `procesarDocumento()` en `ProcesadorDeDocumentos` es la solución.

![Template method defines the skeleton of the algorithm](https://refactoring.guru/images/patterns/diagrams/template-method/solution-en.png)

- La estructura del algoritmo (abrir, extraer, analizar, reportar, cerrar) está definida en `ProcesadorDeDocumentos`.
- `ProcesadorPDF` y `ProcesadorCSV` solo se encargan de implementar `abrirDocumento()` y `extraerDatos()` de forma específica para cada formato.
- La lógica de `analizarDatos()`, `generarReporte()` y `cerrarDocumento()` que es común (o tiene una buena implementación por defecto) se mantiene en `ProcesadorDeDocumentos`, evitando duplicación.

#### 3. **Notas o advertencias:**

- La clave está en identificar correctamente los pasos del algoritmo que son comunes y los que varían. Una buena abstracción es crucial para que el Template Method sea efectivo.
- A veces, puede ser difícil decidir qué pasos deben ser abstractos y cuáles concretos. Empieza con pasos abstractos para las partes que _seguro_ varían, y considera hacer concretos los pasos que tienen una implementación por defecto útil.

---

## E - Analogía del mundo real para el Template Method

#### 1. **Definición:**

Una buena **analogía** para entender el Template Method es la **construcción de casas en serie**.

#### 2. **Ejemplo:**

![Mass housing construction](https://refactoring.guru/images/patterns/diagrams/template-method/live-example.png)

Cuando se construyen casas en serie, se utiliza un **plano arquitectónico base** (el Template Method). Este plano define los pasos generales de la construcción:

1.  Cimientos.
2.  Estructura (muros, techo).
3.  Instalaciones (electricidad, fontanería).
4.  Acabados (pintura, suelos).

Este plano base es común para todas las casas de la serie. Sin embargo, cada casa puede tener **variaciones** en algunos pasos (las subclases):

- **Cimientos:** Pueden variar según el tipo de terreno.
- **Acabados:** El cliente puede elegir diferentes colores de pintura, tipos de suelo, etc.

La **estructura general de la construcción (el Template Method) se mantiene**, pero se permite cierta **personalización en pasos específicos (las subclases)**. Esto permite construir muchas casas de forma eficiente (reutilización del plano base) pero con cierta flexibilidad para adaptarse a las necesidades o gustos de cada cliente.

#### 3. **Notas o advertencias:**

- La analogía de la casa en serie ilustra bien cómo el Template Method equilibra la **estructura común** con la **flexibilidad para variaciones**.
- Piensa en el plano base como la clase abstracta y en las casas individuales como las clases concretas.

---

## F - Estructura del Template Method

#### 1. **Definición:**

La estructura del Template Method se compone principalmente de dos partes:

1.  **Clase Abstracta (Abstract Class):**

    - Define el **Template Method**: Un método `final` que contiene la estructura del algoritmo, llamando a una serie de pasos. Se declara `final` para evitar que las subclases lo redefinan y cambien la estructura del algoritmo.
    - Declara **métodos abstractos**: Representan los pasos del algoritmo que deben ser implementados por las subclases.
    - Puede incluir **métodos concretos**: Representan pasos del algoritmo que tienen una implementación por defecto y pueden ser opcionalmente redefinidos por las subclases. También puede incluir **métodos "hook"** (gancho) que son métodos concretos con una implementación vacía o por defecto, que permiten a las subclases "enganchar" lógica adicional en puntos específicos del algoritmo.

2.  **Clases Concretas (Concrete Classes):**
    - Heredan de la Clase Abstracta.
    - Implementan los **métodos abstractos** definidos en la Clase Abstracta, proporcionando la lógica específica para cada paso variable del algoritmo.
    - Pueden **redefinir (opcionalmente)** los métodos concretos de la Clase Abstracta si necesitan un comportamiento diferente para esos pasos. **Nunca deben redefinir el Template Method.**

#### 2. **Diagrama:**

![Structure of the Template Method design pattern](https://refactoring.guru/images/patterns/diagrams/template-method/structure.png)
![Structure of the Template Method design pattern](https://refactoring.guru/images/patterns/diagrams/template-method/structure-indexed.png)

**Explicación del diagrama:**

1.  **Clase Abstracta (Abstract Class):** Define el `TemplateMethod()` que llama a `Operation1()`, `Operation2()`, etc. `AbstractClass` puede implementar algunos de estos métodos (`Operation2()` en el diagrama) o dejarlos abstractos (`Operation1()`, `PrimitiveOperation1()`, `PrimitiveOperation2()`).
2.  **Clase Concreta (ConcreteClass):** Hereda de `AbstractClass` e implementa los métodos abstractos (`PrimitiveOperation1()` y `PrimitiveOperation2()`) para proporcionar la lógica específica. Puede también redefinir métodos concretos de la clase abstracta (`Operation2()`).

#### 3. **Notas o advertencias:**

- El Template Method se basa en la **herencia**. La relación "es-un" (is-a) entre la clase abstracta y las clases concretas es fundamental.
- El uso de `final` en el Template Method es importante para asegurar que la estructura del algoritmo se mantenga intacta.
- Los métodos abstractos fuerzan a las subclases a proporcionar implementaciones para los pasos variables, mientras que los métodos concretos ofrecen flexibilidad y reutilización.

---

## G - Seudocódigo del Template Method (Ejemplo Juego de IA)

#### 1. **Definición:**

El siguiente **seudocódigo** (adaptado a Java en el ejemplo siguiente) ilustra cómo se puede usar el Template Method para crear diferentes tipos de Inteligencia Artificial (IA) para un juego de estrategia.

#### 2. **Seudocódigo y Ejemplo en Java:**

**Seudocódigo (del texto original):**

```
// Clase abstracta que define el Template Method para la IA del juego
class GameAI is
    // Template Method: define el turno de la IA
    method turn() is
        collectResources()
        buildStructures()
        buildUnits()
        attack()

    // Método concreto (implementación por defecto)
    method collectResources() is
        foreach (s in this.builtStructures) do
            s.collect()

    // Métodos abstractos (deben ser implementados por las subclases)
    abstract method buildStructures()
    abstract method buildUnits()

    // Otro Template Method (ejemplo de ataque)
    method attack() is
        enemy = closestEnemy()
        if (enemy == null)
            sendScouts(map.center)
        else
            sendWarriors(enemy.position)

    abstract method sendScouts(position)
    abstract method sendWarriors(position)


// Clase concreta: IA para Orcos
class OrcsAI extends GameAI is
    method buildStructures() is
        if (there are some resources) then
            // Construir granjas, luego barracas, luego fortaleza.

    method buildUnits() is
        if (there are plenty of resources) then
            if (there are no scouts)
                // Construir peón, añadirlo al grupo de exploradores.
            else
                // Construir grunt, añadirlo al grupo de guerreros.

    // ...

    method sendScouts(position) is
        if (scouts.length > 0) then
            // Enviar exploradores a la posición.

    method sendWarriors(position) is
        if (warriors.length > 5) then
            // Enviar guerreros a la posición.


// Clase concreta: IA para Monstruos (con implementaciones por defecto vacías o diferentes)
class MonstersAI extends GameAI is
    method collectResources() is
        // Los monstruos no recolectan recursos.

    method buildStructures() is
        // Los monstruos no construyen estructuras.

    method buildUnits() is
        // Los monstruos no construyen unidades.
```

**Ejemplo en Java (basado en el seudocódigo):**

```java
// Clase abstracta GameAI (Abstract Class)
abstract class GameAI {
    // Template Method: define el turno de la IA
    public final void turn() {
        collectResources();
        buildStructures();
        buildUnits();
        attack();
    }

    // Método concreto (con implementación por defecto)
    protected void collectResources() {
        System.out.println("GameAI: Recolectando recursos de forma genérica.");
        // Lógica genérica para recolectar recursos
    }

    // Métodos abstractos (deben ser implementados por las subclases)
    protected abstract void buildStructures();
    protected abstract void buildUnits();
    protected abstract void attack();

    // Otro Template Method (ejemplo de ataque)
    public final void attackEnemy() {
        Enemy enemy = closestEnemy();
        if (enemy == null) {
            sendScouts(Map.center);
        } else {
            sendWarriors(enemy.getPosition());
        }
    }

    protected abstract Enemy closestEnemy(); // Método abstracto auxiliar
    protected abstract void sendScouts(Position position);
    protected abstract void sendWarriors(Position position);


    // Clases internas para simplificar el ejemplo
    static class Enemy { Position position; public Position getPosition() { return position; } }
    static class Map { static Position center = new Position(); }
    static class Position {}
}

// Clase concreta OrcsAI (Concrete Class)
class OrcsAI extends GameAI {
    @Override
    protected void buildStructures() {
        System.out.println("OrcsAI: Construyendo estructuras Orcas (granjas, barracas, fortaleza).");
        // Lógica específica de construcción de estructuras Orcas
    }

    @Override
    protected void buildUnits() {
        System.out.println("OrcsAI: Construyendo unidades Orcas (peones, guerreros).");
        // Lógica específica de construcción de unidades Orcas
    }

    @Override
    protected void attack() {
        System.out.println("OrcsAI: ¡Atacando agresivamente!");
        // Lógica de ataque específica de Orcos
    }

    @Override
    protected Enemy closestEnemy() {
        return new Enemy(); // Simplificado para el ejemplo
    }

    @Override
    protected void sendScouts(Position position) {
        System.out.println("OrcsAI: Enviando exploradores a la posición: " + position);
    }

    @Override
    protected void sendWarriors(Position position) {
        System.out.println("OrcsAI: Enviando guerreros a la posición: " + position);
    }
}

// Clase concreta MonstersAI (Concrete Class)
class MonstersAI extends GameAI {
    @Override
    protected void collectResources() {
        System.out.println("MonstersAI: Los monstruos no recolectan recursos.");
    }

    @Override
    protected void buildStructures() {
        System.out.println("MonstersAI: Los monstruos no construyen estructuras.");
    }

    @Override
    protected void buildUnits() {
        System.out.println("MonstersAI: Los monstruos no construyen unidades.");
    }

    @Override
    protected void attack() {
        System.out.println("MonstersAI: ¡Los monstruos atacan aleatoriamente!");
        // Lógica de ataque específica de Monstruos
    }

     @Override
    protected Enemy closestEnemy() {
        return null; // Simplificado para el ejemplo
    }

    @Override
    protected void sendScouts(Position position) {
        System.out.println("MonstersAI: Enviando exploradores... ¿quizás?");
    }

    @Override
    protected void sendWarriors(Position position) {
        System.out.println("MonstersAI: Enviando guerreros... si les apetece.");
    }
}

// Código cliente (Main)
public class Main {
    public static void main(String[] args) {
        GameAI orcAI = new OrcsAI();
        orcAI.turn(); // Ejecuta el Template Method 'turn()' para Orcos

        GameAI monsterAI = new MonstersAI();
        monsterAI.turn(); // Ejecuta el mismo Template Method 'turn()' para Monstruos, pero con comportamiento diferente
    }
}
```

**Explicación del ejemplo en Java:**

- `GameAI` es la clase abstracta que define el Template Method `turn()`. Este método define la secuencia de acciones que la IA debe realizar en cada turno del juego.
- `collectResources()`, `buildStructures()`, `buildUnits()` y `attack()` son los pasos del algoritmo. `collectResources()` tiene una implementación por defecto, mientras que los otros tres son abstractos y deben ser implementados por las subclases.
- `OrcsAI` y `MonstersAI` son clases concretas que heredan de `GameAI` e implementan los métodos abstractos de forma específica para cada tipo de IA. `MonstersAI` incluso redefine `collectResources()` para indicar que los monstruos no recolectan recursos.
- En `Main`, se crea una instancia de `OrcsAI` y `MonstersAI` y se llama al mismo Template Method `turn()` en ambos. Sin embargo, cada instancia ejecuta el algoritmo de turno de forma diferente debido a las implementaciones específicas en sus clases concretas.

#### 3. **Notas o advertencias:**

- Este ejemplo muestra cómo el Template Method permite reutilizar la estructura general del algoritmo de IA (`turn()`) mientras se personalizan los detalles de implementación para diferentes tipos de razas en el juego.
- Observa que el Template Method `turn()` es `final` para asegurar que las subclases no puedan cambiar la estructura del turno de la IA.

---

## H - Aplicabilidad del Template Method

#### 1. **Definición:**

Usa el patrón Template Method en las siguientes situaciones:

- **Controlar la estructura del algoritmo:** Cuando quieres que los clientes solo puedan extender pasos específicos de un algoritmo, pero no el algoritmo completo o su estructura. Quieres asegurar que el algoritmo siga una secuencia definida, pero permitiendo variaciones en ciertos puntos.
- **Algoritmos similares con diferencias menores:** Cuando tienes varias clases que implementan algoritmos casi idénticos, pero con algunas diferencias pequeñas. El Template Method te ayuda a eliminar la duplicación de código al extraer la parte común del algoritmo a una clase base.
- **Refactorizar código duplicado:** Cuando detectas código duplicado en varias clases que siguen una estructura algorítmica similar. El Template Method es una buena forma de refactorizar y consolidar ese código.

#### 2. **Ejemplo:**

- **Frameworks:** Muchos frameworks usan Template Method. Por ejemplo, un framework para aplicaciones web podría definir un Template Method para el ciclo de vida de una petición HTTP (recibir petición, procesar, enviar respuesta). Los desarrolladores que usan el framework pueden extender pasos específicos como "procesar" para implementar la lógica de su aplicación, pero no cambian el ciclo de vida general de la petición.
- **Bibliotecas de pruebas unitarias:** Una biblioteca de pruebas podría tener un Template Method para ejecutar una prueba (configurar, ejecutar prueba, verificar resultados, limpiar). Los usuarios de la biblioteca solo necesitan implementar el paso de "ejecutar prueba" con su lógica de prueba específica.
- **Procesamiento de datos en lotes (batch processing):** Un sistema de procesamiento por lotes podría usar Template Method para definir el flujo de procesamiento de un lote de datos (leer datos, validar, transformar, escribir resultados). Diferentes tipos de procesamiento (por ejemplo, procesamiento de ventas, procesamiento de inventario) podrían ser subclases que implementan los pasos específicos de validación y transformación.

#### 3. **Notas o advertencias:**

- El Template Method es útil cuando la **estructura del algoritmo es más importante que la flexibilidad total**. Si necesitas una flexibilidad extrema y poder cambiar la estructura del algoritmo en tiempo de ejecución, otros patrones como Strategy podrían ser más adecuados.
- No fuerces el uso del Template Method si no hay una estructura algorítmica clara y común entre las clases. A veces, la herencia puede no ser la mejor opción y la composición (como en Strategy) podría ser más flexible.

---

## I - Cómo implementar el Template Method

#### 1. **Pasos para implementar:**

1.  **Analiza el algoritmo:** Identifica los pasos del algoritmo y cuáles son comunes a todas las variaciones y cuáles son únicos.
2.  **Crea la clase abstracta:**
    - Define una clase abstracta que será la base para todas las variaciones del algoritmo.
    - Declara el **Template Method**: Un método `public final` que define la estructura del algoritmo llamando a los pasos. Hazlo `final` para evitar que se redefina en las subclases.
    - Declara **métodos abstractos** para los pasos que deben ser implementados por las subclases.
    - Implementa **métodos concretos** (opcionales de redefinir) para los pasos que tienen una implementación por defecto común.
    - Considera añadir **métodos "hook"** (gancho) como métodos concretos vacíos o con implementación por defecto para puntos de extensión adicionales.
3.  **Crea las clases concretas:**
    - Para cada variación del algoritmo, crea una clase concreta que herede de la clase abstracta.
    - Implementa **todos los métodos abstractos** de la clase base, proporcionando la lógica específica para cada paso variable.
    - **Redefine (opcionalmente)** los métodos concretos de la clase base si necesitas un comportamiento diferente. **Nunca redefinas el Template Method.**

#### 2. **Ejemplo (resumen del ejemplo de IA):**

En el ejemplo del juego de IA:

1.  **Análisis:** El algoritmo "turno de IA" tiene pasos comunes (recolectar recursos, construir, atacar) pero la forma de construir y atacar varía según la raza.
2.  **Clase abstracta `GameAI`:**
    - `turn()` es el Template Method (`public final`).
    - `buildStructures()`, `buildUnits()`, `attack()` son abstractos.
    - `collectResources()` es concreto (con implementación por defecto).
3.  **Clases concretas `OrcsAI`, `MonstersAI`:**
    - Heredan de `GameAI`.
    - Implementan `buildStructures()`, `buildUnits()`, `attack()` de forma específica para Orcos y Monstruos.
    - `MonstersAI` redefine `collectResources()` para indicar que no recolectan recursos.

#### 3. **Notas o advertencias:**

- Empieza por identificar claramente la estructura del algoritmo y los puntos de variación. Un buen diseño del Template Method depende de una buena abstracción inicial.
- No tengas miedo de refactorizar y ajustar tu diseño a medida que implementas y pruebas el Template Method. Puede que necesites mover métodos entre la clase abstracta y las concretas, o añadir/eliminar pasos.

---

## J - Pros y Contras del Template Method

#### 1. **Pros (Ventajas):**

- **Reutilización de código:** Elimina la duplicación de código al mover la lógica común a la clase base. Esto hace que el código sea más limpio, fácil de mantener y menos propenso a errores.
- **Control de la estructura del algoritmo:** Permite controlar la estructura general del algoritmo, asegurando que se siga una secuencia de pasos definida.
- **Extensibilidad controlada:** Permite a los clientes (subclases) extender solo partes específicas del algoritmo, sin cambiar la estructura general. Esto hace que el sistema sea más flexible y adaptable a nuevas necesidades.
- **Simplificación del código cliente:** El código cliente que usa las clases concretas se simplifica, ya que solo necesita llamar al Template Method para ejecutar el algoritmo completo, sin preocuparse por los detalles de implementación de cada paso.

#### 2. **Contras (Desventajas):**

- **Rigidez:** Aunque ofrece flexibilidad en los pasos, la estructura general del algoritmo está fija en la clase abstracta. Si necesitas cambiar la estructura del algoritmo en tiempo de ejecución o tener variaciones muy grandes en la estructura, el Template Method puede ser limitante.
- **Violación del Principio de Sustitución de Liskov (LSP) potencial:** Si una subclase redefine un paso concreto de forma que cambia drásticamente el comportamiento esperado del algoritmo, podría violar el LSP. Por ejemplo, si un paso concreto en la clase base tiene una implementación que se espera que siempre se ejecute, y una subclase lo redefine para que no haga nada, podría romper las expectativas del código cliente.
- **Mantenimiento complejo en algoritmos grandes:** Si el Template Method tiene muchos pasos, la clase abstracta y la jerarquía de clases concretas pueden volverse complejas y difíciles de mantener. Rastrear el flujo del algoritmo y entender cómo se combinan los pasos abstractos y concretos puede ser complicado.

#### 3. **Notas o advertencias:**

- Evalúa cuidadosamente si los pros del Template Method superan los contras en tu situación específica. Considera si la rigidez de la estructura del algoritmo es aceptable y si el potencial riesgo de violación del LSP es manejable.
- Para algoritmos muy complejos o con necesidades de flexibilidad extrema, explora otros patrones de diseño como Strategy o State, que ofrecen más flexibilidad a costa de quizás un poco menos de control sobre la estructura del algoritmo.

---

## K - Relación con otros patrones

#### 1. **Relación con Factory Method:**

- **Factory Method es una especialización de Template Method:** Un Factory Method (Método Fábrica) se puede considerar como un paso dentro de un Template Method más grande. Un Template Method podría usar un Factory Method para crear objetos necesarios para uno de sus pasos.

- **Factory Method como paso en Template Method:** Imagina un Template Method que define el proceso de crear un informe. Uno de los pasos podría ser "crear el formato del informe". Este paso podría implementarse usando un Factory Method. La clase abstracta del Template Method podría definir un método abstracto `crearFormatoInforme()` (el Factory Method), y las subclases concretas podrían implementar este método para crear diferentes tipos de formatos de informe (PDF, HTML, etc.).

#### 2. **Relación con Strategy:**

- **Template Method (herencia) vs. Strategy (composición):** La principal diferencia es el mecanismo de implementación. Template Method se basa en la **herencia**, mientras que Strategy se basa en la **composición**.

- **Template Method: Variación a nivel de clase (estático):** Con Template Method, la variación del algoritmo se define a nivel de clase, creando subclases diferentes. La estructura del algoritmo se fija en tiempo de compilación.

- **Strategy: Variación a nivel de objeto (dinámico):** Con Strategy, la variación del algoritmo se define a nivel de objeto, inyectando diferentes objetos "estrategia" en el objeto principal. Puedes cambiar la estrategia (y por lo tanto el comportamiento) de un objeto en tiempo de ejecución.

- **Cuándo usar cada uno:**
  - **Template Method:** Úsalo cuando la **estructura del algoritmo es fija** y quieres permitir variaciones en **algunos pasos específicos** a través de la herencia. Es más adecuado cuando las variaciones son conocidas en tiempo de compilación y no cambian dinámicamente.
  - **Strategy:** Úsalo cuando quieres **intercambiar algoritmos completos** en tiempo de ejecución, o cuando necesitas **mayor flexibilidad** y **evitar la herencia**. Es más adecuado cuando las variaciones pueden cambiar dinámicamente y necesitas componer el comportamiento de un objeto con diferentes estrategias.

#### 3. **Notas o advertencias:**

- A veces, puedes usar **ambos patrones juntos**. Un Template Method podría usar Strategy para implementar uno de sus pasos, especialmente si ese paso en sí mismo tiene múltiples variaciones que necesitan ser intercambiables dinámicamente.
- La elección entre Template Method y Strategy depende de la **flexibilidad** que necesites y de si la **estructura del algoritmo** debe ser fija o variable.
