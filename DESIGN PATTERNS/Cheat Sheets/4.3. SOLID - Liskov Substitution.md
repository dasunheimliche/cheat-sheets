## A - Principio de Sustitución de Liskov (LSP)

#### 1. **Definición:**

Imagina que tienes una clase padre y creas una clase hija que hereda de ella. El Principio de Sustitución de Liskov dice que **deberías poder usar la clase hija en cualquier lugar donde estés usando la clase padre, sin que nada se rompa**. Es como si pudieras intercambiar piezas de Lego: si una pieza nueva encaja donde iba la vieja, ¡todo sigue funcionando!

#### 2. **Ejemplo Conceptual:**

Piensa en "Animal" como clase padre y "Gato" como clase hija. Si tienes un programa que funciona con "Animales", debería funcionar igual de bien si le das "Gatos" en lugar de "Animales" genéricos.

**Código Conceptual (Java):**

```java
class Animal {
    public void hacerSonido() {
        System.out.println("Sonido genérico de animal");
    }
}

class Gato extends Animal {
    @Override
    public void hacerSonido() {
        System.out.println("¡Miau!");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal miAnimal = new Animal();
        Animal miGato = new Gato(); // Aquí usamos Gato donde esperaríamos Animal

        hacerHablar(miAnimal); // Funciona con Animal
        hacerHablar(miGato);  // ¡Debería funcionar también con Gato sin problemas!
    }

    public static void hacerHablar(Animal animal) {
        animal.hacerSonido();
    }
}
```

**Explicación del ejemplo:**

En este ejemplo, `Gato` es un tipo de `Animal`. El método `hacerHablar` espera un `Animal`, pero le podemos pasar un `Gato` y todo funciona bien. El `Gato` hace su propio sonido ("¡Miau!"), pero sigue cumpliendo con lo que se espera de un `Animal` (hacer un sonido).

#### 3. **Notas o advertencias:**

- **No rompas lo que ya funciona:** Si al usar una clase hija en lugar de la padre, tu programa empieza a comportarse de manera extraña o da errores, ¡estás violando el LSP!
- **Comportamiento consistente:** Las clases hijas deben mantener el "contrato" de la clase padre. Es decir, deben seguir haciendo lo que se espera que hagan, aunque lo hagan a su manera.

## B - Extender, No Sustituir Comportamiento

#### 1. **Definición:**

Cuando creas una clase hija, tu objetivo principal debería ser **añadir o extender** el comportamiento de la clase padre, no **reemplazarlo** por completo con algo totalmente diferente. Piensa en ello como construir sobre una base sólida, no como demoler la casa y construir algo nuevo en su lugar.

#### 2. **Ejemplo Conceptual:**

Imagina una clase `Vehiculo` con un método `acelerar()`. Si creas una clase hija `Coche`, el método `acelerar()` del `Coche` debería seguir acelerando el vehículo, ¡no hacer que vuele o se detenga de repente! Debería _extender_ la idea de acelerar, quizás haciéndolo más rápido o de una manera específica para coches, pero no cambiar la acción fundamental de acelerar.

**Código Conceptual (Java):**

```java
class Vehiculo {
    public void acelerar() {
        System.out.println("Vehículo acelerando de forma genérica.");
    }
}

class Coche extends Vehiculo {
    @Override
    public void acelerar() {
        System.out.println("Coche acelerando rápidamente."); // Extiende el comportamiento
        super.acelerar(); // Aún hace la aceleración genérica también (opcional, pero buen ejemplo)
    }
}

public class Main {
    public static void main(String[] args) {
        Vehiculo miVehiculo = new Vehiculo();
        Vehiculo miCoche = new Coche();

        miVehiculo.acelerar(); // Vehículo acelerando de forma genérica.
        miCoche.acelerar();    // Coche acelerando rápidamente.
                                // Vehículo acelerando de forma genérica. (si super.acelerar() está presente)
    }
}
```

**Explicación del ejemplo:**

La clase `Coche` extiende el comportamiento de `Vehiculo` al acelerar de una manera más específica ("rápidamente"), pero aún mantiene la idea básica de "acelerar". No está haciendo algo completamente diferente.

#### 3. **Notas o advertencias:**

- **Piensa en "ES-UN":** Un "Coche" _ES-UN_ "Vehículo". Si algo _ES-UN_ tipo de otra cosa, la clase hija debería extender y especializar, no contradecir, el comportamiento de la clase padre.
- **Evita sorpresas:** Si alguien usa tu clase padre y luego la reemplaza con una hija, no debería llevarse sorpresas desagradables en cuanto a cómo funcionan las cosas básicas.

## C - Tipos de Parámetros en Métodos

#### 1. **Definición:**

Cuando defines un método en una clase hija que **sobrescribe** un método de la clase padre, los **tipos de los parámetros** que acepta el método de la hija deben ser **iguales o más generales (abstractos)** que los tipos de parámetros del método de la clase padre.

#### 2. **Ejemplo Conceptual (Animales):**

Imagina un método en la clase `Animal` que es `alimentar(Animal animal)`. En una clase hija como `Gato`, puedes sobrescribir este método para que sea `alimentar(Animal animal)` (igual) o `alimentar(SerVivo serVivo)` si `SerVivo` es una clase más general que `Animal` (por ejemplo, si `Animal` hereda de `SerVivo`). Pero **no** deberías hacerlo más específico, como `alimentar(GatoDeBengala gatoBengala)` si `GatoDeBengala` es una raza específica de gato.

**Ejemplo "BIEN" (Parámetro más abstracto):**

```java
class Animal {
    public void alimentar(Animal animal) {
        System.out.println("Alimentando a un animal genérico.");
    }
}

class Gato extends Animal {
    @Override
    public void alimentar(SerVivo serVivo) { // SerVivo es más abstracto que Animal (imaginemos)
        System.out.println("Alimentando a un ser vivo (gato).");
    }
}

// Asumiendo que SerVivo es una clase padre de Animal
class SerVivo {
    // ...
}
```

**Ejemplo "MAL" (Parámetro más específico):**

```java
class Animal {
    public void alimentar(Animal animal) {
        System.out.println("Alimentando a un animal genérico.");
    }
}

class Gato extends Animal {
    @Override
    public void alimentar(GatoDeBengala gatoBengala) { // GatoDeBengala es MÁS específico
        System.out.println("Alimentando a un gato de Bengala.");
    }
}
```

**Explicación de los ejemplos:**

- **"BIEN":** Si el método padre acepta `Animal`, el método hijo puede aceptar algo más general como `SerVivo`. Esto funciona porque si el código cliente esperaba poder alimentar a cualquier `Animal`, también podrá alimentar a cualquier `SerVivo` (asumiendo que `Animal` es un tipo de `SerVivo`).
- **"MAL":** Si el método hijo solo acepta `GatoDeBengala`, y el código cliente esperaba poder alimentar a cualquier `Animal` (incluyendo gatos genéricos), ¡se romperá! El método hijo es demasiado restrictivo.

#### 3. **Notas o advertencias:**

- **Piénsalo al revés:** Imagina que tienes un método que funciona con "cosas grandes". En una clase hija, puedes hacer que funcione con "cosas aún más grandes" o "cosas grandes", pero no solo con "cosas grandes PERO solo las de color azul".
- **Flexibilidad:** Hacer los parámetros más generales o iguales mantiene la flexibilidad y permite que la clase hija sea realmente sustituible por la padre.

## D - Tipos de Retorno en Métodos

#### 1. **Definición:**

Similar a los parámetros, pero al revés. Cuando un método en una clase hija sobrescribe un método de la clase padre, el **tipo de valor que retorna** el método de la hija debe ser **igual o más específico (subtipo)** que el tipo de retorno del método de la clase padre.

#### 2. **Ejemplo Conceptual (Comprar Gatos):**

Imagina un método en la clase `TiendaDeAnimales` que es `comprarGato(): Gato`. En una clase hija como `TiendaDeGatosDeBengala`, puedes sobrescribir este método para que sea `comprarGato(): Gato` (igual) o `comprarGato(): GatoDeBengala` (más específico, ya que `GatoDeBengala` es un tipo de `Gato`). Pero **no** deberías hacerlo más general, como `comprarGato(): Animal`, si `Animal` es una clase más general que `Gato`.

**Ejemplo "BIEN" (Retorno más específico):**

```java
class TiendaDeAnimales {
    public Gato comprarGato() {
        System.out.println("Tienda de animales genérica vende un gato.");
        return new Gato(); // Retorna un Gato genérico
    }
}

class TiendaDeGatosDeBengala extends TiendaDeAnimales {
    @Override
    public GatoDeBengala comprarGato() { // GatoDeBengala es MÁS específico que Gato
        System.out.println("Tienda de gatos de bengala vende un gato de bengala.");
        return new GatoDeBengala(); // Retorna un GatoDeBengala
    }
}
```

**Ejemplo "MAL" (Retorno más general):**

```java
class TiendaDeAnimales {
    public Gato comprarGato() {
        System.out.println("Tienda de animales genérica vende un gato.");
        return new Gato(); // Retorna un Gato genérico
    }
}

class TiendaDeGatosDeBengala extends TiendaDeAnimales {
    @Override
    public Animal comprarGato() { // Animal es MÁS general que Gato
        System.out.println("Tienda de gatos de bengala vende un animal (¿gato?).");
        return new Animal(); // Retorna un Animal genérico (¡podría no ser un gato!)
    }
}
```

**Explicación de los ejemplos:**

- **"BIEN":** Si el método padre retorna `Gato`, el método hijo puede retornar algo más específico como `GatoDeBengala`. Esto funciona porque si el código cliente esperaba recibir un `Gato`, recibir un `GatoDeBengala` (que _es-un_ `Gato`) sigue siendo válido.
- **"MAL":** Si el método hijo retorna `Animal`, y el código cliente esperaba recibir un `Gato` (y quizás usar métodos específicos de `Gato`), ¡se romperá! Podría recibir cualquier tipo de `Animal`, ¡incluso un perro o un pez!

#### 3. **Notas o advertencias:**

- **Consistencia en lo que recibes:** Si esperas "manzanas" de un método, está bien que un método sobrescrito te dé "manzanas rojas" (un tipo de manzana), pero no "fruta" genérica (podría ser una naranja).
- **Seguridad de tipos:** Retornar un subtipo asegura que sigues cumpliendo con las expectativas del código que usa la clase padre.

## E - Tipos de Excepciones

#### 1. **Definición:**

Un método en una clase hija **no debería lanzar tipos de excepciones** que **no se esperen** del método de la clase padre. Las excepciones que lance la hija deben ser del mismo tipo que las de la padre, o subtipos de ellas.

#### 2. **Ejemplo Conceptual (Conexión a Base de Datos):**

Imagina un método `conectarDB()` en una clase `ServicioDB` que puede lanzar una excepción `ConexionFallidaException`. Una clase hija `ServicioDBRemota` que sobrescribe este método **debería lanzar `ConexionFallidaException` o un subtipo de ella**, como `ConexionRemotaFallidaException`. **No debería lanzar una excepción completamente diferente** como `ErrorDeDiscoException`, que no tiene nada que ver con la conexión en sí.

**Ejemplo "BIEN" (Subtipo de excepción):**

```java
class ConexionFallidaException extends Exception {
    public ConexionFallidaException(String message) { super(message); }
}

class ServicioDB {
    public void conectarDB() throws ConexionFallidaException {
        System.out.println("Conectando a la base de datos...");
        // ... código para conectar ...
        if (/* falla la conexión */ true) {
            throw new ConexionFallidaException("No se pudo conectar a la DB.");
        }
    }
}

class ServicioDBRemota extends ServicioDB {
    class ConexionRemotaFallidaException extends ConexionFallidaException { // Subtipo
        public ConexionRemotaFallidaException(String message) { super(message); }
    }

    @Override
    public void conectarDB() throws ConexionFallidaException { // Misma excepción o supertipo
        System.out.println("Conectando a la base de datos remota...");
        // ... código para conectar a DB remota ...
        if (/* falla la conexión remota */ true) {
            throw new ConexionRemotaFallidaException("Fallo conexión remota.");
        }
    }
}
```

**Ejemplo "MAL" (Excepción diferente):**

```java
class ConexionFallidaException extends Exception {
    public ConexionFallidaException(String message) { super(message); }
}

class ErrorDeDiscoException extends Exception { // Excepción diferente
    public ErrorDeDiscoException(String message) { super(message); }
}


class ServicioDB {
    public void conectarDB() throws ConexionFallidaException {
        // ...
    }
}

class ServicioDBRemota extends ServicioDB {
    @Override
    public void conectarDB() throws ErrorDeDiscoException { // ¡Excepción diferente!
        // ...
        if (/* error de disco */ true) {
            throw new ErrorDeDiscoException("Error al acceder al disco.");
        }
    }
}
```

**Explicación de los ejemplos:**

- **"BIEN":** Si el código cliente está preparado para capturar `ConexionFallidaException`, seguirá funcionando si recibe `ConexionRemotaFallidaException` porque es un tipo de `ConexionFallidaException`.
- **"MAL":** Si el código cliente solo captura `ConexionFallidaException` y de repente recibe `ErrorDeDiscoException`, la excepción no será manejada correctamente y podría causar problemas.

#### 3. **Notas o advertencias:**

- **Sorpresas en el `catch`:** El código que usa la clase padre (y tiene bloques `try-catch`) espera ciertas excepciones. No le des sorpresas con excepciones inesperadas en las clases hijas.
- **Jerarquía de excepciones:** Usa la herencia también para las excepciones. Si tienes una excepción general, puedes crear excepciones más específicas que hereden de ella.

## F - Condiciones Previas (Precondiciones)

#### 1. **Definición:**

Una **condición previa** es lo que se debe cumplir **antes** de llamar a un método. Por ejemplo, un método que divide dos números podría tener como precondición que el segundo número (el divisor) no sea cero. El LSP dice que una clase hija **no debe fortalecer las precondiciones** de un método que sobrescribe de la clase padre. En otras palabras, no puedes hacer que un método hijo sea más restrictivo en lo que acepta como entrada que el método padre.

#### 2. **Ejemplo Conceptual (Números Positivos):**

Imagina un método `procesarNumero(int numero)` en una clase `Procesador`. Este método podría funcionar bien con cualquier número entero, incluyendo negativos y cero. Si creas una clase hija `ProcesadorPositivos` y sobrescribes este método para que **solo acepte números positivos**, ¡estás fortaleciendo la precondición! El código que antes funcionaba con `Procesador` y le pasaba números negativos, ahora se romperá si usas `ProcesadorPositivos` en su lugar.

**Ejemplo "MAL" (Precondición más fuerte):**

```java
class Procesador {
    public void procesarNumero(int numero) {
        System.out.println("Procesando número: " + numero);
        // ... código que funciona con cualquier int ...
    }
}

class ProcesadorPositivos extends Procesador {
    @Override
    public void procesarNumero(int numero) {
        if (numero <= 0) { // Precondición más fuerte: ¡solo positivos!
            throw new IllegalArgumentException("Solo se aceptan números positivos.");
        }
        System.out.println("Procesando número positivo: " + numero);
        super.procesarNumero(numero); // Llama al método padre para el procesamiento real
    }
}
```

**Explicación del ejemplo:**

El `Procesador` original acepta cualquier `int`. `ProcesadorPositivos` _restringe_ esto, aceptando solo positivos. Si el código cliente esperaba poder usar `Procesador` con cualquier número, `ProcesadorPositivos` no es un sustituto válido porque impone una restricción adicional.

#### 3. **Notas o advertencias:**

- **Lo que "entra" al método:** Piensa en las precondiciones como las "reglas de entrada" de un método. Una clase hija no puede hacer que estas reglas sean más estrictas que las de la clase padre.
- **Código cliente sorprendido:** El código cliente que usaba la clase padre se basaba en las precondiciones originales. Fortalecerlas puede romper ese código.

## G - Condiciones Postseriores (Postcondiciones)

#### 1. **Definición:**

Una **condición posterior** es lo que se garantiza que será cierto **después** de que un método se ejecute (siempre y cuando se hayan cumplido las precondiciones). Por ejemplo, un método que guarda un documento podría tener como postcondición que el documento se haya guardado correctamente en el disco. El LSP dice que una clase hija **no debe debilitar las postcondiciones** de un método que sobrescribe de la clase padre. Es decir, no puedes hacer que un método hijo garantice _menos_ que el método padre después de su ejecución.

#### 2. **Ejemplo Conceptual (Cerrar Conexiones DB):**

Imagina un método `procesarDatosDB()` en una clase `ServicioDB` que tiene como postcondición que **siempre cierra todas las conexiones a la base de datos** antes de terminar. Si creas una clase hija `ServicioDBConCache` y sobrescribes este método para que **deje algunas conexiones abiertas para reutilizarlas (cache)**, ¡estás debilitando la postcondición! El código cliente que confiaba en que `procesarDatosDB()` siempre cerraría las conexiones podría tener problemas (conexiones fantasma, fugas de recursos) si usa `ServicioDBConCache` en su lugar.

**Ejemplo "MAL" (Postcondición más débil):**

```java
class ServicioDB {
    public void procesarDatosDB() {
        abrirConexion();
        // ... procesar datos ...
        cerrarConexion(); // Postcondición: ¡siempre cierra la conexión!
    }

    protected void abrirConexion() { /* ... */ }
    protected void cerrarConexion() { /* ... */ }
}

class ServicioDBConCache extends ServicioDB {
    @Override
    public void procesarDatosDB() {
        abrirConexion();
        // ... procesar datos ...
        // ¡NO cierra la conexión aquí para cache! (Debilita la postcondición)
        // La conexión se mantiene abierta para reuso futuro (intención de la cache)
    }
}
```

**Explicación del ejemplo:**

El `ServicioDB` original garantiza que después de `procesarDatosDB()`, las conexiones se cierran. `ServicioDBConCache` _rompe_ esta garantía al dejar las conexiones abiertas. Si el código cliente dependía de que las conexiones se cerraran, `ServicioDBConCache` no es un sustituto válido.

#### 3. **Notas o advertencias:**

- **Lo que "sale" del método:** Piensa en las postcondiciones como las "promesas de salida" de un método. Una clase hija no puede prometer _menos_ que la clase padre después de ejecutar el método.
- **Efectos secundarios esperados:** El código cliente puede depender de los efectos secundarios garantizados por las postcondiciones. Debilitar estas condiciones puede llevar a comportamientos inesperados.

## H - Invariantes

#### 1. **Definición:**

Los **invariantes** de una clase son las **condiciones que siempre deben ser verdaderas** para que un objeto de esa clase esté en un estado válido y tenga sentido. Piensa en las características esenciales de un objeto. El LSP dice que una clase hija **debe preservar los invariantes** de la clase padre. No puedes crear una clase hija que rompa las reglas básicas que hacen que un objeto de la clase padre sea lo que es.

#### 2. **Ejemplo Conceptual (Gato Invariantes):**

Los invariantes de un `Gato` podrían ser: tener 4 patas, tener una cola, poder maullar. Si creas una clase hija `GatoRobot`, aunque pueda heredar de `Gato` en algunos aspectos, **no puede romper los invariantes esenciales de un gato biológico**. Por ejemplo, si `GatoRobot` no tiene cola o no puede maullar de ninguna forma que se parezca a un gato, podría estar violando los invariantes de `Gato` (dependiendo de cómo se definan exactamente los invariantes de `Gato` en tu sistema).

**Ejemplo Conceptual (Rectángulo/Cuadrado - Clásico Violación LSP):**

Un ejemplo clásico de violación de LSP con invariantes es el problema del "Rectángulo y Cuadrado".

- **Invariante de Rectángulo:** Ancho y Alto pueden ser independientes.
- **Invariante de Cuadrado:** Ancho y Alto SIEMPRE deben ser iguales.

Si haces que `Cuadrado` herede de `Rectángulo` y intentas sobrescribir los métodos para mantener el invariante del cuadrado (ancho siempre igual a alto), puedes terminar violando las postcondiciones de los métodos de `Rectángulo`. Por ejemplo, si `Rectángulo` tiene métodos `setAncho(ancho)` y `setAlto(alto)` que se supone que cambian ancho y alto _independientemente_, y en `Cuadrado` intentas hacer que `setAncho` y `setAlto` siempre mantengan ancho y alto iguales, ¡estás rompiendo la expectativa de que `setAncho` solo cambia el ancho!

**Código Conceptual (Violación LSP - Rectángulo/Cuadrado):**

```java
class Rectangulo {
    protected int ancho;
    protected int alto;

    public void setAncho(int ancho) {
        this.ancho = ancho;
    }

    public void setAlto(int alto) {
        this.alto = alto;
    }

    public int getAncho() { return ancho; }
    public int getAlto() { return alto; }

    public int calcularArea() { return ancho * alto; }
}

class Cuadrado extends Rectangulo {
    @Override
    public void setAncho(int ancho) {
        super.setAncho(ancho);
        super.setAlto(ancho); // ¡Intento de mantener invariante de cuadrado!
    }

    @Override
    public void setAlto(int alto) {
        super.setAlto(alto);
        super.setAncho(alto); // ¡Intento de mantener invariante de cuadrado!
    }
    // ...
}

public class Main {
    public static void main(String[] args) {
        Rectangulo rect = new Rectangulo();
        rect.setAncho(5);
        rect.setAlto(10);
        System.out.println("Área Rectángulo: " + rect.calcularArea()); // Área Rectángulo: 50

        Cuadrado cuadrado = new Cuadrado();
        cuadrado.setAncho(5);
        cuadrado.setAlto(10); // ¡Se supone que solo debería cambiar el alto!
        System.out.println("Área Cuadrado (esperando 10*10=100, pero...): " + cuadrado.calcularArea()); // Área Cuadrado: 100 (¡¿...?!, no 5*10=50)
    }
}
```

**Explicación del ejemplo:**

En este ejemplo (de violación de LSP), al intentar forzar el invariante del cuadrado en la clase `Cuadrado` que hereda de `Rectangulo`, hemos roto la expectativa de cómo funcionan `setAncho` y `setAlto` en `Rectangulo`. Si esperabas poder cambiar ancho y alto de un rectángulo independientemente, ¡con `Cuadrado` ya no funciona así!

#### 3. **Notas o advertencias:**

- **Esencia de la clase:** Los invariantes son el "corazón" de lo que define una clase. No los rompas en las clases hijas.
- **Diseño cuidadoso:** A veces, la herencia no es la mejor manera de modelar ciertas relaciones (como Rectángulo y Cuadrado). Considera otras opciones como composición si la herencia te lleva a violar invariantes.

## I - Campos Privados de la Superclase

#### 1. **Definición:**

El LSP dice que una clase hija **no debería cambiar los valores de los campos privados** de la clase padre. Esto puede sonar extraño porque, en teoría, los campos privados no deberían ser accesibles directamente desde fuera de la clase, ¡ni siquiera desde las clases hijas! Sin embargo, en algunos lenguajes (o con técnicas como la reflexión en Java), es _posible_ (aunque generalmente no se recomienda) acceder o modificar campos privados de la superclase desde una subclase.

#### 2. **Ejemplo Conceptual (Contador Privado):**

Imagina una clase `Contador` con un campo `private int valor`. Tiene métodos para incrementar y obtener el valor. Si creas una clase hija `ContadorTramposo` que, de alguna manera (quizás usando reflexión), intenta modificar directamente el campo `valor` de la clase padre para "hacer trampa" y cambiar el contador de forma inesperada, ¡estás violando el espíritu del LSP y el encapsulamiento!

**Ejemplo Conceptual (Java - Reflexión - ¡NO RECOMENDADO! - Solo para ilustrar la idea):**

**¡Advertencia!** El siguiente código usa reflexión, que generalmente **no es una buena práctica** para el uso normal. Es solo para ilustrar el _concepto_ de modificar campos privados y cómo podría violar el LSP.

```java
import java.lang.reflect.Field;

class Contador {
    private int valor = 0;

    public void incrementar() {
        valor++;
    }

    public int getValor() {
        return valor;
    }
}

class ContadorTramposo extends Contador {
    public void hacerTrampaYResetear() {
        try {
            Field valorField = Contador.class.getDeclaredField("valor"); // Accede al campo privado 'valor'
            valorField.setAccessible(true); // ¡Permite acceso aunque sea privado! (Reflexión)
            valorField.setInt(this, 0); // ¡Cambia el valor directamente a 0!
            System.out.println("¡He hecho trampa y reseteado el contador!");
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Contador contador = new Contador();
        contador.incrementar();
        System.out.println("Valor contador normal: " + contador.getValor()); // Valor contador normal: 1

        ContadorTramposo contadorTramposo = new ContadorTramposo();
        contadorTramposo.incrementar();
        System.out.println("Valor contador tramposo antes de trampa: " + contadorTramposo.getValor()); // Valor contador tramposo antes de trampa: 1
        contadorTramposo.hacerTrampaYResetear(); // ¡He hecho trampa y reseteado el contador!
        System.out.println("Valor contador tramposo DESPUÉS de trampa: " + contadorTramposo.getValor()); // Valor contador tramposo DESPUÉS de trampa: 0
    }
}
```

**Explicación del ejemplo (con reflexión - ¡NO USAR EN PRODUCCIÓN!):**

`ContadorTramposo` usa reflexión para acceder y modificar el campo `private valor` de `Contador`. Esto es una violación del encapsulamiento y del LSP. Si el código cliente esperaba que el contador solo se modificara a través del método `incrementar()`, `ContadorTramposo` rompe esa expectativa al cambiar el valor de forma "oculta" y directa.

#### 3. **Notas o advertencias:**

- **Encapsulamiento:** Los campos privados están pensados para ser internos a la clase. Modificarlos desde fuera (especialmente desde subclases de forma "tramposa") va en contra del principio de encapsulamiento y puede llevar a comportamientos inesperados y difíciles de mantener.
- **Acceso no intencionado:** Aunque técnicamente sea posible en algunos casos, modificar campos privados de la superclase desde una subclase suele ser una mala idea y una señal de que el diseño de la herencia podría no ser el adecuado.

## J - Ejemplo de Violación LSP: Documento de Solo Lectura (ANTES)

#### 1. **Definición del Problema:**

En el ejemplo "ANTES" del texto, tenemos una jerarquía de clases de `Document` donde hay un `Document` base y un `ReadOnlyDocument` que hereda de él. El problema es que en `ReadOnlyDocument`, el método `save()` **no tiene sentido** (un documento de solo lectura no se puede guardar). La solución "mala" (ANTES) es que `ReadOnlyDocument` sobrescribe el método `save()` para que **lance una excepción** si alguien intenta guardarlo.

#### 2. **Diagrama "ANTES" (Violación LSP):**

![image](https://i.ibb.co/fVy0064Y/image.png)

**Explicación del Diagrama "ANTES":**

- **`Document` (Clase Padre):** Tiene datos (`data`, `filename`) y métodos (`open()`, `save()`). El método `save()` en la clase base _se supone_ que guarda el documento.
- **`ReadOnlyDocument` (Clase Hija):** Hereda de `Document`. Sobrescribe el método `save()` para que **lance una excepción**. Esto significa que `ReadOnlyDocument` **no se comporta como un `Document` en cuanto a la operación de guardar**.

#### 3. **Código Conceptual "ANTES" (Violación LSP):**

```java
class Document {
    protected String data;
    protected String filename;

    public void open() {
        System.out.println("Abriendo documento: " + filename);
        // ... código para abrir ...
    }

    public void save() {
        System.out.println("Guardando documento: " + filename);
        // ... código para guardar ...
    }
}

class ReadOnlyDocument extends Document {
    @Override
    public void save() {
        throw new UnsupportedOperationException("No se puede guardar un documento de solo lectura.");
    }
}

public class Project {
    private List<Document> documents = new ArrayList<>();

    public void addDocument(Document doc) {
        documents.add(doc);
    }

    public void openAll() {
        for (Document doc : documents) {
            doc.open();
        }
    }

    public void saveAll() {
        for (Document doc : documents) {
            doc.save(); // ¡Aquí podría fallar si 'doc' es ReadOnlyDocument!
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Project project = new Project();
        project.addDocument(new Document());
        project.addDocument(new ReadOnlyDocument());

        project.openAll(); // Abre ambos documentos sin problema

        try {
            project.saveAll(); // ¡Lanza excepción para ReadOnlyDocument!
        } catch (UnsupportedOperationException e) {
            System.out.println("Error al guardar: " + e.getMessage()); // Error al guardar: No se puede guardar un documento de solo lectura.
        }
    }
}
```

**Explicación del Ejemplo "ANTES":**

- El método `saveAll()` en `Project` itera sobre una lista de `Document`s y llama a `doc.save()`. **Se espera que `save()` funcione para cualquier `Document`**.
- Pero si un `Document` es en realidad un `ReadOnlyDocument`, `save()` lanza una excepción. **Esto rompe la expectativa del código cliente** (el método `saveAll()`) que asumía que podía llamar a `save()` en cualquier `Document` sin problemas.
- **Violación LSP:** `ReadOnlyDocument` no es completamente sustituible por `Document` porque la operación `save()` no se comporta de forma compatible.

#### 4. **Problemas Adicionales (Código Cliente Dependiente del Tipo):**

El texto menciona que este diseño también viola el Principio Abierto/Cerrado (OCP). ¿Por qué? Porque si el código cliente (como `Project.saveAll()`) necesita manejar correctamente los `ReadOnlyDocument`s, **tendría que empezar a comprobar el tipo de documento antes de llamar a `save()`**:

```java
public void saveAll_ConComprobacionDeTipo() { // ¡Código más complejo y menos flexible!
    for (Document doc : documents) {
        if (!(doc instanceof ReadOnlyDocument)) { // ¡Comprobación de tipo!
            doc.save();
        } else {
            System.out.println("Documento de solo lectura, no se guarda: " + doc.filename);
        }
    }
}
```

**Problemas de la Comprobación de Tipo:**

- **Más complejo:** El código se vuelve más enrevesado y difícil de leer.
- **Menos flexible:** Si añades un nuevo tipo de `Document` (por ejemplo, `EncryptedDocument`), ¡tendrías que modificar `saveAll()` de nuevo para manejarlo! El código cliente se vuelve dependiente de los tipos concretos de `Document`s, en lugar de depender solo de la abstracción `Document`.

## K - Solución LSP: Documento de Solo Lectura como Clase Base (DESPUÉS)

#### 1. **Definición de la Solución:**

La solución "DESPUÉS" en el texto es **reorganizar la jerarquía de clases**. En lugar de hacer que `ReadOnlyDocument` herede de `Document` y "rompa" el método `save()`, se **invierte la jerarquía**. `ReadOnlyDocument` se convierte en la **clase base**, y `WritableDocument` (documento que se puede escribir) hereda de `ReadOnlyDocument` y **añade** la funcionalidad de `save()`.

#### 2. **Diagrama "DESPUÉS" (Solución LSP):**

![image](https://i.ibb.co/67TyNpwP/image.png)

**Explicación del Diagrama "DESPUÉS":**

- **`ReadOnlyDocument` (Clase Base):** Ahora es la clase base. Tiene datos (`data`, `filename`) y el método `open()`. **No tiene método `save()`** porque un documento de solo lectura no se guarda.
- **`WritableDocument` (Clase Hija):** Hereda de `ReadOnlyDocument`. **Añade** el método `save()`. Un `WritableDocument` _es-un_ tipo de `ReadOnlyDocument` (en el sentido de que también se puede abrir y leer), pero _además_ se puede escribir y guardar.

#### 3. **Código Conceptual "DESPUÉS" (Solución LSP):**

```java
class ReadOnlyDocument { // ¡Ahora es la clase base!
    protected String data;
    protected String filename;

    public void open() {
        System.out.println("Abriendo documento de solo lectura: " + filename);
        // ... código para abrir ...
    }
    // ¡NO tiene método save()!
}

class WritableDocument extends ReadOnlyDocument { // ¡Hereda de ReadOnlyDocument!
    public void save() {
        System.out.println("Guardando documento editable: " + filename);
        // ... código para guardar ...
    }
}

public class Project_SolucionLSP {
    private List<ReadOnlyDocument> allDocs = new ArrayList<>(); // Lista de ReadOnlyDocument (o subtipos)
    private List<WritableDocument> writableDocs = new ArrayList<>(); // Lista separada para WritableDocument

    public void addDocument(ReadOnlyDocument doc) {
        allDocs.add(doc);
        if (doc instanceof WritableDocument) { // Si es editable, añádelo también a la lista de editables
            writableDocs.add((WritableDocument) doc);
        }
    }

    public void openAll() {
        for (ReadOnlyDocument doc : allDocs) {
            doc.open(); // Funciona para ReadOnlyDocument y WritableDocument
        }
    }

    public void saveAll() {
        for (WritableDocument doc : writableDocs) { // ¡Solo itera sobre WritableDocument!
            doc.save(); // ¡Ahora SIEMPRE funciona porque solo son WritableDocument!
        }
    }
}

public class Main_SolucionLSP {
    public static void main(String[] args) {
        Project_SolucionLSP project = new Project_SolucionLSP();
        project.addDocument(new ReadOnlyDocument());
        project.addDocument(new WritableDocument());

        project.openAll(); // Abre ambos documentos sin problema
        project.saveAll(); // Guarda SOLO el documento editable, ¡sin excepciones!
    }
}
```

**Explicación del Ejemplo "DESPUÉS":**

- **Jerarquía Invertida:** `ReadOnlyDocument` es la base. `WritableDocument` _extiende_ `ReadOnlyDocument` añadiendo la capacidad de guardar.
- **`saveAll()` Simplificado:** En `Project_SolucionLSP`, `saveAll()` ahora itera sobre una lista separada de `WritableDocument`s. **Ya no necesita comprobar el tipo de documento** porque sabe que todos los documentos en `writableDocs` _son_ `WritableDocument`s y, por lo tanto, _tienen_ el método `save()` que funciona.
- **Cumple LSP:** Un `WritableDocument` _es-un_ `ReadOnlyDocument` (puede hacer todo lo que hace un `ReadOnlyDocument` y más). Puedes usar un `WritableDocument` en cualquier lugar donde esperes un `ReadOnlyDocument` sin romper nada. La operación `open()` funciona igual para ambos. La diferencia es que `WritableDocument` _además_ tiene `save()`.

#### 4. **Beneficios de la Solución "DESPUÉS":**

- **Cumple LSP:** La jerarquía de clases ahora sigue el Principio de Sustitución de Liskov.
- **Código Cliente Simplificado:** `Project.saveAll()` es más simple y claro. No necesita comprobaciones de tipo.
- **Más flexible y extensible:** Si añades nuevos tipos de documentos en el futuro, el código cliente será más fácil de mantener y extender.
