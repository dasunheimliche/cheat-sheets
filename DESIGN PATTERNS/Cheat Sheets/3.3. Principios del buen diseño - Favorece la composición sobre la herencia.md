## A - Herencia vs Composición

#### 1. **Definición:**

En programación orientada a objetos, tenemos dos formas principales de reutilizar código y establecer relaciones entre clases:

- **Herencia:** Es como decir "esto **es un** tipo de aquello". Una clase nueva (subclase) hereda características y comportamientos de una clase existente (superclase). Piensa en un "Coche **es un** Vehículo".
- **Composición:** Es como decir "esto **tiene un** aquello". Una clase contiene objetos de otras clases como partes de sí misma. Piensa en un "Coche **tiene un** Motor".

#### 2. **Ejemplo:**

**Herencia (Ejemplo Conceptual):**

```java
// Ejemplo conceptual - No es código Java ejecutable directamente
class Vehiculo {
    public void moverse() {
        System.out.println("Vehículo moviéndose");
    }
}

class Coche extends Vehiculo {
    // Coche hereda el comportamiento de Vehiculo
}

class Camion extends Vehiculo {
    // Camion también hereda el comportamiento de Vehiculo
}
```

**Composición (Ejemplo Conceptual):**

```java
// Ejemplo conceptual - No es código Java ejecutable directamente
interface Motor {
    void arrancar();
}

class MotorCombustion implements Motor {
    public void arrancar() {
        System.out.println("Motor de combustión arrancando");
    }
}

class Coche {
    Motor motor; // Coche TIENE un Motor

    public Coche(Motor motor) {
        this.motor = motor;
    }

    public void arrancarCoche() {
        motor.arrancar(); // Delega el comportamiento al Motor
        System.out.println("Coche listo para conducir");
    }
}
```

**Explicación del ejemplo:**

- **Herencia:** `Coche` y `Camion` **son** tipos de `Vehiculo`. Heredan automáticamente la capacidad de `moverse` de la clase `Vehiculo`.
- **Composición:** `Coche` **tiene un** `Motor`. En lugar de heredar el comportamiento de un motor, el `Coche` utiliza un objeto `Motor` para realizar acciones relacionadas con el motor, como `arrancar`.

#### 3. **Notas o advertencias:**

- La **herencia** crea una relación **fuerte** entre la superclase y la subclase. Cambios en la superclase pueden afectar a todas las subclases.
- La **composición** crea una relación **más flexible**. Puedes cambiar el tipo de `Motor` de un `Coche` fácilmente sin afectar la clase `Coche` en sí.

---

## B - Problemas de la Herencia

#### 1. **Definición:**

Aunque la herencia parece sencilla al principio, puede traer problemas a medida que tu programa crece. Aquí te presento algunos inconvenientes comunes:

#### 2. **Problemas:**

1.  **No puedes reducir la interfaz de la superclase:**

    - Si heredas de una clase, **tienes que implementar todos sus métodos abstractos**, ¡sí o sí! Incluso si algunos de esos métodos no tienen sentido para tu subclase. Es como si te obligaran a usar herramientas que no necesitas.

2.  **Comportamiento compatible al sobrescribir métodos:**

    - Cuando cambias un método heredado (sobrescribir), debes asegurarte de que el nuevo comportamiento **no rompa** lo que se esperaba de la clase original. Imagina que la clase padre prometía hacer una cosa, y la hija hace algo totalmente diferente... ¡caos!

3.  **Rompe la encapsulación:**

    - La herencia expone detalles internos de la clase padre a las subclases. Es como si la subclase tuviera acceso a secretos de la clase padre que no debería conocer. Esto puede hacer que el código sea más frágil y difícil de mantener.

4.  **Fuerte acoplamiento:**

    - Las subclases dependen mucho de las superclases. Si cambias algo en la superclase, ¡pum! Puede que rompas las subclases sin querer. Es como si estuvieran pegadas con pegamento muy fuerte.

5.  **Jerarquías de herencia paralelas y explosión combinatoria:**
    - Si intentas usar la herencia para muchas características diferentes (dimensiones), puedes terminar con un montón de clases y subclases que se multiplican rápidamente. ¡Una locura! Esto se ve muy claro en el ejemplo de los coches y camiones con diferentes tipos de motor y navegación.

#### 3. **Ejemplo: Explosión Combinatoria con Herencia**

**Imagen:**

![image](https://i.ibb.co/7NYDjtt1/image.png)

**Explicación del ejemplo:**

Mira la imagen de arriba. Si quieres clasificar vehículos por:

- **Tipo de carga:** Coche o Camión
- **Tipo de motor:** Eléctrico o Combustión
- **Tipo de navegación:** Manual o Autopilot

¡La herencia te obliga a crear un montón de combinaciones! `CocheElectricoAutopilot`, `CamionCombustionManual`, etc. Se vuelve muy complicado y repetitivo.

#### 4. **Notas o advertencias:**

- La herencia puede ser útil para relaciones **"es un"** muy claras y simples.
- Pero para sistemas complejos con muchas características combinables, la herencia puede convertirse en un dolor de cabeza.

---

## C - La Composición al Rescate

#### 1. **Definición:**

La composición ofrece una alternativa más flexible y poderosa a la herencia. En lugar de "ser un", se trata de "tener un".

#### 2. **Beneficios de la Composición:**

1.  **Flexibilidad:**

    - Puedes combinar objetos de diferentes clases de forma más libre. No estás limitado por una jerarquía rígida de herencia.

2.  **Reutilización de comportamiento sin acoplamiento fuerte:**

    - Las clases se componen de otras clases, pero no dependen tanto de la estructura interna de esas clases. El acoplamiento es más débil.

3.  **Comportamiento en tiempo de ejecución:**
    - Puedes cambiar los componentes de un objeto (por ejemplo, el motor de un coche) mientras el programa está funcionando. ¡Mucha más dinámica!

#### 3. **Ejemplo: Composición para Vehículos**

**Imagen:**

![image](https://i.ibb.co/zWh7w2ZW/image.png)

**Explicación del ejemplo:**

Mira la imagen de arriba. Con composición, organizamos las cosas de forma diferente:

- **Transporte** (clase base o abstracta): Define lo básico de un vehículo (motor, conductor, capacidad de entregar).
- **Motor** (interfaz): Define qué hace un motor (arrancar, acelerar, etc.). Tenemos diferentes tipos de motores que **implementan** esta interfaz: `MotorCombustion`, `MotorElectrico`.
- **Conductor** (interfaz): Define qué hace un conductor (navegar, conducir). Tenemos diferentes tipos de conductores: `Robot`, `Humano`.

Ahora, un `Coche` o un `Camion` **tienen** un `Motor` y un `Conductor`. Podemos combinar diferentes tipos de motores y conductores fácilmente.

**Ejemplo Conceptual en Java:**

```java
// Interfaces
interface Engine {
    void move();
}

interface Driver {
    void navigate();
}

// Implementaciones de Engine
class CombustionEngine implements Engine {
    public void move() {
        System.out.println("Motor de combustión en marcha");
    }
}

class ElectricEngine implements Engine {
    public void move() {
        System.out.println("Motor eléctrico en marcha");
    }
}

// Implementaciones de Driver
class HumanDriver implements Driver {
    public void navigate() {
        System.out.println("Conductor humano navegando");
    }
}

class RobotDriver implements Driver {
    public void navigate() {
        System.out.println("Robot piloto automático navegando");
    }
}

// Clase Transport (Vehículo) usando composición
class Transport {
    Engine engine;
    Driver driver;

    public Transport(Engine engine, Driver driver) {
        this.engine = engine;
        this.driver = driver;
    }

    public void deliver(String destination, String cargo) {
        System.out.println("Entregando " + cargo + " a " + destination);
        engine.move();
        driver.navigate();
    }
}

// Ejemplo de uso
public class Main {
    public static void main(String[] args) {
        Engine electricEngine = new ElectricEngine();
        HumanDriver humanDriver = new HumanDriver();

        Transport electricCar = new Transport(electricEngine, humanDriver);
        electricCar.deliver("Ciudad A", "Paquete pequeño");

        Engine combustionEngine = new CombustionEngine();
        RobotDriver autopilot = new RobotDriver();

        Transport combustionTruckAutopilot = new Transport(combustionEngine, autopilot);
        combustionTruckAutopilot.deliver("Ciudad B", "Carga pesada");
    }
}
```

**Explicación del ejemplo de código:**

- Hemos creado interfaces `Engine` y `Driver` para definir los comportamientos.
- Tenemos diferentes implementaciones de `Engine` (combustión, eléctrico) y `Driver` (humano, robot).
- La clase `Transport` (vehículo) **tiene** un `Engine` y un `Driver` como **componentes**.
- En `Main`, podemos crear diferentes tipos de `Transport` (coches, camiones) simplemente **combinando** diferentes implementaciones de `Engine` y `Driver`. ¡Mucha flexibilidad!

#### 4. **Notas o advertencias:**

- La composición a menudo lleva a un diseño más flexible y mantenible, especialmente en sistemas complejos.
- Piensa en la composición como "construir con bloques LEGO". Puedes combinar diferentes bloques (objetos) para crear cosas más grandes y complejas.

---

## D - Agregación (Un Tipo de Composición)

#### 1. **Definición:**

La agregación es una forma "más suave" de composición. La diferencia principal está en la **dependencia del ciclo de vida**.

- **Composición "fuerte":** Si la clase contenedora se destruye, los objetos contenidos también se destruyen (o no pueden existir sin el contenedor). Ejemplo: Un `Motor` es parte esencial de un `Coche`. Si destruyes el coche, el motor probablemente ya no tenga sentido por sí solo en ese contexto.
- **Agregación "débil":** Los objetos contenidos pueden existir **independientemente** de la clase contenedora. Ejemplo: Un `Conductor` puede conducir un `Coche`, pero el conductor sigue existiendo y puede conducir otros coches o hacer otras cosas incluso si el coche se destruye.

#### 2. **Ejemplo:**

En el ejemplo del `Coche` y el `Conductor`:

- **Composición:** Podríamos decir que el `Motor` está **compuesto** dentro del `Coche`. El motor es una parte integral del coche.
- **Agregación:** El `Conductor` está **agregado** al `Coche`. El coche usa un conductor, pero el conductor no es una parte inseparable del coche.

#### 3. **Notas o advertencias:**

- En la práctica, la diferencia entre composición y agregación a veces es sutil y depende del contexto de tu diseño.
- Lo importante es entender la idea de "tener un" y cómo te da más flexibilidad que la herencia en muchos casos.

---

## E - Favorecer la Composición sobre la Herencia: La Conclusión

#### 1. **Definición:**

El principio de "Favorecer la Composición sobre la Herencia" es una guía de diseño que te anima a usar la composición (y la agregación) como principal mecanismo para reutilizar código y establecer relaciones entre clases, **en lugar de depender excesivamente de la herencia**.

#### 2. **Resumen de Ventajas de la Composición:**

- **Más flexible:** Combina objetos de forma libre.
- **Menos acoplamiento:** Clases menos dependientes entre sí.
- **Comportamiento dinámico:** Cambia componentes en tiempo de ejecución.
- **Evita la explosión combinatoria:** Diseño más limpio y manejable.

#### 3. **Cuándo usar Herencia (con precaución):**

- Para relaciones **"es un"** muy claras y simples.
- Cuando quieres reutilizar **toda** la interfaz y comportamiento de una clase padre.
- En jerarquías pequeñas y bien definidas.

#### 4. **Cuándo usar Composición (preferiblemente):**

- En la mayoría de los casos, especialmente en sistemas complejos.
- Cuando necesitas flexibilidad y evitar el acoplamiento fuerte.
- Cuando quieres combinar diferentes comportamientos de forma dinámica.

#### 5. **Notas o advertencias:**

- No significa que la herencia sea "mala" y la composición "buena" en todos los casos.
- Es una cuestión de **elegir la herramienta adecuada** para cada situación. Pero en general, la composición suele ser una opción más robusta y flexible a largo plazo.
