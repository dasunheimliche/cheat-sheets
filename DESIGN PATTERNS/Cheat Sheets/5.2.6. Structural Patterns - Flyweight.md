## A - Flyweight: Compartiendo para ahorrar memoria

#### 1. **Definicion:**

El patrón **Flyweight** es como un mago que hace aparecer muchos objetos usando muy pocos "ingredientes" reales. Imagina que tienes miles de objetos casi idénticos, como hojas en un bosque. En lugar de guardar cada hoja por separado (¡ocuparía muchísima memoria!), Flyweight te permite compartir las partes comunes entre todas las hojas. Así, solo guardas la información única de cada hoja (como su posición en el árbol) y la combinas con la información compartida (como el color y la forma típica de la hoja). ¡Magia! Esto ahorra un montón de memoria RAM.

#### 2. **Ejemplo:**

Imagina que estamos creando un juego con muchos árboles. Cada árbol tiene una posición (x, y) en el mapa, pero todos los árboles de la misma especie comparten la misma forma, color de hojas y textura de tronco.

```java
// 1. La parte compartida (Flyweight): TreeType
class TreeType {
    private String name;
    private String color;
    private String texture;

    public TreeType(String name, String color, String texture) {
        this.name = name;
        this.color = color;
        this.texture = texture;
    }

    public void draw(java.awt.Graphics g, int x, int y) {
        // Simulación de dibujar el árbol usando color y textura compartidos
        System.out.println("Dibujando un árbol de tipo " + name + " en (" + x + "," + y + ") con color " + color + " y textura " + texture);
        // En un juego real, aquí irían las instrucciones para dibujar usando g
    }
}

// 2. El "contenedor" de la parte compartida (Flyweight Factory)
class TreeFactory {
    private static java.util.HashMap<String, TreeType> treeTypes = new java.util.HashMap<>();

    public static TreeType getTreeType(String name, String color, String texture) {
        String key = name + "-" + color + "-" + texture;
        TreeType type = treeTypes.get(key);
        if (type == null) {
            type = new TreeType(name, color, texture);
            treeTypes.put(key, type);
            System.out.println("Creando nuevo TreeType para: " + key);
        } else {
            System.out.println("Reutilizando TreeType existente para: " + key);
        }
        return type;
    }
}

// 3. El objeto individual (Contexto) que usa la parte compartida (Flyweight)
class Tree {
    private int x;
    private int y;
    private TreeType type; // Referencia al Flyweight

    public Tree(int x, int y, TreeType type) {
        this.x = x;
        this.y = y;
        this.type = type;
    }

    public void draw(java.awt.Graphics g) {
        type.draw(g, x, y); // Delega el dibujo al Flyweight, pasando la posición única
    }
}

// 4. El cliente que usa todo (ejemplo en main)
public class Forest {
    private java.util.List<Tree> trees = new java.util.ArrayList<>();

    public void plantTree(int x, int y, String name, String color, String texture) {
        TreeType type = TreeFactory.getTreeType(name, color, texture); // Obtiene o crea el TreeType compartido
        Tree tree = new Tree(x, y, type); // Crea un Tree individual con la posición y el TreeType compartido
        trees.add(tree);
    }

    public void draw(java.awt.Graphics g) {
        for (Tree tree : trees) {
            tree.draw(g); // Dibuja cada árbol
        }
    }

    public static void main(String[] args) {
        Forest forest = new Forest();
        forest.plantTree(10, 10, "Pino", "Verde", "TexturaPino");
        forest.plantTree(20, 15, "Pino", "Verde", "TexturaPino"); // Reutiliza el mismo TreeType para Pino
        forest.plantTree(30, 20, "Roble", "Marrón", "TexturaRoble");

        // Simulamos el dibujo del bosque (en realidad no estamos usando Graphics aquí)
        forest.draw(null);
    }
}
```

**Explicación del ejemplo:**

- **`TreeType` (Flyweight):** Representa la información compartida entre árboles del mismo tipo (nombre, color, textura). El método `draw` sabe _cómo_ dibujar un árbol de ese tipo, pero necesita las coordenadas `x` e `y` que son únicas para cada árbol.
- **`TreeFactory` (Flyweight Factory):** Se encarga de crear y **reutilizar** objetos `TreeType`. Si ya existe un `TreeType` con las mismas características (nombre, color, textura), lo devuelve en lugar de crear uno nuevo. Esto es clave para ahorrar memoria.
- **`Tree` (Contexto):** Representa un árbol individual. Guarda la información **única** de cada árbol: su posición (`x`, `y`) y una **referencia** a un `TreeType` (la parte compartida). Cuando se llama a `tree.draw()`, delega el trabajo al `TreeType`, pasándole su posición.
- **`Forest` (Cliente):** Crea y gestiona los árboles. Usa `TreeFactory` para obtener los `TreeType` y luego crea objetos `Tree` individuales.

**Output del código:**

```
Creando nuevo TreeType para: Pino-Verde-TexturaPino
Reutilizando TreeType existente para: Pino-Verde-TexturaPino
Creando nuevo TreeType para: Roble-Marrón-TexturaRoble
Dibujando un árbol de tipo Pino en (10,10) con color Verde y textura TexturaPino
Dibujando un árbol de tipo Pino en (20,15) con color Verde y textura TexturaPino
Dibujando un árbol de tipo Roble en (30,20) con color Marrón y textura TexturaRoble
```

**Explicación del output:**

Observa que "Creando nuevo TreeType" solo aparece dos veces, para "Pino" y "Roble". Cuando plantamos el segundo "Pino", se **reutilizó** el `TreeType` existente. Esto demuestra cómo Flyweight ahorra memoria al compartir objetos.

#### 3. **Notas o advertencias:**

- **No abuses de Flyweight:** Solo úsalo cuando realmente tengas problemas de memoria por tener muchos objetos similares. Si no es así, puede complicar tu código innecesariamente.
- **Identifica bien lo compartido:** El truco está en separar correctamente qué parte del objeto es **intrínseca** (compartida, Flyweight) y qué parte es **extrínseca** (única, Contexto).
- **Inmutabilidad del Flyweight:** Los objetos Flyweight (como `TreeType`) deberían ser **inmutables**, es decir, una vez creados, no deberían cambiar. Esto es importante porque se comparten entre muchos "contextos" (como diferentes `Tree`). Si un Flyweight cambiara, afectaría a todos los que lo están usando, ¡y eso sería un caos!

---

## B - Intrinsic vs Extrinsic State: El corazón de Flyweight

#### 1. **Definicion:**

Para que Flyweight funcione, necesitamos dividir la información de nuestros objetos en dos tipos:

- **Estado Intrínseco (Intrinsic State):** Es la parte de la información que es **compartida** por muchos objetos. Es como la "esencia" del objeto, lo que lo define como tipo. En nuestro ejemplo de árboles, el tipo de árbol, su color y textura son intrínsecos. Esta información se guarda en el **Flyweight**. Es **inmutable**, no cambia.
- **Estado Extrínseco (Extrinsic State):** Es la parte de la información que es **única** para cada objeto individual. Es el "contexto" en el que existe el objeto. En los árboles, la posición (x, y) es extrínseca. Esta información **no** se guarda en el Flyweight, sino en el **Contexto** (en nuestro ejemplo, el objeto `Tree`). Se pasa al Flyweight cuando se necesita, por ejemplo, al dibujar.

**Piensa en una galleta con forma de estrella:**

- **Intrínseco:** La forma de estrella, la receta básica de la galleta (ingredientes comunes). Todas las galletas de estrella comparten esto. Sería el Flyweight.
- **Extrínseco:** El color del glaseado, las chispas de colores, si está en un plato o en una caja. Cada galleta de estrella puede tener esto diferente. Sería el Contexto.

#### 2. **Ejemplo:**

Volviendo al ejemplo de los árboles:

- **Estado Intrínseco (en `TreeType`):**

  - `name` (ej: "Pino", "Roble")
  - `color` (ej: "Verde", "Marrón")
  - `texture` (ej: "TexturaPino", "TexturaRoble")

- **Estado Extrínseco (en `Tree`):**
  - `x` (posición horizontal)
  - `y` (posición vertical)

Cuando llamamos a `tree.draw(g)`, el objeto `Tree` (Contexto) le pasa su estado extrínseco (`x`, `y`) al método `draw` del `TreeType` (Flyweight), que ya tiene el estado intrínseco (nombre, color, textura) para poder dibujar el árbol correctamente en la posición indicada.

#### 3. **Notas o advertencias:**

- **La clave del ahorro:** Flyweight funciona porque el estado intrínseco suele ser mucho más "pesado" en términos de memoria (por ejemplo, imágenes grandes, modelos 3D) que el estado extrínseco (que suelen ser datos simples como números o coordenadas).
- **Diseño cuidadoso:** Identificar correctamente el estado intrínseco y extrínseco requiere un buen análisis del problema. Si te equivocas y pones estado extrínseco en el Flyweight, ¡perderás el beneficio del patrón!
- **Inmutabilidad reforzada:** Asegúrate de que el estado intrínseco sea realmente inmutable. Si necesitas cambiar algo del estado "compartido", probablemente necesites crear un nuevo Flyweight en lugar de modificar uno existente.

---

## C - Flyweight Factory: El gestor de Flyweights

#### 1. **Definicion:**

El **Flyweight Factory** es como un "almacén" o "biblioteca" de objetos Flyweight. Su trabajo es:

1.  **Crear Flyweights:** Cuando se necesita un nuevo Flyweight (por ejemplo, un nuevo `TreeType` con ciertas características), la Factory lo crea y lo guarda en su "almacén".
2.  **Reutilizar Flyweights:** Antes de crear un nuevo Flyweight, la Factory **comprueba si ya existe** uno con las mismas características en su "almacén". Si lo encuentra, **lo devuelve** en lugar de crear uno nuevo.

Esto asegura que solo haya **una instancia** de cada Flyweight con un estado intrínseco dado, maximizando el ahorro de memoria.

#### 2. **Ejemplo:**

En nuestro ejemplo de `TreeFactory`:

- Usamos un `HashMap` llamado `treeTypes` como nuestro "almacén" de `TreeType`s. La clave del `HashMap` es una combinación del estado intrínseco (`name + "-" + color + "-" + texture`) para poder buscar rápidamente Flyweights existentes.
- El método `getTreeType(name, color, texture)` es la Factory en acción:
  1.  **Busca:** Crea una clave basada en el estado intrínseco y busca en `treeTypes` si ya existe un `TreeType` con esa clave.
  2.  **Reutiliza o Crea:**
      - Si **encuentra** un `TreeType` (no es `null`), significa que ya existe uno con esas características. Lo **reutiliza** y lo devuelve.
      - Si **no encuentra** un `TreeType` (`null`), crea uno **nuevo**, lo guarda en `treeTypes` para futuras reutilizaciones, y luego lo devuelve.

#### 3. **Notas o advertencias:**

- **Clave de búsqueda eficiente:** La Factory necesita una forma rápida de buscar Flyweights existentes. Usar un `HashMap` con una clave bien diseñada (como en el ejemplo) es una buena opción para búsquedas rápidas por estado intrínseco.
- **Dónde colocar la Factory:** Puedes hacer la Factory como una clase separada (`TreeFactory`), o como un método estático dentro de la clase Flyweight (`TreeType`). La mejor opción depende de la complejidad de tu sistema.
- **Opcional pero recomendada:** La Factory no es estrictamente _obligatoria_ para el patrón Flyweight, pero es **muy recomendable** para gestionar y reutilizar los Flyweights de forma eficiente y centralizada. Sin una Factory, el cliente tendría que encargarse de la creación y reutilización de Flyweights, lo cual sería más complicado y propenso a errores.

---

## D - Estructura del patrón Flyweight

#### 1. **Definicion:**

Aquí te presento un resumen visual de cómo se conectan las piezas del patrón Flyweight:

![Estructura del patrón Flyweight](https://refactoring.guru/images/patterns/diagrams/flyweight/structure.png)
![Estructura del patrón Flyweight indexado](https://refactoring.guru/images/patterns/diagrams/flyweight/structure-indexed.png)

**Componentes principales:**

1.  **Flyweight:**

    - Es la clase que guarda el **estado intrínseco** (la parte compartida).
    - Debe ser **inmutable**.
    - Define métodos que pueden actuar sobre el estado intrínseco, pero también **reciben el estado extrínseco** como parámetros para poder operar en un contexto específico. En nuestro ejemplo, `TreeType` es el Flyweight.

2.  **Concrete Flyweight:**

    - Es una implementación concreta de la interfaz Flyweight (si la hay). En ejemplos sencillos, el "Flyweight" y "Concrete Flyweight" a menudo se refieren a la misma clase, como `TreeType`. Si tuvieras diferentes _tipos_ de Flyweights (ej: diferentes tipos de objetos compartidos), tendrías Concrete Flyweights específicos para cada tipo.

3.  **Flyweight Factory:**

    - Crea y gestiona los objetos Flyweight.
    - Asegura la reutilización de Flyweights existentes.
    - El cliente usa la Factory para obtener Flyweights, en lugar de crearlos directamente. En nuestro ejemplo, `TreeFactory`.

4.  **Context:**

    - Representa el **estado extrínseco** (la parte única) de un objeto.
    - Contiene una **referencia** a un objeto Flyweight.
    - Pasa el estado extrínseco a los métodos del Flyweight cuando es necesario. En nuestro ejemplo, `Tree` es el Contexto.

5.  **Client:**
    - Es la parte del código que usa el patrón Flyweight.
    - Crea y gestiona los objetos Context.
    - Obtiene Flyweights de la Flyweight Factory.
    - Suministra el estado extrínseco a los Flyweights a través de los Contextos. En nuestro ejemplo, la clase `Forest` y el `main` en `Forest` son el Cliente.

#### 2. **Ejemplo:**

En nuestro ejemplo de árboles, mapeando a la estructura:

- **Flyweight:** `TreeType`
- **Concrete Flyweight:** `TreeType` (en este caso, es la misma)
- **Flyweight Factory:** `TreeFactory`
- **Context:** `Tree`
- **Client:** `Forest` y el `main`

#### 3. **Notas o advertencias:**

- **Flexibilidad:** La estructura puede variar ligeramente dependiendo del problema. A veces no necesitas una interfaz Flyweight explícita, o el Contexto puede ser implícito en otra clase.
- **Optimización, no funcionalidad:** Recuerda que Flyweight es un patrón de **optimización** para ahorrar memoria. No cambia la funcionalidad principal de tu programa, solo la forma en que gestiona los objetos en memoria.
- **Complejidad añadida:** Implementar Flyweight añade cierta complejidad al código. Asegúrate de que el beneficio en ahorro de memoria justifica esta complejidad.

---

## E - Aplicabilidad: ¿Cuándo usar Flyweight?

#### 1. **Definicion:**

Usa el patrón Flyweight **solo cuando realmente lo necesites** para resolver un problema de memoria. No lo uses "por si acaso", ya que puede complicar tu código sin necesidad.

**Situaciones ideales para Flyweight:**

- **Gran cantidad de objetos similares:** Tu programa necesita crear y gestionar **muchísimos** objetos que son muy parecidos entre sí. Piensa en miles, millones, o incluso más.
- **Problemas de memoria RAM:** Esta gran cantidad de objetos está **consumiendo demasiada memoria RAM**, causando problemas de rendimiento o incluso crashes por falta de memoria.
- **Estado repetitivo:** Estos objetos similares comparten una parte importante de su estado (información). Esta parte **repetida** es la que podemos extraer como estado intrínseco y compartir con Flyweight.

**Ejemplos típicos:**

- **Juegos:** Partículas (balas, explosiones), árboles, personajes no jugadores (NPCs) idénticos, elementos del escenario repetitivos.
- **Procesamiento de texto:** Caracteres en un documento (muchos caracteres 'a', 'e', 's', etc. que comparten fuente, estilo, etc.).
- **Gráficos:** Formas geométricas repetitivas, iconos, glifos de fuentes.

#### 2. **Ejemplo:**

- **Sí usar Flyweight:** Un juego de estrategia en tiempo real con miles de unidades militares idénticas en pantalla. Cada unidad tiene la misma apariencia y comportamiento básico, pero diferente posición y salud. Flyweight podría compartir la apariencia y el comportamiento, y guardar solo la posición y salud de forma individual.
- **No usar Flyweight:** Una aplicación de gestión de contactos con solo unos cientos de contactos. Aunque los contactos comparten algunos campos (nombre, teléfono), la cantidad no es lo suficientemente grande como para justificar la complejidad de Flyweight. Además, el ahorro de memoria sería mínimo.

#### 3. **Notas o advertencias:**

- **Medir antes de optimizar:** Antes de implementar Flyweight, **mide** el uso de memoria de tu programa. Asegúrate de que el problema de memoria es real y significativo. A veces, otras optimizaciones más sencillas pueden ser suficientes.
- **Compensación CPU vs RAM:** Flyweight ahorra RAM, pero a veces puede **aumentar el uso de CPU**. Esto ocurre si necesitas recalcular el estado extrínseco cada vez que usas un Flyweight. Evalúa si esta compensación es aceptable en tu caso.
- **Complejidad vs Beneficio:** Siempre sopesa la **complejidad** que añade Flyweight al código frente al **beneficio** real en ahorro de memoria. Si el beneficio es pequeño y la complejidad grande, ¡quizás no valga la pena!

---

## F - Implementación paso a paso de Flyweight

#### 1. **Definicion:**

Aquí tienes una guía paso a paso para aplicar el patrón Flyweight:

1.  **Identifica candidatos:** Encuentra las clases que crean muchos objetos similares y que están causando problemas de memoria.
2.  **Divide el estado:** Para cada clase candidata, separa sus campos en dos categorías:
    - **Estado Intrínseco:** Datos **compartidos** e **inmutables**. Serán parte del Flyweight.
    - **Estado Extrínseco:** Datos **únicos** y **variables**. Serán parte del Contexto.
3.  **Crea la clase Flyweight:**
    - Crea una nueva clase (o modifica la existente) para representar el Flyweight.
    - Mueve el **estado intrínseco** a esta clase como campos.
    - Haz que los campos del estado intrínseco sean **inmutables** (inicializados en el constructor, sin setters).
    - Modifica los métodos de la clase Flyweight para que **reciban el estado extrínseco como parámetros** en lugar de usar campos de instancia para el estado extrínseco.
4.  **Crea la Flyweight Factory:**
    - Crea una clase Factory para gestionar la creación y reutilización de Flyweights.
    - Implementa un método en la Factory que:
      - Reciba el **estado intrínseco** deseado como parámetros.
      - **Busque** en su "almacén" (ej: `HashMap`) un Flyweight existente con ese estado intrínseco.
      - Si lo **encuentra**, lo **devuelva**.
      - Si **no lo encuentra**, cree un **nuevo** Flyweight, lo **guarde** en su "almacén", y lo **devuelva**.
5.  **Crea la clase Contexto (si es necesario):**
    - Si el estado extrínseco es complejo o necesitas agruparlo, crea una clase Contexto.
    - Mueve el **estado extrínseco** a esta clase como campos.
    - Añade un campo en el Contexto para **referenciar** un objeto Flyweight.
6.  **Modifica el Cliente:**
    - En el código cliente, en lugar de crear directamente objetos de la clase original, usa la **Flyweight Factory** para obtener los Flyweights.
    - Crea objetos Contexto (si los usas) y asóciales a los Flyweights obtenidos de la Factory.
    - Pasa el **estado extrínseco** a los métodos del Flyweight a través del Contexto cuando sea necesario.

#### 2. **Ejemplo:**

Ya hemos visto el ejemplo de los árboles que sigue estos pasos. Repasa el código de `TreeType`, `TreeFactory`, `Tree` y `Forest` para ver cómo se aplican estos pasos en la práctica.

#### 3. **Notas o advertencias:**

- **Iterativo:** La implementación de Flyweight puede ser un proceso iterativo. Puede que necesites refinar la división del estado intrínseco y extrínseco a medida que avanzas.
- **Pruebas:** Después de implementar Flyweight, **prueba** tu programa a fondo para asegurarte de que funciona correctamente y de que realmente estás ahorrando memoria. Compara el uso de memoria antes y después de aplicar el patrón.
- **Documentación:** Documenta bien tu código Flyweight. Explica claramente qué es el estado intrínseco, qué es el estado extrínseco, y cómo funciona la Factory. Esto ayudará a otros desarrolladores (¡y a ti mismo en el futuro!) a entender y mantener el código.

---

## G - Pros y Contras del patrón Flyweight

#### 1. **Definicion:**

Como todo patrón de diseño, Flyweight tiene sus ventajas y desventajas. Es importante conocerlas para decidir si es la solución adecuada para tu problema.

**Pros (Ventajas):**

- **Ahorro de memoria RAM:** ¡El beneficio principal! Reduce drásticamente el uso de memoria al compartir el estado intrínseco entre muchos objetos. Esto puede ser crucial para aplicaciones con gran cantidad de objetos similares.
- **Mejora del rendimiento (en algunos casos):** Al usar menos memoria, puede mejorar el rendimiento general de la aplicación, especialmente si la falta de memoria estaba causando problemas de swapping o garbage collection excesivo.

**Cons (Desventajas):**

- **Mayor complejidad del código:** Flyweight añade complejidad al diseño y al código. Introduce nuevas clases (Flyweight, Factory, Contexto) y requiere una separación cuidadosa del estado. El código puede volverse más difícil de entender y mantener si no se implementa correctamente.
- **Posible aumento del uso de CPU:** Si el estado extrínseco necesita ser recalculado o pasado como parámetro con frecuencia, puede aumentar el uso de CPU en comparación con tener objetos completamente independientes.
- **Dificultad para encontrar el estado intrínseco/extrínseco:** No siempre es fácil identificar claramente qué parte del estado es intrínseco y qué parte es extrínseco. Un diseño incorrecto puede anular los beneficios de Flyweight o incluso empeorar el rendimiento.
- **Posible costo de la Factory:** La Flyweight Factory añade cierta sobrecarga, aunque suele ser mínima. La búsqueda en el "almacén" de Flyweights (ej: `HashMap`) tiene un costo, aunque suele ser muy rápido.

#### 2. **Ejemplo:**

- **Pro:** En un juego con miles de árboles, Flyweight puede reducir significativamente la memoria usada para representar los árboles, permitiendo que el juego funcione mejor en dispositivos con menos RAM.
- **Contra:** Implementar Flyweight para los árboles añade complejidad al código del juego. Los nuevos programadores en el equipo podrían tardar más en entender cómo funciona el sistema de árboles basado en Flyweight. Si el juego no tiene realmente problemas de memoria con los árboles, esta complejidad podría ser innecesaria.

#### 3. **Notas o advertencias:**

- **Evalúa cuidadosamente:** Antes de usar Flyweight, evalúa cuidadosamente si los **pros** superan a los **contras** en tu situación específica. Considera el tamaño del ahorro de memoria esperado, el aumento de complejidad del código, y el posible impacto en el rendimiento de la CPU.
- **Alternativas:** A veces, existen otras técnicas de optimización más sencillas que pueden ser suficientes para resolver problemas de memoria, como la optimización de algoritmos, la reducción del tamaño de las texturas, o el uso de estructuras de datos más eficientes. Explora estas alternativas antes de recurrir a Flyweight.
- **Documentación clara:** Si decides usar Flyweight, asegúrate de documentar muy bien el diseño y la implementación para que sea comprensible para ti y para otros desarrolladores.

---

## H - Relación con otros patrones de diseño

#### 1. **Definicion:**

Flyweight a menudo se usa en combinación con otros patrones de diseño para resolver problemas más complejos. Aquí te presento algunas relaciones importantes:

- **Composite:** Puedes usar Flyweight para implementar los nodos hoja (leaf nodes) de un árbol Composite. Si tienes muchos nodos hoja similares, puedes usar Flyweight para compartir su estado intrínseco y ahorrar memoria en la estructura del árbol Composite. Imagina un sistema de archivos representado con Composite. Muchos archivos podrían ser del mismo tipo (ej: archivos de texto). Podrías usar Flyweight para compartir la información común de los archivos de texto (ej: icono, tipo de archivo por defecto).
- **Facade:** Flyweight se enfoca en crear muchos objetos pequeños y eficientes, mientras que Facade se enfoca en crear un objeto simple que representa un subsistema complejo. Son patrones opuestos en cuanto a su objetivo. Podrías usar Facade para simplificar la interfaz de un subsistema que internamente usa Flyweight para optimizar la gestión de objetos.
- **Singleton:** Flyweight podría parecerse a Singleton si reduces todo el estado compartido a un único objeto Flyweight. Sin embargo, hay diferencias clave:
  1.  **Instancias:** Singleton asegura que haya **una sola instancia** de una clase. Flyweight puede tener **múltiples instancias** de Flyweight, cada una con un estado intrínseco diferente (aunque compartido por muchos Contextos). En nuestro ejemplo, `TreeFactory` puede crear un `TreeType` para "Pino" y otro para "Roble".
  2.  **Mutabilidad:** Los objetos Singleton pueden ser **mutables** (su estado puede cambiar después de la creación). Los objetos Flyweight **deben ser inmutables**.

#### 2. **Ejemplo:**

- **Composite + Flyweight:** En un editor de texto complejo que usa Composite para representar la estructura del documento (documento -> párrafos -> líneas -> caracteres), podrías usar Flyweight para los objetos "carácter". Muchos caracteres pueden ser la misma letra, con la misma fuente y estilo. Flyweight podría compartir esta información, y cada objeto "carácter" solo guardaría su posición y el Flyweight compartido.
- **Facade + Flyweight:** Podrías crear un Facade para un sistema de renderizado gráfico complejo. Internamente, este sistema podría usar Flyweight para gestionar eficientemente miles de objetos gráficos repetitivos (ej: sprites, partículas). El Facade simplificaría la interfaz para el cliente, ocultando la complejidad interna del uso de Flyweight.

#### 3. **Notas o advertencias:**

- **Combinación poderosa:** La combinación de patrones puede ser muy poderosa para resolver problemas complejos de diseño. Entender cómo se relacionan los patrones te permite usarlos de forma más efectiva.
- **No son mutuamente excluyentes:** Puedes usar Flyweight y otros patrones en el mismo sistema para resolver diferentes problemas. Cada patrón tiene su propósito específico.
- **Contexto es clave:** La mejor combinación de patrones depende del contexto específico de tu problema. No hay una "receta mágica" que funcione para todos los casos. Analiza tu problema y elige los patrones que mejor se adapten a él.
