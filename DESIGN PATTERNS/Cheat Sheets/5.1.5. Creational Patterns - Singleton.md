## A - Singleton

#### 1. **Definición:**

Singleton es un patrón de diseño creacional que te asegura que una clase tenga **una única instancia** y proporciona un punto de acceso global a ella. Imagina que solo quieres que exista un objeto de cierto tipo en toda tu aplicación, como un "jefe único" que coordina todo. Singleton te ayuda a lograr esto.

#### 2. **Ejemplo:**

Imagina que tienes una clase `Configuracion` que lee la configuración de tu programa desde un archivo. Solo necesitas una instancia de `Configuracion` para que todos los componentes de tu programa usen la misma configuración.

```java
public class Configuracion {
    private static Configuracion instancia;
    private String nombreApp;

    private Configuracion() {
        // Simula la lectura de configuración desde un archivo
        this.nombreApp = "Mi Aplicacion";
        System.out.println("Configuración inicializada.");
    }

    public static Configuracion obtenerInstancia() {
        if (instancia == null) {
            instancia = new Configuracion();
        }
        return instancia;
    }

    public String obtenerNombreApp() {
        return nombreApp;
    }
}

public class Main {
    public static void main(String[] args) {
        Configuracion config1 = Configuracion.obtenerInstancia();
        Configuracion config2 = Configuracion.obtenerInstancia();

        System.out.println("Instancia 1: " + config1.obtenerNombreApp());
        System.out.println("Instancia 2: " + config2.obtenerNombreApp());
        System.out.println("¿Son la misma instancia? " + (config1 == config2));
    }
}
```

**Explicación del ejemplo:**

En este ejemplo, `Configuracion` es un Singleton.

- El constructor es `private`, así que no puedes crear instancias directamente con `new Configuracion()`.
- `obtenerInstancia()` es un método estático que se encarga de crear la instancia **solo la primera vez** que se llama. Las siguientes veces, devuelve la misma instancia que ya existe.
- En `Main`, `config1` y `config2` apuntan a la **misma instancia** de `Configuracion`, lo que se demuestra al comparar con `==` y ver que imprimen el mismo nombre de aplicación.

#### 3. **Notas o advertencias:**

- Singleton es útil cuando necesitas controlar el acceso a un recurso compartido, como una conexión a base de datos o un archivo de configuración, asegurando que solo haya una instancia gestionando ese recurso.
- Asegúrate de que la inicialización dentro del constructor privado no sea demasiado costosa, ya que solo se ejecutará la primera vez. Si es costosa, considera la inicialización perezosa (lazy initialization) dentro del método `obtenerInstancia()`.

---

## B - Problemas que resuelve Singleton

#### 1. **Definición:**

El patrón Singleton ataca dos problemas principales a la vez:

- **Asegurar una única instancia de una clase:** A veces, solo quieres que exista un objeto de una clase en toda tu aplicación. Piensa en un gestor de ventanas, un sistema de archivos o, como en el ejemplo anterior, una configuración. Singleton te garantiza que no se creen más instancias accidentalmente.
- **Proporcionar un punto de acceso global a esa instancia:** Necesitas poder acceder a esa instancia única desde cualquier parte de tu código. Singleton te da un "camino" global para llegar a ese objeto, como si fuera una variable global pero de forma más controlada y segura.

#### 2. **Ejemplo:**

Imagina un sistema de registro (logging) donde quieres que todos los mensajes de registro vayan al mismo objeto para escribirse en un archivo o consola.

```java
public class Logger {
    private static Logger instancia;

    private Logger() {
        System.out.println("Logger inicializado.");
    }

    public static Logger obtenerInstancia() {
        if (instancia == null) {
            instancia = new Logger();
        }
        return instancia;
    }

    public void log(String mensaje) {
        System.out.println("Log: " + mensaje);
    }
}

public class ServicioA {
    public void hacerAlgo() {
        Logger.obtenerInstancia().log("Servicio A haciendo algo.");
    }
}

public class ServicioB {
    public void hacerOtraCosa() {
        Logger.obtenerInstancia().log("Servicio B haciendo otra cosa.");
    }
}

public class Main {
    public static void main(String[] args) {
        ServicioA servicioA = new ServicioA();
        ServicioB servicioB = new ServicioB();

        servicioA.hacerAlgo();
        servicioB.hacerOtraCosa();
    }
}
```

**Explicación del ejemplo:**

- `Logger` es un Singleton. No importa si `ServicioA` o `ServicioB` intentan obtener el `Logger`, siempre obtendrán la **misma instancia**.
- Ambos servicios usan `Logger.obtenerInstancia()` para acceder al mismo objeto logger y registrar sus mensajes.
- Esto asegura que todos los logs se manejen de manera centralizada a través de una única instancia de `Logger`.

#### 3. **Notas o advertencias:**

- Antes de usar Singleton, pregúntate si realmente necesitas un único punto de acceso global. A veces, otras soluciones como la inyección de dependencias pueden ser más flexibles y fáciles de probar.
- El uso excesivo de Singleton puede llevar a un código acoplado, donde muchas partes del programa dependen de esta instancia global, dificultando las pruebas y el mantenimiento.

---

## C - Solución Singleton: Constructor Privado y Método Estático

#### 1. **Definición:**

La "magia" del Singleton se logra con dos ingredientes clave:

- **Constructor Privado:** Hacer el constructor de la clase `private` impide que otras clases puedan crear instancias de Singleton directamente usando `new`. Esto fuerza a usar el método estático para obtener la instancia.
- **Método de Creación Estático:** Se crea un método `static` (normalmente llamado `obtenerInstancia()` o `getInstance()`) que:
  - Crea la instancia de Singleton **la primera vez** que se llama (si aún no existe).
  - Guarda esta instancia en un campo `static` dentro de la propia clase Singleton.
  - Devuelve la instancia guardada en todas las llamadas posteriores.

#### 2. **Ejemplo:**

Volvamos al ejemplo de `Configuracion` para ver estos ingredientes en acción:

```java
public class Configuracion {
    private static Configuracion instancia; // Campo estático para guardar la instancia

    private Configuracion() { // Constructor privado
        System.out.println("Configuración inicializada.");
    }

    public static Configuracion obtenerInstancia() { // Método estático de creación
        if (instancia == null) { // Inicialización perezosa: solo se crea la primera vez
            instancia = new Configuracion(); // Llama al constructor privado
        }
        return instancia; // Devuelve la instancia guardada
    }
    // ... (resto de la clase)
}
```

**Explicación del ejemplo:**

- `private static Configuracion instancia;`: Aquí declaramos un campo estático `instancia` que guardará la única instancia de `Configuracion`. Es `static` para que pertenezca a la clase y no a las instancias (¡que no queremos crear directamente!). Es `private` para que solo la clase `Configuracion` pueda acceder a él.
- `private Configuracion() { ... }`: El constructor es `private`. Esto es crucial. Nadie fuera de la clase `Configuracion` puede hacer `new Configuracion()`.
- `public static Configuracion obtenerInstancia() { ... }`: Este es el punto de acceso público al Singleton.
  - `if (instancia == null)`: Comprueba si `instancia` es `null` (es decir, si aún no se ha creado la instancia).
  - `instancia = new Configuracion();`: Si es `null`, **dentro de la clase Singleton**, podemos llamar al constructor privado para crear la instancia **por primera vez**.
  - `return instancia;`: Devuelve la instancia, ya sea la recién creada o la que ya existía.

#### 3. **Notas o advertencias:**

- La inicialización perezosa (`if (instancia == null)`) dentro de `obtenerInstancia()` es común pero no siempre necesaria. Si la creación de la instancia no es costosa y siempre la vas a necesitar, puedes crearla de forma eager (inmediata) directamente al declarar el campo estático: `private static Configuracion instancia = new Configuracion();`.
- En entornos multihilo, la inicialización perezosa puede tener problemas si varios hilos intentan crear la instancia al mismo tiempo. En esos casos, se necesita sincronización (veremos esto más adelante).

---

## D - Analogía del Mundo Real: El Gobierno

#### 1. **Definición:**

El texto usa una analogía muy clara para entender el Singleton: **el gobierno de un país**.

- Solo puede haber **un gobierno oficial** por país en un momento dado. No tiene sentido tener "dos gobiernos" oficiales compitiendo.
- "El Gobierno de X" es un **punto de acceso global** para identificar al grupo de personas que están al mando. No importa quiénes formen parte del gobierno en un momento dado, el concepto de "El Gobierno" es único y reconocible.

#### 2. **Ejemplo:**

Piensa en cómo interactúas con el gobierno:

- Necesitas un permiso de conducir: Vas a la **única** entidad gubernamental encargada de eso.
- Tienes que pagar impuestos: Los pagas al **único** sistema tributario del gobierno.
- Necesitas información oficial: La buscas en las fuentes **oficiales** del gobierno.

En todos estos casos, estás interactuando con una **única** instancia del "gobierno", aunque internamente esté compuesto por muchas personas y departamentos.

#### 3. **Notas o advertencias:**

- Esta analogía ayuda a entender la idea de **unicidad** y **punto de acceso global** del Singleton.
- No te tomes la analogía demasiado literal. El Singleton es un patrón de software, no una estructura política. Simplemente ilustra los principios clave del patrón.

---

## E - Estructura del Patrón Singleton

#### 1. **Definición:**

La estructura del Singleton es muy sencilla y se centra en dos partes principales:

- **Clase Singleton:** Es la clase que implementa el patrón.
  - Tiene un **constructor privado**.
  - Tiene un **método estático público `obtenerInstancia()`** que devuelve la única instancia.
  - Puede tener otros métodos y atributos normales para su funcionalidad.
- **Cliente:** Cualquier otra parte del código que necesite usar el Singleton.
  - **No puede crear instancias directamente** del Singleton.
  - **Debe usar el método `obtenerInstancia()`** para obtener la única instancia.

#### 2. **Diagrama:**

![Estructura del patrón Singleton](https://refactoring.guru/images/patterns/diagrams/singleton/structure-en.png)
![Estructura indexada del patrón Singleton](https://refactoring.guru/images/patterns/diagrams/singleton/structure-en-indexed.png)

**Explicación del diagrama:**

1.  **Singleton:** La clase `Singleton` en sí misma.
2.  **`getInstance()`:** El método estático público que los clientes usan para obtener la instancia.
3.  **Constructor Privado:** Representa el constructor privado que impide la creación directa de instancias.

#### 3. **Notas o advertencias:**

- La estructura es muy directa. Lo importante es recordar el constructor privado y el método estático `obtenerInstancia()`.
- Esta estructura asegura que el control de la creación de instancias recae completamente en la clase Singleton.

---

## F - Seudocódigo del Singleton (Ejemplo Base de Datos)

#### 1. **Definición:**

El texto proporciona un seudocódigo que ilustra el Singleton con un ejemplo de conexión a una base de datos. La idea es que solo quieras una conexión a la base de datos compartida por toda tu aplicación para optimizar recursos y evitar problemas de concurrencia.

#### 2. **Seudocódigo (adaptado a Java):**

```java
class Database {
    private static Database instancia; // Instancia única

    private Database() {
        // Código de inicialización, ej., conexión a la base de datos
        System.out.println("Conexión a la base de datos establecida.");
    }

    public static Database obtenerInstancia() {
        if (instancia == null) {
            // Sincronización para entornos multihilo (más adelante)
            synchronized (Database.class) {
                if (instancia == null) { // Doble verificación por si otro hilo ya creó la instancia
                    instancia = new Database();
                }
            }
        }
        return instancia;
    }

    public void query(String sql) {
        // Lógica para ejecutar consultas SQL
        System.out.println("Ejecutando consulta: " + sql);
    }
}

class Aplicacion {
    public static void main(String[] args) {
        Database db1 = Database.obtenerInstancia();
        db1.query("SELECT * FROM tabla1");

        Database db2 = Database.obtenerInstancia();
        db2.query("SELECT * FROM tabla2");

        System.out.println("¿db1 y db2 son la misma instancia? " + (db1 == db2)); // Debería ser true
    }
}
```

**Explicación del seudocódigo:**

- `Database` simula una clase que gestiona la conexión a una base de datos.
- `obtenerInstancia()` asegura que solo se cree una conexión a la base de datos.
- La sección `synchronized` dentro de `obtenerInstancia()` es importante para **entornos multihilo**. Asegura que solo un hilo a la vez pueda crear la instancia, evitando que se creen múltiples instancias accidentalmente en un entorno con varios hilos. La doble verificación (`if (instancia == null)` dentro del bloque `synchronized`) es una optimización para reducir la sobrecarga de la sincronización una vez que la instancia ya ha sido creada.
- `query(String sql)` representa la funcionalidad para interactuar con la base de datos.
- En `Aplicacion`, `db1` y `db2` son la misma instancia de `Database`.

#### 3. **Notas o advertencias:**

- El ejemplo de la base de datos es muy común para ilustrar el Singleton.
- La sincronización en `obtenerInstancia()` es crucial en aplicaciones multihilo para evitar problemas de creación múltiple de instancias. Si tu aplicación es de un solo hilo, puedes omitir la sincronización (pero es buena práctica incluirla por si acaso).

---

## G - Aplicabilidad del Singleton

#### 1. **Definición:**

¿Cuándo deberías usar el patrón Singleton? Es útil en estas situaciones:

- **Instancia Única Requerida:** Cuando necesitas garantizar que solo exista una instancia de una clase en todo el sistema. Ejemplos:
  - Gestores de recursos (conexión a base de datos, pool de hilos, etc.).
  - Configuraciones globales.
  - Loggers.
  - Ciertas clases "controladoras" o "managers" que coordinan acciones en el sistema.
- **Control Estricto de Variables Globales:** Si te encuentras usando muchas variables globales, Singleton puede ser una forma más controlada y orientada a objetos de gestionar un punto de acceso global a un objeto. En lugar de variables globales sueltas, encapsulas la instancia única dentro de una clase Singleton.

#### 2. **Ejemplos de Uso:**

- **Gestión de la Configuración de la Aplicación:** Como hemos visto en ejemplos anteriores.
- **Pool de Conexiones a Base de Datos:** Un Singleton puede gestionar un pool de conexiones, asegurando que se reutilicen las conexiones en lugar de crear nuevas constantemente.
- **Sistema de Logging Centralizado:** Como también vimos, para que todos los componentes de la aplicación escriban logs en el mismo lugar.
- **Gestor de Impresora:** En un sistema operativo, podría haber un Singleton que gestione el acceso a la impresora, evitando conflictos si varias aplicaciones intentan imprimir al mismo tiempo.

#### 3. **Notas o advertencias:**

- **No abuses del Singleton.** Úsalo solo cuando realmente necesites una instancia única y un punto de acceso global. En muchos casos, otras soluciones de diseño pueden ser más adecuadas.
- **Piensa en las alternativas.** Antes de usar Singleton, considera si podrías lograr lo mismo con inyección de dependencias, objetos estáticos (con más cuidado), o simplemente creando una instancia y pasándola donde se necesite.

---

## H - Cómo Implementar Singleton (Pasos)

#### 1. **Definición:**

Implementar el patrón Singleton es un proceso sencillo que consta de estos pasos:

1.  **Campo Estático Privado para la Instancia:** Declara un campo `static private` del mismo tipo que la clase Singleton. Este campo guardará la única instancia. Ejemplo: `private static MiSingleton instancia;`
2.  **Método de Creación Estático Público:** Crea un método `static public` que será el punto de acceso para obtener la instancia. Normalmente se llama `obtenerInstancia()` o `getInstance()`. Ejemplo: `public static MiSingleton obtenerInstancia() { ... }`
3.  **Inicialización Perezosa (Lazy Initialization) en el Método Estático:** Dentro del método estático, implementa la lógica para crear la instancia **solo si aún no existe**. Usa una comprobación `if (instancia == null)` y, si es necesario, sincronización para entornos multihilo. Ejemplo:

    ```java
    public static MiSingleton obtenerInstancia() {
        if (instancia == null) {
            synchronized (MiSingleton.class) { // Sincronización (si es necesario)
                if (instancia == null) {
                    instancia = new MiSingleton(); // Crear la instancia
                }
            }
        }
        return instancia; // Devolver la instancia
    }
    ```

4.  **Constructor Privado:** Haz el constructor de la clase `private`. Esto impide la creación de instancias desde fuera de la clase. Ejemplo: `private MiSingleton() { ... }`
5.  **Reemplazar Llamadas al Constructor en el Código Cliente:** En todo tu código, busca cualquier lugar donde estés creando instancias de la clase Singleton con `new MiSingleton()` y reemplázalas por llamadas al método estático `MiSingleton.obtenerInstancia()`.

#### 2. **Ejemplo (Resumen):**

```java
public class MiSingleton {
    private static MiSingleton instancia; // Paso 1: Campo estático privado

    private MiSingleton() { // Paso 4: Constructor privado
        System.out.println("MiSingleton inicializado.");
    }

    public static MiSingleton obtenerInstancia() { // Paso 2: Método estático público
        if (instancia == null) { // Paso 3: Inicialización perezosa
            synchronized (MiSingleton.class) {
                if (instancia == null) {
                    instancia = new MiSingleton();
                }
            }
        }
        return instancia;
    }

    public void hacerAlgo() {
        System.out.println("MiSingleton haciendo algo.");
    }
}

// Código Cliente:
public class Cliente {
    public static void main(String[] args) {
        MiSingleton singleton1 = MiSingleton.obtenerInstancia(); // Paso 5: Usar obtenerInstancia()
        MiSingleton singleton2 = MiSingleton.obtenerInstancia();

        singleton1.hacerAlgo();
        System.out.println("¿Son la misma instancia? " + (singleton1 == singleton2));
    }
}
```

#### 3. **Notas o advertencias:**

- Sigue estos pasos en orden para implementar correctamente el Singleton.
- Recuerda la sincronización en el paso 3 si tu aplicación es multihilo.
- Asegúrate de reemplazar **todas** las llamadas directas al constructor por `obtenerInstancia()` en tu código cliente.

---

## I - Pros y Contras del Singleton

#### 1. **Definición:**

Como todo patrón de diseño, Singleton tiene sus ventajas y desventajas.

**Pros (Ventajas):**

- **Instancia Única Garantizada:** Te asegura que una clase solo tendrá una instancia.
- **Punto de Acceso Global:** Proporciona un punto de acceso global a esa instancia única.
- **Inicialización Perezosa (Opcional):** La instancia se puede crear solo cuando se necesita por primera vez, lo que puede ser útil si la creación es costosa y no siempre se requiere.

**Cons (Desventajas):**

- **Violación del Principio de Responsabilidad Única:** El Singleton resuelve dos problemas a la vez (instancia única y acceso global), lo que puede considerarse una violación de este principio.
- **Puede Ocultar Mal Diseño:** El uso excesivo de Singletons puede indicar que las partes de tu programa están demasiado acopladas y saben demasiado unas de otras.
- **Dificultad en Entornos Multihilo (si no se implementa correctamente):** Requiere cuidado especial en entornos multihilo para evitar la creación de múltiples instancias.
- **Dificultad para Pruebas Unitarias:** Puede ser difícil de probar unitariamente porque:
  - Su constructor privado dificulta la creación de "mocks" o "simulaciones" para las pruebas.
  - Los métodos estáticos son más difíciles de "mockear" que los métodos de instancia.
  - Esto puede llevar a que se eviten las pruebas unitarias para el código que usa Singletons (¡lo cual es malo!).

#### 2. **Ejemplos de Problemas en Pruebas Unitarias:**

Imagina que quieres probar la clase `ServicioQueUsaLogger` que usa el `Logger` Singleton. En una prueba unitaria, quizás quieras reemplazar el `Logger` real por un "Logger falso" que no escriba en un archivo o consola, sino que simplemente guarde los mensajes en memoria para verificar que el `ServicioQueUsaLogger` está registrando correctamente. Con un Singleton, esto puede ser complicado porque no puedes "inyectar" un Logger falso fácilmente.

#### 3. **Notas o advertencias:**

- **Pondera los pros y los contras cuidadosamente** antes de decidir usar Singleton.
- **Considera alternativas** como la inyección de dependencias, especialmente si la capacidad de probar tu código es importante.
- Si decides usar Singleton, asegúrate de implementarlo correctamente, especialmente en entornos multihilo, y ten en cuenta las posibles dificultades en las pruebas unitarias.

---

## J - Relaciones con Otros Patrones

#### 1. **Definición:**

El patrón Singleton a veces se relaciona o se puede combinar con otros patrones de diseño. El texto menciona algunas relaciones:

- **Facade:** Una clase Facade a menudo se puede convertir en un Singleton. Un Facade proporciona una interfaz simplificada a un sistema complejo. A menudo, solo necesitas un objeto Facade para todo el sistema, por lo que hacerlo Singleton tiene sentido.
- **Flyweight:** Aunque Flyweight y Singleton parecen similares en el sentido de compartir objetos, son fundamentalmente diferentes:
  - **Singleton:** Solo una instancia de la clase.
  - **Flyweight:** Puede haber múltiples instancias, pero comparten "estado intrínseco" para ahorrar memoria. Los objetos Flyweight deben ser inmutables.
- **Abstract Factory, Builder, Prototype:** Estos patrones creacionales (que se usan para crear objetos) a veces se pueden implementar como Singletons. Por ejemplo, podrías tener una Abstract Factory Singleton que sea responsable de crear familias de objetos.

#### 2. **Ejemplos de Relaciones:**

- **Facade Singleton:** Imagina un Facade para un sistema de procesamiento de pagos. Podrías tener una clase `GestorDePagosFacade` que simplifica la interacción con el complejo sistema de pagos. Hacer `GestorDePagosFacade` un Singleton asegura que solo haya un punto de entrada a este sistema.
- **Abstract Factory Singleton:** Podrías tener una `FabricaDeGUI` (Abstract Factory) que crea diferentes tipos de componentes de interfaz gráfica (botones, ventanas, etc.) para diferentes sistemas operativos (Windows, macOS, Linux). Hacer `FabricaDeGUI` un Singleton podría asegurar que solo haya una fábrica principal para toda la aplicación.

#### 3. **Notas o advertencias:**

- Entender las relaciones entre patrones te ayuda a elegir el patrón más adecuado para cada situación y a combinarlos de forma efectiva.
- No fuerces las relaciones. Usa cada patrón cuando realmente aporte valor a tu diseño.
