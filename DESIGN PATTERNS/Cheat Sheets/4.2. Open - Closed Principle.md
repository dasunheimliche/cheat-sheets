# ¬øQu√© es el Principio de Abierto/Cerrado?

Es como construir con LEGO: puedes a√±adir nuevas piezas (abierto a extensi√≥n) pero no necesitas modificar las piezas existentes (cerrado a modificaci√≥n).

# Ejemplo Pr√°ctico: Sistema de Env√≠os

1.  **El Problema: Sistema R√≠gido**

    - Imagina una pizzer√≠a que solo tiene delivery por moto
    - Si queremos agregar delivery por bicicleta, ¬°tenemos que modificar todo el c√≥digo original!
    - Esto es arriesgado: podr√≠amos romper el c√≥digo que ya funciona

2.  **La Soluci√≥n: Sistema Flexible**

    - Creamos una "plantilla" base (interface) para cualquier tipo de env√≠o
    - Cada nuevo m√©todo de env√≠o sigue esta plantilla
    - ¬°Podemos agregar nuevos m√©todos sin tocar el c√≥digo existente!

```java
// ‚ùå MALA IMPLEMENTACI√ìN
public class PedidoMalo {
    private String tipoEnvio;

    public double calcularCostoEnvio() {
        if (tipoEnvio.equals("terrestre")) {
            // L√≥gica para env√≠o terrestre
        } else if (tipoEnvio.equals("aereo")) {
            // L√≥gica para env√≠o a√©reo
        }
        // ¬°Cada nuevo tipo de env√≠o requiere modificar este m√©todo!
        return 0;
    }
}

// ‚úÖ BUENA IMPLEMENTACI√ìN
// 1. Creamos una interfaz base
interface MetodoEnvio {
    double calcularCosto(Pedido pedido);
}

// 2. Cada tipo de env√≠o implementa la interfaz
class EnvioTerrestre implements MetodoEnvio {
    public double calcularCosto(Pedido pedido) {
        return pedido.getPeso() * 1.5;
    }
}

class EnvioAereo implements MetodoEnvio {
    public double calcularCosto(Pedido pedido) {
        return pedido.getPeso() * 3.0;
    }
}

// 3. La clase Pedido usa cualquier m√©todo de env√≠o
public class Pedido {
    private MetodoEnvio metodoEnvio;

    public void setMetodoEnvio(MetodoEnvio metodo) {
        this.metodoEnvio = metodo;
    }

    public double calcularCostoEnvio() {
        return metodoEnvio.calcularCosto(this);
    }
}
```

# La Clave üîë

Lo fundamental es entender que:

- Es mejor EXTENDER que MODIFICAR
- Dise√±a tus clases pensando en el futuro
- Usa interfaces y herencia para permitir extensiones
- El c√≥digo que ya funciona, ¬°no lo toques!

# Beneficios Pr√°cticos üéØ

1.  Menos bugs: no modificas c√≥digo que ya funciona
2.  M√°s f√°cil de testear: cada nueva funcionalidad est√° aislada
3.  C√≥digo m√°s mantenible: los cambios no afectan a otras partes
4.  M√°s r√°pido de desarrollar: solo te concentras en lo nuevo
