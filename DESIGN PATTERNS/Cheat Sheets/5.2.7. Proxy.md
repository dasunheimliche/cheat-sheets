# ¬øQu√© es el Patr√≥n Proxy? üé≠

El Proxy es como un "guardi√°n" o "representante" que se coloca delante de un objeto real para controlar el acceso a √©l. ¬°Piensa en √©l como un mayordomo que gestiona el acceso a su jefe!

# Ejemplo del Mundo Real: Netflix üé¨

Imagina c√≥mo funciona Netflix cuando reproducimos un video:

1.  **Situaci√≥n Inicial**
    - Quieres ver una pel√≠cula de 2GB
    - Necesitas empezar a verla inmediatamente
    - No puedes esperar a que se descarguen los 2GB completos
2.  **El Problema**
    - Descargar todo el video llevar√≠a mucho tiempo
    - Desperdiciar√≠amos recursos si el usuario solo ve 5 minutos
    - Necesitamos una soluci√≥n m√°s inteligente ü§î

# La Soluci√≥n: Patr√≥n Proxy üõ°Ô∏è

```java
// Interfaz com√∫n para Imagen real y Proxy
interface IImagen {
    void mostrar();
    void cargarMetadata();
    String getInformacion();
}

// Clase que representa una imagen de alta resoluci√≥n (objeto pesado)
class ImagenReal implements IImagen {
    private String id;
    private String url;
    private byte[] datos;  // Simulamos datos de imagen en alta resoluci√≥n
    private Map<String, String> metadata;

    public ImagenReal(String id, String url) {
        this.id = id;
        this.url = url;
        this.metadata = new HashMap<>();
        cargarImagenCompleta();
    }

    private void cargarImagenCompleta() {
        // Simulamos carga pesada de imagen de alta resoluci√≥n
        System.out.println("üñºÔ∏è Cargando imagen HD desde: " + url);
        try {
            Thread.sleep(2000); // Simulamos tiempo de carga
            this.datos = new byte[1024 * 1024]; // Simulamos 1MB de datos
            System.out.println("‚úÖ Imagen HD cargada completamente!");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void mostrar() {
        System.out.println("üì∏ Mostrando imagen HD: " + id);
        // Aqu√≠ se mostrar√≠a la imagen en alta resoluci√≥n
    }

    @Override
    public void cargarMetadata() {
        System.out.println("‚ÑπÔ∏è Cargando metadata de la imagen...");
        metadata.put("fecha", LocalDateTime.now().toString());
        metadata.put("tama√±o", datos.length + " bytes");
        metadata.put("tipo", "JPG");
    }

    @Override
    public String getInformacion() {
        return String.format("Imagen[id=%s, url=%s, tama√±o=%s]",
            id, url, metadata.getOrDefault("tama√±o", "desconocido"));
    }
}

// Proxy que gestiona la carga diferida y el cach√© de im√°genes
class ProxyImagen implements IImagen {
    private ImagenReal imagenReal;
    private String id;
    private String url;
    private String previewUrl;  // URL de la imagen en baja resoluci√≥n
    private Map<String, String> metadataCache;
    private boolean metadataCargada = false;

    public ProxyImagen(String id, String url) {
        this.id = id;
        this.url = url;
        this.previewUrl = generarUrlPreview(url);
        this.metadataCache = new HashMap<>();
    }

    private String generarUrlPreview(String originalUrl) {
        // En un caso real, esto generar√≠a la URL de la versi√≥n en miniatura
        return originalUrl.replace("/original/", "/preview/");
    }

    @Override
    public void mostrar() {
        // Primero mostramos la versi√≥n preview (carga r√°pida)
        System.out.println("üîç Mostrando preview de la imagen: " + id);
        System.out.println("   URL Preview: " + previewUrl);

        // Si el usuario se detiene a ver la imagen, cargamos la versi√≥n HD
        if (imagenReal == null) {
            System.out.println("‚è≥ Usuario se detuvo a ver la imagen, cargando versi√≥n HD...");
            imagenReal = new ImagenReal(id, url);
        }

        imagenReal.mostrar();
    }

    @Override
    public void cargarMetadata() {
        if (!metadataCargada) {
            System.out.println("üìù Cargando metadata b√°sica desde cach√©...");
            metadataCache.put("fecha", LocalDateTime.now().toString());
            metadataCache.put("previewUrl", previewUrl);
            metadataCargada = true;
        }

        // Solo cargamos la metadata completa si ya tenemos la imagen real
        if (imagenReal != null) {
            imagenReal.cargarMetadata();
        }
    }

    @Override
    public String getInformacion() {
        if (imagenReal != null) {
            return imagenReal.getInformacion();
        }
        return String.format("Preview[id=%s, previewUrl=%s]", id, previewUrl);
    }

    // M√©todos adicionales espec√≠ficos del Proxy
    public boolean estaImagenHDCargada() {
        return imagenReal != null;
    }

    public void precargarHD() {
        if (imagenReal == null) {
            System.out.println("‚ö° Precargando imagen HD...");
            imagenReal = new ImagenReal(id, url);
        }
    }
}

// Simulaci√≥n de un feed de red social
class FeedRedSocial {
    private List<ProxyImagen> imagenes;

    public FeedRedSocial() {
        this.imagenes = new ArrayList<>();
    }

    public void agregarImagen(String id, String url) {
        imagenes.add(new ProxyImagen(id, url));
    }

    public void mostrarFeed() {
        System.out.println("\nüì± === Feed de Red Social === üì±\n");
        for (ProxyImagen imagen : imagenes) {
            // Solo mostramos previews al hacer scroll
            System.out.println("üëÜ Usuario haciendo scroll...");
            imagen.mostrar();
            System.out.println();
        }
    }

    public void usuarioSeDetiene(int indice) {
        if (indice >= 0 && indice < imagenes.size()) {
            System.out.println("\nüëÄ Usuario se detuvo en la imagen " + indice);
            imagenes.get(indice).mostrar();  // Esto cargar√° la versi√≥n HD
        }
    }
}

// Demostraci√≥n del sistema
public class DemoRedSocial {
    public static void main(String[] args) {
        // Creamos un feed de red social
        FeedRedSocial feed = new FeedRedSocial();

        // Agregamos algunas im√°genes
        feed.agregarImagen("1", "https://ejemplo.com/original/foto1.jpg");
        feed.agregarImagen("2", "https://ejemplo.com/original/foto2.jpg");
        feed.agregarImagen("3", "https://ejemplo.com/original/foto3.jpg");

        // Simulamos scroll r√°pido por el feed
        System.out.println("=== üì± Simulaci√≥n de scroll r√°pido ===");
        feed.mostrarFeed();

        // Simulamos que el usuario se detiene en una imagen
        System.out.println("\n=== üîç Usuario se detiene en una imagen ===");
        feed.usuarioSeDetiene(1);

        // Simulamos continuar con el scroll
        System.out.println("\n=== ‚è≠Ô∏è Usuario contin√∫a el scroll ===");
        feed.usuarioSeDetiene(2);
    }
}
```

# La Clave üîë

Lo fundamental del Proxy es que:

1.  **Control de Acceso**: Act√∫a como intermediario entre el cliente y el objeto real
2.  **Carga Diferida**: Puede retrasar la creaci√≥n de objetos costosos hasta que sean realmente necesarios
3.  **Transparencia**: El cliente no necesita saber que est√° tratando con un proxy

# Tipos de Proxy Comunes üé≠

1.  **Proxy Virtual**: Para carga diferida (como nuestro ejemplo de Netflix)
2.  **Proxy de Protecci√≥n**: Para control de acceso (como un firewall)
3.  **Proxy de Cach√©**: Para almacenar resultados y evitar c√°lculos repetidos
4.  **Proxy Remoto**: Para acceder a objetos en otros servidores

# Consejo Pr√°ctico üí°

Usa el patr√≥n Proxy cuando:

- Necesites controlar el acceso a un objeto
- Quieras implementar carga diferida de objetos pesados
- Necesites a√±adir comportamiento antes o despu√©s de usar un objeto
- Quieras cachear resultados de operaciones costosas

# Estructura del Patr√≥n üèóÔ∏è

En el diagrama podemos ver:

1.  **ServiceInterface**: La interfaz com√∫n que comparten Proxy y Service
2.  **Service**: La clase real que hace el trabajo pesado
3.  **Proxy**: El intermediario que controla el acceso al Service
4.  **Client**: El c√≥digo que usa el servicio a trav√©s del proxy

La magia est√° en que el Client no sabe si est√° hablando con el Service real o con el Proxy. ¬°Es como tener un doble secreto! üé≠
