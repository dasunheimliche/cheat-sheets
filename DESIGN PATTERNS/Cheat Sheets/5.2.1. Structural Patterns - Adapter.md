## A - Patrón Adapter

#### 1. **Definición:**

El patrón Adapter es como un **traductor** mágico para tus objetos de programación. Imagina que tienes dos personas que hablan idiomas diferentes, como español y chino. Un traductor se pone en medio y les permite entenderse, ¿verdad? El Adapter hace algo similar: permite que dos objetos con **"idiomas" (interfaces) diferentes** puedan trabajar juntos sin problemas. ¡Es como un puente lingüístico en tu código!

#### 2. **Ejemplo:**

Piensa en una app que trabaja con datos en formato XML (un "idioma"). Ahora quieres usar una librería genial para hacer gráficos, ¡pero solo entiende datos en formato JSON (otro "idioma")! Necesitas un "Adapter" que **convierta** el XML a JSON para que la librería de gráficos pueda usar los datos sin problemas de comunicación.

**Analogía fácil:** Un adaptador de enchufe para viajar. Tu enchufe "americano" no entra en un enchufe "europeo", ¡necesitas un adaptador para que sean compatibles!

#### 3. **Notas o advertencias:**

- El Adapter es un **mediador**, no cambia a los objetos originales. Solo crea un intermediario para que puedan comunicarse sin problemas.
- Súper útil cuando no puedes modificar el código de uno de los objetos, como cuando usas librerías de terceros o sistemas antiguos.

---

## B - El Problema: Interfaces Incompatibles

#### 1. **Definición:**

El problema surge cuando tienes **clases o librerías** que hacen cosas útiles, pero la forma en que "hablas" con ellas (sus interfaces) **no coincide** con la forma en que tu código está organizado. Es como querer conectar un enchufe redondo a una toma cuadrada, ¡simplemente no encajan!

#### 2. **Ejemplo:**

Imagina una app que obtiene información del clima en XML. Ahora encuentras una librería de gráficos fantástica, ¡pero solo funciona con datos JSON! Sin un Adapter, no puedes usar esa librería directamente con tus datos XML. ¡Es como tener dos piezas de puzzle que no se unen!

![The structure of the app before integration with the analytics library](https://refactoring.guru/images/patterns/diagrams/adapter/problem-en.png)

**Explicación del ejemplo:**
La imagen muestra tu app (izquierda) hablando XML, pero la librería de gráficos (derecha) esperando JSON. ¡Hay una barrera de "idiomas" entre ellas!

#### 3. **Notas o advertencias:**

- Este problema es muy común al integrar **librerías de terceros** o al trabajar con **sistemas heredados**.
- Modificar la librería para que sea compatible podría ser **imposible** o muy arriesgado (podrías romper algo sin querer).

---

## C - La Solución: ¡El Adapter al Rescate!

#### 1. **Definición:**

El Adapter es como un **puente mágico** que conecta dos interfaces incompatibles. Este "puente" es un objeto especial que:

1.  **Se disfraza** para encajar con la interfaz que tu código ya usa.
2.  **Traduce** las peticiones a un "idioma" que la otra clase (la incompatible) pueda entender.

¡Es como tener un intérprete en una conversación entre personas que hablan idiomas distintos!

#### 2. **Ejemplo:**

Volviendo al ejemplo del clima, creas un **XMLtoJSONAdapter**. Este Adapter hace lo siguiente:

1.  **Recibe** los datos XML de tu app.
2.  **Transforma** esos datos XML al formato JSON.
3.  **Entrega** los datos JSON a la librería de gráficos.

¡Ahora tu app y la librería son amigas y trabajan juntas sin problemas! ¡Ninguna tuvo que cambiar su forma de ser!

![Adapter's solution](https://refactoring.guru/images/patterns/diagrams/adapter/solution-en.png)

**Explicación del ejemplo:**
Aquí ves al Adapter en el centro. Tu app (izquierda) sigue enviando XML al Adapter, y el Adapter lo convierte a JSON para la librería de gráficos (derecha). ¡Problema de comunicación resuelto!

#### 3. **Notas o advertencias:**

- El Adapter **esconde** la complejidad de la conversión, haciendo tu código más limpio y fácil de entender.
- Puedes tener **varios Adapters** para diferentes tipos de "incompatibilidades". ¡Un Adapter para cada "idioma" diferente!

---

## D - Analogía Real: El Adaptador de Enchufe de Viaje

#### 1. **Definición:**

Cuando viajas a otro país, a menudo los enchufes son diferentes. Tu enchufe "tipo A" no entra en un enchufe "tipo C". ¡Necesitas un **adaptador de enchufe**!

#### 2. **Ejemplo:**

![The Adapter pattern example](https://refactoring.guru/images/patterns/content/adapter/adapter-comic-1-en.png)

**Explicación del ejemplo:**
La imagen muestra una maleta y un adaptador de enchufe. El enchufe original (izquierda) no cabe en la toma de corriente (derecha). El adaptador (en medio) **adapta** el enchufe para que funcione en la toma diferente. ¡Magia de la compatibilidad!

#### 3. **Notas o advertencias:**

- El adaptador de enchufe **no cambia** tu cargador ni la toma de corriente. Solo los hace **compatibles**.
- Es una solución **simple y efectiva** para un problema de incompatibilidad. ¡Justo como el Adapter en programación!

---

## E - Estructura del Adapter: ¡Adapter de Objeto en Detalle!

#### 1. **Definición:**

El Adapter de Objeto es la forma **más común y flexible** de usar el patrón Adapter. Se basa en la **composición**. ¿Composición? ¡Fácil! Significa que el Adapter **tiene dentro de sí** una instancia del objeto que necesita "traducir". ¡Es como llevar un traductor personal contigo!

#### 2. **Diagrama y Explicación:**

![Structure of the Adapter design pattern (the object adapter)](https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter-indexed.png)

- **Cliente (1):** Tu código principal, el que quiere usar un servicio.
- **Interfaz Cliente (2):** La forma en que el Cliente espera interactuar con los objetos. Es el "idioma" que el Cliente entiende.
- **Servicio (3):** La clase útil, pero "habla otro idioma" (incompatible).
- **Adapter (4):** ¡El traductor! **Implementa** la Interfaz Cliente (para que el Cliente pueda hablarle) y **contiene** un objeto Servicio (para poder hablar con él).
- **Comunicación:** El Cliente le "habla" al Adapter a través de la Interfaz Cliente. El Adapter **traduce** esas peticiones y se las "dice" al Servicio en su propio "idioma".

#### 3. **Notas o advertencias:**

- El Cliente solo se comunica con el Adapter a través de la Interfaz Cliente. Esto hace que el sistema sea **muy flexible y fácil de cambiar**.
- Puedes cambiar el Adapter por otro **sin que el Cliente se entere** ni se vea afectado. ¡Modularidad al máximo!

---

## F - Estructura del Adapter: Adapter de Clase

#### 1. **Definición:**

El Adapter de Clase usa **herencia múltiple**. El Adapter **hereda** tanto de la interfaz que el cliente espera como de la clase que necesita ser adaptada. ¡Es como si el Adapter fuera bilingüe de nacimiento, hablando ambos "idiomas" a la vez!

#### 2. **Diagrama y Explicación:**

![Adapter design pattern (class adapter)](https://refactoring.guru/images/patterns/diagrams/adapter/structure-class-adapter-indexed.png)

- **Adapter de Clase (1):** **Hereda** directamente de la **Interfaz Cliente** (para cumplir con las expectativas del cliente) **Y** de la clase **Servicio** (la que necesita ser adaptada). ¡No necesita "contener" un objeto Servicio! Simplemente **ES** ambos a la vez gracias a la herencia múltiple.
- **Adaptación:** La "traducción" o adaptación de la interfaz ocurre dentro de los **métodos que el Adapter de Clase reescribe** (sobrescribe) de la clase Servicio o de la Interfaz Cliente. Es en estos métodos donde se realiza la "traducción" mágica.

#### 3. **Notas o advertencias:**

- El Adapter de Clase es **menos común** en la práctica, principalmente porque la **herencia múltiple puede ser compleja** y **no está directamente soportada en algunos lenguajes** populares como Java (aunque se puede simular, es más complicado).
- Debido a la complejidad de la herencia múltiple, el **Adapter de Objeto (basado en composición)** suele ser **más flexible, más fácil de entender y mantener**, y por lo tanto, **más preferido** en la mayoría de los casos.
- Aun así, entender el Adapter de Clase es **valioso para tener una visión completa del patrón Adapter** y sus diferentes enfoques. Te ayuda a comprender las ventajas y desventajas de la herencia frente a la composición en este contexto.

---

## G - Ejemplo en Código: Adaptando Clavijas Cuadradas (¡Adapter de Objeto!)

#### 1. **Definición:**

Este ejemplo clásico ilustra el Adapter con clavijas cuadradas y agujeros redondos. Una clavija cuadrada **no entra** en un agujero redondo directamente. ¡Necesitamos un Adapter para "redondear" la clavija cuadrada! Este es el ejemplo del **Adapter de Objeto**.

#### 2. **Código Java y Explicación:**

```java
// Interfaz para Clavijas (nuestro "idioma" común)
interface Clavija {
    double getRadio();
}

// Clases existentes y compatibles: AgujeroRedondo y ClavijaRedonda
class AgujeroRedondo {
    private double radio;

    public AgujeroRedondo(double radio) {
        this.radio = radio;
    }

    public double getRadio() {
        return radio;
    }

    public boolean encaja(Clavija clavija) { // Ahora usa la interfaz Clavija
        return this.getRadio() >= clavija.getRadio();
    }
}

class ClavijaRedonda implements Clavija { // Implementa la interfaz Clavija
    private double radio;

    public ClavijaRedonda(double radio) {
        this.radio = radio;
    }

    public double getRadio() {
        return radio;
    }
}

// Clase incompatible: ClavijaCuadrada (¡no implementa Clavija!)
class ClavijaCuadrada {
    private double ancho;

    public ClavijaCuadrada(double ancho) {
        this.ancho = ancho;
    }

    public double getAncho() {
        return ancho;
    }
}

// Adapter de Objeto: ClavijaCuadradaAdapter IMPLEMENTA Clavija y CONTIENE una ClavijaCuadrada
class ClavijaCuadradaAdapter implements Clavija {
    private ClavijaCuadrada clavijaCuadrada; // ¡COMPOSICIÓN! Contiene una ClavijaCuadrada

    public ClavijaCuadradaAdapter(ClavijaCuadrada clavija) {
        this.clavijaCuadrada = clavija;
    }

    @Override
    public double getRadio() {
        // "Traduce" el ancho de la clavija cuadrada a un "radio equivalente"
        return clavijaCuadrada.getAncho() * Math.sqrt(2) / 2;
    }
}

// Código cliente
public class Main {
    public static void main(String[] args) {
        AgujeroRedondo agujero = new AgujeroRedondo(5);
        ClavijaRedonda clavijaRedonda = new ClavijaRedonda(5);
        System.out.println(agujero.encaja(clavijaRedonda)); // true, ¡encaja perfecto!

        ClavijaCuadrada clavijaCuadradaPequeña = new ClavijaCuadrada(5);
        ClavijaCuadrada clavijaCuadradaGrande = new ClavijaCuadrada(10);
        // agujero.encaja(clavijaCuadradaPequeña); // ¡Error! agujero.encaja espera una Clavija, no ClavijaCuadrada

        ClavijaCuadradaAdapter adapterPequeño = new ClavijaCuadradaAdapter(clavijaCuadradaPequeña); // Creamos el Adapter para la pequeña
        ClavijaCuadradaAdapter adapterGrande = new ClavijaCuadradaAdapter(clavijaCuadradaGrande);   // Creamos el Adapter para la grande
        System.out.println(agujero.encaja(adapterPequeño)); // true, ¡el adapter hace que encaje!
        System.out.println(agujero.encaja(adapterGrande)); // false, ¡el adapter también respeta el tamaño!
    }
}
```

**Explicación del ejemplo:**

- Hemos creado una interfaz `Clavija` que define el "idioma" común: tener un `radio`.
- `ClavijaRedonda` ahora "habla" el idioma `Clavija` (implementa la interfaz).
- `ClavijaCuadrada` sigue siendo "extranjera" (no implementa `Clavija`).
- `ClavijaCuadradaAdapter` es nuestro **Adapter de Objeto**:
  - **Implementa** `Clavija`, así que el `AgujeroRedondo` puede "hablar" con él.
  - **Contiene** una `ClavijaCuadrada` (¡composición!).
  - En su método `getRadio()`, **traduce** el "ancho" de la `ClavijaCuadrada` a un "radio equivalente" para que el `AgujeroRedondo` pueda entenderlo.

#### 3. **Notas o advertencias:**

- Este ejemplo muestra claramente el **Adapter de Objeto** en acción: ¡composición para la victoria!
- La clave está en la interfaz `Clavija` que define el "idioma" común y en cómo el Adapter "traduce" la `ClavijaCuadrada` a ese idioma.

---

## H - Ejemplo en Código: Adaptando Clavijas Cuadradas (¡Adapter de Clase!)

#### 1. **Definición:**

Ahora vamos a ver cómo sería el ejemplo de las clavijas cuadradas usando un **Adapter de Clase**. En este caso, usaremos herencia múltiple (o una simulación en Java, ya que Java no tiene herencia múltiple directa de clases, pero sí de interfaces).

#### 2. **Código Java (Simulando Adapter de Clase) y Explicación:**

```java
// Interfaz para Clavijas (nuestro "idioma" común)
interface Clavija {
    double getRadio();
}

// Clases existentes y compatibles: AgujeroRedondo y ClavijaRedonda (igual que antes)
class AgujeroRedondo {
    private double radio;

    public AgujeroRedondo(double radio) {
        this.radio = radio;
    }

    public double getRadio() {
        return radio;
    }

    public boolean encaja(Clavija clavija) {
        return this.getRadio() >= clavija.getRadio();
    }
}

class ClavijaRedonda implements Clavija {
    private double radio;

    public ClavijaRedonda(double radio) {
        this.radio = radio;
    }

    public double getRadio() {
        return radio;
    }
}

// Clase incompatible: ClavijaCuadrada (igual que antes)
class ClavijaCuadrada {
    private double ancho;

    public ClavijaCuadrada(double ancho) {
        this.ancho = ancho;
    }

    public double getAncho() {
        return ancho;
    }
}

// Adapter de Clase (SIMULADO en Java): ClavijaCuadradaAdapter HEREDA de ClavijaRedonda y "usa" ClavijaCuadrada
// NOTA: En Java no podemos heredar de ClavijaCuadrada y ClavijaRedonda a la vez (herencia múltiple de clases no permitida).
//       Aquí SIMULAMOS el Adapter de Clase usando herencia de interfaz (Clavija) y COMPOSICIÓN de ClavijaCuadrada.
//       En lenguajes con herencia múltiple real, ClavijaCuadradaAdapter HEREDARÍA de ambas directamente.

class ClavijaCuadradaAdapter extends ClavijaCuadrada implements Clavija { // ¡EXTIENDE ClavijaCuadrada e IMPLEMENTA Clavija!

    public ClavijaCuadradaAdapter(double ancho) {
        super(ancho); // Llama al constructor de ClavijaCuadrada para inicializar el ancho
    }

    @Override
    public double getRadio() {
        // "Traduce" el ancho de la clavija cuadrada a un "radio equivalente" (igual que en el Adapter de Objeto)
        return getAncho() * Math.sqrt(2) / 2; // Ahora podemos usar getAncho() porque HEREDAMOS de ClavijaCuadrada
    }
}


// Código cliente (igual que en el ejemplo de Adapter de Objeto)
public class Main {
    public static void main(String[] args) {
        AgujeroRedondo agujero = new AgujeroRedondo(5);
        ClavijaRedonda clavijaRedonda = new ClavijaRedonda(5);
        System.out.println(agujero.encaja(clavijaRedonda)); // true

        ClavijaCuadrada clavijaCuadradaPequeña = new ClavijaCuadrada(5);
        ClavijaCuadrada clavijaCuadradaGrande = new ClavijaCuadrada(10);
        // agujero.encaja(clavijaCuadradaPequeña); // ¡Error de compilación! Tipos incompatibles

        // ¡Ahora usamos DIRECTAMENTE ClavijaCuadradaAdapter, ya que "ES" una Clavija (gracias a la herencia)!
        ClavijaCuadradaAdapter adapterPequeño = new ClavijaCuadradaAdapter(5); // Pasamos el ancho al constructor del Adapter de Clase
        ClavijaCuadradaAdapter adapterGrande = new ClavijaCuadradaAdapter(10);
        System.out.println(agujero.encaja(adapterPequeño)); // true
        System.out.println(agujero.encaja(adapterGrande)); // false
    }
}
```

**Explicación del ejemplo (Adapter de Clase Simulado en Java):**

- **Simulación en Java:** Como Java no permite heredar de dos clases a la vez, **simulamos** el Adapter de Clase haciendo que `ClavijaCuadradaAdapter` **extienda** de `ClavijaCuadrada` (herencia) e **implemente** la interfaz `Clavija`.
- **Herencia y "ES-UN":** Al extender de `ClavijaCuadrada`, `ClavijaCuadradaAdapter` **hereda** las propiedades y métodos de `ClavijaCuadrada` (en este caso, el `ancho`). Al implementar `Clavija`, se compromete a "ser" una `Clavija` y proporcionar el método `getRadio()`.
- **Adaptación en `getRadio()`:** El método `getRadio()` en `ClavijaCuadradaAdapter` ahora puede acceder directamente a `getAncho()` (heredado de `ClavijaCuadrada`) y realizar la "traducción" al "radio equivalente".
- **Uso en el Cliente:** El código cliente ahora puede usar `ClavijaCuadradaAdapter` **directamente** donde se espera una `Clavija`, ya que `ClavijaCuadradaAdapter` **ES-UN** `Clavija` (gracias a la implementación de la interfaz).

#### 3. **Notas o advertencias (Adapter de Clase):**

- **Limitaciones de Java:** Este ejemplo en Java es una **simulación** del Adapter de Clase. En lenguajes con herencia múltiple real, el Adapter de Clase sería más directo y heredaría directamente de ambas clases.
- **Menos Flexible:** El Adapter de Clase está **más acoplado** a las clases que adapta, ya que usa herencia. Si la clase `ClavijaCuadrada` cambia mucho, el Adapter de Clase podría necesitar más modificaciones. El Adapter de Objeto (con composición) suele ser más flexible ante cambios en las clases adaptadas.
- **Cuándo Considerarlo:** Aunque menos común, el Adapter de Clase puede ser útil en situaciones donde la herencia múltiple es una opción natural en el lenguaje y se busca una solución más "ligera" en términos de objetos (ya que no necesita "contener" un objeto adaptado, sino que "ES" el adaptador).

---

## I - Aplicabilidad del Adapter (Igual para ambos tipos)

#### 1. **Definición:**

Usa el Adapter cuando:

- Quieres usar una clase existente, pero su interfaz **no coincide** con la que tu código necesita.
- Necesitas usar una clase de **terceros** o un sistema **antiguo** con una interfaz diferente.
- Quieres **reutilizar** varias subclases existentes que **carecen de una funcionalidad común** que no se puede añadir a la superclase.

#### 2. **Ejemplo:**

- Integrar una **librería de pago** para procesamiento de imágenes que usa un formato de datos diferente al de tu aplicación.
- Conectar tu aplicación moderna a una **base de datos antigua** con una API obsoleta.
- Unificar el manejo de **diferentes servicios de pago** (PayPal, Stripe, etc.) bajo una interfaz común en tu aplicación.

#### 3. **Notas o advertencias:**

- El Adapter es útil para **integración** y **reutilización** de código existente.
- Considera si es más sencillo **modificar la clase de servicio** en lugar de crear un Adapter, si es posible y no introduce problemas.

---

## J - Cómo Implementar el Adapter (Pasos Generales, Adaptables a ambos tipos)

#### 1. **Pasos:**

1.  **Identifica** las clases incompatibles: el `Servicio` (la clase que quieres usar) y el `Cliente` (tu código).
2.  **Define la Interfaz Cliente:** Describe cómo el `Cliente` espera interactuar con los objetos.
3.  **Crea la clase Adapter:**
    - **Adapter de Objeto:** Implementa la `Interfaz Cliente` y **contiene** una instancia del `Servicio`.
    - **Adapter de Clase:** **Hereda** de la `Interfaz Cliente` y del `Servicio` (o simula herencia múltiple si es necesario).
4.  **Implementa los métodos del Adapter:** Para cada método de la `Interfaz Cliente`, escribe la lógica en el Adapter para:
    - **Recibir** la llamada del `Cliente`.
    - **Traducir** la llamada al formato que el `Servicio` entiende.
    - **Llamar** al método correspondiente del `Servicio`.
    - **Traducir** la respuesta del `Servicio` al formato que el `Cliente` espera (si es necesario).
5.  **Usa el Adapter en el Cliente:** El `Cliente` debe interactuar con el Adapter a través de la `Interfaz Cliente`.

#### 2. **Ejemplo (Resumen del ejemplo de Clavija):**

En el ejemplo de la clavija:

1.  **Incompatibles:** `AgujeroRedondo` (Cliente) y `ClavijaCuadrada` (Servicio).
2.  **Interfaz Cliente:** Implícitamente, la interfaz de `ClavijaRedonda` (método `getRadio()`).
3.  **Adapter:**
    - **Adapter de Objeto:** `ClavijaCuadradaAdapter` implementa `Clavija` y contiene `ClavijaCuadrada`.
    - **Adapter de Clase:** `ClavijaCuadradaAdapter` extiende `ClavijaCuadrada` e implementa `Clavija` (simulado en Java).
4.  **Implementación de métodos:** `getRadio()` en ambos Adapters traduce el ancho de `ClavijaCuadrada` a un radio equivalente.
5.  **Uso en Cliente:** `AgujeroRedondo` usa ambos tipos de `ClavijaCuadradaAdapter` como si fueran una `ClavijaRedonda`.

#### 3. **Notas o advertencias:**

- Empieza por la **Interfaz Cliente** para tener claro qué necesita el `Cliente`.
- La **traducción** en el Adapter puede ser simple o compleja, dependiendo de la incompatibilidad.
- **Elige entre Adapter de Objeto y de Clase:** Considera la flexibilidad, la complejidad de la herencia múltiple en tu lenguaje y las necesidades específicas de tu proyecto. En general, el **Adapter de Objeto suele ser la opción más versátil y recomendada**.

---

## K - Pros y Contras del Adapter (Igual para ambos tipos)

#### 1. **Pros:**

- **Principio de Responsabilidad Única:** Separa la lógica de conversión de interfaz del código principal.
- **Principio Abierto/Cerrado:** Puedes añadir nuevos Adapters sin modificar el código del Cliente, siempre que usen la misma Interfaz Cliente.

#### 2. **Contras:**

- **Aumenta la complejidad:** Introduce nuevas interfaces y clases. A veces, modificar directamente la clase de servicio es más simple (si es posible).

#### 3. **Notas o advertencias:**

- Evalúa si la complejidad añadida por el Adapter **compensa** los beneficios de la flexibilidad y la reutilización.
- Si la incompatibilidad es **muy simple**, un Adapter podría ser excesivo.

---

## L - Relación con otros patrones (Igual para ambos tipos)

#### 1. **Comparaciones:**

- **Bridge vs. Adapter:** `Bridge` se diseña **desde el principio** para separar abstracción e implementación. `Adapter` se usa **después**, para hacer que clases incompatibles trabajen juntas.
- **Decorator vs. Adapter:** `Adapter` cambia la **interfaz**. `Decorator` **extiende** o mantiene la misma interfaz, añadiendo funcionalidad. `Decorator` permite composición recursiva, `Adapter` no.
- **Proxy vs. Adapter:** `Adapter` cambia la **interfaz**. `Proxy` mantiene la **misma interfaz**, controlando el acceso al objeto.
- **Facade vs. Adapter:** `Facade` crea una **nueva interfaz simplificada** para un subsistema. `Adapter` **adapta una interfaz existente** para que sea usable. `Facade` trabaja con **múltiples objetos**, `Adapter` suele con **uno**.
- **Bridge, State, Strategy, Adapter:** Estructuras similares (basadas en composición). La **intención** y el **problema que resuelven** son diferentes para cada patrón.

#### 2. **Tabla resumen (simplificada):**

| Patrón      | Cambia Interfaz | Añade Funcionalidad | Propósito Principal                                   |
| :---------- | :-------------: | :-----------------: | :---------------------------------------------------- |
| **Adapter** |       Sí        |         No          | Hacer compatibles interfaces incompatibles            |
| Decorator   |       No        |         Sí          | Añadir funcionalidad dinámicamente                    |
| Proxy       |       No        |         No          | Controlar acceso al objeto                            |
| Facade      |       Sí        |         No          | Simplificar la interfaz de un subsistema              |
| Bridge      |       No        |         No          | Separar abstracción e implementación (diseño inicial) |

#### 3. **Notas o advertencias:**

- Entender las **diferencias sutiles** entre patrones es clave para elegir el más adecuado.
- Los patrones a menudo se usan **combinados** para resolver problemas complejos.
