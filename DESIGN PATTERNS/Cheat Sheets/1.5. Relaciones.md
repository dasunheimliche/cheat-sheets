## A - Dependencia

![image](https://i.ibb.co/JRHTR5p5/image.png)

#### 1. **Definición:**

Imagina que tienes dos clases, como "Profesor" y "Curso". Hay **dependencia** cuando un cambio en la clase "Curso" (por ejemplo, si cambias el nombre de un método o cómo funciona) podría obligarte a cambiar algo en la clase "Profesor". Es como si el Profesor **dependiera** de que el Curso sea de cierta manera para poder hacer su trabajo. Es la relación más básica y débil entre clases.

#### 2. **Ejemplo:**

```java
class Curso {
    public String obtenerConocimientos() {
        return "Conocimientos del curso";
    }
}

class Profesor {
    public void enseñar(Curso curso) {
        String conocimientos = curso.obtenerConocimientos();
        System.out.println("Profesor enseñando: " + conocimientos);
    }
}

public class Main {
    public static void main(String[] args) {
        Curso curso = new Curso();
        Profesor profesor = new Profesor();
        profesor.enseñar(curso);
    }
}
```

**Explicación del ejemplo:**

Aquí, la clase `Profesor` **depende** de la clase `Curso`. Fíjate en el método `enseñar` del `Profesor`. Recibe un `Curso` como argumento y usa el método `obtenerConocimientos()` de `Curso`. Si mañana decides cambiar el nombre de `obtenerConocimientos()` en la clase `Curso`, ¡tendrás que ir a la clase `Profesor` y cambiar también el nombre en el método `enseñar`! Eso es dependencia en acción.

#### 3. **Notas o advertencias:**

- **No siempre se muestra en UML:** Los diagramas UML no suelen mostrar todas las dependencias porque ¡habría demasiadas! Solo se muestran las más importantes.
- **Hacerla más débil:** Puedes reducir la dependencia usando interfaces o clases abstractas en lugar de clases concretas. Esto hace que tu código sea más flexible.

---

## B - Asociación

#### 1. **Definición:**

La **asociación** es cuando un objeto de una clase **usa** o **interactúa** con un objeto de otra clase. Piensa en un "Profesor" que se comunica con "Estudiantes". Es una relación más fuerte que la dependencia. En UML, se representa con una flecha que va desde la clase que usa a la clase usada. Si la relación es en ambos sentidos (bidireccional), la flecha tiene punta en ambos extremos.

#### 2. **Ejemplo:**

```java
class Estudiante {
    public void recordar(String conocimiento) {
        System.out.println("Estudiante recuerda: " + conocimiento);
    }
}

class Profesor {
    private Estudiante estudiante; // Asociación: Profesor "tiene" un Estudiante

    public Profesor(Estudiante estudiante) {
        this.estudiante = estudiante;
    }

    public void enseñar(Curso curso) {
        String conocimientos = curso.obtenerConocimientos();
        System.out.println("Profesor enseñando: " + conocimientos);
        this.estudiante.recordar(conocimientos); // Profesor usa Estudiante
    }
}

class Curso {
    public String obtenerConocimientos() {
        return "Conocimientos del curso";
    }
}


public class Main {
    public static void main(String[] args) {
        Estudiante estudiante = new Estudiante();
        Profesor profesor = new Profesor(estudiante);
        Curso curso = new Curso();
        profesor.enseñar(curso);
    }
}
```

**Explicación del ejemplo:**

Aquí, el `Profesor` **tiene una asociación** con `Estudiante` porque la clase `Profesor` tiene un campo `estudiante` de tipo `Estudiante`. Además, en el método `enseñar`, el `Profesor` **usa** al `Estudiante` llamando al método `recordar()`. La asociación significa que el `Profesor` siempre tiene acceso a un `Estudiante` (en este caso, a través del campo `estudiante`).

#### 3. **Notas o advertencias:**

- **Dependencia especializada:** La asociación es como un tipo especial de dependencia donde siempre hay un "vínculo" entre los objetos.
- **Campo o método:** Una asociación puede representarse como un campo en una clase (como en el ejemplo) o, desde una perspectiva de interfaz, podría indicar que hay un método que devuelve el objeto asociado.

---

## C - Agregación

#### 1. **Definición:**

La **agregación** es un tipo especial de asociación que representa relaciones de tipo "uno a muchos" o "todo a parte". Imagina un "Departamento" que **contiene** a varios "Profesores". El "Departamento" es el contenedor y los "Profesores" son los componentes. Lo importante aquí es que un "Profesor" **puede existir sin el "Departamento"** y podría incluso pertenecer a varios departamentos a la vez. En UML, se usa un diamante vacío en el lado del contenedor.

#### 2. **Ejemplo:**

```java
import java.util.ArrayList;
import java.util.List;

class Profesor {
    private String nombre;

    public Profesor(String nombre) {
        this.nombre = nombre;
    }

    public String getNombre() {
        return nombre;
    }
}

class Departamento {
    private List<Profesor> profesores; // Agregación: Departamento "tiene" una lista de Profesores
    private String nombreDepartamento;

    public Departamento(String nombreDepartamento) {
        this.nombreDepartamento = nombreDepartamento;
        this.profesores = new ArrayList<>();
    }

    public void agregarProfesor(Profesor profesor) {
        this.profesores.add(profesor);
    }

    public List<Profesor> getProfesores() {
        return profesores;
    }

    public String getNombreDepartamento() {
        return nombreDepartamento;
    }
}

public class Main {
    public static void main(String[] args) {
        Departamento departamento = new Departamento("Informática");
        Profesor profesor1 = new Profesor("Juan");
        Profesor profesor2 = new Profesor("Maria");

        departamento.agregarProfesor(profesor1);
        departamento.agregarProfesor(profesor2);

        System.out.println("Departamento: " + departamento.getNombreDepartamento());
        System.out.println("Profesores en el departamento:");
        for (Profesor profesor : departamento.getProfesores()) {
            System.out.println("- " + profesor.getNombre());
        }
    }
}
```

**Explicación del ejemplo:**

Aquí, un `Departamento` **agrega** `Profesores`. El `Departamento` tiene una lista de `Profesor`es. Si "destruyes" el `Departamento`, los `Profesor`es seguirán existiendo. Podrían trabajar en otro departamento o en otro lugar. La relación es de "contener", pero no de "poseer" en el sentido de que la vida del componente dependa del contenedor.

#### 3. **Notas o advertencias:**

- **Contenedor y componente:** Un objeto "contenedor" tiene un grupo de objetos "componentes".
- **Componente independiente:** El componente puede existir por sí solo y puede estar en varios contenedores a la vez.
- **UML:** Diamante vacío en el lado del contenedor.

---

## D - Composición

#### 1. **Definición:**

La **composición** es un tipo aún más fuerte de agregación. Imagina una "Universidad" que **se compone** de "Departamentos". La gran diferencia con la agregación es que en la composición, el componente **solo puede existir como parte del contenedor**. Si destruyes la "Universidad", los "Departamentos" también dejan de existir (en el contexto de esa universidad, claro). Es una relación de "todo a partes" muy fuerte. En UML, se usa un diamante **relleno** en el lado del contenedor.

#### 2. **Ejemplo:**

```java
import java.util.ArrayList;
import java.util.List;

class Departamento { // Mismo Departamento que antes, pero ahora en Composición
    private String nombreDepartamento;
    // ... (mismos métodos que antes) ...
    public Departamento(String nombreDepartamento) {
        this.nombreDepartamento = nombreDepartamento;
        this.profesores = new ArrayList<>(); // Sigue agregando profesores, pero en composición, el ciclo de vida del Departamento y Profesor están más ligados en un contexto mayor como Universidad
    }
    private List<Profesor> profesores; // Agregación: Departamento "tiene" una lista de Profesores (en este ejemplo, para simplificar, mantenemos la agregación de profesores dentro del departamento, pero la composición se centra en la relación Universidad-Departamento)

    // ... (métodos agregarProfesor, getProfesores, getNombreDepartamento) ...
}


class Universidad {
    private String nombreUniversidad;
    private List<Departamento> departamentos; // Composición: Universidad "se compone" de Departamentos

    public Universidad(String nombreUniversidad) {
        this.nombreUniversidad = nombreUniversidad;
        this.departamentos = new ArrayList<>();
    }

    public void agregarDepartamento(Departamento departamento) {
        this.departamentos.add(departamento);
    }

    public List<Departamento> getDepartamentos() {
        return departamentos;
    }

    public String getNombreUniversidad() {
        return nombreUniversidad;
    }

    // Método para "destruir" la universidad (y con ella, sus departamentos)
    public void cerrarUniversidad() {
        System.out.println("Cerrando la universidad " + nombreUniversidad);
        this.departamentos.clear(); // Al "cerrar" la universidad, los departamentos "desaparecen" en este contexto
        System.out.println("Departamentos eliminados.");
    }
}


public class Main {
    public static void main(String[] args) {
        Universidad universidad = new Universidad("Mi Universidad");
        Departamento departamento1 = new Departamento("Ingeniería");
        Departamento departamento2 = new Departamento("Ciencias");

        universidad.agregarDepartamento(departamento1);
        universidad.agregarDepartamento(departamento2);

        System.out.println("Universidad: " + universidad.getNombreUniversidad());
        System.out.println("Departamentos en la universidad:");
        for (Departamento departamento : universidad.getDepartamentos()) {
            System.out.println("- " + departamento.getNombreDepartamento());
        }

        universidad.cerrarUniversidad(); // Al cerrar la universidad, los departamentos "desaparecen" en este contexto
        System.out.println("Departamentos después de cerrar la universidad: " + universidad.getDepartamentos().size()); // Debería ser 0
    }
}
```

**Explicación del ejemplo:**

Aquí, la `Universidad` **se compone** de `Departamento`s. Si creas una `Universidad`, necesitas crear `Departamento`s **para esa universidad**. Los `Departamento`s no tienen sentido fuera de una `Universidad` en este ejemplo de composición. Cuando "cierras" la `Universidad` (simulado con el método `cerrarUniversidad()`), los `Departamento`s, en este contexto, dejan de existir como parte de esa universidad. La `Universidad` **gestiona el ciclo de vida** de los `Departamento`s.

#### 3. **Notas o advertencias:**

- **Componente dependiente:** El componente (Departamento) depende totalmente del contenedor (Universidad) para su existencia.
- **Ciclo de vida:** El contenedor gestiona el ciclo de vida del componente. Cuando el contenedor se destruye, los componentes también.
- **UML:** Diamante relleno en el lado del contenedor.
- **Composición vs. Agregación:** La diferencia clave es la dependencia del ciclo de vida. En la agregación, el componente puede vivir sin el contenedor; en la composición, no.
- **"Composición" en general:** A veces, la gente usa "composición" para referirse tanto a la agregación como a la composición en general, especialmente cuando hablan de "composición de objetos" como alternativa a la herencia.
