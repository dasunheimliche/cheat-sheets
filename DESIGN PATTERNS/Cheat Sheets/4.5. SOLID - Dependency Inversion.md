## A - Principio de Inversión de Dependencia (DIP)

#### 1. **Definición:**

El Principio de Inversión de Dependencia (DIP) nos dice que las partes más importantes de nuestro programa (las clases de "alto nivel") no deberían depender directamente de las partes menos importantes (las clases de "bajo nivel"). En lugar de eso, ¡ambas deberían depender de abstracciones! Y aún más, las abstracciones no deberían depender de los detalles, ¡sino al revés! Los detalles deberían depender de las abstracciones. Suena un poco trabalenguas, ¿verdad? Pero no te preocupes, lo vamos a desglosar para que lo entiendas súper bien.

#### 2. **Ejemplo:**

Imagina que tienes una clase `ReportePresupuesto` (clase de alto nivel) que necesita guardar información en una base de datos. Antes de aplicar el DIP, podrías tener algo así:

```java
class ReportePresupuesto {
    private MySQLDatabase database; // Dependencia directa de una clase concreta de bajo nivel

    public ReportePresupuesto() {
        this.database = new MySQLDatabase();
    }

    public void guardarReporte(Reporte reporte) {
        database.insert(reporte.datos());
    }
}

class MySQLDatabase { // Clase de bajo nivel
    public void insert(String datos) {
        // Código para insertar datos en MySQL
        System.out.println("Guardando en MySQL: " + datos);
    }
}

class Reporte {
    public String datos() {
        return "Datos del reporte";
    }
}

public class Main {
    public static void main(String[] args) {
        ReportePresupuesto reporte = new ReportePresupuesto();
        reporte.guardarReporte(new Reporte());
    }
}
```

**Output:**

```
Guardando en MySQL: Datos del reporte
```

**Explicación del ejemplo:**

En este ejemplo _antes_ de aplicar el DIP, `ReportePresupuesto` depende directamente de `MySQLDatabase`. Si quisieras cambiar a otra base de datos (por ejemplo, `PostgreSQLDatabase`), tendrías que modificar `ReportePresupuesto`. ¡Esto no es ideal! El DIP nos dice que deberíamos evitar esta dependencia directa.

#### 3. **Notas o advertencias:**

- **Alto nivel vs. Bajo nivel:** Las clases de **bajo nivel** suelen ser las que se encargan de tareas técnicas específicas, como interactuar con bases de datos, sistemas de archivos, redes, etc. Las clases de **alto nivel** se centran en la lógica de negocio de tu aplicación, en "qué" hace tu programa en términos de negocio.
- **Dependencia directa = Problemas:** Cuando las clases de alto nivel dependen directamente de las de bajo nivel, tu código se vuelve rígido y difícil de cambiar. Un cambio en una clase de bajo nivel (incluso si es solo un detalle técnico) puede obligarte a cambiar clases de alto nivel, ¡que no deberían verse afectadas por esos detalles!

---

## B - Abstracciones: La Clave del DIP

#### 1. **Definición:**

Una **abstracción** en programación es como una idea general de algo, sin entrar en los detalles específicos de cómo se hace. En Java, las **interfaces** son una forma muy común de crear abstracciones. Una interfaz define _qué_ se puede hacer, pero no _cómo_ se hace.

#### 2. **Ejemplo:**

Siguiendo con el ejemplo anterior, vamos a crear una interfaz `Database` que defina las operaciones básicas que necesitamos para guardar datos, sin especificar _qué tipo_ de base de datos vamos a usar.

```java
interface Database { // Abstracción: Interfaz Database
    void insert(String datos);
}

class ReportePresupuesto {
    private Database database; // Dependencia de la abstracción (interfaz)

    public ReportePresupuesto(Database database) { // Inyección de dependencia
        this.database = database;
    }

    public void guardarReporte(Reporte reporte) {
        database.insert(reporte.datos());
    }
}

class MySQLDatabase implements Database { // Implementación concreta de la interfaz
    public void insert(String datos) {
        // Código para insertar datos en MySQL
        System.out.println("Guardando en MySQL: " + datos);
    }
}

class MongoDBDatabase implements Database { // Otra implementación concreta
    public void insert(String datos) {
        // Código para insertar datos en MongoDB
        System.out.println("Guardando en MongoDB: " + datos);
    }
}


class Reporte {
    public String datos() {
        return "Datos del reporte";
    }
}


public class Main {
    public static void main(String[] args) {
        Database mysql = new MySQLDatabase();
        ReportePresupuesto reporteConMySQL = new ReportePresupuesto(mysql);
        reporteConMySQL.guardarReporte(new Reporte());

        Database mongoDB = new MongoDBDatabase();
        ReportePresupuesto reporteConMongoDB = new ReportePresupuesto(mongoDB);
        reporteConMongoDB.guardarReporte(new Reporte());
    }
}
```

**Output:**

```
Guardando en MySQL: Datos del reporte
Guardando en MongoDB: Datos del reporte
```

**Explicación del ejemplo:**

Ahora, `ReportePresupuesto` ya no depende directamente de `MySQLDatabase`. En su lugar, depende de la interfaz `Database`. `MySQLDatabase` y `MongoDBDatabase` _implementan_ la interfaz `Database`. Esto significa que `ReportePresupuesto` puede trabajar con _cualquier_ base de datos que implemente la interfaz `Database`, ¡sin necesidad de cambiar su código! Hemos "invertido" la dependencia: ahora las clases de bajo nivel (como `MySQLDatabase`) dependen de la abstracción de alto nivel (`Database`).

#### 3. **Notas o advertencias:**

- **Interfaces como contratos:** Piensa en las interfaces como contratos. La interfaz `Database` dice: "Cualquier clase que implemente `Database` debe tener un método `insert(String datos)`". Esto asegura que `ReportePresupuesto` sepa qué esperar de cualquier base de datos que use.
- **Inyección de Dependencia:** En el ejemplo, pasamos la instancia de la base de datos a `ReportePresupuesto` a través del constructor (`public ReportePresupuesto(Database database)`). Esto se llama **inyección de dependencia** y es una forma común de aplicar el DIP. Permite configurar las dependencias de una clase desde fuera, haciéndola más flexible y fácil de probar.

---

## C - Inversión de la Dependencia en la Práctica

#### 1. **Definición:**

"Invertir la dependencia" significa cambiar la dirección de quién depende de quién. Originalmente, las clases de alto nivel dependían de los detalles de las clases de bajo nivel. Con el DIP, hacemos que las clases de bajo nivel dependan de las abstracciones definidas por las clases de alto nivel (o al menos, en el contexto de la lógica de negocio).

#### 2. **Ejemplo:**

Las imágenes que proporcionaste ilustran esto visualmente:

![image](https://i.ibb.co/Ps0ychMf/image.png)

**ANTES:** `BudgetReport` (clase de alto nivel) depende directamente de `MySQLDatabase` (clase de bajo nivel). Cualquier cambio en `MySQLDatabase` podría afectar a `BudgetReport`.

![image](https://i.ibb.co/Qv1sqLJy/image.png)

**DESPUÉS:** `BudgetReport` depende de la abstracción `Database` (una interfaz). Tanto `MySQLDatabase` como `MongoDBDatabase` dependen de la interfaz `Database`. Ahora, `BudgetReport` es independiente de los detalles de la base de datos específica. Podemos cambiar o extender las bases de datos sin afectar a `BudgetReport`.

#### 3. **Notas o advertencias:**

- **Beneficios del DIP:**
  - **Menos acoplamiento:** Las clases están menos conectadas entre sí, lo que facilita los cambios y el mantenimiento.
  - **Mayor flexibilidad:** Puedes cambiar las implementaciones de bajo nivel (como la base de datos) sin afectar a la lógica de negocio de alto nivel.
  - **Mejor testabilidad:** Es más fácil probar las clases de alto nivel porque puedes usar "mocks" o "stubs" que implementen las abstracciones en lugar de depender de implementaciones reales de bajo nivel.
  - **Reutilización:** Las abstracciones pueden ser reutilizadas por diferentes clases de alto nivel, y las implementaciones de bajo nivel pueden ser reutilizadas con diferentes abstracciones.
- **Relación con el Principio Abierto/Cerrado:** El DIP a menudo va de la mano con el Principio Abierto/Cerrado. Al usar abstracciones, puedes extender el comportamiento de tu sistema (añadiendo nuevas bases de datos, por ejemplo) sin modificar el código existente de las clases de alto nivel.
