## A - Strategy: El Patrón Estrategia

#### 1. **Definicion:**

Imagina que tienes un problema que puedes resolver de muchas maneras diferentes, como elegir entre ir en coche, bici o autobús. El patrón Strategy te permite definir cada una de estas "maneras" (algoritmos) por separado, en sus propias clases, y luego intercambiarlas fácilmente dentro de tu programa. Es como tener un conjunto de herramientas, donde puedes cambiar de herramienta según la tarea que necesites hacer, ¡sin cambiar la caja de herramientas en sí!

![Strategy design pattern](https://refactoring.guru/images/patterns/content/strategy/strategy.png)

#### 2. **Ejemplo:**

Piensa en una aplicación que calcula rutas. Puede calcular rutas para ir en coche, andando o en bicicleta. Con el patrón Strategy, crearíamos una "estrategia" para cada tipo de ruta.

```java
// 1. Interfaz Strategy: Define el método para calcular la ruta
interface RutaStrategy {
    void calcularRuta(String origen, String destino);
}

// 2. Estrategias Concretas: Implementan diferentes algoritmos de ruta
class RutaCocheStrategy implements RutaStrategy {
    @Override
    public void calcularRuta(String origen, String destino) {
        System.out.println("Calculando ruta en coche desde " + origen + " hasta " + destino);
        // Aquí iría la lógica para calcular rutas en coche
    }
}

class RutaAndandoStrategy implements RutaStrategy {
    @Override
    public void calcularRuta(String origen, String destino) {
        System.out.println("Calculando ruta andando desde " + origen + " hasta " + destino);
        // Aquí iría la lógica para calcular rutas andando
    }
}

// 3. Contexto: Usa la estrategia seleccionada
class CalculadorRutas {
    private RutaStrategy strategy;

    public void setStrategy(RutaStrategy strategy) {
        this.strategy = strategy;
    }

    public void calcular(String origen, String destino) {
        strategy.calcularRuta(origen, destino);
    }
}

// 4. Cliente: Elige y usa la estrategia
public class EjemploStrategy {
    public static void main(String[] args) {
        CalculadorRutas calculador = new CalculadorRutas();

        // Calcular ruta en coche
        calculador.setStrategy(new RutaCocheStrategy());
        calculador.calcular("Casa", "Trabajo");

        // Calcular ruta andando
        calculador.setStrategy(new RutaAndandoStrategy());
        calculador.calcular("Casa", "Parque");
    }
}
```

**Explicación del ejemplo:**

- **`RutaStrategy` (Interfaz Strategy):** Es como el contrato que dice "cualquier estrategia de ruta debe saber cómo `calcularRuta`".
- **`RutaCocheStrategy`, `RutaAndandoStrategy` (Estrategias Concretas):** Son las diferentes formas de calcular rutas. Cada una implementa `RutaStrategy` pero lo hace de manera diferente (coche vs. andando).
- **`CalculadorRutas` (Contexto):** Es quien realmente usa las estrategias. No le importa _cómo_ se calcula la ruta, solo que se pueda `calcularRuta`. Puede cambiar de estrategia fácilmente con `setStrategy`.
- **`EjemploStrategy` (Cliente):** Es quien decide _qué_ estrategia usar y se la pasa al `CalculadorRutas`.

#### 3. **Notas o advertencias:**

- **Flexibilidad:** La clave es que puedes cambiar la estrategia en tiempo de ejecución, ¡sin modificar el `CalculadorRutas`!
- **Código más limpio:** Evitas tener un montón de `if/else` o `switch` gigantes para elegir el algoritmo. Cada algoritmo está en su propia clase, fácil de entender y mantener.
- **Para principiantes:** Imagina que cada estrategia es como una "app" pequeña dentro de tu app principal. Puedes cambiar de "app" (estrategia) según lo que necesites.

## B - El Problema que Resuelve Strategy: Código Hinchado

#### 1. **Definicion:**

Imagina que tu programa principal se vuelve enorme y difícil de manejar porque tiene _muchas_ formas diferentes de hacer algo. Cada vez que añades una nueva forma, el código se hace más grande y confuso. Esto es como tener una mochila que se hincha y se hincha hasta que ya no puedes encontrar nada dentro. El patrón Strategy ayuda a "deshinchar" ese código.

![The code of the navigator became very bloated](https://refactoring.guru/images/patterns/diagrams/strategy/problem.png)

#### 2. **Ejemplo:**

Volvamos a la app de rutas. Si _no_ usáramos Strategy, podríamos tener una clase `Navigator` gigante con un método `calcularRuta` que contenga un montón de `if/else` para cada tipo de ruta:

```java
class Navigator {
    public void calcularRuta(String origen, String destino, String tipoRuta) {
        if (tipoRuta.equals("coche")) {
            System.out.println("Calculando ruta en coche...");
            // Lógica para ruta en coche
        } else if (tipoRuta.equals("andando")) {
            System.out.println("Calculando ruta andando...");
            // Lógica para ruta andando
        } else if (tipoRuta.equals("bici")) {
            System.out.println("Calculando ruta en bici...");
            // Lógica para ruta en bici
        } // ... ¡y más tipos de ruta!
    }
}

public class EjemploSinStrategy {
    public static void main(String[] args) {
        Navigator navigator = new Navigator();
        navigator.calcularRuta("Casa", "Trabajo", "coche");
        navigator.calcularRuta("Casa", "Parque", "andando");
    }
}
```

**Explicación del ejemplo:**

- **`Navigator` gigante:** La clase `Navigator` se vuelve muy larga y difícil de leer. Cada vez que quieras añadir un nuevo tipo de ruta (ej: transporte público), ¡tendrás que modificar esta clase gigante y añadir más `if/else`!
- **Riesgo de errores:** Modificar una clase tan grande aumenta el riesgo de romper algo que ya funcionaba.
- **Problemas en equipo:** Si varias personas trabajan en la misma clase gigante, ¡los problemas para combinar el código (merge conflicts) están garantizados!

#### 3. **Notas o advertencias:**

- **Código repetitivo:** A menudo, la lógica para diferentes algoritmos puede tener partes en común, pero en este enfoque "gigante" es más difícil reutilizar código.
- **Mantenimiento difícil:** Encontrar y corregir errores en una clase gigante es como buscar una aguja en un pajar.
- **Anticipación:** Piensa en Strategy cuando veas que tu clase empieza a crecer demasiado por tener muchas formas de hacer algo similar.

## C - La Solución Strategy: Divide y Vencerás

#### 1. **Definicion:**

El patrón Strategy nos dice: "Si tienes muchas formas de hacer algo, ¡sácalas de la clase principal y ponlas en clases separadas!". Así, la clase principal (Contexto) solo se encarga de _usar_ una de esas formas (Estrategias) sin preocuparse de _cómo_ funciona cada una por dentro. Es como organizar tus herramientas en cajas separadas: una caja para destornilladores, otra para llaves, etc. ¡Es mucho más fácil encontrar lo que necesitas!

![Route planning strategies](https://refactoring.guru/images/patterns/diagrams/strategy/solution.png)

#### 2. **Ejemplo:**

Ya vimos el ejemplo de la app de rutas con Strategy en la sección A. La clave es que:

- Cada tipo de ruta (`RutaCocheStrategy`, `RutaAndandoStrategy`, etc.) está en su propia clase.
- La clase `CalculadorRutas` (Contexto) _no sabe_ qué tipo de ruta está usando concretamente. Solo sabe que tiene una `RutaStrategy` y puede pedirle que `calcularRuta`.
- Podemos cambiar la estrategia de `CalculadorRutas` fácilmente con `setStrategy`.

```java
// (Código de ejemplo RutaStrategy, RutaCocheStrategy, RutaAndandoStrategy, CalculadorRutas  -  ¡Es el mismo que en la sección A!)

// ... Clase CalculadorRutas y interfaces RutaStrategy (ya definidos en la sección A) ...

public class EjemploStrategySolucion {
    public static void main(String[] args) {
        CalculadorRutas calculador = new CalculadorRutas();

        // Usando la estrategia de coche
        calculador.setStrategy(new RutaCocheStrategy());
        calculador.calcular("Oficina", "Casa");

        // Cambiando a la estrategia de andar ¡en tiempo de ejecución!
        calculador.setStrategy(new RutaAndandoStrategy());
        calculador.calcular("Oficina", "Parque");
    }
}
```

**Explicación del ejemplo:**

- **Clases pequeñas y enfocadas:** Cada clase de estrategia es pequeña y fácil de entender. Solo se encarga de _un_ algoritmo.
- **Contexto simple:** La clase `CalculadorRutas` se simplifica mucho. Ya no tiene un montón de `if/else`. Solo se preocupa de usar la estrategia que le den.
- **Fácil de extender:** Para añadir un nuevo tipo de ruta (ej: bici), solo tienes que crear una nueva clase que implemente `RutaStrategy` (ej: `RutaBiciStrategy`) y ¡listo! No tienes que tocar la clase `CalculadorRutas`.

#### 3. **Notas o advertencias:**

- **Separación de responsabilidades:** Cada clase tiene una tarea clara: las estrategias calculan rutas, el contexto las usa. Esto hace que el código sea más organizado.
- **Reutilización:** Si tienes lógica común entre diferentes estrategias, puedes crear clases base o utilidades para reutilizar ese código.
- **Pensar en interfaces:** La interfaz `RutaStrategy` es clave. Define el "contrato" que todas las estrategias deben seguir, permitiendo que el Contexto las use de forma intercambiable.

## D - Analogía del Mundo Real: Estrategias de Transporte

#### 1. **Definicion:**

Piensa en cómo te mueves de un lugar a otro. Tienes diferentes "estrategias" de transporte: coche, autobús, bicicleta, taxi, andar... Cada estrategia tiene sus pros y sus contras (coste, tiempo, comodidad...). El patrón Strategy es como tener la opción de elegir la estrategia de transporte que mejor se adapte a tus necesidades en cada momento.

![Various transportation strategies](https://refactoring.guru/images/patterns/content/strategy/strategy-comic-1-en.png)

#### 2. **Ejemplo:**

Imagina que necesitas ir al aeropuerto. Tus estrategias podrían ser:

- **Taxi:** Rápido, cómodo, pero caro.
- **Autobús:** Más barato, pero más lento y menos cómodo.
- **Coche propio:** Depende del tráfico, coste de parking, etc.
- **Bicicleta:** Económico, saludable, pero solo si el aeropuerto no está muy lejos y el tiempo es bueno.

Tú (el Cliente) decides qué estrategia (taxi, autobús, bici...) usar dependiendo de tus prioridades (tiempo, dinero, ganas de hacer ejercicio...). La "aplicación" que te lleva al aeropuerto (el Contexto) no le importa _cómo_ llegues, solo que llegues. Simplemente usa la estrategia que tú le digas.

#### 3. **Notas o advertencias:**

- **Elección flexible:** Puedes cambiar de estrategia de transporte (taxi a autobús) en cualquier momento, según cambien tus circunstancias.
- **Cada estrategia es diferente:** Cada forma de transporte (estrategia) tiene su propia forma de funcionar, pero todas te llevan al mismo destino (cumplen el mismo objetivo).
- **Analogía simple:** Esta analogía te ayuda a entender la idea de tener diferentes algoritmos (estrategias) intercambiables.

## E - Estructura del Patrón Strategy: Las Piezas Clave

#### 1. **Definicion:**

El patrón Strategy tiene cuatro partes principales, como los ingredientes de una receta:

1.  **Contexto:** Es la clase que quiere usar un algoritmo, pero no quiere implementarlo directamente. Tiene un "hueco" donde puede "enchufar" diferentes estrategias.
2.  **Interfaz Strategy:** Define el "contrato" que todas las estrategias deben seguir. Dice qué método(s) deben implementar las estrategias para que el Contexto pueda usarlas.
3.  **Estrategias Concretas:** Son las clases que implementan la Interfaz Strategy. Cada una implementa el algoritmo de una manera diferente.
4.  **Cliente:** Es quien elige qué Estrategia Concreta usar y se la pasa al Contexto.

![Structure of the Strategy design pattern](https://refactoring.guru/images/patterns/diagrams/strategy/structure.png)
![Structure of the Strategy design pattern](https://refactoring.guru/images/patterns/diagrams/strategy/structure-indexed.png)

#### 2. **Ejemplo (Relacionado con la imagen):**

- **1. Contexto (Context):** En nuestro ejemplo de rutas, sería la clase `CalculadorRutas`. Mantiene una referencia a una `RutaStrategy`.
- **2. Interfaz Strategy (Strategy):** Sería la interfaz `RutaStrategy` con el método `calcularRuta()`.
- **3. Estrategias Concretas (Concrete Strategies):** Serían las clases `RutaCocheStrategy`, `RutaAndandoStrategy`, etc. Cada una implementa `calcularRuta()` de forma diferente.
- **5. Cliente (Client):** Sería la clase `EjemploStrategy` (o cualquier parte del código que use `CalculadorRutas`). Crea las estrategias concretas (ej: `new RutaCocheStrategy()`) y las "enchufa" en el Contexto (`calculador.setStrategy(...)`).

#### 3. **Notas o advertencias:**

- **Comunicación:** El Contexto solo se comunica con las Estrategias a través de la Interfaz Strategy. No sabe qué estrategia concreta está usando.
- **Intercambiabilidad:** Gracias a la Interfaz Strategy, puedes cambiar de una Estrategia Concreta a otra en tiempo de ejecución, ¡sin que el Contexto se entere!
- **Setter para la estrategia:** El Contexto suele tener un método `setStrategy()` para que el Cliente pueda cambiar la estrategia que se está usando.

## F - Pseudocódigo en Java: Operaciones Matemáticas con Estrategias

#### 1. **Definicion:**

Vamos a ver un ejemplo sencillo en pseudocódigo (adaptado a Java) para entender mejor cómo funciona el patrón Strategy en código. En este ejemplo, usaremos estrategias para realizar diferentes operaciones matemáticas: sumar, restar y multiplicar.

#### 2. **Ejemplo:**

```java
// 1. Interfaz Strategy: OperacionStrategy
interface OperacionStrategy {
    int ejecutar(int a, int b);
}

// 2. Estrategias Concretas: Sumar, Restar, Multiplicar
class SumarStrategy implements OperacionStrategy {
    @Override
    public int ejecutar(int a, int b) {
        return a + b;
    }
}

class RestarStrategy implements OperacionStrategy {
    @Override
    public int ejecutar(int a, int b) {
        return a - b;
    }
}

class MultiplicarStrategy implements OperacionStrategy {
    @Override
    public int ejecutar(int a, int b) {
        return a * b;
    }
}

// 3. Contexto: CalculadoraContext
class CalculadoraContext {
    private OperacionStrategy strategy;

    public void setStrategy(OperacionStrategy strategy) {
        this.strategy = strategy;
    }

    public int realizarOperacion(int a, int b) {
        return strategy.ejecutar(a, b);
    }
}

// 4. Cliente: EjemploAplicacion
public class EjemploAplicacion {
    public static void main(String[] args) {
        CalculadoraContext context = new CalculadoraContext();

        int num1 = 10;
        int num2 = 5;

        // Sumar
        context.setStrategy(new SumarStrategy());
        int resultadoSuma = context.realizarOperacion(num1, num2);
        System.out.println(num1 + " + " + num2 + " = " + resultadoSuma); // Output: 10 + 5 = 15

        // Restar
        context.setStrategy(new RestarStrategy());
        int resultadoResta = context.realizarOperacion(num1, num2);
        System.out.println(num1 + " - " + num2 + " = " + resultadoResta); // Output: 10 - 5 = 5

        // Multiplicar
        context.setStrategy(new MultiplicarStrategy());
        int resultadoMultiplicacion = context.realizarOperacion(num1, num2);
        System.out.println(num1 + " * " + num2 + " = " + resultadoMultiplicacion); // Output: 10 * 5 = 50
    }
}
```

**Explicación del ejemplo:**

- **`OperacionStrategy`:** La interfaz define la operación `ejecutar(a, b)`.
- **`SumarStrategy`, `RestarStrategy`, `MultiplicarStrategy`:** Cada clase implementa `OperacionStrategy` para realizar una operación matemática diferente.
- **`CalculadoraContext`:** El Contexto usa una `OperacionStrategy` para `realizarOperacion(a, b)`.
- **`EjemploAplicacion`:** El Cliente elige qué operación realizar cambiando la estrategia en el Contexto.

#### 3. **Notas o advertencias:**

- **Ejemplo simple:** Este ejemplo es muy sencillo, pero muestra claramente la estructura del patrón Strategy.
- **Intercambio de algoritmos:** Puedes cambiar la operación matemática (estrategia) fácilmente en tiempo de ejecución.
- **Claridad del código:** Cada operación está en su propia clase, haciendo el código más fácil de entender y mantener.

## G - Cuándo Usar Strategy: Aplicabilidad

#### 1. **Definicion:**

Usa el patrón Strategy cuando te encuentres en estas situaciones:

- **Algoritmos intercambiables:** Necesitas usar diferentes versiones de un algoritmo dentro de un objeto y poder cambiar entre ellas en tiempo de ejecución.
- **Muchas clases similares:** Tienes muchas clases que hacen casi lo mismo, pero con pequeñas diferencias en cómo ejecutan alguna parte de su trabajo.
- **Aislar lógica de negocio:** Quieres separar la lógica principal de tu clase de los detalles de implementación de algoritmos que pueden cambiar.
- **Condicionales gigantes:** Tu clase tiene un `if/else` o `switch` enorme para elegir entre diferentes algoritmos.

#### 2. **Ejemplos de Aplicabilidad (basados en el texto):**

- **App de navegación (ejemplo principal):** Diferentes algoritmos de ruta (coche, andando, bici) intercambiables.
- **Procesamiento de pagos:** Diferentes métodos de pago (tarjeta de crédito, PayPal, transferencia bancaria) como estrategias.
- **Compresión de datos:** Diferentes algoritmos de compresión (ZIP, RAR, 7z) intercambiables.
- **Validación de datos:** Diferentes reglas de validación (email, teléfono, código postal) como estrategias.
- **Ordenamiento de listas:** Diferentes algoritmos de ordenamiento (Bubble Sort, Quick Sort, Merge Sort) como estrategias.

#### 3. **Notas o advertencias:**

- **No siempre es necesario:** Si solo tienes un par de algoritmos que rara vez cambian, puede que Strategy sea "demasiado" para tu problema. No sobrecompliques el código si no es necesario.
- **Cliente consciente:** El Cliente debe saber qué estrategias hay disponibles para elegir la adecuada.
- **Alternativas:** En algunos casos, funciones anónimas o lambdas (en lenguajes que las soportan) pueden ser una alternativa más sencilla a Strategy, especialmente si las estrategias son muy simples.

## H - Cómo Implementar Strategy: Paso a Paso

#### 1. **Definicion:**

Aquí tienes los pasos para implementar el patrón Strategy:

1.  **Identifica el algoritmo variable:** Encuentra en tu clase el código que cambia con frecuencia o el `if/else` gigante que elige entre algoritmos.
2.  **Crea la Interfaz Strategy:** Define una interfaz común para todos los algoritmos. Esta interfaz debe tener un método (o métodos) que el Contexto usará para ejecutar el algoritmo.
3.  **Crea Estrategias Concretas:** Para cada algoritmo diferente, crea una clase que implemente la Interfaz Strategy. Pon la lógica específica de cada algoritmo en estas clases.
4.  **Añade un campo de estrategia al Contexto:** En la clase Contexto, añade un campo para guardar una referencia a un objeto Strategy. Crea un método `setStrategy()` para que el Cliente pueda cambiar la estrategia.
5.  **Usa la estrategia en el Contexto:** En lugar de implementar los algoritmos directamente en el Contexto, delega la ejecución del algoritmo al objeto Strategy que tengas guardado.
6.  **El Cliente elige la estrategia:** En el código del Cliente, crea las Estrategias Concretas que necesites y pásalas al Contexto usando `setStrategy()`.

#### 2. **Ejemplo (Resumen de pasos con ejemplo de rutas):**

1.  **Algoritmo variable:** El cálculo de rutas en la clase `Navigator` (en el ejemplo del problema).
2.  **Interfaz Strategy:** `RutaStrategy` con el método `calcularRuta()`.
3.  **Estrategias Concretas:** `RutaCocheStrategy`, `RutaAndandoStrategy`, etc.
4.  **Campo de estrategia en Contexto:** `private RutaStrategy strategy;` y `setStrategy()` en `CalculadorRutas`.
5.  **Usar estrategia en Contexto:** `strategy.calcularRuta(origen, destino);` en `CalculadorRutas.calcular()`.
6.  **Cliente elige estrategia:** `calculador.setStrategy(new RutaCocheStrategy());` en `EjemploStrategy`.

#### 3. **Notas o advertencias:**

- **Empieza por identificar:** El paso más importante es identificar claramente qué parte de tu código quieres hacer flexible y variable.
- **Interfaz clara:** Diseña la Interfaz Strategy de forma que sea lo suficientemente general para todas las estrategias, pero también lo suficientemente específica para que el Contexto pueda usarla fácilmente.
- **Refactorización gradual:** Si ya tienes código existente, puedes refactorizarlo gradualmente para aplicar el patrón Strategy, paso a paso.

## I - Pros y Contras de Strategy: Ventajas y Desventajas

#### 1. **Definicion:**

Como todo patrón de diseño, Strategy tiene sus ventajas y desventajas. Es importante conocerlas para decidir si es la mejor opción para tu problema.

#### 2. **Pros (Ventajas):**

- **Intercambio de algoritmos en tiempo de ejecución:** Puedes cambiar el algoritmo que usa un objeto mientras el programa está funcionando. ¡Mucha flexibilidad!
- **Aislamiento de la implementación del algoritmo:** Los detalles de cómo funciona cada algoritmo están escondidos dentro de sus propias clases. El código que usa el algoritmo no necesita saber cómo funciona por dentro.
- **Composición en lugar de herencia:** En lugar de usar herencia para crear diferentes variantes de un algoritmo, usas composición (tener objetos Strategy dentro del Contexto). Esto suele ser más flexible.
- **Principio Abierto/Cerrado:** Puedes añadir nuevas estrategias sin tener que modificar el Contexto. El código está "abierto" a la extensión pero "cerrado" a la modificación.

#### 3. **Contras (Desventajas):**

- **Sobrecomplicación (si no es necesario):** Si solo tienes unos pocos algoritmos simples que no cambian mucho, usar Strategy puede ser "exagerado" y añadir más clases e interfaces de las necesarias.
- **Cliente consciente de las estrategias:** El Cliente tiene que saber qué estrategias hay disponibles y cómo elegir la adecuada. A veces, esto puede hacer que el Cliente sea más complejo.
- **Alternativas más simples:** En algunos casos, funciones anónimas o lambdas pueden ser una forma más sencilla de implementar diferentes algoritmos, sin necesidad de crear tantas clases.

#### 4. **Notas o advertencias:**

- **Evalúa la necesidad:** Antes de usar Strategy, pregúntate si realmente necesitas la flexibilidad de intercambiar algoritmos en tiempo de ejecución. Si no, puede que haya soluciones más simples.
- **Complejidad vs. Mantenimiento:** Strategy puede añadir un poco de complejidad inicial al código, pero a la larga puede hacer que el código sea más fácil de mantener y extender.
- **Considera el contexto:** Piensa en el contexto de tu proyecto. ¿Es un proyecto grande y complejo donde la flexibilidad es importante? ¿O es un proyecto pequeño y sencillo donde la simplicidad es clave?

## J - Relación con Otros Patrones: Conexiones y Diferencias

#### 1. **Definicion:**

El patrón Strategy se parece a otros patrones de diseño en algunos aspectos, pero también tiene diferencias importantes. Entender estas relaciones te ayuda a elegir el patrón adecuado para cada situación.

#### 2. **Relaciones (basadas en el texto):**

- **Bridge, State, Adapter:** Estos patrones, como Strategy, se basan en la composición (delegar trabajo a otros objetos). Comparten una estructura similar, pero resuelven problemas diferentes. Lo importante es entender _qué problema_ resuelve cada patrón.
- **Command:** Command y Strategy pueden parecerse porque ambos permiten "parametrizar" un objeto con una acción. Pero:
  - **Command:** Convierte _cualquier_ operación en un objeto. Sirve para retrasar la ejecución, encolar operaciones, deshacer/rehacer, etc.
  - **Strategy:** Se centra en diferentes _formas_ de hacer _lo mismo_. Permite intercambiar algoritmos dentro de un Contexto.
- **Decorator:**
  - **Decorator:** Cambia la "apariencia" de un objeto, añadiendo funcionalidades extra "por fuera".
  - **Strategy:** Cambia las "tripas" de un objeto, cambiando el algoritmo que usa "por dentro".
- **Template Method:**
  - **Template Method:** Se basa en la _herencia_. Define un algoritmo "esqueleto" en una clase base y deja que las subclases implementen partes específicas. Es _estático_ (se decide en tiempo de compilación).
  - **Strategy:** Se basa en la _composición_. Permite cambiar el algoritmo en _tiempo de ejecución_.
- **State:**
  - **State:** Puede verse como una extensión de Strategy. También usa composición para cambiar el comportamiento de un Contexto delegando en objetos "estado".
  - **Strategy:** Las estrategias son independientes entre sí.
  - **State:** Los estados pueden estar relacionados y cambiar el estado del Contexto.

#### 3. **Notas o advertencias:**

- **No te centres solo en la estructura:** Muchos patrones comparten estructuras similares. Lo importante es entender el _problema_ que cada patrón está diseñado para resolver.
- **Elige el patrón adecuado:** Piensa en _qué quieres lograr_ y _qué problema estás intentando resolver_ antes de elegir un patrón. No uses un patrón solo porque "suena bien".
- **Combina patrones:** A veces, puedes combinar diferentes patrones para resolver problemas más complejos. Por ejemplo, podrías usar Strategy y Decorator juntos.
