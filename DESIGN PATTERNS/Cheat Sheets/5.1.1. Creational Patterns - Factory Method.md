## A - Factory Method

#### 1. **Definición:**

El **Factory Method** es un patrón de diseño de creación que te da una forma de crear objetos en una clase padre, pero dejando que las clases hijas decidan exactamente qué tipo de objetos se crearán. Imagina que la clase padre dice "Yo sé _cómo_ crear objetos, pero _qué_ objeto crear, lo decides tú, clase hija".

#### 2. **Ejemplo:**

```java
// Interfaz común para todos los productos (Transporte)
interface Transport {
    void deliver();
}

// Productos concretos (Camión y Barco)
class Truck implements Transport {
    @Override
    public void deliver() {
        System.out.println("Entrega por tierra en camión");
    }
}

class Ship implements Transport {
    @Override
    public void deliver() {
        System.out.println("Entrega por mar en barco");
    }
}

// Creador abstracto (Logística)
abstract class Logistics {
    // Método fábrica: las subclases decidirán qué tipo de transporte crear
    public abstract Transport createTransport();

    public void planDelivery() {
        Transport transport = createTransport();
        transport.deliver();
    }
}

// Creadores concretos (Logística por Carretera y Logística Marítima)
class RoadLogistics extends Logistics {
    @Override
    public Transport createTransport() {
        return new Truck(); // Crea un camión
    }
}

class SeaLogistics extends Logistics {
    @Override
    public Transport createTransport() {
        return new Ship(); // Crea un barco
    }
}

// Ejemplo de uso
public class FactoryMethodExample {
    public static void main(String[] args) {
        Logistics roadLogistics = new RoadLogistics();
        roadLogistics.planDelivery(); // Imprime: Entrega por tierra en camión

        Logistics seaLogistics = new SeaLogistics();
        seaLogistics.planDelivery(); // Imprime: Entrega por mar en barco
    }
}
```

**Explicación del ejemplo:**

Tenemos una interfaz `Transport` que define qué hace un transporte (entregar). Luego, tenemos dos tipos de transporte concretos: `Truck` (camión) y `Ship` (barco), cada uno entregando de manera diferente.

La clase `Logistics` es el "Creador". Tiene un método importante llamado `createTransport()`, que es un **Factory Method**. Fíjate que `createTransport()` es `abstract`, lo que significa que la clase `Logistics` no decide _qué_ transporte crear.

Las clases `RoadLogistics` y `SeaLogistics` son "Creadores Concretos". Cada una de ellas **extiende** `Logistics` y **especifica** en `createTransport()` qué tipo de transporte crear: `RoadLogistics` crea `Truck` y `SeaLogistics` crea `Ship`.

En `main`, cuando usamos `roadLogistics.planDelivery()`, internamente se llama a `createTransport()` de `RoadLogistics` que crea un `Truck`. Lo mismo pasa con `seaLogistics`, pero creando un `Ship`.

#### 3. **Notas o advertencias:**

- **Flexibilidad:** El Factory Method te da mucha flexibilidad. Si necesitas añadir un nuevo tipo de transporte (ej: avión), solo tienes que crear una nueva clase de transporte (`Airplane`) y una nueva clase de logística (`AirLogistics`) que cree aviones en su Factory Method. ¡No tienes que cambiar el código existente!
- **Interfaz común:** Es crucial que todos los productos (en este caso, `Truck` y `Ship`) implementen la misma interfaz (`Transport`). Así, el código que usa estos productos (como `planDelivery()` en `Logistics`) no tiene que preocuparse por el tipo concreto de transporte, solo sabe que puede llamar al método `deliver()`.

---

## B - Intención del Factory Method

#### 1. **Definición:**

La **intención** principal del Factory Method es definir una interfaz para crear un objeto, pero dejar que las subclases decidan qué clase concreta instanciar. Es como decir: "Yo sé cómo hacer un juguete, pero tú dime si quieres un coche, un barco o un avión".

#### 2. **Ejemplo:**

Imagina una aplicación para dibujar figuras geométricas. Tienes una clase base `Shape` y subclases como `Circle`, `Square` y `Triangle`. Quieres que la aplicación pueda crear diferentes formas según la necesidad, pero sin que el código que usa las formas tenga que saber _exactamente_ qué clase crear en cada momento.

```java
// Interfaz común para todas las formas
interface Shape {
    void draw();
}

// Formas concretas
class Circle implements Shape {
    @Override
    public void draw() {
        System.out.println("Dibujando un círculo");
    }
}

class Square implements Shape {
    @Override
    public void draw() {
        System.out.println("Dibujando un cuadrado");
    }
}

// Creador abstracto: ShapeFactory
abstract class ShapeFactory {
    public abstract Shape createShape(); // Factory Method

    public void drawShape() {
        Shape shape = createShape();
        shape.draw();
    }
}

// Creadores concretos: CircleFactory y SquareFactory
class CircleFactory extends ShapeFactory {
    @Override
    public Shape createShape() {
        return new Circle();
    }
}

class SquareFactory extends ShapeFactory {
    @Override
    public Shape createShape() {
        return new Square();
    }
}

// Ejemplo de uso
public class FactoryMethodIntentExample {
    public static void main(String[] args) {
        ShapeFactory circleFactory = new CircleFactory();
        circleFactory.drawShape(); // Imprime: Dibujando un círculo

        ShapeFactory squareFactory = new SquareFactory();
        squareFactory.drawShape(); // Imprime: Dibujando un cuadrado
    }
}
```

**Explicación del ejemplo:**

Aquí, `ShapeFactory` es el creador abstracto con el Factory Method `createShape()`. `CircleFactory` y `SquareFactory` son creadores concretos que deciden si crear un `Circle` o un `Square`. El código cliente (en `main`) usa las fábricas para crear y dibujar formas sin saber los detalles de la creación.

#### 3. **Notas o advertencias:**

- **"Constructor Virtual":** A veces se le llama "Constructor Virtual" porque el Factory Method se comporta un poco como un constructor virtual. En lugar de usar `new ClaseConcreta()`, usas `factory.createObjeto()` y la "fábrica" (el creador concreto) decide qué clase concreta construir.
- **Desacoplamiento:** El Factory Method ayuda a desacoplar el código que _usa_ los objetos del código que _crea_ los objetos. Esto hace que tu código sea más flexible y fácil de mantener.

---

## C - Problema que resuelve el Factory Method

#### 1. **Definición:**

El Factory Method es útil cuando tienes un código que necesita trabajar con diferentes tipos de objetos, pero no quieres que este código dependa de _cómo_ se crean esos objetos o de _qué tipo concreto_ son. El problema surge cuando tu código se vuelve rígido y difícil de extender porque está muy ligado a la creación de objetos específicos.

#### 2. **Ejemplo:**

Volvamos al ejemplo de la logística. Imagina que tu aplicación de logística inicialmente solo manejaba camiones (`Truck`). Todo tu código está escrito pensando en camiones.

```java
class Truck {
    public void deliver() {
        System.out.println("Entrega por tierra en camión");
    }
}

class LogisticsApp {
    public void planDelivery() {
        Truck truck = new Truck(); // Creación directa de Truck
        truck.deliver();
        // ... más lógica específica de camiones ...
    }
}
```

Ahora, necesitas añadir barcos (`Ship`). Si tu código está lleno de `new Truck()`, tendrías que modificar muchas partes para añadir soporte para `Ship`. Esto puede llevar a un código confuso y lleno de `if`s para decidir si usar `Truck` o `Ship`.

**Problema:** Añadir un nuevo tipo de transporte (como `Ship`) requiere cambiar mucho código existente que ya estaba funcionando bien con `Truck`.

![Adding a new transportation class to the program causes an issue](https://refactoring.guru/images/patterns/diagrams/factory-method/problem1-en.png)

#### 3. **Notas o advertencias:**

- **Código acoplado:** El problema principal es el **acoplamiento**. Tu clase `LogisticsApp` está _acoplada_ a la clase `Truck` porque crea objetos `Truck` directamente. Si quieres cambiar el tipo de transporte, tienes que cambiar `LogisticsApp`.
- **Mantenimiento difícil:** Si sigues añadiendo más tipos de transporte (trenes, aviones, etc.) y modificando `LogisticsApp` cada vez, el código se volverá muy difícil de mantener y entender.

---

## D - Solución: El Factory Method

#### 1. **Definición:**

El Factory Method **soluciona** el problema de acoplamiento reemplazando la creación directa de objetos (`new Truck()`) con llamadas a un **método fábrica**. Este método fábrica se encarga de crear los objetos, y las subclases pueden **redefinir** este método para crear diferentes tipos de objetos.

#### 2. **Ejemplo:**

Usando el Factory Method en el ejemplo de logística, la clase `LogisticsApp` ya no crea `Truck` directamente. En su lugar, llama a un método fábrica (`createTransport()`) para obtener un objeto de transporte.

```java
// (Interfaz Transport y clases Truck y Ship como en el ejemplo A)

// Creador abstracto (Logistics) -  igual que en el ejemplo A
abstract class Logistics {
    public abstract Transport createTransport(); // Factory Method

    public void planDelivery() {
        Transport transport = createTransport(); // Usa el Factory Method
        transport.deliver();
    }
}

// Creadores concretos (RoadLogistics y SeaLogistics) - igual que en el ejemplo A
class RoadLogistics extends Logistics {
    @Override
    public Transport createTransport() {
        return new Truck();
    }
}

class SeaLogistics extends Logistics {
    @Override
    public Transport createTransport() {
        return new Ship();
    }
}

// Ejemplo de uso - similar al ejemplo A
public class FactoryMethodSolutionExample {
    public static void main(String[] args) {
        Logistics roadLogistics = new RoadLogistics();
        roadLogistics.planDelivery();

        Logistics seaLogistics = new SeaLogistics();
        seaLogistics.planDelivery();
    }
}
```

**Explicación del ejemplo:**

Ahora, `LogisticsApp` (en este caso, la clase `Logistics` y sus subclases) ya no está acoplada a `Truck` o `Ship` directamente. `planDelivery()` llama a `createTransport()`, y son las **subclases** (`RoadLogistics`, `SeaLogistics`) las que deciden si `createTransport()` crea un `Truck` o un `Ship`.

![The structure of creator classes](https://refactoring.guru/images/patterns/diagrams/factory-method/solution1.png)

#### 3. **Notas o advertencias:**

- **Inversión de control:** El Factory Method **invierte el control** de la creación de objetos. En lugar de que la clase `Logistics` controle directamente _cómo_ se crean los transportes, delega esa responsabilidad a sus subclases.
- **Código más flexible:** Ahora, añadir un nuevo tipo de transporte es mucho más fácil. Solo necesitas crear una nueva clase de transporte (ej: `Airplane`) y una nueva clase de logística (ej: `AirLogistics`) que cree aviones en su Factory Method. No tienes que modificar la clase `Logistics` ni el código que usa la clase `Logistics`.

---

## E - Productos y Creadores

#### 1. **Definición:**

En el Factory Method, hablamos de dos roles principales:

- **Productos:** Son los objetos que se crean. En el ejemplo de logística, `Truck` y `Ship` son productos. Todos los productos deben seguir una **interfaz común** (como `Transport`).
- **Creadores:** Son las clases que contienen el Factory Method y que saben _cómo_ usar los productos. En el ejemplo, `Logistics` es el creador abstracto, y `RoadLogistics` y `SeaLogistics` son creadores concretos.

#### 2. **Ejemplo:**

En el ejemplo del pseudocódigo de la interfaz de usuario (UI):

- **Productos:** `Button` (interfaz), `WindowsButton`, `HTMLButton` (productos concretos).
- **Creadores:** `Dialog` (creador abstracto), `WindowsDialog`, `WebDialog` (creadores concretos).

![The structure of the products hierarchy](https://refactoring.guru/images/patterns/diagrams/factory-method/solution2-en.png)

#### 3. **Notas o advertencias:**

- **Interfaz de Producto:** La interfaz de producto (`Transport`, `Button`, `Shape`) es crucial. Permite que el código del creador (ej: `planDelivery()`, `render()` en `Dialog`) funcione con cualquier producto concreto sin tener que saber su tipo específico.
- **Responsabilidad del Creador:** Ojo, la responsabilidad principal del creador **no es crear productos**. El creador suele tener otra lógica de negocio importante que _usa_ los productos. El Factory Method simplemente le ayuda a obtener los productos de la manera correcta, sin acoplarse a la creación específica. Piensa en una empresa de software: su trabajo principal es hacer software, no formar programadores, aunque tenga un departamento de formación.

---

## F - Estructura del Factory Method

#### 1. **Definición:**

La estructura del Factory Method se compone de los siguientes elementos:

1.  **Producto (Product):** Define la interfaz común para todos los objetos que se pueden crear.
2.  **Producto Concreto (Concrete Product):** Son las implementaciones específicas de la interfaz de Producto.
3.  **Creador (Creator):** Declara el Factory Method que devuelve un objeto Producto. Puede ser abstracto o tener una implementación por defecto.
4.  **Creador Concreto (Concrete Creator):** Hereda del Creador y redefine el Factory Method para devolver un tipo específico de Producto Concreto.

![The structure of the Factory Method pattern](https://refactoring.guru/images/patterns/diagrams/factory-method/structure.png)
![The structure of the Factory Method pattern](https://refactoring.guru/images/patterns/diagrams/factory-method/structure-indexed.png)

#### 2. **Ejemplo:**

Usando la estructura numerada de la imagen "structure-indexed.png":

1.  **Producto:** `Button` (interfaz)
2.  **Productos Concretos:** `WindowsButton`, `HTMLButton`
3.  **Creador:** `Dialog` (clase abstracta)
4.  **Creadores Concretos:** `WindowsDialog`, `WebDialog`

#### 3. **Notas o advertencias:**

- **Factory Method Abstracto vs. Concreto:** El Factory Method en el Creador puede ser `abstract` (obligando a las subclases a implementarlo) o tener una implementación por defecto (si hay un producto "por defecto").
- **No siempre crea objetos nuevos:** El Factory Method no siempre tiene que crear un objeto nuevo cada vez. Puede devolver objetos existentes de una caché, un pool de objetos, etc. Esto es útil para ahorrar recursos.

---

## G - Pseudocódigo del Factory Method

#### 1. **Definición:**

El pseudocódigo muestra un ejemplo de cómo usar el Factory Method para crear elementos de UI multiplataforma (botones) sin que el código cliente dependa de las clases concretas de UI.

![The structure of the Factory Method pattern example](https://refactoring.guru/images/patterns/diagrams/factory-method/example.png)

#### 2. **Ejemplo:**

El pseudocódigo proporcionado en el texto ilustra la creación de `Dialog`s y `Button`s para diferentes sistemas operativos (Windows y Web).

```pseudocode
// (Pseudocódigo del texto original)
// ... (Clases Dialog, WindowsDialog, WebDialog, Button, WindowsButton, HTMLButton, Application) ...
```

**Explicación del ejemplo del pseudocódigo:**

- `Dialog` es el creador abstracto con el Factory Method `createButton()`.
- `WindowsDialog` y `WebDialog` son creadores concretos que crean `WindowsButton` y `HTMLButton` respectivamente.
- `Button` es la interfaz de producto.
- `WindowsButton` y `HTMLButton` son productos concretos.
- `Application` decide qué tipo de `Dialog` crear (y por lo tanto, qué tipo de `Button` se usará) basándose en la configuración del sistema operativo.

#### 3. **Notas o advertencias:**

- **Abstracción de la UI:** El ejemplo muestra cómo el Factory Method permite abstraer la creación de elementos de UI. El código de `Dialog` funciona con `Button`s abstractos, sin importar si son botones de Windows o botones web.
- **Acercándose al Abstract Factory:** El texto menciona que si añades más Factory Methods a `Dialog` para crear otros elementos de UI (ej: menús, ventanas), te acercas al patrón Abstract Factory. El Abstract Factory es como una "fábrica de fábricas" que crea familias completas de objetos relacionados.

---

## H - Aplicabilidad del Factory Method

#### 1. **Definición:**

Usa el Factory Method cuando:

1.  **No sabes de antemano los tipos exactos de objetos** que tu código necesita usar. Quieres que las subclases decidan qué tipos se instanciarán.
2.  Quieres dar a los usuarios de tu librería o framework una forma de **extender sus componentes internos**.
3.  Quieres **reutilizar objetos existentes** para ahorrar recursos del sistema.

#### 2. **Ejemplos de cuándo usarlo:**

1.  **Tipos de objetos desconocidos:** Como en el ejemplo de la logística, no sabes de antemano si vas a usar camiones, barcos o aviones. El Factory Method te permite decidirlo en tiempo de ejecución o en subclases.
2.  **Extensión de frameworks:** Si creas un framework UI, puedes usar Factory Methods para permitir a los usuarios crear sus propios estilos de botones, ventanas, etc., sin modificar el código del framework. El ejemplo de `RoundButton` extendiendo `Button` y `UIWithRoundButtons` extendiendo `UIFramework` ilustra esto.
3.  **Reutilización de objetos:** Para conexiones a bases de datos, sistemas de archivos, etc., crear y destruir objetos puede ser costoso. El Factory Method puede implementar un "pool de objetos" para reutilizar instancias existentes en lugar de crear nuevas cada vez.

#### 3. **Notas o advertencias:**

- **Flexibilidad vs. Complejidad:** El Factory Method añade flexibilidad, pero también puede aumentar la complejidad del código al introducir más clases y subclases.
- **Alternativas:** Considera otros patrones de creación como Abstract Factory, Builder o Prototype si el Factory Method no se ajusta bien a tu problema.

---

## I - Cómo implementar el Factory Method

#### 1. **Definición:**

Pasos para implementar el Factory Method:

1.  **Interfaz de Producto:** Crea una interfaz común para todos los productos.
2.  **Factory Method en el Creador:** Añade un Factory Method (inicialmente vacío o con una implementación por defecto) en la clase Creador. El tipo de retorno debe ser la interfaz de Producto.
3.  **Reemplazar `new` con el Factory Method:** Busca todas las creaciones directas de productos (`new ProductoConcreto()`) en el código del Creador y reemplázalas con llamadas al Factory Method. Mueve el código de creación de productos al Factory Method.
4.  **Creadores Concretos:** Crea subclases del Creador para cada tipo de producto. Redefine el Factory Method en cada subclase para que cree el producto concreto correspondiente.
5.  **Parámetro de Control (Opcional):** Si tienes muchos tipos de productos y no quieres crear una subclase para cada uno, puedes añadir un parámetro al Factory Method para controlar qué tipo de producto crear.
6.  **Factory Method Abstracto (Opcional):** Si el Factory Method base queda vacío después de mover el código a las subclases, puedes hacerlo `abstract`.

#### 2. **Ejemplo (Pasos simplificados):**

Imagina que tienes una clase `Document` y quieres poder crear diferentes tipos de documentos (`Report`, `Article`).

1.  **Interfaz de Producto:**
    ```java
    interface Document {
        void open();
    }
    ```
2.  **Factory Method en el Creador:**

    ```java
    abstract class DocumentCreator {
        public abstract Document createDocument(); // Factory Method

        public void openDocument() {
            Document doc = createDocument();
            doc.open();
        }
    }
    ```

3.  **Creadores Concretos:**

    ```java
    class ReportCreator extends DocumentCreator {
        @Override
        public Document createDocument() {
            return new Report(); // Suponiendo que Report implementa Document
        }
    }

    class ArticleCreator extends DocumentCreator {
        @Override
        public Document createDocument() {
            return new Article(); // Suponiendo que Article implementa Document
        }
    }
    ```

#### 3. **Notas o advertencias:**

- **Refactorización gradual:** Implementar el Factory Method suele ser un proceso de refactorización gradual. Empieza identificando los puntos de creación de objetos y moviéndolos al Factory Method paso a paso.
- **Complejidad inicial:** Al principio, el Factory Method puede parecer más complicado que la creación directa de objetos, pero a largo plazo, facilita la extensión y el mantenimiento del código.

---

## J - Pros y Contras del Factory Method

#### 1. **Definición:**

**Pros (Ventajas):**

- **Desacoplamiento:** Evitas el acoplamiento fuerte entre el creador y los productos concretos. El código depende de abstracciones (interfaces) en lugar de implementaciones concretas.
- **Principio de Responsabilidad Única:** Mueves el código de creación de productos a un solo lugar (el Factory Method), facilitando el mantenimiento y la modificación.
- **Principio Abierto/Cerrado:** Puedes añadir nuevos tipos de productos sin modificar el código cliente existente. Solo necesitas crear nuevos creadores concretos.

**Cons (Desventajas):**

- **Complejidad:** Puede aumentar la complejidad del código al introducir más clases y subclases.
- **Jerarquía de Clases:** A veces, puede llevar a crear jerarquías de clases de creadores paralelas a las jerarquías de clases de productos, lo que puede ser confuso si no se gestiona bien.

#### 2. **Ejemplo (Pros):**

- **Desacoplamiento:** En el ejemplo de logística, `Logistics` no depende de `Truck` o `Ship` directamente.
- **Responsabilidad Única:** La lógica de creación de transportes está centralizada en los Factory Methods de `RoadLogistics` y `SeaLogistics`.
- **Abierto/Cerrado:** Añadir `Airplane` y `AirLogistics` no requiere cambiar `Logistics` ni el código que usa `Logistics`.

#### 3. **Notas o advertencias:**

- **Cuándo usarlo con cuidado:** Si la creación de objetos es muy simple y no esperas añadir muchos tipos de productos, el Factory Method podría ser una sobreingeniería. Úsalo cuando realmente necesites la flexibilidad y el desacoplamiento que ofrece.
- **Alternativas más simples:** Para casos simples, a veces una función estática o un simple método de fábrica en una clase utilitaria puede ser suficiente en lugar de un patrón completo.

---

## K - Relaciones con otros patrones

#### 1. **Definición:**

El Factory Method se relaciona con otros patrones de diseño:

- **Abstract Factory:** Muchos diseños empiezan con Factory Method y evolucionan hacia Abstract Factory, Prototype o Builder para mayor flexibilidad, aunque con más complejidad. Abstract Factory a menudo usa Factory Methods internamente.
- **Iterator:** Puedes usar Factory Method con Iterator para que las subclases de colecciones devuelvan diferentes tipos de iteradores compatibles con esas colecciones.
- **Prototype:** Prototype no se basa en herencia como Factory Method, pero requiere una inicialización más compleja del objeto clonado. Factory Method es más simple en ese sentido.
- **Template Method:** Factory Method es una especialización de Template Method. Un Factory Method puede ser un paso dentro de un Template Method más grande.

#### 2. **Ejemplo (Relación con Abstract Factory):**

Imagina que en lugar de solo crear botones, necesitas crear toda una familia de elementos de UI (botones, menús, ventanas) para diferentes sistemas operativos. En ese caso, podrías usar Abstract Factory. Un Abstract Factory podría usar Factory Methods para crear cada tipo de elemento de UI (un Factory Method para botones, otro para menús, etc.).

#### 3. **Notas o advertencias:**

- **Evolución de patrones:** Es común que un diseño empiece simple con Factory Method y, a medida que las necesidades crecen, evolucione hacia patrones más complejos como Abstract Factory.
- **Combinación de patrones:** Los patrones de diseño a menudo se combinan para resolver problemas complejos. Entender las relaciones entre ellos te ayuda a elegir la mejor combinación para tu situación.
