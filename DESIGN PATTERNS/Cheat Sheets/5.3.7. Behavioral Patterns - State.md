## A - State (Estado)

#### 1. **Definición:**

El patrón **State** es como darle superpoderes de transformación a un objeto. Imagina que un objeto puede cambiar su comportamiento interno dependiendo de su "estado" actual. ¡Es como si cambiara de clase sobre la marcha!

![State Design Pattern](https://refactoring.guru/images/patterns/content/state/state-en.png)

#### 2. **Ejemplo:**

Piensa en una bombilla con interruptor. Puede estar en estado "Encendida" o "Apagada". Si intentas "encenderla" cuando ya está "Encendida", no pasa nada. Si intentas "apagarla" cuando está "Apagada", tampoco. El comportamiento del interruptor cambia según el estado de la bombilla.

**Explicación del ejemplo:**
El estado de la bombilla (Encendida o Apagada) define cómo responde a la acción de "pulsar el interruptor". El patrón State permite que un objeto cambie su comportamiento de manera similar, dependiendo de su estado interno.

#### 3. **Notas o advertencias:**

- Es útil cuando un objeto tiene un número limitado de "estados" posibles.
- El objeto parece cambiar de tipo, pero en realidad solo cambia su comportamiento interno.

## B - El Problema de los Estados Condicionales

#### 1. **Definición:**

Imagina que tienes un objeto, como un `Documento`, que puede estar en diferentes estados: `Borrador`, `Moderación` y `Publicado`. Cada estado afecta a cómo funciona el objeto, especialmente cuando intentas realizar acciones como `publicar`.

![Finite-State Machine](https://refactoring.guru/images/patterns/diagrams/state/problem1.png)

#### 2. **Ejemplo:**

```java
class Documento {
    String estado = "Borrador";

    public void publicar(Usuario usuario) {
        if (estado.equals("Borrador")) {
            estado = "Moderacion";
            System.out.println("Documento enviado a moderación.");
        } else if (estado.equals("Moderacion")) {
            if (usuario.esAdmin()) {
                estado = "Publicado";
                System.out.println("Documento publicado.");
            } else {
                System.out.println("Solo los administradores pueden publicar documentos en moderación.");
            }
        } else if (estado.equals("Publicado")) {
            System.out.println("El documento ya está publicado.");
        }
    }
}

class Usuario {
    String rol;

    public Usuario(String rol) {
        this.rol = rol;
    }

    public boolean esAdmin() {
        return rol.equals("admin");
    }
}

public class Main {
    public static void main(String[] args) {
        Documento doc = new Documento();
        Usuario usuarioNormal = new Usuario("usuario");
        Usuario usuarioAdmin = new Usuario("admin");

        doc.publicar(usuarioNormal); // Documento enviado a moderación.
        doc.publicar(usuarioNormal); // Solo los administradores pueden publicar documentos en moderación.
        doc.publicar(usuarioAdmin); // Documento publicado.
        doc.publicar(usuarioAdmin); // El documento ya está publicado.
    }
}
```

**Explicación del ejemplo:**
En este código, la clase `Documento` usa una variable `estado` y un montón de `if` para decidir qué hacer en el método `publicar()`. A medida que añades más estados y acciones, este código se vuelve muy complicado y difícil de mantener. ¡Es como un plato de espaguetis!

#### 3. **Notas o advertencias:**

- Usar muchos `if` o `switch` para manejar estados hace que el código sea difícil de leer y modificar.
- Cada vez que añades un nuevo estado, tienes que revisar y cambiar muchos métodos.
- Este enfoque no escala bien cuando el número de estados y comportamientos aumenta.

## C - La Solución: Patrón State

#### 1. **Definición:**

El patrón **State** nos dice que debemos crear **clases separadas** para cada estado posible de un objeto. Cada clase de estado se encarga de definir el comportamiento específico para ese estado. El objeto original (llamado **Contexto**) ya no tiene que preocuparse por los `if` y `switch`, ¡simplemente delega el trabajo al objeto de estado actual!

![Document delegates the work to a state object](https://refactoring.guru/images/patterns/diagrams/state/solution-en.png)

#### 2. **Ejemplo:**

En lugar de un solo `Documento` con muchos `if`, creamos clases para cada estado: `BorradorEstado`, `ModeracionEstado`, `PublicadoEstado`. El `Documento` ahora tiene una variable que guarda el estado actual, y cuando se llama a `publicar()`, delega la acción al objeto de estado actual.

```java
// Interfaz para todos los estados
interface EstadoDocumento {
    void publicar(Documento contexto);
}

// Estados concretos
class BorradorEstado implements EstadoDocumento {
    @Override
    public void publicar(Documento contexto) {
        System.out.println("Documento enviado a moderación.");
        contexto.cambiarEstado(new ModeracionEstado());
    }
}

class ModeracionEstado implements EstadoDocumento {
    @Override
    public void publicar(Documento contexto) {
        if (contexto.getUsuarioActual().esAdmin()) {
            System.out.println("Documento publicado.");
            contexto.cambiarEstado(new PublicadoEstado());
        } else {
            System.out.println("Solo los administradores pueden publicar documentos en moderación.");
        }
    }
}

class PublicadoEstado implements EstadoDocumento {
    @Override
    public void publicar(Documento contexto) {
        System.out.println("El documento ya está publicado.");
    }
}

// Contexto
class Documento {
    private EstadoDocumento estadoActual;
    private Usuario usuarioActual;

    public Documento(Usuario usuario) {
        this.estadoActual = new BorradorEstado(); // Estado inicial
        this.usuarioActual = usuario;
    }

    public void publicar() {
        estadoActual.publicar(this); // Delegar al estado actual
    }

    public void cambiarEstado(EstadoDocumento nuevoEstado) {
        this.estadoActual = nuevoEstado;
    }

    public Usuario getUsuarioActual() {
        return usuarioActual;
    }
}


// Clase Usuario (la misma que antes)
class Usuario {
    String rol;

    public Usuario(String rol) {
        this.rol = rol;
    }

    public boolean esAdmin() {
        return rol.equals("admin");
    }
}


public class Main {
    public static void main(String[] args) {
        Usuario usuarioNormal = new Usuario("usuario");
        Usuario usuarioAdmin = new Usuario("admin");
        Documento doc1 = new Documento(usuarioNormal);
        Documento doc2 = new Documento(usuarioAdmin);

        doc1.publicar(); // Documento enviado a moderación.
        doc1.publicar(); // Solo los administradores pueden publicar documentos en moderación.
        doc2.publicar(); // Documento enviado a moderación.
        doc2.publicar(); // Documento publicado.
        doc2.publicar(); // El documento ya está publicado.
    }
}
```

**Explicación del ejemplo:**
Ahora, cada estado (`BorradorEstado`, `ModeracionEstado`, `PublicadoEstado`) tiene su propia clase que define cómo funciona `publicar()`. La clase `Documento` simplemente guarda el estado actual y le pide al estado que haga el trabajo. ¡El código es mucho más limpio y fácil de entender!

#### 3. **Notas o advertencias:**

- Cada estado se convierte en una clase separada, lo que hace que el código sea más organizado.
- Añadir nuevos estados es más fácil, solo tienes que crear una nueva clase de estado.
- El `Documento` (Contexto) se simplifica mucho, ya no tiene lógica de estado compleja.

## D - Analogía del Mundo Real: El Smartphone

#### 1. **Definición:**

Piensa en los botones de tu smartphone. No siempre hacen lo mismo, ¿verdad? Su comportamiento cambia dependiendo del "estado" del teléfono: bloqueado, desbloqueado, batería baja, etc.

#### 2. **Ejemplo:**

- **Teléfono Desbloqueado:** Pulsar el botón de inicio te lleva a la pantalla principal.
- **Teléfono Bloqueado:** Pulsar el botón de inicio te muestra la pantalla de desbloqueo.
- **Batería Baja:** Pulsar cualquier botón puede mostrar la pantalla de carga.

**Explicación del ejemplo:**
El mismo botón (por ejemplo, el de inicio) tiene diferentes acciones dependiendo del estado del teléfono. El patrón State funciona de manera similar para los objetos en programación.

#### 3. **Notas o advertencias:**

- Esta analogía muestra cómo un mismo "control" (el botón) puede tener comportamientos diferentes según el estado.
- El patrón State permite modelar este tipo de comportamiento en software.

## E - Estructura del Patrón State

#### 1. **Definición:**

El patrón State tiene los siguientes componentes principales:

![Structure of the State design pattern](https://refactoring.guru/images/patterns/diagrams/state/structure-en.png)
![Structure of the State design pattern](https://refactoring.guru/images/patterns/diagrams/state/structure-en-indexed.png)

1.  **Contexto (Context):** Es el objeto principal que tiene un estado y delega el comportamiento a los objetos de estado. Conoce el estado actual y puede cambiarlo.
2.  **Interfaz Estado (State Interface):** Define las operaciones que todos los estados concretos deben implementar. Es como un "contrato" para los estados.
3.  **Estados Concretos (Concrete States):** Son las clases que implementan la interfaz Estado. Cada estado concreto define un comportamiento específico para el Contexto.

#### 2. **Ejemplo (en términos de la estructura):**

- **Contexto:** La clase `Documento` en nuestro ejemplo anterior.
- **Interfaz Estado:** La interfaz `EstadoDocumento`.
- **Estados Concretos:** Las clases `BorradorEstado`, `ModeracionEstado`, `PublicadoEstado`.

**Explicación del ejemplo:**
El Contexto (`Documento`) no sabe _cómo_ publicar en cada estado, solo sabe que debe pedirle al objeto de estado actual que lo haga. Cada Estado Concreto sabe _cómo_ implementar la acción `publicar()` de manera específica para ese estado.

#### 3. **Notas o advertencias:**

- La estructura se parece un poco al patrón Strategy, pero la intención es diferente. (Ver sección J).
- El Contexto se comunica con los Estados a través de la Interfaz Estado, lo que permite cambiar de estado fácilmente.

## F - Seudocódigo de Ejemplo: Reproductor de Audio

#### 1. **Definición:**

Este ejemplo muestra cómo el patrón State puede hacer que los controles de un reproductor de música (como los botones de "play", "pause", "bloquear") funcionen de manera diferente según el estado de reproducción (reproduciendo, pausado, bloqueado, etc.).

![Structure of the State pattern example](https://refactoring.guru/images/patterns/diagrams/state/example.png)

#### 2. **Ejemplo (Pseudocódigo adaptado a Java - simplificado):**

```java
// Contexto: Reproductor de Audio
class ReproductorAudio {
    private EstadoReproductor estadoActual;
    // ... otros componentes del reproductor (UI, playlist, etc.)

    public ReproductorAudio() {
        this.estadoActual = new EstadoListo(this); // Estado inicial: Listo
        // ... inicializar UI y asociar botones a métodos click...
    }

    public void cambiarEstado(EstadoReproductor nuevoEstado) {
        this.estadoActual = nuevoEstado;
    }

    // Métodos que delegan al estado actual
    public void clickBloquear() {
        estadoActual.clickBloquear();
    }
    public void clickReproducir() {
        estadoActual.clickReproducir();
    }
    public void clickSiguiente() {
        estadoActual.clickSiguiente();
    }
    public void clickAnterior() {
        estadoActual.clickAnterior();
    }

    // Métodos de servicio del reproductor (llamados por los estados)
    public void iniciarReproduccion() { /* ... */ System.out.println("Iniciando reproducción"); }
    public void detenerReproduccion() { /* ... */ System.out.println("Deteniendo reproducción"); }
    public void siguienteCancion() { /* ... */ System.out.println("Siguiente canción"); }
    public void cancionAnterior() { /* ... */ System.out.println("Canción anterior"); }
    // ...
}

// Interfaz Estado
interface EstadoReproductor {
    void clickBloquear();
    void clickReproducir();
    void clickSiguiente();
    void clickAnterior();
}

// Estados Concretos
class EstadoBloqueado implements EstadoReproductor {
    private ReproductorAudio reproductor;

    public EstadoBloqueado(ReproductorAudio reproductor) {
        this.reproductor = reproductor;
    }

    @Override
    public void clickBloquear() {
        System.out.println("Desbloqueando reproductor");
        reproductor.cambiarEstado(new EstadoListo(reproductor)); // Transición a estado Listo
    }
    @Override
    public void clickReproducir() { System.out.println("Reproductor bloqueado, no hace nada al pulsar Play"); }
    @Override
    public void clickSiguiente() { System.out.println("Reproductor bloqueado, no hace nada al pulsar Siguiente"); }
    @Override
    public void clickAnterior() { System.out.println("Reproductor bloqueado, no hace nada al pulsar Anterior"); }
}

class EstadoListo implements EstadoReproductor {
    private ReproductorAudio reproductor;

    public EstadoListo(ReproductorAudio reproductor) {
        this.reproductor = reproductor;
    }
    @Override
    public void clickBloquear() {
        System.out.println("Bloqueando reproductor");
        reproductor.cambiarEstado(new EstadoBloqueado(reproductor)); // Transición a estado Bloqueado
    }
    @Override
    public void clickReproducir() {
        System.out.println("Reproduciendo desde estado Listo");
        reproductor.iniciarReproduccion();
        reproductor.cambiarEstado(new EstadoReproduciendo(reproductor)); // Transición a estado Reproduciendo
    }
    @Override
    public void clickSiguiente() { reproductor.siguienteCancion(); }
    @Override
    public void clickAnterior() { reproductor.cancionAnterior(); }
}

class EstadoReproduciendo implements EstadoReproductor {
    private ReproductorAudio reproductor;

    public EstadoReproduciendo(ReproductorAudio reproductor) {
        this.reproductor = reproductor;
    }
    @Override
    public void clickBloquear() {
        System.out.println("Bloqueando reproductor desde Reproduciendo");
        reproductor.cambiarEstado(new EstadoBloqueado(reproductor)); // Transición a estado Bloqueado
    }
    @Override
    public void clickReproducir() {
        System.out.println("Pausando reproducción");
        reproductor.detenerReproduccion();
        reproductor.cambiarEstado(new EstadoListo(reproductor)); // Transición a estado Listo (Pausado en este caso)
    }
    @Override
    public void clickSiguiente() { reproductor.siguienteCancion(); }
    @Override
    public void clickAnterior() { reproductor.cancionAnterior(); }
}


public class Main {
    public static void main(String[] args) {
        ReproductorAudio reproductor = new ReproductorAudio();

        reproductor.clickReproducir(); // Iniciando reproducción
        reproductor.clickBloquear();   // Bloqueando reproductor desde Reproduciendo
        reproductor.clickReproducir(); // Reproductor bloqueado, no hace nada al pulsar Play
        reproductor.clickBloquear();   // Desbloqueando reproductor
        reproductor.clickReproducir(); // Reproduciendo desde estado Listo
        reproductor.clickReproducir(); // Pausando reproducción
    }
}
```

**Explicación del ejemplo:**
El `ReproductorAudio` es el Contexto. `EstadoReproductor` es la interfaz. `EstadoBloqueado`, `EstadoListo`, `EstadoReproduciendo` son los Estados Concretos. Cuando pulsas un botón en el reproductor, la acción se delega al estado actual, que decide qué hacer y cómo cambiar de estado si es necesario.

#### 3. **Notas o advertencias:**

- Este ejemplo muestra cómo los estados pueden cambiar el comportamiento de un objeto en respuesta a los mismos eventos (clicks de botones).
- Los estados pueden incluso cambiar el estado del Contexto, creando transiciones entre estados.

## G - Aplicabilidad del Patrón State

#### 1. **Definición:**

Usa el patrón State cuando:

- Un objeto se comporta de manera diferente según su estado actual.
- El número de estados es grande y/o los estados cambian con frecuencia.
- Tienes un código lleno de `if` y `switch` basados en el estado del objeto.
- Hay mucho código duplicado entre estados similares.

#### 2. **Ejemplo (situaciones donde es útil):**

- **Validación de formularios:** Un formulario puede tener estados como "Validando", "Válido", "Inválido". Las acciones como "guardar" o "enviar" se comportan diferente en cada estado.
- **Conexiones de red:** Una conexión puede estar en estados como "Conectando", "Conectado", "Desconectado", "Fallido". Las operaciones de envío y recepción de datos varían según el estado.
- **Máquinas de estados finitos:** Cualquier sistema que pueda modelarse como una máquina de estados finitos es un buen candidato para el patrón State.

#### 3. **Notas o advertencias:**

- Si solo tienes unos pocos estados simples y que no cambian mucho, quizás el patrón State sea demasiado complejo.
- Piensa si realmente necesitas la flexibilidad y organización que ofrece el patrón State antes de implementarlo.

## H - Cómo Implementar el Patrón State

#### 1. **Pasos:**

1.  **Identifica el Contexto:** ¿Qué clase va a tener estados?
2.  **Define la Interfaz Estado:** Crea una interfaz que declare las acciones relacionadas con el estado.
3.  **Crea Estados Concretos:** Para cada estado posible, crea una clase que implemente la interfaz Estado y defina el comportamiento específico.
4.  **Añade el Estado al Contexto:** En la clase Contexto, añade una variable para guardar el estado actual y un método para cambiar el estado.
5.  **Delega al Estado:** En los métodos del Contexto que dependen del estado, delega la lógica al objeto de estado actual.
6.  **Transiciones de Estado:** Los estados concretos pueden cambiar el estado del Contexto cuando sea necesario.

#### 2. **Ejemplo (resumen de los pasos en el ejemplo del Documento):**

1.  **Contexto:** `Documento`
2.  **Interfaz Estado:** `EstadoDocumento` (método `publicar()`)
3.  **Estados Concretos:** `BorradorEstado`, `ModeracionEstado`, `PublicadoEstado` (implementan `publicar()` de forma diferente)
4.  **Estado en Contexto:** `Documento` tiene `estadoActual` y `cambiarEstado()`
5.  **Delegación:** `Documento.publicar()` llama a `estadoActual.publicar(this)`
6.  **Transiciones:** Dentro de `BorradorEstado.publicar()` se llama a `contexto.cambiarEstado(new ModeracionEstado())`

#### 3. **Notas o advertencias:**

- Al mover código a las clases de estado, puede que necesites acceder a miembros privados del Contexto. Hay varias formas de manejar esto (hacerlos públicos, crear métodos públicos en el Contexto, clases anidadas).
- Decide dónde se crean las instancias de los estados concretos y cómo se cambian. Puede ser en el Contexto, en los propios estados o en el cliente.

## I - Pros y Contras del Patrón State

#### 1. **Pros (Ventajas):**

- **Principio de Responsabilidad Única:** Cada clase de estado se encarga solo de la lógica de un estado específico.
- **Principio de Abierto/Cerrado:** Puedes añadir nuevos estados sin modificar las clases de estado existentes ni el Contexto.
- **Simplifica el Contexto:** Elimina grandes bloques de `if` y `switch` en el Contexto, haciendo el código más limpio.

#### 2. **Contras (Desventajas):**

- **Sobrecarga (Overkill) para pocos estados:** Si solo tienes unos pocos estados simples, usar el patrón State puede ser más complicado de lo necesario.
- **Aumento del número de clases:** Añades clases para cada estado, lo que puede aumentar la complejidad general del proyecto si no se necesita realmente.

#### 3. **Notas o advertencias:**

- Evalúa si los beneficios del patrón State (organización, flexibilidad) justifican la posible complejidad adicional.
- No uses el patrón State si tu máquina de estados es muy simple y no va a cambiar mucho.

## J - Relación con Otros Patrones

#### 1. **Relaciones:**

- **Strategy, Bridge, Adapter:** Estos patrones tienen estructuras similares al patrón State (basados en composición y delegación). La diferencia principal está en el **problema que resuelven**.
- **Strategy vs. State:** Ambos usan composición para cambiar el comportamiento. **Strategy** hace que los objetos de estrategia sean independientes entre sí. **State** permite que los estados se conozcan y cambien el estado del Contexto. Se puede ver State como una extensión de Strategy donde los estados pueden "saber" del Contexto y de otros estados.

#### 2. **Ejemplo (diferencia clave Strategy vs. State):**

- **Strategy:** Imagina diferentes algoritmos de ordenamiento (QuickSort, MergeSort, BubbleSort). Puedes usar Strategy para cambiar el algoritmo de ordenamiento que usa un objeto. Los algoritmos de ordenamiento no "saben" del objeto que los usa ni de otros algoritmos.
- **State:** En el reproductor de audio, los estados (Bloqueado, Listo, Reproduciendo) sí "saben" del reproductor y pueden cambiar el estado del reproductor. Los estados están relacionados y forman parte de una máquina de estados.

#### 3. **Notas o advertencias:**

- No te centres solo en la estructura del patrón, sino también en la **intención** y el **problema que resuelve**.
- Entender las diferencias entre patrones similares te ayudará a elegir el patrón correcto para cada situación.
