## A - Chain of Responsibility

#### 1. **Definición:**

Imagina una cadena de "expertos", cada uno especializado en resolver un tipo de problema. Cuando llega un problema, se lo pasas al primer experto de la cadena. Si este experto puede resolverlo, ¡genial! Problema resuelto. Si no puede, simplemente le pasa el problema al siguiente experto en la cadena, y así sucesivamente, hasta que alguien pueda solucionarlo. **Chain of Responsibility** es justo eso: un patrón que te permite pasar una solicitud a través de una cadena de objetos ("expertos" o "handlers"). Cada objeto decide si procesa la solicitud o si la pasa al siguiente en la cadena.

#### 2. **Ejemplo:**

Pensemos en un sistema de atención al cliente en un banco. Hay diferentes niveles de empleados que pueden aprobar o rechazar solicitudes de préstamo, dependiendo de la cantidad de dinero.

```java
// Interfaz para los manejadores (expertos)
interface Handler {
    Handler setNext(Handler handler);
    String handle(Solicitud solicitud);
}

// Clase base abstracta para los manejadores, para evitar repetir código
abstract class AbstractHandler implements Handler {
    private Handler nextHandler;

    public Handler setNext(Handler handler) {
        this.nextHandler = handler;
        return handler;
    }

    public String handle(Solicitud solicitud) {
        if (nextHandler != null) {
            return nextHandler.handle(solicitud);
        }
        return "Fin de la cadena. No se pudo procesar la solicitud.";
    }
}

// Manejador concreto para solicitudes de bajo monto
class ManejadorNivel1 extends AbstractHandler {
    private double limite = 1000; // Límite de aprobación de este nivel

    public String handle(Solicitud solicitud) {
        if (solicitud.getMonto() <= limite) {
            return "Manejador Nivel 1: Solicitud aprobada para $" + solicitud.getMonto();
        }
        return super.handle(solicitud); // Pasar al siguiente manejador
    }
}

// Manejador concreto para solicitudes de monto medio
class ManejadorNivel2 extends AbstractHandler {
    private double limite = 10000; // Límite de aprobación de este nivel

    public String handle(Solicitud solicitud) {
        if (solicitud.getMonto() <= limite) {
            return "Manejador Nivel 2: Solicitud aprobada para $" + solicitud.getMonto();
        }
        return super.handle(solicitud); // Pasar al siguiente manejador
    }
}

// Manejador concreto para solicitudes de alto monto
class ManejadorNivel3 extends AbstractHandler {
    private double limite = 100000; // Límite de aprobación de este nivel

    public String handle(Solicitud solicitud) {
        if (solicitud.getMonto() <= limite) {
            return "Manejador Nivel 3: Solicitud aprobada para $" + solicitud.getMonto();
        }
        return super.handle(solicitud); // Pasar al siguiente manejador
    }
}

// Clase para representar una solicitud
class Solicitud {
    private double monto;
    private String descripcion;

    public Solicitud(double monto, String descripcion) {
        this.monto = monto;
        this.descripcion = descripcion;
    }

    public double getMonto() {
        return monto;
    }

    public String getDescripcion() {
        return descripcion;
    }
}

// Cliente que usa la cadena de responsabilidad
public class ClienteBanco {
    public static void main(String[] args) {
        // Crear la cadena de manejadores
        ManejadorNivel1 manejador1 = new ManejadorNivel1();
        ManejadorNivel2 manejador2 = new ManejadorNivel2();
        ManejadorNivel3 manejador3 = new ManejadorNivel3();

        manejador1.setNext(manejador2).setNext(manejador3); // ¡Encadenamos los manejadores!

        // Crear solicitudes de diferentes montos
        Solicitud solicitudBaja = new Solicitud(500, "Solicitud para gastos menores");
        Solicitud solicitudMedia = new Solicitud(5000, "Solicitud para mejoras en casa");
        Solicitud solicitudAlta = new Solicitud(50000, "Solicitud para inversión de negocio");
        Solicitud solicitudMuyAlta = new Solicitud(500000, "Solicitud para compra de propiedad");

        // Procesar las solicitudes
        System.out.println("Procesando solicitud baja: " + manejador1.handle(solicitudBaja));
        System.out.println("Procesando solicitud media: " + manejador1.handle(solicitudMedia));
        System.out.println("Procesando solicitud alta: " + manejador1.handle(solicitudAlta));
        System.out.println("Procesando solicitud muy alta: " + manejador1.handle(solicitudMuyAlta));
    }
}
```

**Resultado del ejemplo:**

```
Procesando solicitud baja: Manejador Nivel 1: Solicitud aprobada para $500.0
Procesando solicitud media: Manejador Nivel 2: Solicitud aprobada para $5000.0
Procesando solicitud alta: Manejador Nivel 3: Solicitud aprobada para $50000.0
Procesando solicitud muy alta: Fin de la cadena. No se pudo procesar la solicitud.
```

**Explicación del ejemplo:**

- Tenemos una `interface Handler` que define cómo debe ser un "manejador" en nuestra cadena. Cada manejador debe poder `setNext` para indicar quién es el siguiente en la cadena y tener un método `handle` para procesar la solicitud.
- `AbstractHandler` es una clase base que implementa la lógica común de pasar la solicitud al siguiente manejador si el actual no puede procesarla.
- `ManejadorNivel1`, `ManejadorNivel2` y `ManejadorNivel3` son los "expertos" concretos. Cada uno maneja solicitudes hasta un cierto límite de monto. Si la solicitud está dentro de su límite, la procesan (la "aprueban" en este caso). Si no, la pasan al siguiente manejador en la cadena usando `super.handle(solicitud)`.
- En `ClienteBanco`, creamos la cadena de manejadores usando `setNext` para conectarlos. Luego, enviamos diferentes `Solicitud`s a la cadena, empezando por el `ManejadorNivel1`. Cada solicitud viaja por la cadena hasta que un manejador la procesa o hasta que se llega al final de la cadena sin que nadie la procese (como la solicitud de $500,000 que es demasiado alta para todos los niveles).

#### 3. **Notas o advertencias:**

- **Orden Importa:** El orden en que defines la cadena es crucial. Si pones al `ManejadorNivel3` primero, ¡él intentará manejar todas las solicitudes primero!
- **Posiblemente no manejada:** Es posible que una solicitud llegue al final de la cadena sin ser procesada por nadie, como vimos con la solicitud de $500,000. Debes considerar cómo manejar estos casos en tu aplicación (por ejemplo, mostrar un mensaje de error).
- **Flexibilidad:** La gran ventaja es que puedes añadir, quitar o reordenar los manejadores en la cadena muy fácilmente sin modificar el código del cliente que envía las solicitudes. ¡Esto hace que tu sistema sea muy adaptable a cambios!

---

## B - Intención del Chain of Responsibility

#### 1. **Definición:**

La **intención** principal del patrón Chain of Responsibility es **evitar acoplar el emisor de una solicitud a su receptor**. En lugar de que el emisor sepa _exactamente_ quién va a procesar la solicitud, se la envía a una cadena de posibles "manejadores". Cada manejador decide si es el adecuado para procesar la solicitud. Si no lo es, la pasa al siguiente en la cadena. Esto te da mucha flexibilidad y desacoplamiento en tu código.

#### 2. **Ejemplo:**

Volvamos al ejemplo del banco. Imagina que antes, el código para aprobar préstamos era algo así (¡muy simplificado y poco flexible!):

```java
public class Banco {
    public String aprobarPrestamo(Solicitud solicitud) {
        if (solicitud.getMonto() <= 1000) {
            // Aprobar nivel 1
            return "Préstamo aprobado por Nivel 1";
        } else if (solicitud.getMonto() <= 10000) {
            // Aprobar nivel 2
            return "Préstamo aprobado por Nivel 2";
        } else if (solicitud.getMonto() <= 100000) {
            // Aprobar nivel 3
            return "Préstamo aprobado por Nivel 3";
        } else {
            return "Préstamo rechazado: Monto muy alto";
        }
    }
}
```

**Explicación del ejemplo:**

En este código "antiguo", la clase `Banco` tiene que saber _exactamente_ cómo y quién va a aprobar cada tipo de préstamo. Está muy acoplado a la lógica de aprobación. Si quieres añadir un nuevo nivel de aprobación o cambiar la lógica, ¡tienes que modificar la clase `Banco` directamente!

Con Chain of Responsibility, como vimos en el ejemplo anterior, la clase `ClienteBanco` (que sería como el "Banco" en este ejemplo simplificado) **no sabe** qué manejador específico va a aprobar cada solicitud. Solo sabe que tiene una cadena de manejadores y le envía la solicitud al primero. El resto es "magia" interna de la cadena. Esto es el **desacoplamiento** en acción.

#### 3. **Notas o advertencias:**

- **Flexibilidad ante cambios:** Si necesitas añadir un nuevo nivel de aprobación (por ejemplo, un "ManejadorNivel4"), solo tienes que crear la nueva clase y añadirla a la cadena. ¡No tienes que tocar el código existente de los otros manejadores ni del cliente!
- **Responsabilidad Única:** Cada manejador tiene una responsabilidad muy clara: decidir si puede procesar la solicitud y, si no, pasarla al siguiente. Esto sigue el principio de Responsabilidad Única y hace que el código sea más fácil de entender y mantener.
- **Comportamiento en tiempo de ejecución:** Puedes configurar la cadena de responsabilidad **en tiempo de ejecución**. Esto significa que puedes cambiar la cadena dependiendo de la configuración, del tipo de usuario, o de cualquier otra condición. ¡Mucha potencia!

---

## C - Problema que resuelve Chain of Responsibility

#### 1. **Definición:**

Chain of Responsibility es muy útil cuando tienes que procesar solicitudes a través de **múltiples pasos o verificaciones secuenciales**, y no quieres que el código que inicia la solicitud sepa _todos_ los detalles de este procesamiento. También es ideal cuando el conjunto de estos pasos o su orden **puede cambiar** con el tiempo o en diferentes situaciones.

#### 2. **Ejemplo:**

El texto original nos da un excelente ejemplo: un **sistema de pedidos online**. Imagina que necesitas hacer estas verificaciones _antes_ de que el sistema de pedidos procese una orden:

1.  **Autenticación:** ¿El usuario está logueado?
2.  **Autorización:** ¿El usuario tiene permisos para crear pedidos? (Por ejemplo, ¿es un usuario normal o un administrador?)
3.  **Validación de datos:** ¿Los datos del pedido son correctos y seguros? (Por ejemplo, ¿sanitizar la entrada para evitar ataques).
4.  **Límite de peticiones:** ¿El usuario no está haciendo demasiadas peticiones seguidas (para prevenir ataques de fuerza bruta)?
5.  **Caché:** ¿Ya tenemos una respuesta en caché para esta misma solicitud? Si sí, devolver la caché y no procesar de nuevo.

**Problema sin Chain of Responsibility:**

Si intentáramos hacer esto sin Chain of Responsibility, podríamos terminar con un código muy enredado, como una larga función con muchos `if` anidados o `else if`. Sería difícil de leer, mantener y modificar. Cada vez que añadieras una nueva verificación, la función se haría más grande y compleja. Además, si quisieras reutilizar algunas de estas verificaciones en otra parte del sistema, tendrías que copiar y pegar código, ¡lo cual es una mala práctica!

**Problema resuelto con Chain of Responsibility:**

Chain of Responsibility nos permite convertir cada una de estas verificaciones en un **manejador** separado. Luego, podemos **encadenar** estos manejadores en el orden que queramos. Cuando llega una solicitud de pedido, la enviamos al primer manejador de la cadena (por ejemplo, el de autenticación). Cada manejador hace su verificación y decide si:

- **Procesa la solicitud:** En algunos casos, un manejador podría _procesar_ la solicitud completamente y detener la cadena. Por ejemplo, el manejador de caché: si encuentra una respuesta en caché, la devuelve y no necesita pasar la solicitud a los siguientes manejadores.
- **Pasa la solicitud al siguiente:** Si el manejador no puede o no debe procesar la solicitud completamente, la pasa al siguiente manejador en la cadena. Por ejemplo, el manejador de autenticación: si autentica al usuario, pasa la solicitud al siguiente manejador (autorización). Si la autenticación falla, puede detener la cadena y rechazar la solicitud.

#### 3. **Notas o advertencias:**

- **Código más limpio y organizado:** Cada verificación está en su propia clase, lo que hace que el código sea más modular, fácil de entender y mantener.
- **Reutilización de código:** Puedes reutilizar los manejadores en diferentes cadenas o en diferentes partes de tu sistema. Por ejemplo, podrías usar el mismo manejador de autenticación para proteger diferentes partes de tu aplicación.
- **Flexibilidad para el futuro:** Añadir nuevas verificaciones o cambiar el orden de las existentes es muy sencillo. Solo tienes que crear un nuevo manejador o reordenar la cadena. ¡No tienes que reescribir código existente!

---

## D - Solución con Chain of Responsibility: Handlers y Cadena

#### 1. **Definición:**

La solución que propone Chain of Responsibility se basa en dos ideas principales:

1.  **Handlers (Manejadores):** Cada paso del procesamiento (como autenticación, validación, etc.) se convierte en un objeto **handler** independiente. Cada handler sabe cómo realizar una tarea específica y tiene la posibilidad de procesar la solicitud o pasarla al siguiente handler.
2.  **Chain (Cadena):** Los handlers se organizan en una **cadena**. Cuando llega una solicitud, se envía al **primer handler** de la cadena. Cada handler en la cadena decide si procesa la solicitud o la pasa al siguiente handler en la cadena.

#### 2. **Ejemplo:**

Volvamos al ejemplo del sistema de pedidos online y las verificaciones: autenticación, autorización, validación, límite de peticiones y caché. Podríamos tener un handler para cada una:

- `AutenticacionHandler`
- `AutorizacionHandler`
- `ValidacionDatosHandler`
- `LimitePeticionesHandler`
- `CacheHandler`

Y podríamos encadenarlos así:

`CacheHandler -> LimitePeticionesHandler -> AutenticacionHandler -> AutorizacionHandler -> ValidacionDatosHandler -> SistemaDePedidos`

Cuando llega una solicitud de pedido, se envía primero a `CacheHandler`.

- **`CacheHandler`:** Verifica si hay una respuesta en caché. Si sí, la devuelve y **detiene la cadena**. Si no, pasa la solicitud a `LimitePeticionesHandler`.
- **`LimitePeticionesHandler`:** Verifica si el usuario ha excedido el límite de peticiones. Si sí, rechaza la solicitud y **detiene la cadena**. Si no, pasa la solicitud a `AutenticacionHandler`.
- **`AutenticacionHandler`:** Autentica al usuario. Si falla la autenticación, rechaza la solicitud y **detiene la cadena**. Si tiene éxito, pasa la solicitud a `AutorizacionHandler`.
- **`AutorizacionHandler`:** Verifica si el usuario tiene permisos. Si no tiene permisos, rechaza la solicitud y **detiene la cadena**. Si tiene permisos, pasa la solicitud a `ValidacionDatosHandler`.
- **`ValidacionDatosHandler`:** Valida los datos del pedido. Si los datos no son válidos, rechaza la solicitud y **detiene la cadena**. Si son válidos, pasa la solicitud al `SistemaDePedidos` (que sería el último "handler" o el destino final de la solicitud).
- **`SistemaDePedidos`:** Procesa el pedido finalmente.

![Handlers are lined-up one by one, forming a chain](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/solution1-en.png)

**Explicación del ejemplo:**

Como ves en la imagen, los handlers se alinean uno tras otro, formando una cadena. Cada handler tiene la oportunidad de procesar la solicitud. Si un handler decide que no debe seguir procesando la solicitud (por ejemplo, porque la autenticación falló o se encontró una respuesta en caché), puede **detener la cadena**. Si no, pasa la solicitud al siguiente handler.

#### 3. **Notas o advertencias:**

- **Flexibilidad en el flujo:** Puedes definir diferentes cadenas para diferentes tipos de solicitudes o situaciones. Por ejemplo, podrías tener una cadena más corta para solicitudes de lectura y una más larga para solicitudes de escritura.
- **Decisión en cada paso:** Cada handler toma una decisión: ¿proceso o paso? Esta decisión puede basarse en la solicitud misma, en el estado del sistema, o en cualquier otra lógica que necesites.
- **Responsabilidad clara:** Cada handler tiene una responsabilidad muy específica, lo que facilita el desarrollo, las pruebas y el mantenimiento.

---

## E - Dos enfoques de procesamiento en Chain of Responsibility

#### 1. **Definición:**

Hay dos maneras principales en que un handler puede procesar una solicitud en Chain of Responsibility:

1.  **Procesar y posiblemente pasar:** El handler realiza su tarea (por ejemplo, autenticar al usuario) y luego **siempre** pasa la solicitud al siguiente handler en la cadena. Todos los handlers en la cadena tienen la oportunidad de hacer algo con la solicitud. Este enfoque es útil cuando quieres que _todos_ los handlers se ejecuten para cada solicitud, pero en un orden específico.
2.  **Procesar o pasar (exclusivo):** El handler decide si **puede** procesar la solicitud. Si puede, la procesa y **detiene la cadena**. Ningún handler posterior en la cadena procesará la solicitud. Si el handler no puede procesar la solicitud, la pasa al siguiente. Este enfoque es útil cuando solo quieres que **un** handler procese la solicitud, el primero que sea capaz de hacerlo.

#### 2. **Ejemplo:**

**Enfoque 1: Procesar y posiblemente pasar (Todos los handlers actúan)**

Imagina un sistema de **registro de logs (registros de eventos)**. Quieres registrar información sobre cada paso de un proceso. Podrías tener una cadena de handlers de logging:

- `LogHandlerConsola` (registra en la consola)
- `LogHandlerArchivo` (registra en un archivo)
- `LogHandlerBaseDeDatos` (registra en una base de datos)

Cuando ocurre un evento, envías la información del evento al primer handler (`LogHandlerConsola`). Cada handler registra la información a su manera (consola, archivo, base de datos) y luego **siempre** pasa la información al siguiente handler en la cadena. Así, el evento se registra en todos los destinos.

**Enfoque 2: Procesar o pasar (Un solo handler actúa)**

Este es el enfoque que vimos en el ejemplo del banco y en el ejemplo del sistema de pedidos online. Un handler procesa la solicitud (si puede) y detiene la cadena. Por ejemplo, en el sistema de pedidos, el `CacheHandler` procesa la solicitud (devuelve la caché) y detiene la cadena. O el `AutenticacionHandler` procesa la solicitud (autentica) y la pasa, pero si falla la autenticación, procesa la solicitud (rechaza) y detiene la cadena.

**Ejemplo del GUI (Interfaz Gráfica de Usuario) del texto:**

El ejemplo del texto sobre la ayuda contextual en una GUI usa el **enfoque 2**. Cuando el usuario presiona F1, la solicitud de ayuda se envía al componente GUI actual.

- Si el componente tiene un `tooltipText`, lo muestra y **detiene la cadena**.
- Si no, pasa la solicitud a su contenedor padre.
- El contenedor padre hace lo mismo: si tiene ayuda específica (`modalHelpText` para un `Panel` o `wikiPageURL` para un `Dialog`), la muestra y **detiene la cadena**.
- Si no, pasa la solicitud a su contenedor padre, y así sucesivamente, hasta llegar al contenedor raíz (como la ventana principal de la aplicación).
- Si ningún componente en la cadena puede proporcionar ayuda, la solicitud llega al final de la cadena sin ser procesada (en este caso, simplemente no se muestra ayuda).

![A chain can be formed from a branch of an object tree](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/solution2-en.png)

**Explicación del ejemplo:**

En el ejemplo del GUI, la cadena se forma a partir de la jerarquía de componentes GUI (como un árbol). La solicitud de ayuda "sube" por este árbol hasta que encuentra un componente que puede manejarla. Solo **un** componente en la cadena (el primero que encuentre ayuda) procesa la solicitud.

#### 3. **Notas o advertencias:**

- **Elige el enfoque adecuado:** La elección entre estos dos enfoques depende de lo que necesites lograr. ¿Quieres que todos los handlers actúen? (Enfoque 1) ¿O solo quieres que uno actúe, el primero que pueda? (Enfoque 2).
- **Flexibilidad:** Chain of Responsibility es flexible porque te permite implementar ambos enfoques y combinarlos según sea necesario en tu sistema.

---

## F - Analogía del Mundo Real: Soporte Técnico

#### 1. **Definición:**

La analogía del **soporte técnico telefónico** es una forma muy intuitiva de entender Chain of Responsibility. Cuando llamas a soporte técnico, tu llamada pasa por una cadena de "operadores" o "niveles de soporte".

#### 2. **Ejemplo:**

1.  **Respuesta automática (primer nivel):** Primero, te atiende una voz automática que te ofrece soluciones comunes. Si alguna de estas soluciones resuelve tu problema, ¡genial! Problema resuelto en el primer nivel. Si no, la llamada pasa al siguiente nivel.
2.  **Operador de primer nivel (segundo nivel):** Te conecta con un operador "normal" de soporte. Este operador intenta ayudarte con problemas más comunes, consultando manuales o bases de conocimiento. Si el operador puede resolver tu problema, ¡perfecto! Si no, la llamada pasa al siguiente nivel.
3.  **Ingeniero especializado (tercer nivel):** Si el operador de primer nivel no puede ayudarte, te transfieren a un ingeniero más especializado, con conocimientos más profundos. Este ingeniero puede diagnosticar problemas más complejos y ofrecer soluciones más técnicas. Si el ingeniero puede resolver tu problema, ¡excelente! Si no, la llamada podría pasar a un nivel aún más alto (si existe) o simplemente terminar sin solución.

![Talking with tech support can be hard](https://refactoring.guru/images/patterns/content/chain-of-responsibility/chain-of-responsibility-comic-1-en.png)

**Explicación del ejemplo:**

- **Solicitud:** Tu problema técnico (por ejemplo, tu Linux no reconoce el nuevo hardware).
- **Cadena de Responsabilidad:** Respuesta automática -> Operador de primer nivel -> Ingeniero especializado.
- **Handlers (Manejadores):** Cada nivel de soporte (respuesta automática, operador, ingeniero) es un "handler". Cada uno intenta resolver el problema.
- **Procesar o Pasar:** Cada handler decide si puede resolver el problema. Si puede, lo resuelve y la "cadena" termina para ti (¡problema resuelto!). Si no puede, pasa la "solicitud" (tu llamada) al siguiente nivel en la cadena.
- **Posiblemente no manejada:** Si llegas al final de la cadena (al último nivel de soporte disponible) y nadie puede resolver tu problema, tu solicitud queda "sin manejar" (¡problema no resuelto, mala suerte!).

#### 3. **Notas o advertencias:**

- **Claridad de roles:** Cada nivel de soporte (handler) tiene un rol y una especialización definidos. Esto hace que el proceso de soporte sea más eficiente.
- **Escalabilidad:** Si necesitas añadir un nuevo nivel de soporte (por ejemplo, un "experto en hardware muy específico"), simplemente lo añades a la cadena.
- **Eficiencia:** Los problemas más comunes se resuelven en los primeros niveles de soporte, que suelen ser más rápidos y menos costosos. Solo los problemas más complejos llegan a los niveles superiores, que requieren más tiempo y recursos. Esto hace que el sistema de soporte sea más eficiente en general.

---

## G - Estructura del Chain of Responsibility

#### 1. **Definición:**

Para implementar Chain of Responsibility, necesitas definir las siguientes partes principales:

1.  **Handler (Manejador):** Una interfaz o clase abstracta que define la estructura común para todos los handlers en la cadena. Normalmente, tiene un método para "manejar" la solicitud (por ejemplo, `handleRequest(Request request)`) y un método para establecer el "siguiente" handler en la cadena (por ejemplo, `setNextHandler(Handler nextHandler)`).
2.  **Concrete Handlers (Manejadores Concretos):** Clases concretas que implementan la interfaz Handler. Cada Concrete Handler contiene la lógica real para procesar la solicitud (o parte de ella). Cada Concrete Handler también decide si pasa la solicitud al siguiente handler en la cadena.
3.  **Client (Cliente):** El código que inicia la solicitud y la envía al primer handler de la cadena. El cliente no necesita saber _qué_ handler específico procesará la solicitud, solo necesita enviar la solicitud al inicio de la cadena.

![Structure of the Chain Of Responsibility design pattern](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/structure.png)
![Structure of the Chain Of Responsibility design pattern](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/structure-indexed.png)

#### 2. **Explicación de la estructura (según la imagen indexada):**

1.  **Handler (Interfaz `Handler`):** Define la interfaz común para todos los manejadores. Tiene el método `handleRequest()`.
2.  **Base Handler (Clase abstracta `AbstractHandler` - opcional):** Proporciona una implementación base para los handlers concretos. Aquí puedes poner código común, como la lógica para mantener una referencia al siguiente handler y la lógica por defecto para pasar la solicitud al siguiente handler. **No siempre es necesaria**, pero es útil para evitar repetir código.
3.  **Concrete Handlers (Clases `ConcreteHandlerA`, `ConcreteHandlerB`, etc.):** Implementan la interfaz `Handler` y contienen la lógica específica para procesar la solicitud. Cada uno decide si procesa la solicitud y si la pasa al siguiente.
4.  **Client (Clase `Client`):** Crea y configura la cadena de handlers. Envía las solicitudes al primer handler de la cadena.

#### 3. **Notas o advertencias:**

- **Interfaz Handler es clave:** La interfaz `Handler` es fundamental para el patrón. Permite que los handlers sean intercambiables y que la cadena sea flexible.
- **Base Handler opcional pero útil:** La clase `AbstractHandler` es una buena práctica para reducir la duplicación de código, pero no es estrictamente necesaria para el patrón.
- **Cliente desacoplado:** El cliente no se acopla a los handlers concretos. Solo interactúa con la interfaz `Handler` y con el primer handler de la cadena. Esto hace que el sistema sea más flexible y fácil de mantener.
- **Construcción de la cadena:** El cliente es responsable de construir la cadena, generalmente configurando el "siguiente handler" de cada handler. La cadena puede ser construida estáticamente al inicio de la aplicación o dinámicamente en tiempo de ejecución.

---

## H - Pseudocódigo del ejemplo de GUI (Ayuda Contextual)

#### 1. **Definición:**

El pseudocódigo del ejemplo de la GUI en el texto ilustra cómo se puede implementar Chain of Responsibility para manejar solicitudes de ayuda contextual en una interfaz gráfica de usuario. La cadena se forma a partir de la jerarquía de componentes GUI.

#### 2. **Pseudocódigo explicado paso a paso:**

```pseudocode
// A. Interfaz para componentes con ayuda contextual
interface ComponentWithContextualHelp is
    method showHelp() // Método que los handlers deben implementar

// B. Clase base abstracta para componentes GUI simples
abstract class Component implements ComponentWithContextualHelp is
    field tooltipText: string // Texto de ayuda simple (tooltip)
    protected field container: Container // Referencia al contenedor padre (siguiente en la cadena)

    // Implementación del método showHelp en la clase base
    method showHelp() is
        if (tooltipText != null) // Si hay tooltipText
            // Mostrar tooltip (ayuda simple)
        else // Si no hay tooltipText, pasar al contenedor padre
            container.showHelp() // Llamar al showHelp del contenedor padre

// C. Clase abstracta para Contenedores GUI (que pueden contener otros componentes)
abstract class Container extends Component is
    protected field children: array of Component // Lista de componentes hijos

    method add(child) is // Método para añadir un componente hijo al contenedor
        children.add(child)
        child.container = this // Establecer el contenedor padre del hijo (¡clave para la cadena!)

// D. Componente GUI primitivo: Botón (puede usar la ayuda por defecto)
class Button extends Component is
    // ... (No necesita implementar showHelp de nuevo, usa la de Component)

// E. Componente GUI complejo: Panel (puede tener ayuda modal)
class Panel extends Container is
    field modalHelpText: string // Texto de ayuda modal (ventana emergente)

    method showHelp() is // Reimplementa showHelp para Panel
        if (modalHelpText != null) // Si hay modalHelpText
            // Mostrar ventana modal con el texto de ayuda
        else // Si no hay modalHelpText, usar la ayuda del contenedor padre (clase base Component)
            super.showHelp() // Llamar al showHelp de la clase base (Component)

// F. Componente GUI complejo: Dialog (puede tener ayuda en una página web)
class Dialog extends Container is
    field wikiPageURL: string // URL de la página de ayuda en la wiki

    method showHelp() is // Reimplementa showHelp para Dialog
        if (wikiPageURL != null) // Si hay wikiPageURL
            // Abrir la página de ayuda en el navegador web
        else // Si no hay wikiPageURL, usar la ayuda del contenedor padre
            super.showHelp() // Llamar al showHelp de la clase base (Component)

// G. Clase Cliente: Aplicación GUI
class Application is
    method createUI() is // Método para crear la interfaz de usuario
        dialog = new Dialog("Budget Reports") // Crear un Dialog (ventana principal)
        dialog.wikiPageURL = "http://..." // Configurar ayuda para el Dialog (página web)
        panel = new Panel(0, 0, 400, 800) // Crear un Panel dentro del Dialog
        panel.modalHelpText = "This panel does..." // Configurar ayuda para el Panel (modal)
        ok = new Button(250, 760, 50, 20, "OK") // Crear un botón dentro del Panel
        ok.tooltipText = "This is an OK button that..." // Configurar ayuda para el botón (tooltip)
        cancel = new Button(320, 760, 50, 20, "Cancel") // Crear otro botón
        // ...
        panel.add(ok) // Añadir botones al Panel
        panel.add(cancel)
        dialog.add(panel) // Añadir Panel al Dialog

    method onF1KeyPress() is // Método que se llama cuando se presiona F1
        component = this.getComponentAtMouseCoords() // Obtener el componente GUI bajo el cursor
        component.showHelp() // Iniciar la cadena de responsabilidad llamando a showHelp del componente
```

![Structure of the Chain of Responsibility example](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/example-en.png)
![Structure of the Chain of Responsibility example](https://refactoring.guru/images/patterns/diagrams/chain-of-responsibility/example2-en.png)

**Explicación del pseudocódigo:**

- **`ComponentWithContextualHelp`:** Interfaz Handler. Define el método `showHelp()`.
- **`Component`:** Clase base abstracta (Base Handler). Implementa `showHelp()` por defecto: muestra tooltip si existe, sino, pasa la solicitud al `container`.
- **`Container`:** Clase abstracta para contenedores. Extiende `Component` y mantiene una lista de `children`. En `add(child)`, establece el `container` del hijo, creando la cadena.
- **`Button`:** Concrete Handler simple. Usa la implementación de `showHelp()` de `Component` (ayuda por tooltip).
- **`Panel` y `Dialog`:** Concrete Handlers complejos. Reimplementan `showHelp()` para ofrecer ayuda más elaborada (modal, página web). Si no tienen ayuda específica, llaman a `super.showHelp()` para pasar la solicitud al contenedor padre.
- **`Application`:** Cliente. Crea la interfaz GUI, configura la cadena (relaciones padre-hijo de los componentes) y, cuando se presiona F1, inicia la cadena llamando a `showHelp()` del componente enfocado.

#### 3. **Notas o advertencias:**

- **Jerarquía GUI como cadena:** La clave aquí es que la cadena de responsabilidad se construye implícitamente a través de la jerarquía de contenedores GUI. El `container` de cada componente es el "siguiente handler" en la cadena.
- **Reutilización de `showHelp()`:** Los componentes simples como `Button` pueden reutilizar la implementación de `showHelp()` de la clase base `Component`. Los componentes más complejos como `Panel` y `Dialog` pueden _extender_ o _reemplazar_ la implementación de `showHelp()` para ofrecer un comportamiento más específico.
- **Solicitud "burbujea":** La solicitud de ayuda "burbujea" hacia arriba en la jerarquía de contenedores hasta que encuentra un componente que puede manejarla. Si nadie la maneja, simplemente no pasa nada.

---

## I - Aplicabilidad del Chain of Responsibility

#### 1. **Definición:**

Usa Chain of Responsibility cuando:

1.  **Múltiples handlers para diferentes tipos de solicitudes:** Tu programa debe procesar diferentes tipos de solicitudes de varias maneras, pero no sabes de antemano qué tipos de solicitudes llegarán ni en qué orden.
2.  **Orden específico de handlers es importante:** Necesitas ejecutar varios handlers en un orden particular. Chain of Responsibility te permite definir y controlar este orden.
3.  **Conjunto de handlers y su orden pueden cambiar en tiempo de ejecución:** Quieres poder añadir, quitar o reordenar handlers dinámicamente, sin modificar el código cliente.

#### 2. **Ejemplos de cuándo usar Chain of Responsibility:**

- **Validación de datos en formularios:** Diferentes validaciones (formato, longitud, rango, etc.) pueden ser handlers en una cadena.
- **Procesamiento de eventos en interfaces gráficas:** Eventos como clics de ratón pueden propagarse a través de una cadena de componentes GUI hasta que uno los maneje.
- **Sistemas de autorización y autenticación:** Verificaciones de autenticación, autorización por roles, permisos específicos, etc., pueden ser handlers en una cadena.
- **Filtros de peticiones web:** Filtros para logs, seguridad, caché, compresión, etc., pueden formar una cadena para procesar peticiones HTTP.
- **Manejo de excepciones:** Puedes tener una cadena de "catch blocks" especializados para manejar diferentes tipos de excepciones.

#### 3. **Casos en los que NO usar Chain of Responsibility:**

- **Un solo handler para todas las solicitudes:** Si solo tienes un tipo de procesamiento para todas las solicitudes, Chain of Responsibility puede ser excesivo. Un simple `if/else` o una función directa podría ser suficiente.
- **Conoces exactamente qué handler debe procesar cada solicitud:** Si el cliente siempre sabe _exactamente_ qué handler debe usar para cada tipo de solicitud, no necesitas una cadena. Podrías usar un patrón como Strategy o simplemente llamar al handler directamente.
- **Cadena demasiado larga y compleja:** Si la cadena se vuelve demasiado larga y compleja, puede ser difícil de mantener y depurar. Considera si puedes simplificar el procesamiento o usar otros patrones.

---

## J - Cómo Implementar Chain of Responsibility (Pasos)

#### 1. **Definición:**

Aquí tienes los pasos generales para implementar Chain of Responsibility:

1.  **Define la interfaz Handler:** Crea una interfaz (o clase abstracta) `Handler` que declare el método para manejar solicitudes (por ejemplo, `handleRequest(Request request)`) y el método para establecer el siguiente handler (`setNextHandler(Handler nextHandler)`). Decide cómo se pasarán los datos de la solicitud al método `handleRequest`. Usar un objeto `Request` es una buena práctica para mayor flexibilidad.
2.  **Crea una clase Base Handler (opcional):** Si quieres evitar repetir código común en los handlers concretos, crea una clase abstracta `AbstractHandler` que implemente la interfaz `Handler`. Esta clase puede tener un campo para almacenar el siguiente handler y una implementación por defecto para `handleRequest` que simplemente pasa la solicitud al siguiente handler (si existe).
3.  **Crea Handlers Concretos:** Para cada tipo de procesamiento que necesites, crea una clase Concrete Handler que extienda la clase Base Handler (o implemente directamente la interfaz Handler). En cada Concrete Handler, implementa la lógica específica para procesar la solicitud. Cada handler debe decidir:
    - **¿Procesar la solicitud?** Si sí, realiza el procesamiento necesario.
    - **¿Pasar la solicitud al siguiente handler?** Si sí (y si hay un siguiente handler), llama al método `handleRequest` del siguiente handler. Si no, o si no hay siguiente handler, la cadena termina aquí.
4.  **Crea el Cliente:** En el código cliente, crea instancias de los Concrete Handlers y **configura la cadena** enlazándolos usando el método `setNextHandler`. Envía las solicitudes al **primer handler** de la cadena. El cliente no necesita saber nada sobre los handlers concretos ni cómo se procesa la solicitud, solo necesita iniciar la cadena.
5.  **Manejo de solicitudes no manejadas:** Considera qué pasa si una solicitud llega al final de la cadena sin ser procesada por ningún handler. ¿Debería haber un handler "por defecto" al final de la cadena? ¿Debería el cliente manejar el caso de que la solicitud no sea procesada?

#### 2. **Puntos clave a recordar:**

- **Flexibilidad en la cadena:** Puedes construir la cadena de forma estática o dinámica. Puedes cambiar el orden de los handlers, añadir nuevos handlers o quitar handlers existentes sin modificar el código cliente.
- **Decisión en cada handler:** Cada handler tiene la responsabilidad de decidir si procesa la solicitud y si la pasa al siguiente. Esta decisión puede basarse en la solicitud misma, en el estado del sistema, o en cualquier otra lógica.
- **Desacoplamiento:** Chain of Responsibility desacopla el emisor de la solicitud (el cliente) de los receptores (los handlers). El cliente no necesita saber qué handler procesará la solicitud.

#### 3. **Advertencias:**

- **Posiblemente no manejada:** Asegúrate de considerar el caso en que una solicitud no sea manejada por ningún handler en la cadena.
- **Depuración:** Si la cadena es muy larga o compleja, puede ser un poco más difícil de depurar. Asegúrate de tener logs o mecanismos de seguimiento para entender cómo se procesan las solicitudes a través de la cadena.
- **Rendimiento:** Si la cadena es muy larga y cada handler realiza un procesamiento costoso, el rendimiento puede verse afectado. Considera si Chain of Responsibility es realmente el patrón más eficiente para tu caso.

---

## K - Pros y Contras del Chain of Responsibility

#### 1. **Pros (Ventajas):**

- **Control del orden de procesamiento:** Puedes definir y controlar el orden exacto en que se ejecutan los handlers para procesar una solicitud.
- **Principio de Responsabilidad Única:** Desacopla las clases que _invocan_ operaciones (clientes) de las clases que _realizan_ las operaciones (handlers). Cada handler tiene una responsabilidad específica y bien definida.
- **Principio Abierto/Cerrado:** Puedes añadir nuevos handlers al sistema sin modificar el código cliente existente ni los handlers existentes. Simplemente creas una nueva clase handler y la añades a la cadena. Esto hace que el sistema sea muy extensible y adaptable a cambios.
- **Flexibilidad y Desacoplamiento:** Reduce el acoplamiento entre el emisor y los receptores de las solicitudes. El cliente no necesita saber qué handler procesará la solicitud.
- **Reutilización de Handlers:** Puedes reutilizar los handlers en diferentes cadenas o en diferentes partes del sistema.

#### 2. **Contras (Desventajas):**

- **Posiblemente no manejada:** Algunas solicitudes pueden llegar al final de la cadena sin ser procesadas por ningún handler. Esto puede ser un problema si esperas que _todas_ las solicitudes sean manejadas. Debes considerar cómo manejar este caso.
- **Rendimiento:** Si la cadena es muy larga y cada handler realiza un procesamiento costoso, el rendimiento puede verse afectado. La solicitud tiene que pasar por varios handlers, lo que puede llevar tiempo.
- **Depuración y Seguimiento:** Puede ser un poco más difícil de depurar y seguir el flujo de una solicitud a través de la cadena, especialmente si la cadena es compleja.
- **Complejidad (en algunos casos):** Para problemas muy simples, Chain of Responsibility puede añadir una complejidad innecesaria. A veces, una solución más simple (como un `if/else` o una función directa) puede ser más adecuada.

#### 3. **Cuándo considerar si los Contras son aceptables:**

Los contras de Chain of Responsibility suelen ser aceptables cuando:

- La **flexibilidad y extensibilidad** son prioridades importantes.
- Necesitas un **control preciso sobre el orden** de procesamiento.
- El **desacoplamiento** entre el emisor y los receptores es valioso.
- Puedes manejar el caso de **solicitudes no manejadas** de forma adecuada.
- El impacto en el **rendimiento** no es crítico, o puedes optimizar los handlers si es necesario.
- La **complejidad** añadida por el patrón se justifica por los beneficios que aporta.

---

## L - Relaciones con Otros Patrones

#### 1. **Definición:**

Chain of Responsibility se relaciona con otros patrones de diseño que también se centran en cómo conectar emisores y receptores de solicitudes, pero de diferentes maneras.

#### 2. **Relaciones con otros patrones (según el texto):**

- **Chain of Responsibility, Command, Mediator, Observer:** Estos cuatro patrones abordan diferentes formas de conectar emisores y receptores de solicitudes:

  - **Chain of Responsibility:** Pasa una solicitud secuencialmente a lo largo de una cadena dinámica de posibles receptores hasta que uno la maneja. **Enfoque en la cadena y el orden secuencial.**
  - **Command:** Establece conexiones unidireccionales entre emisores y receptores. Encapsula una solicitud como un objeto. **Enfoque en encapsular la solicitud y desacoplar la invocación de la ejecución.**
  - **Mediator:** Elimina las conexiones directas entre emisores y receptores, forzándolos a comunicarse indirectamente a través de un objeto mediador. **Enfoque en centralizar la comunicación y reducir el acoplamiento directo.**
  - **Observer:** Permite a los receptores suscribirse y desuscribirse dinámicamente para recibir solicitudes (notificaciones). **Enfoque en la comunicación uno-a-muchos y la notificación de eventos.**

- **Chain of Responsibility y Composite:** Chain of Responsibility se usa a menudo junto con Composite. En este caso, cuando un componente hoja (en un árbol Composite) recibe una solicitud, puede pasarla a través de la cadena de todos sus componentes padres hasta la raíz del árbol de objetos. **Composite organiza objetos en una jerarquía de árbol, Chain of Responsibility puede usar esa jerarquía como cadena.**

- **Handlers en Chain of Responsibility como Commands:** Los handlers en Chain of Responsibility pueden implementarse como Commands. En este caso, puedes ejecutar muchas operaciones diferentes (Commands) sobre el mismo objeto de contexto (la solicitud). **Puedes usar Command para implementar la acción que realiza cada Handler.**

  - **Alternativa:** La solicitud en sí misma puede ser un objeto Command. En este caso, puedes ejecutar la misma operación (Command) en una serie de diferentes contextos (handlers en la cadena). **La solicitud podría ser un Command que se ejecuta en diferentes Handlers.**

- **Chain of Responsibility y Decorator:** Chain of Responsibility y Decorator tienen estructuras de clase muy similares (ambos usan composición recursiva para pasar la ejecución a través de una serie de objetos). Sin embargo, hay diferencias clave:
  - **Chain of Responsibility:** Los handlers pueden ejecutar operaciones arbitrarias independientemente unos de otros. Pueden detener el flujo de la solicitud en cualquier punto. **Handlers independientes, pueden detener la cadena.**
  - **Decorator:** Los decorators extienden el comportamiento de un objeto, pero manteniendo su interfaz base consistente. Los decorators no pueden romper el flujo de la solicitud. **Decoradores extienden comportamiento, no pueden detener el flujo.**

#### 3. **En resumen:**

Chain of Responsibility es un patrón flexible para manejar solicitudes en una cadena de objetos. Se relaciona con otros patrones que también abordan la comunicación entre objetos, pero se distingue por su enfoque en el **orden secuencial**, la **cadena dinámica** y la **posibilidad de que cada handler decida si procesa o pasa la solicitud**. A menudo se combina con Composite para formar cadenas basadas en jerarquías de objetos y puede usar Command para implementar las acciones de los handlers. Aunque similar en estructura a Decorator, tiene un propósito y comportamiento diferente.
