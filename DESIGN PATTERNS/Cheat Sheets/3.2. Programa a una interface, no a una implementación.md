# ¬øQu√© es "Programar hacia una Interfaz"?

Es un principio de dise√±o que nos ense√±a a escribir c√≥digo que dependa de abstracciones (interfaces o clases abstractas) en lugar de implementaciones concretas. Es como establecer un "contrato" que define QU√â se puede hacer, sin preocuparnos por C√ìMO se hace.

# Ejemplo Pr√°ctico: El Gato y su Comida üê±

1.  **Enfoque R√≠gido (Malo)**
    - El gato solo puede comer salchichas
    - ¬øPor qu√© es malo? Porque limita las opciones futuras
    - No podemos darle otro tipo de comida sin cambiar el c√≥digo
2.  **Enfoque Flexible (Bueno)**
    - El gato puede comer cualquier "Comida"
    - ¬øPor qu√© es bueno? Porque es extensible
    - Podemos a√±adir nuevos tipos de comida sin tocar el c√≥digo existente

```java
// ‚ùå IMPLEMENTACI√ìN R√çGIDA
public class GatoRigido {
    private int energia;

    public void comer(Salchicha salchicha) {
        energia += salchicha.getNutricion();
    }
}

// ‚úÖ IMPLEMENTACI√ìN FLEXIBLE
public interface Comida {
    int getNutricion();
}

public class GatoFlexible {
    private int energia;

    public void comer(Comida comida) {
        energia += comida.getNutricion();
    }
}

// Ahora podemos crear diferentes tipos de comida
public class Salchicha implements Comida {
    public int getNutricion() { return 10; }
}

public class Pescado implements Comida {
    public int getNutricion() { return 15; }
}
```

# Ejemplo Pr√°ctico: La Empresa de Software üè¢

1.  **Primera Versi√≥n (R√≠gida)**
    - La empresa trabaja directamente con tipos espec√≠ficos de empleados
    - Problema: Si queremos a√±adir nuevos tipos de empleados, hay que modificar la clase Empresa
2.  **Versi√≥n Mejorada (Flexible)**
    - La empresa trabaja con una interfaz "Empleado"
    - Ventaja: Podemos a√±adir nuevos tipos de empleados sin tocar la clase Empresa
    - Cada empleado implementa su propia forma de trabajar

# La Clave üîë

Lo m√°s importante que debes entender es que:

- Las interfaces act√∫an como "contratos" que definen comportamientos
- El c√≥digo que depende de interfaces es m√°s flexible y f√°cil de extender
- Aunque el c√≥digo inicial puede parecer m√°s complejo, la flexibilidad que ganamos vale la pena
- Este principio es fundamental para el patr√≥n Factory Method que veremos m√°s adelante

---

# Ejemplo avanzado:

```java
// ANTES: C√≥digo fuertemente acoplado
// ‚ùå Las clases est√°n directamente dependientes unas de otras

public class Designer {
    public void designArchitecture() {
        System.out.println("Dise√±ando la arquitectura...");
    }
}

public class Programmer {
    public void writeCode() {
        System.out.println("Escribiendo c√≥digo...");
    }
}

public class Tester {
    public void testSoftware() {
        System.out.println("Probando el software...");
    }
}

public class Company {
    private Designer designer;
    private Programmer programmer;
    private Tester tester;

    public void createSoftware() {
        // Creaci√≥n directa de objetos = Acoplamiento fuerte
        designer = new Designer();
        programmer = new Programmer();
        tester = new Tester();

        // Secuencia de desarrollo
        designer.designArchitecture();
        programmer.writeCode();
        tester.testSoftware();
    }
}

// DESPU√âS: Usando interfaces y el patr√≥n Factory Method
// ‚úÖ C√≥digo m√°s flexible y extensible

// 1. Interface com√∫n para todos los empleados
public interface Employee {
    void doWork();
}

// 2. Implementaciones concretas
public class Designer implements Employee {
    @Override
    public void doWork() {
        designArchitecture();
    }

    private void designArchitecture() {
        System.out.println("Dise√±ando la arquitectura...");
    }
}

public class Programmer implements Employee {
    @Override
    public void doWork() {
        writeCode();
    }

    private void writeCode() {
        System.out.println("Escribiendo c√≥digo...");
    }
}

public class Tester implements Employee {
    @Override
    public void doWork() {
        testSoftware();
    }

    private void testSoftware() {
        System.out.println("Probando el software...");
    }
}

// 3. Clase abstracta Company con Factory Method
public abstract class Company {
    // Factory Method - Cada subclase decidir√° qu√© empleados crear
    protected abstract List<Employee> getEmployees();

    // M√©todo principal que usa los empleados
    public void createSoftware() {
        List<Employee> employees = getEmployees();
        // Trabajar con empleados a trav√©s de la interfaz
        for (Employee employee : employees) {
            employee.doWork();
        }
    }
}

// 4. Implementaciones concretas de Company
public class GameDevCompany extends Company {
    @Override
    protected List<Employee> getEmployees() {
        return Arrays.asList(
            new Designer(),
            new Artist(),  // Nuevo tipo de empleado espec√≠fico para juegos
            new Programmer()
        );
    }
}

public class OutsourcingCompany extends Company {
    @Override
    protected List<Employee> getEmployees() {
        return Arrays.asList(
            new Programmer(),
            new Tester()
        );
    }
}

// 5. Ejemplo de uso
public class Main {
    public static void main(String[] args) {
        // Podemos usar diferentes tipos de compa√±√≠as
        Company gameCompany = new GameDevCompany();
        Company outsourcingCompany = new OutsourcingCompany();

        System.out.println("Desarrollo de juego:");
        gameCompany.createSoftware();

        System.out.println("\nDesarrollo outsourcing:");
        outsourcingCompany.createSoftware();
    }
}
```
