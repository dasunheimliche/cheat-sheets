# Â¿QuÃ© es el PatrÃ³n Decorator? ğŸ

El patrÃ³n Decorator es como una "capa de regalo" que puedes poner alrededor de un objeto para darle nuevas capacidades sin cambiar su cÃ³digo original. Â¡Como cuando le pones accesorios a tu avatar en un videojuego!

# Ejemplo del Mundo Real: Sistema de Notificaciones ğŸ“±

Imagina que tienes una app que solo envÃ­a emails, pero tus usuarios quieren mÃ¡s:

1.  **SituaciÃ³n Inicial**
    - Solo podÃ­as enviar emails
    - Los usuarios quieren notificaciones por SMS
    - TambiÃ©n quieren notificaciones por Facebook y Slack
    - Â¡Y algunos quieren recibir todo a la vez!
2.  **El Problema**
    - Crear una subclase por cada combinaciÃ³n serÃ­a un caos
    - NecesitarÃ­as: EmailYSms, EmailYFacebook, EmailYSlackYSms...
    - Â¡Las combinaciones se multiplicarÃ­an sin control! ğŸ˜±

# La SoluciÃ³n: Decorator ğŸ”§

```java
// 1. Interfaz base (Component)
interface Notificador {
    void enviar(String mensaje);
}

// 2. ImplementaciÃ³n base (ConcreteComponent)
class NotificadorEmail implements Notificador {
    @Override
    public void enviar(String mensaje) {
        System.out.println("ğŸ“§ Enviando email: " + mensaje);
    }
}

// 3. Decorador base (BaseDecorator)
class NotificadorDecorator implements Notificador {
    protected Notificador wrapped;

    public NotificadorDecorator(Notificador n) {
        this.wrapped = n;
    }

    @Override
    public void enviar(String mensaje) {
        wrapped.enviar(mensaje);
    }
}

// 4. Decoradores concretos (ConcreteDecorators)
class SMSDecorator extends NotificadorDecorator {
    public SMSDecorator(Notificador n) {
        super(n);
    }

    @Override
    public void enviar(String mensaje) {
        super.enviar(mensaje);
        System.out.println("ğŸ“± Enviando SMS: " + mensaje);
    }
}

class FacebookDecorator extends NotificadorDecorator {
    public FacebookDecorator(Notificador n) {
        super(n);
    }

    @Override
    public void enviar(String mensaje) {
        super.enviar(mensaje);
        System.out.println("ğŸ‘¥ Enviando notificaciÃ³n de Facebook: " + mensaje);
    }
}

class SlackDecorator extends NotificadorDecorator {
    public SlackDecorator(Notificador n) {
        super(n);
    }

    @Override
    public void enviar(String mensaje) {
        super.enviar(mensaje);
        System.out.println("ğŸ’¬ Enviando mensaje de Slack: " + mensaje);
    }
}

// 5. Cliente usando el patrÃ³n
public class Cliente {
    public static void main(String[] args) {
        // Caso 1: Solo email
        System.out.println("ğŸ”¹ NotificaciÃ³n bÃ¡sica:");
        Notificador notificador1 = new NotificadorEmail();
        notificador1.enviar("Â¡Hola mundo!");

        System.out.println("\nğŸ”¹ NotificaciÃ³n con email + SMS:");
        // Caso 2: Email + SMS
        Notificador notificador2 = new SMSDecorator(new NotificadorEmail());
        notificador2.enviar("Â¡Hola mundo!");

        System.out.println("\nğŸ”¹ NotificaciÃ³n completa:");
        // Caso 3: Email + SMS + Facebook + Slack
        Notificador notificador3 = new SlackDecorator(
            new FacebookDecorator(
                new SMSDecorator(
                    new NotificadorEmail()
                )
            )
        );
        notificador3.enviar("Â¡Hola mundo!");
    }
}

/* Salida:
ğŸ”¹ NotificaciÃ³n bÃ¡sica:
ğŸ“§ Enviando email: Â¡Hola mundo!

ğŸ”¹ NotificaciÃ³n con email + SMS:
ğŸ“§ Enviando email: Â¡Hola mundo!
ğŸ“± Enviando SMS: Â¡Hola mundo!

ğŸ”¹ NotificaciÃ³n completa:
ğŸ“§ Enviando email: Â¡Hola mundo!
ğŸ“± Enviando SMS: Â¡Hola mundo!
ğŸ‘¥ Enviando notificaciÃ³n de Facebook: Â¡Hola mundo!
ğŸ’¬ Enviando mensaje de Slack: Â¡Hola mundo!
*/
```

# La Clave ğŸ”‘

Lo mÃ¡s importante es entender que:

1.  **Flexibilidad**: Puedes aÃ±adir o quitar funcionalidades en tiempo de ejecuciÃ³n
2.  **ComposiciÃ³n**: Usamos composiciÃ³n en lugar de herencia - Â¡es como apilar LEGO!
3.  **ReutilizaciÃ³n**: Cada decorador es independiente y reutilizable

# Estructura del PatrÃ³n ğŸ—ï¸

Como vemos en el diagrama:

1.  **Component** (Notificador): Es la interfaz base que todos deben implementar
2.  **ConcreteComponent** (NotificadorEmail): La clase base que queremos decorar
3.  **BaseDecorator** (NotificadorDecorator): Mantiene la referencia al objeto decorado
4.  **ConcreteDecorators** (SMSDecorator, etc): AÃ±aden las nuevas funcionalidades
5.  **Client**: Quien construye la cadena de decoradores

# CuÃ¡ndo Usarlo ğŸ’¡

Usa el patrÃ³n Decorator cuando:

- Necesites aÃ±adir funcionalidades a objetos sin alterar su cÃ³digo
- Quieras evitar una explosiÃ³n de subclases para cada combinaciÃ³n
- Necesites poder activar/desactivar funcionalidades en tiempo de ejecuciÃ³n

# AnalogÃ­a Final ğŸ¯

Â¡Es como vestirse por la maÃ±ana! Empiezas con una camiseta (NotificadorEmail) y segÃºn el clima vas aÃ±adiendo capas: un suÃ©ter (SMSDecorator), una chaqueta (FacebookDecorator), un impermeable (SlackDecorator)... Cada prenda aÃ±ade una funcionalidad sin modificar las otras, Â¡y puedes quitarlas cuando quieras!
