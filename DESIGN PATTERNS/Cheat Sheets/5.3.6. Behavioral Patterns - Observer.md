## A - Observer

#### 1. **Definición:**

El patrón Observer es como un sistema de suscripción. Permite que un objeto, llamado **Publisher** (Publicador), notifique automáticamente a otros objetos, llamados **Subscribers** (Suscriptores), cuando algo importante sucede. Imagina que el Publisher tiene información interesante que los Subscribers quieren conocer en tiempo real.

#### 2. **Ejemplo:**

Imagina una tienda online (`Publisher`) y clientes (`Subscribers`). Los clientes se suscriben para recibir notificaciones cuando un producto que les interesa vuelve a estar en stock. En lugar de que los clientes revisen constantemente la web, la tienda les avisa directamente cuando el producto está disponible.

#### 3. **Notas o advertencias:**

- También se conoce como Event-Subscriber o Listener.
- Es útil cuando no sabes cuántos objetos necesitan ser notificados o cuando esos objetos pueden cambiar con el tiempo.

---

## B - Intent (Objetivo)

#### 1. **Definición:**

El objetivo principal del patrón Observer es definir un mecanismo de suscripción para notificar a múltiples objetos sobre eventos que ocurren en el objeto que están observando. En otras palabras, permite que un objeto (**Publisher**) avise a muchos otros objetos (**Subscribers**) cuando su estado cambia.

#### 2. **Ejemplo:**

Piensa en un botón en una aplicación. Varios componentes de la aplicación (como registros, interfaces de usuario, etc.) pueden querer reaccionar cuando se pulsa ese botón. El patrón Observer permite que el botón (Publisher) notifique a todos estos componentes (Subscribers) cuando es pulsado, sin que el botón sepa quiénes son o qué hacen exactamente los componentes.

#### 3. **Notas o advertencias:**

- Separa el objeto que causa el evento (Publisher) de los objetos que reaccionan al evento (Subscribers).
- Promueve un acoplamiento débil entre Publishers y Subscribers.

---

## C - Problem (Problema)

#### 1. **Definición:**

El problema que resuelve el patrón Observer surge cuando tienes un objeto cuyo estado interesa a muchos otros objetos, pero no quieres que estén fuertemente acoplados. Si los objetos revisan constantemente el estado del primero (polling) se desperdician recursos. Si el primer objeto notifica directamente a todos, se acopla demasiado a ellos y puede que notifique a objetos que no están interesados.

#### 2. **Ejemplo:**

Volvamos al ejemplo de la tienda y el cliente interesado en un iPhone nuevo.

- **Problema 1 (Cliente revisa constantemente):** El cliente podría ir a la tienda cada día a preguntar si ya llegó el iPhone. Esto es ineficiente para el cliente (tiempo perdido) y para la tienda (atender consultas repetitivas).

- **Problema 2 (Tienda envía spam):** La tienda podría enviar emails masivos a todos sus clientes cada vez que llega un nuevo producto. Esto molesta a los clientes que no están interesados y puede ser considerado spam.

![Visiting store vs. sending spam](https://refactoring.guru/images/patterns/content/observer/observer-comic-1-en.png)

#### 3. **Notas o advertencias:**

- El problema es cómo comunicar cambios de estado de un objeto a otros de forma eficiente y desacoplada.
- Se busca evitar tanto el polling ineficiente como el acoplamiento fuerte y las notificaciones innecesarias.

---

## D - Solution (Solución)

#### 1. **Definición:**

La solución del patrón Observer es crear un sistema de suscripción. El **Publisher** mantiene una lista de **Subscribers**. Cuando ocurre un evento importante, el Publisher notifica a todos los Subscribers en su lista. Los Subscribers se suscriben para recibir notificaciones y pueden desuscribirse cuando ya no estén interesados.

#### 2. **Ejemplo:**

En el patrón Observer, la tienda (Publisher) implementa un sistema de suscripción. Los clientes (Subscribers) se registran en este sistema para el iPhone. Cuando el iPhone llega a la tienda, la tienda notifica automáticamente a todos los clientes suscritos.

![Subscription mechanism](https://refactoring.guru/images/patterns/diagrams/observer/solution1-en.png)

#### 3. **Notas o advertencias:**

- Se basa en una interfaz común para los Subscribers, lo que permite al Publisher comunicarse con cualquier Subscriber sin conocer su clase concreta.
- El Publisher no necesita saber nada sobre los Subscribers, solo que implementan la interfaz de Subscriber.

---

## E - Real-World Analogy (Analogía del mundo real)

#### 1. **Definición:**

Una buena analogía para entender el patrón Observer son las suscripciones a revistas o periódicos.

#### 2. **Ejemplo:**

Cuando te suscribes a una revista, no necesitas ir a la tienda cada mes para ver si salió el nuevo número. La editorial (Publisher) te envía directamente la revista (notificación) a tu casa (Subscriber) cuando se publica. Puedes cancelar tu suscripción (desuscribirte) cuando quieras dejar de recibir la revista.

![Magazine and newspaper subscriptions](https://refactoring.guru/images/patterns/content/observer/observer-comic-2-en.png)

#### 3. **Notas o advertencias:**

- La editorial mantiene una lista de suscriptores y sabe a qué revistas están suscritos.
- Los suscriptores pueden unirse o abandonar la lista en cualquier momento.

---

## F - Structure (Estructura)

#### 1. **Definición:**

El patrón Observer tiene los siguientes componentes principales:

1.  **Publisher (Sujeto):** El objeto que tiene un estado interesante y notifica a los Subscribers cuando este estado cambia. Mantiene una lista de Subscribers y métodos para suscribirse y desuscribirse.
2.  **Subscriber Interface (Interfaz de Suscriptor):** Define un método `update()` que los Subscribers deben implementar para recibir notificaciones del Publisher.
3.  **Concrete Subscribers (Suscriptores Concretos):** Clases que implementan la interfaz de Subscriber y realizan alguna acción cuando son notificados por el Publisher.
4.  **Client (Cliente):** Crea objetos Publisher y Subscriber y los conecta, suscribiendo los Subscribers al Publisher.

![Structure of the Observer design pattern](https://refactoring.guru/images/patterns/diagrams/observer/structure.png)

![Structure of the Observer design pattern](https://refactoring.guru/images/patterns/diagrams/observer/structure-indexed.png)

#### 2. **Ejemplo:**

En el ejemplo de la tienda y el cliente:

- **Publisher:** La tienda.
- **Subscriber Interface:** Una interfaz que define un método como `onProductAvailable(Product product)`.
- **Concrete Subscribers:** Clases como `EmailNotificationSubscriber`, `SMSNotificationSubscriber`, etc., que implementan la interfaz y envían notificaciones por email o SMS.
- **Client:** El código que crea la tienda y los clientes, y suscribe a los clientes a las notificaciones de la tienda.

#### 3. **Notas o advertencias:**

- El Publisher solo conoce la interfaz de Subscriber, no las clases concretas de los Subscribers.
- Esto permite añadir nuevos tipos de Subscribers sin modificar el Publisher.

---

## G - Pseudocode (Pseudocódigo)

#### 1. **Definición:**

El pseudocódigo muestra una implementación básica del patrón Observer para un editor de texto que notifica a otros servicios cuando se abren o guardan archivos.

#### 2. **Ejemplo:**

```java
// Interfaz para los suscriptores
interface EventListener {
    void update(String filename);
}

// Suscriptor concreto para logging
class LoggingListener implements EventListener {
    private String logFile;

    public LoggingListener(String logFile) {
        this.logFile = logFile;
    }

    @Override
    public void update(String filename) {
        System.out.println("LOG: Archivo " + filename + " ha sido modificado. Log en: " + logFile);
    }
}

// Suscriptor concreto para alertas por email
class EmailAlertsListener implements EventListener {
    private String adminEmail;

    public EmailAlertsListener(String adminEmail) {
        this.adminEmail = adminEmail;
    }

    @Override
    public void update(String filename) {
        System.out.println("EMAIL: Alerta enviada a " + adminEmail + " sobre el archivo: " + filename);
    }
}

// Clase para gestionar eventos y suscriptores (Publisher auxiliar)
class EventManager {
    private Map<String, List<EventListener>> listeners = new HashMap<>();

    public void subscribe(String eventType, EventListener listener) {
        listeners.computeIfAbsent(eventType, k -> new ArrayList<>()).add(listener);
    }

    public void unsubscribe(String eventType, EventListener listener) {
        if (listeners.containsKey(eventType)) {
            listeners.get(eventType).remove(listener);
        }
    }

    public void notify(String eventType, String data) {
        if (listeners.containsKey(eventType)) {
            for (EventListener listener : listeners.get(eventType)) {
                listener.update(data);
            }
        }
    }
}

// Publisher concreto (Editor de texto)
class Editor {
    public EventManager events;
    private String file;

    public Editor() {
        this.events = new EventManager();
    }

    public void openFile(String filePath) {
        this.file = filePath;
        events.notify("open", file);
    }

    public void saveFile() {
        events.notify("save", file);
    }
}

// Clase de aplicación que configura todo
class Application {
    public static void main(String[] args) {
        Editor editor = new Editor();

        LoggingListener logger = new LoggingListener("app.log");
        editor.events.subscribe("open", logger);

        EmailAlertsListener emailAlerts = new EmailAlertsListener("admin@example.com");
        editor.events.subscribe("save", emailAlerts);

        editor.openFile("documento.txt");
        editor.saveFile();
    }
}
```

**Explicación del ejemplo:**

- `EventListener` es la interfaz de Subscriber con el método `update()`.
- `LoggingListener` y `EmailAlertsListener` son Subscribers concretos que registran eventos y envían emails respectivamente.
- `EventManager` gestiona la lista de Subscribers y notifica a los interesados en un evento específico.
- `Editor` es el Publisher que usa `EventManager` para notificar eventos "open" y "save".
- `Application` configura y ejecuta el ejemplo, creando un Editor, Subscribers y suscribiéndolos.

![Structure of the Observer pattern example](https://refactoring.guru/images/patterns/diagrams/observer/example.png)

#### 3. **Notas o advertencias:**

- El `EventManager` es un componente auxiliar que facilita la gestión de suscripciones.
- Este ejemplo muestra cómo desacoplar el Editor de los servicios de logging y email, permitiendo añadir más servicios fácilmente.

---

## H - Applicability (Aplicabilidad)

#### 1. **Definición:**

Usa el patrón Observer cuando:

- Un cambio en un objeto requiere cambiar otros objetos, y no sabes de antemano cuáles son o pueden cambiar dinámicamente.
- Algunos objetos deben observar a otros solo por un tiempo limitado o en casos específicos.
- Quieres desacoplar el objeto que causa los eventos de los objetos que reaccionan a ellos.

#### 2. **Ejemplo:**

- **Interfaces gráficas (GUI):** Botones, menús y otros controles (Publishers) notifican eventos (clicks, selecciones) a los componentes de la aplicación (Subscribers) que necesitan reaccionar.
- **Sistemas de noticias:** Un servicio de noticias (Publisher) notifica a los suscriptores (Subscribers) cuando hay nuevas noticias.
- **Hojas de cálculo:** Cuando una celda cambia (Publisher), las celdas dependientes (Subscribers) se recalculan automáticamente.

#### 3. **Notas o advertencias:**

- Es muy útil en sistemas basados en eventos.
- Permite crear sistemas flexibles y extensibles donde los componentes pueden interactuar sin conocerse directamente.

---

## I - How to Implement (Cómo Implementar)

#### 1. **Definición:**

Pasos para implementar el patrón Observer:

1.  **Identifica Publisher y Subscribers:** Define qué objeto será el Publisher (el que tiene el estado interesante) y cuáles serán los Subscribers (los que necesitan ser notificados).
2.  **Crea la interfaz Subscriber:** Define una interfaz con un método `update()` (o similar) que los Subscribers deben implementar. Este método recibirá las notificaciones del Publisher.
3.  **Crea la interfaz Publisher:** Define una interfaz con métodos para `subscribe(Subscriber)` y `unsubscribe(Subscriber)`.
4.  **Implementa el Publisher:** Crea la clase Publisher que implementa la interfaz Publisher. Debe mantener una lista de Subscribers y notificarles cuando ocurra un evento importante.
5.  **Implementa los Subscribers:** Crea clases Concrete Subscriber que implementen la interfaz Subscriber y definan la lógica para reaccionar a las notificaciones en el método `update()`.
6.  **Cliente conecta Publisher y Subscribers:** En el código cliente, crea instancias de Publisher y Subscribers y suscribe los Subscribers al Publisher.

#### 2. **Ejemplo:**

(Ver el ejemplo de pseudocódigo en la sección **G - Pseudocode** para una implementación más detallada en Java).

#### 3. **Notas o advertencias:**

- Puedes usar una clase abstracta para el Publisher para reutilizar la lógica de gestión de suscripciones.
- Considera si el Subscriber necesita información adicional del Publisher al ser notificado. Puedes pasar datos en el método `update()` o permitir que el Subscriber solicite datos al Publisher.

---

## J - Pros and Cons (Ventajas y Desventajas)

#### 1. **Definición:**

**Ventajas:**

- **Principio de Abierto/Cerrado:** Puedes añadir nuevos Subscribers sin modificar el código del Publisher (y viceversa si hay una interfaz de Publisher).
- **Acoplamiento Débil:** Publishers y Subscribers no necesitan conocerse en detalle, solo interactúan a través de interfaces.
- **Relaciones Dinámicas:** Puedes establecer relaciones entre objetos en tiempo de ejecución.

**Desventajas:**

- **Orden de Notificación Aleatorio:** Los Subscribers son notificados en un orden no específico. No puedes depender de un orden particular.
- **Posibles Problemas de Rendimiento:** Si hay muchos Subscribers o las notificaciones son muy frecuentes, puede afectar el rendimiento.
- **Posibles Fugas de Memoria:** Si no se gestionan correctamente las desuscripciones, puede haber fugas de memoria si los Subscribers no se liberan cuando ya no son necesarios.

#### 2. **Ejemplo:**

- **Ventaja:** En un sistema de noticias, puedes añadir fácilmente nuevos tipos de suscriptores (ej. visualización web, app móvil, email) sin cambiar el servicio de noticias principal.
- **Desventaja:** Si el servicio de noticias tiene millones de suscriptores, enviar notificaciones a todos puede consumir muchos recursos.

#### 3. **Notas o advertencias:**

- Considera las implicaciones de rendimiento si esperas un gran número de Subscribers.
- Asegúrate de implementar correctamente la desuscripción para evitar fugas de memoria.

---

## K - Relations with Other Patterns (Relaciones con otros patrones)

#### 1. **Definición:**

El patrón Observer se relaciona con otros patrones de diseño que también tratan sobre la comunicación entre objetos:

- **Chain of Responsibility, Command, Mediator:** Estos patrones, junto con Observer, abordan diferentes formas de conectar emisores y receptores de solicitudes.

  - **Chain of Responsibility:** Pasa una solicitud a través de una cadena dinámica de posibles receptores hasta que uno la maneja.
  - **Command:** Establece conexiones unidireccionales entre emisores y receptores.
  - **Mediator:** Elimina conexiones directas, haciendo que la comunicación sea a través de un objeto mediador.
  - **Observer:** Permite a los receptores suscribirse y desuscribirse dinámicamente para recibir solicitudes.

- **Mediator vs. Observer:** A veces son similares. Un Mediator puede implementarse usando Observer, donde el Mediator actúa como Publisher y los componentes como Subscribers. La diferencia clave es que Mediator busca centralizar la comunicación para reducir dependencias mutuas, mientras que Observer se centra en la notificación uno-a-muchos dinámica.

#### 2. **Ejemplo:**

- **Mediator y Observer juntos:** En un chatroom (Mediator), los usuarios (componentes) se suscriben (Observer) a las notificaciones del chat (Publisher en el Mediator). El Mediator gestiona la comunicación centralizada y usa Observer para notificar a los usuarios sobre nuevos mensajes.

#### 3. **Notas o advertencias:**

- Entender las diferencias entre estos patrones ayuda a elegir el más adecuado para cada situación.
- A veces, se pueden combinar patrones para resolver problemas más complejos.
