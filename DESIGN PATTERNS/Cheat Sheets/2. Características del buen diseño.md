## A - **Reutilización de Código**

#### 1. **Definición:**

Usar código que ya existe en proyectos nuevos, en lugar de escribirlo desde cero cada vez. ¡Es como usar piezas de Lego que ya tienes para construir algo nuevo!

#### 2. **Beneficios:**

- **Ahorra tiempo y dinero:** Desarrollar más rápido y con menos costos. ¡Más tiempo para ti y menos gasto para tu jefe!
- **Llegar al mercado antes:** Lanza tu producto antes que la competencia. ¡Sé el primero en la fiesta!

#### 3. **El Problema:**

A veces, reutilizar código es más difícil de lo que parece. Si el código viejo está muy "pegado" (acoplado) o depende de cosas muy específicas, adaptarlo a algo nuevo puede ser un lío.

#### 4. **Soluciones:**

- **Patrones de Diseño:** Hacen que las partes de tu software sean más flexibles y fáciles de reutilizar. ¡Como hacer piezas de Lego más versátiles!
- **Frameworks:** Son como plantillas o estructuras que te ayudan a construir software reutilizando ideas y diseños.

#### 5. **Advertencia:**

A veces, buscar la reutilización puede complicar las cosas. ¡No siempre es la solución mágica!

## B - **Niveles de Reutilización (Según Erich Gamma)**

Erich Gamma, un experto en patrones de diseño, nos explica que hay diferentes formas de reutilizar código, como niveles:

#### 1. **Nivel Bajo: Clases y Bibliotecas**

**Definición:** Reutilizar clases individuales, bibliotecas de funciones, o pequeños grupos de clases que trabajan juntas (como contenedores e iteradores). ¡Son como piezas de Lego sueltas o pequeños sets!

**Ejemplo:** Usar una biblioteca para manejar fechas o para conectarte a una base de datos.

**Explicación:** Es la forma más básica de reutilización. Usas componentes ya hechos para tareas específicas.

#### 2. **Nivel Medio: Patrones de Diseño**

**Definición:** Reutilizar ideas y conceptos de diseño, no solo código específico. Son como "instrucciones" sobre cómo organizar tus piezas de Lego para resolver problemas comunes.

**Ejemplo:** Usar el patrón "Observer" para que diferentes partes de tu programa se enteren cuando algo cambia, sin que estén directamente conectadas.

**Explicación:** Más abstracto que las clases. Te ayudan a reutilizar _cómo_ construir, no solo las piezas ya hechas. Menos arriesgado que los frameworks.

#### 3. **Nivel Alto: Frameworks**

**Definición:** Estructuras completas que definen cómo se construye una aplicación. Son como bases Lego pre-diseñadas que te guían en la construcción y te dicen cuándo y cómo añadir tus propias piezas.

**Ejemplo:** JUnit para pruebas automáticas en Java. Te da la estructura (Test, TestCase, TestSuite) y te dice "¡es tu turno de escribir el código de prueba!".

**Explicación:** Más "toscos" que las clases o patrones, pero muy poderosos. Usan el "Principio de Hollywood": "No nos llames, nosotros te llamamos a ti". El framework te dice _cuándo_ tu código debe actuar. Más arriesgado y requiere más inversión que los patrones.

## C - **Extensibilidad**

#### 1. **Definición:**

La facilidad con la que puedes añadir nuevas funcionalidades o modificar las existentes en tu software, sin romper lo que ya funciona. ¡Es como construir con Lego y poder añadir más piezas o cambiar algunas sin que se caiga toda la construcción!

#### 2. **La Realidad del Cambio:**

En programación, ¡todo cambia constantemente! Siempre habrá nuevas necesidades, nuevas tecnologías o nuevas ideas.

#### 3. **Ejemplos de Cambios:**

- **Nuevas plataformas:** Tu juego funciona en Windows, ¡pero ahora lo quieren para macOS!
- **Tendencias de diseño:** Botones cuadrados eran geniales, ¡ahora todos quieren botones redondos!
- **Nuevas funcionalidades:** Tu tienda online es genial, ¡pero ahora quieren aceptar pedidos por teléfono!

#### 4. **¿Por qué Cambia Todo Tanto?**

- **Mejor Comprensión:** A medida que construyes, entiendes mejor el problema. ¡A veces quieres reescribir todo desde cero porque ahora lo harías mejor!
- **Cambios Externos:** Tecnologías que se vuelven obsoletas (¡adiós Flash!).
- **Requisitos Cambiantes:** El cliente siempre quiere "solo unos pequeños cambios más" que en realidad son grandes. ¡Pero es buena señal, significa que les gusta tu trabajo!

#### 5. **Prepararse para el Cambio:**

Los programadores con experiencia siempre diseñan pensando en que el software tendrá que cambiar y crecer en el futuro. ¡Diseñar para que sea fácil de extender es clave!

## D - **Razones Detalladas para la Extensibilidad**

Profundicemos en por qué el software necesita ser extensible:

#### 1. **Mejor Comprensión del Problema**

**Definición:** Cuando empiezas un proyecto, no lo entiendes completamente. A medida que avanzas y ves la primera versión funcionando, te das cuenta de cómo podrías haberlo hecho mejor.

**Explicación:** Es como aprender a cocinar. La primera vez sigues la receta al pie de la letra, pero luego entiendes los sabores y cómo combinarlos mejor. ¡La segunda vez te sale mucho mejor!

#### 2. **Cambios Fuera de Tu Control**

**Definición:** El mundo de la tecnología cambia rápido. Algo que usabas puede dejar de funcionar o volverse obsoleto.

**Ejemplo:** Flash era popular para animaciones web, pero los navegadores dejaron de soportarlo. ¡Todos los que usaron Flash tuvieron que rehacer sus trabajos!

**Explicación:** Hay que estar preparado para adaptar el software a nuevas tecnologías y cambios en el entorno.

#### 3. **Requisitos que Evolucionan**

**Definición:** Los clientes (o usuarios) cambian de opinión o descubren nuevas necesidades a medida que ven el software funcionando.

**Ejemplo:** Un cliente pide una tienda online básica, pero al verla funcionando, se da cuenta de que también necesita aceptar pedidos por teléfono, ofrecer descuentos, etc.

**Explicación:** El éxito de tu software puede generar nuevas peticiones. ¡Es una buena señal, pero hay que estar listo para añadir esas nuevas funcionalidades!
