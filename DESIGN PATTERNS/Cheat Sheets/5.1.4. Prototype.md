# ¬øQu√© es el Patr√≥n Prototype? üß¨

El patr√≥n Prototype es como tener una "fotocopiadora de objetos" que nos permite crear copias exactas de objetos existentes sin depender de sus clases concretas. ¬°Es como la divisi√≥n celular en biolog√≠a, donde una c√©lula se duplica a s√≠ misma!

# Ejemplo del Mundo Real: Sistema de Documentos üìÑ

Imagina que tienes una aplicaci√≥n de documentos con diferentes tipos de plantillas:

1.  **Situaci√≥n Inicial**
    - Tienes documentos complejos con muchas configuraciones
    - Crear cada documento desde cero es costoso
    - Necesitas variaciones de documentos similares
2.  **El Problema**
    - Crear nuevos documentos es lento y consume recursos
    - No siempre conocemos la clase exacta del objeto
    - Algunos campos son privados y no accesibles desde fuera

# La Soluci√≥n: Prototype üîß

```java
// Enfoque Directo (Problem√°tico) ‚ùå
class EditorGrafico {
    public Forma duplicarForma(Forma forma) {
        // ¬°PROBLEMA! Necesitamos saber la clase exacta
        if (forma instanceof Circulo) {
            Circulo circulo = (Circulo) forma;
            return new Circulo(circulo.getX(), circulo.getY(), circulo.getRadio());
        }
        else if (forma instanceof Rectangulo) {
            Rectangulo rectangulo = (Rectangulo) forma;
            return new Rectangulo(rectangulo.getX(), rectangulo.getY(),
                                rectangulo.getAncho(), rectangulo.getAlto());
        }
        // ¬øY si a√±adimos una nueva forma? üò±
        // Habr√≠a que modificar este c√≥digo
        return null;
    }
}

// Soluci√≥n con Prototype (Mejor Enfoque) ‚úÖ

// Solo necesitamos conocer esta interfaz
interface Forma {
    Forma clonar();  // ¬°Cada forma sabe clonarse a s√≠ misma!
}

class Circulo implements Forma {
    private int x, y, radio;

    @Override
    public Forma clonar() {
        return new Circulo(this.x, this.y, this.radio);
    }
}

class Rectangulo implements Forma {
    private int x, y, ancho, alto;

    @Override
    public Forma clonar() {
        return new Rectangulo(this.x, this.y, this.ancho, this.alto);
    }
}

class EditorGrafico {
    public Forma duplicarForma(Forma forma) {
        // ¬°MUCHO MEJOR! No necesitamos saber la clase concreta
        return forma.clonar();
    }
}
```

# La Clave üîë

Los puntos m√°s importantes son:

1.  **Delegaci√≥n**: El objeto original es responsable de crear su propia copia
2.  **Independencia**: No necesitas conocer la clase concreta para crear copias
3.  **Eficiencia**: Evitas la inicializaci√≥n costosa al clonar objetos existentes

# Estructura del Patr√≥n üèóÔ∏è

El diagrama muestra dos implementaciones:

1.  **Implementaci√≥n B√°sica**:
    - `Prototype`: Interfaz con m√©todo clonar()
    - `ConcretePrototype`: Implementa la clonaci√≥n
    - `Client`: Usa el prototipo para crear copias

![image info](prototype1.png)

# Consejo Pr√°ctico üí°

Usa Prototype cuando:

- La creaci√≥n de objetos es costosa o compleja
- Quieres reducir el n√∫mero de subclases
- Necesitas ocultar la complejidad de crear objetos
- Quieres evitar repetir la inicializaci√≥n de objetos similares

# ¬øQu√© es el Registro de Prototipos? üìö

Imagina que tienes una biblioteca de plantillas reutilizables. El Registro de Prototipos es como un "cat√°logo" o "biblioteca" donde guardas objetos pre-configurados listos para ser clonados.

# Ejemplo Pr√°ctico: Sistema de UI üé®

```java
// 1. Primero, definimos nuestro registro
class PrototypeRegistry {
    private Map<String, UIComponent> items = new HashMap<>();

    // Guardar un prototipo
    public void addItem(String key, UIComponent prototype) {
        items.put(key, prototype);
    }

    // Obtener una copia de un prototipo
    public UIComponent getByName(String key) {
        UIComponent prototype = items.get(key);
        return prototype != null ? prototype.clonar() : null;
    }
}

// 2. Ejemplo de uso
class Main {
    public static void main(String[] args) {
        PrototypeRegistry registry = new PrototypeRegistry();

        // Guardamos prototipos pre-configurados
        Button botonRojoGrande = new Button(100, 50, "rojo", 20);
        Button botonAzulPequeno = new Button(60, 30, "azul", 14);

        registry.addItem("boton.rojo.grande", botonRojoGrande);
        registry.addItem("boton.azul.pequeno", botonAzulPequeno);

        // M√°s tarde, cuando necesitemos un bot√≥n...
        Button nuevoBoton = registry.getByName("boton.rojo.grande").clonar();
    }
}
```

# Versi√≥n Avanzada con B√∫squeda por Criterios üîç

```java
class PrototypeRegistryAvanzado {
    private List<UIComponent> items = new ArrayList<>();

    public void addItem(UIComponent prototype) {
        items.add(prototype);
    }

    // B√∫squeda por m√∫ltiples criterios
    public UIComponent getByCriteria(Map<String, Object> criteria) {
        return items.stream()
            .filter(item -> matchesCriteria(item, criteria))
            .findFirst()
            .map(UIComponent::clonar)
            .orElse(null);
    }

    private boolean matchesCriteria(UIComponent item, Map<String, Object> criteria) {
        return criteria.entrySet().stream()
            .allMatch(entry -> {
                String property = entry.getKey();
                Object value = entry.getValue();

                return switch (property) {
                    case "color" -> item.getColor().equals(value);
                    case "size" -> item.getSize() == (int) value;
                    case "type" -> item.getType().equals(value);
                    default -> false;
                };
            });
    }
}

// Uso del registro avanzado
Map<String, Object> criteria = new HashMap<>();
criteria.put("color", "rojo");
criteria.put("size", 20);
criteria.put("type", "button");

Button botonEspecifico = registry.getByCriteria(criteria).clonar();
```

# Beneficios del Registro üéÅ

1.  **Centralizaci√≥n**: Todos los prototipos en un solo lugar
2.  **Reutilizaci√≥n**: Evitas crear los mismos objetos una y otra vez
3.  **Mantenibilidad**: F√°cil de a√±adir o modificar prototipos
4.  **Flexibilidad**: Puedes implementar diferentes estrategias de b√∫squeda

# Estructura del Patr√≥n üèóÔ∏è

El diagrama muestra dos implementaciones:

1.  **Registro de Prototipos**:
    - Almacena prototipos comunes
    - Permite buscar y clonar por nombre o criterio
    - √ötil para gestionar m√∫ltiples prototipos

![image info](prototype2.png)

# Consejo Pr√°ctico üí°

El registro es especialmente √∫til cuando:

- Tienes objetos que se crean frecuentemente
- La configuraci√≥n de los objetos es compleja
- Necesitas mantener una "biblioteca" de objetos predefinidos
- Quieres un punto central para gestionar todos tus prototipos
