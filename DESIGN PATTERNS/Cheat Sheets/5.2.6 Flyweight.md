# ¬øQu√© es el Patr√≥n Flyweight? üé®

El Flyweight es como una biblioteca de recursos compartidos. Imagina que en lugar de que cada libro tenga su propia copia de todas las im√°genes, la biblioteca tiene un cat√°logo central de im√°genes que todos los libros comparten.

# Ejemplo del Mundo Real: Editor de Texto Rico üìù

Imagina que est√°s construyendo un editor de texto como Microsoft Word o Google Docs:

1.  **Situaci√≥n Inicial**
    - El documento tiene millones de caracteres
    - Cada car√°cter tiene informaci√≥n de fuente, tama√±o, color, estilo...
    - Los usuarios reportan que el editor consume mucha RAM üò±
2.  **El Problema**
    - Cada letra 'a' guarda su propia informaci√≥n de formato
    - Una 'a' en Arial 12pt negrita se repite miles de veces
    - ¬°Estamos desperdiciando memoria!

# La Soluci√≥n: Flyweight üöÄ

```java
// ‚ùå ANTES (cada car√°cter guarda toda su informaci√≥n)
class Caracter {
    char simbolo;
    String fuente;      // "Arial", "Times New Roman", etc.
    int tama√±o;         // 12, 14, 16, etc.
    String color;       // "Negro", "Rojo", etc.
    boolean negrita;    // true/false
    boolean cursiva;    // true/false
    int posicionX;      // Posici√≥n espec√≠fica
    int posicionY;      // en el documento
}

// ‚úÖ DESPU√âS (usando Flyweight)
// 1. Estado intr√≠nseco (compartido) - El Flyweight
class EstiloCaracter {
    private final String fuente;
    private final int tama√±o;
    private final String color;
    private final boolean negrita;
    private final boolean cursiva;

    // Constructor inmutable
    public EstiloCaracter(String fuente, int tama√±o, String color,
                         boolean negrita, boolean cursiva) {
        this.fuente = fuente;
        this.tama√±o = tama√±o;
        this.color = color;
        this.negrita = negrita;
        this.cursiva = cursiva;
    }

    // Solo getters, sin setters para mantener inmutabilidad
    public void dibujar(char simbolo, int x, int y, Graphics g) {
        // Configura el estilo y dibuja el car√°cter
        g.setFont(new Font(fuente, getFontStyle(), tama√±o));
        g.setColor(Color.decode(color));
        g.drawString(String.valueOf(simbolo), x, y);
    }
}

// 2. Estado extr√≠nseco - El Contexto
class CaracterEnDocumento {
    private char simbolo;
    private int x;
    private int y;
    private EstiloCaracter estilo;  // Referencia al Flyweight

    public CaracterEnDocumento(char simbolo, int x, int y, EstiloCaracter estilo) {
        this.simbolo = simbolo;
        this.x = x;
        this.y = y;
        this.estilo = estilo;
    }

    public void dibujar(Graphics g) {
        estilo.dibujar(simbolo, x, y, g);
    }
}

// 3. F√°brica de Flyweights
class EstiloCaracterFactory {
    private static final Map<String, EstiloCaracter> estilos = new HashMap<>();

    public static EstiloCaracter obtenerEstilo(String fuente, int tama√±o,
                                             String color, boolean negrita,
                                             boolean cursiva) {
        // Creamos una clave √∫nica para este estilo
        String clave = String.format("%s_%d_%s_%b_%b",
            fuente, tama√±o, color, negrita, cursiva);

        // Reutilizamos el estilo si ya existe
        return estilos.computeIfAbsent(clave, k ->
            new EstiloCaracter(fuente, tama√±o, color, negrita, cursiva));
    }
}

// 4. El Documento que usa los Flyweights
class Documento {
    private List<CaracterEnDocumento> contenido = new ArrayList<>();

    public void a√±adirCaracter(char simbolo, int x, int y,
                              String fuente, int tama√±o,
                              String color, boolean negrita,
                              boolean cursiva) {
        // Obtiene (o crea) el estilo compartido
        EstiloCaracter estilo = EstiloCaracterFactory.obtenerEstilo(
            fuente, tama√±o, color, negrita, cursiva);

        // Crea el contexto espec√≠fico para este car√°cter
        CaracterEnDocumento caracter = new CaracterEnDocumento(
            simbolo, x, y, estilo);

        contenido.add(caracter);
    }

    public void dibujar(Graphics g) {
        for (CaracterEnDocumento caracter : contenido) {
            caracter.dibujar(g);
        }
    }
}
```

# Ejemplo de Uso üíª

```java
public class EditorTexto {
    public static void main(String[] args) {
        Documento doc = new Documento();

        // A√±adimos texto con el mismo estilo
        String texto = "¬°Hola Mundo!";
        int x = 10;
        for (char c : texto.toCharArray()) {
            doc.a√±adirCaracter(c, x, 100, "Arial", 12, "#000000", true, false);
            x += 10; // Movemos la posici√≥n X para el siguiente car√°cter
        }

        // Aunque creamos 11 caracteres, solo existe UN objeto EstiloCaracter
        // compartido por todos ellos, ¬°ahorrando memoria!
    }
}
```

# Beneficios Concretos üìä

En este ejemplo:

- Sin Flyweight: Cada car√°cter = ~30-40 bytes √ó millones = GB de RAM
- Con Flyweight: Solo unos pocos KB para todos los estilos compartidos

# Estructura del Patr√≥n üèóÔ∏è

1.  **EstiloCaracter (Flyweight)**
    - Contiene el estado compartido inmutable
    - No tiene setters, solo getters
    - Se crea una sola vez y se reutiliza
2.  **CaracterEnDocumento (Contexto)**
    - Contiene el estado √∫nico (posici√≥n, s√≠mbolo)
    - Referencia al Flyweight compartido
3.  **EstiloCaracterFactory**
    - Gestiona la creaci√≥n y cache de Flyweights
    - Asegura que no se dupliquen estilos id√©nticos
4.  **Documento**
    - Cliente que utiliza los Flyweights
    - Coordina la creaci√≥n y uso de caracteres

# Consejo Pr√°ctico Avanzado üéì

1.  **Identifica Claramente los Estados:**
    - Intr√≠nseco: Lo que se puede compartir (estilos)
    - Extr√≠nseco: Lo √∫nico de cada objeto (posici√≥n)
2.  **Asegura la Inmutabilidad:**
    - Los Flyweights deben ser inmutables
    - Usa constructores completos
    - No proporciones setters
3.  **Optimiza la F√°brica:**
    - Usa una buena estrategia de cach√©
    - Considera limpiar el cach√© si es necesario
    - Usa claves √∫nicas eficientes

Este ejemplo muestra c√≥mo el patr√≥n Flyweight puede hacer que una aplicaci√≥n que maneja grandes cantidades de datos similares sea mucho m√°s eficiente en t√©rminos de memoria, mientras mantiene una estructura clara y mantenible.
