# ¬øQu√© es el Principio de Sustituci√≥n de Liskov?

El Principio de Sustituci√≥n de Liskov (LSP) es como una "regla de reemplazo seguro" en programaci√≥n orientada a objetos. Imagina que tienes una receta que pide "fruta" - deber√≠as poder usar una manzana o una naranja y la receta deber√≠a funcionar igual de bien. De la misma manera, cuando heredas de una clase, tu nueva clase deber√≠a poder "reemplazar" a la clase padre sin romper nada.

# Ejemplo Pr√°ctico: La Jerarqu√≠a Animal

1.  **Buen Ejemplo: Gato y Animal**

    ```java
        // Clase base
        class Animal {
            public void comer(Comida comida) {
                // L√≥gica b√°sica de alimentaci√≥n
            }
        }

        // ‚úÖ CORRECTO: GatoDomestico extiende sin romper nada
        class GatoDomestico extends Animal {
            @Override
            public void comer(Comida comida) {
                // Puede agregar comportamiento espec√≠fico
                super.comer(comida);  // Mantiene comportamiento base
            }
        }
    ```

2.  **Mal Ejemplo: Documento de Solo Lectura**

    ```java
        // ‚ùå INCORRECTO: Rompe el principio
        class Documento {
            public void guardar() {
                // Guarda el documento
            }
        }

        class DocumentoSoloLectura extends Documento {
            @Override
            public void guardar() {
                throw new Exception("No se puede guardar"); // ¬°Rompe el comportamiento esperado!
            }
        }
    ```

# Las 5 Reglas de Oro üåü

1.  **Regla de los Par√°metros**
    - Los par√°metros en la clase hija pueden ser m√°s generales, nunca m√°s espec√≠ficos
    - Ejemplo: Si el padre acepta `Gato`, el hijo puede aceptar `Animal` (m√°s general)
2.  **Regla del Retorno**
    - El valor de retorno en la clase hija puede ser m√°s espec√≠fico, nunca m√°s general
    - Ejemplo: Si el padre retorna `Animal`, el hijo puede retornar `Gato` (m√°s espec√≠fico)
3.  **Regla de las Excepciones**
    - Las excepciones en la clase hija deben ser del mismo tipo o subtipos de las del padre
    - No puedes lanzar nuevas excepciones que el padre no maneje
4.  **Regla de las Precondiciones y Postcondiciones**
    - No puedes hacer las reglas m√°s estrictas en la clase hija
    - Si el padre acepta n√∫meros negativos, el hijo tambi√©n debe aceptarlos
5.  **Regla de los Invariantes**
    - Las caracter√≠sticas fundamentales de la clase padre deben mantenerse
    - Si un gato siempre tiene cuatro patas en la clase padre, no puedes crear un gato con tres patas en la clase hija

# La Soluci√≥n en la Pr√°ctica üõ†Ô∏è

Mirando el ejemplo de los documentos en las im√°genes:

1.  **Problema Original (Imagen 1)**
    - `ReadOnlyDocument` hereda de `Document` pero rompe su comportamiento
    - Lanza una excepci√≥n en `save()` que no se espera
2.  **Soluci√≥n Correcta (Imagen 2)**
    - Se invierte la jerarqu√≠a
    - `Document` es la base con funcionalidad b√°sica
    - `WritableDocument` extiende a√±adiendo la capacidad de guardar

# Consejo Final üí°

Cuando heredes de una clase, preg√∫ntate:

- ¬øMi nueva clase puede hacer TODO lo que hace la clase padre?
- ¬øMantengo todas las promesas (contratos) de la clase padre?
- ¬øUn usuario puede usar mi clase sin saber que no es la clase padre?

Si la respuesta a todas es "s√≠", ¬°est√°s respetando el Principio de Liskov!

---

# Ejemplo avanzado

```java
// ‚ùå Caso INCORRECTO que viola el Principio de Sustituci√≥n de Liskov

public class Document {
    protected String data;
    protected String filename;

    public void open() {
        System.out.println("Abriendo documento: " + filename);
        // L√≥gica de apertura
    }

    public void save() {
        System.out.println("Guardando documento: " + filename);
        // L√≥gica de guardado
    }
}

public class ReadOnlyDocument extends Document {
    @Override
    public void save() {
        // ‚ùå Viola LSP: Cambia el comportamiento esperado lanzando una excepci√≥n
        throw new RuntimeException("No se puede guardar el archivo de solo lectura.");
    }
}

public class Project {
    private List<Document> documents;

    public Project() {
        this.documents = new ArrayList<>();
    }

    public void openAll() {
        for (Document doc : documents) {
            doc.open();
        }
    }

    public void saveAll() {
        for (Document doc : documents) {
            // ‚ùå Problema: Necesitamos verificar el tipo para evitar la excepci√≥n
            if (!(doc instanceof ReadOnlyDocument)) {
                doc.save();
            }
        }
    }
}

// ‚úÖ Caso CORRECTO que respeta el Principio de Sustituci√≥n de Liskov

public class Document {
    protected String data;
    protected String filename;

    public void open() {
        System.out.println("Abriendo documento: " + filename);
        // L√≥gica de apertura
    }
}

public class WritableDocument extends Document {
    public void save() {
        System.out.println("Guardando documento: " + filename);
        // L√≥gica de guardado
    }
}

public class Project {
    private List<Document> allDocs;        // Todos los documentos
    private List<WritableDocument> writableDocs;  // Solo documentos escribibles

    public Project() {
        this.allDocs = new ArrayList<>();
        this.writableDocs = new ArrayList<>();
    }

    public void openAll() {
        // Todos los documentos pueden abrirse
        for (Document doc : allDocs) {
            doc.open();
        }
    }

    public void saveAll() {
        // ‚úÖ Solo intentamos guardar los documentos que sabemos que son escribibles
        for (WritableDocument doc : writableDocs) {
            doc.save();
        }
    }

    public void addDocument(Document doc) {
        allDocs.add(doc);
        if (doc instanceof WritableDocument) {
            writableDocs.add((WritableDocument) doc);
        }
    }
}

// Ejemplo de uso
public class Main {
    public static void main(String[] args) {
        Project project = new Project();

        // Crear documentos
        Document readOnlyDoc = new Document();  // Documento de solo lectura
        WritableDocument writableDoc = new WritableDocument();  // Documento escribible

        // Agregar al proyecto
        project.addDocument(readOnlyDoc);
        project.addDocument(writableDoc);

        // Usar el proyecto
        project.openAll();  // Abre todos los documentos
        project.saveAll();  // Solo guarda los documentos escribibles
    }
}
```
