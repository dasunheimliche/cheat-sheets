## A - Dividiendo tu Store en "Rebanadas" MÃ¡s PequeÃ±as

#### 1. **DefiniciÃ³n:**

A medida que tu aplicaciÃ³n crece, tu store de Zustand puede volverse enorme y difÃ­cil de mantener. El patrÃ³n de "Slices" te ayuda a dividir un store grande en stores individuales mÃ¡s pequeÃ±os y modulares, Â¡como cortar un pastel grande en rebanadas mÃ¡s manejables! ğŸ°

#### 2. **Ejemplo:**

Imagina que tienes un store que maneja informaciÃ³n sobre osos y peces. En lugar de tener un store gigante, puedes crear dos "rebanadas" separadas:

**Primera rebanada (para peces):**

```typescript
export const createFishSlice = (set) => ({
  fishes: 0,
  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),
});
```

**Segunda rebanada (para osos):**

```typescript
export const createBearSlice = (set) => ({
  bears: 0,
  addBear: () => set((state) => ({ bears: state.bears + 1 })),
  eatFish: () => set((state) => ({ fishes: state.fishes - 1 })), // Â¡Ojo! Esta rebanada tambiÃ©n afecta a 'fishes'
});
```

**ExplicaciÃ³n del ejemplo:**

- **`createFishSlice` y `createBearSlice`:** Cada una de estas funciones crea una "rebanada" de tu store. Cada rebanada es responsable de una parte especÃ­fica del estado y las acciones relacionadas.
- **`set` dentro de cada rebanada:** Cada rebanada recibe la funciÃ³n `set` de Zustand, que usa para actualizar su propia parte del estado. FÃ­jate que `createBearSlice` tambiÃ©n puede modificar `fishes`, Â¡aunque `fishes` estÃ© definido en otra rebanada!

#### 3. **Notas o advertencias:**

- **Modularidad y OrganizaciÃ³n:** El patrÃ³n de slices hace que tu cÃ³digo sea mÃ¡s modular, organizado y fÃ¡cil de entender. Cada rebanada se enfoca en una parte especÃ­fica de la lÃ³gica, Â¡lo que facilita el mantenimiento y la colaboraciÃ³n! ğŸ—‚ï¸
- **Rebanadas como funciones:** Las rebanadas se crean como funciones (`createFishSlice`, `createBearSlice`) que reciben `set` (y opcionalmente `get`). Esta es la forma estÃ¡ndar de definir la lÃ³gica de un store en Zustand.

## B - Combinando las "Rebanadas" en un Store "Unido"

#### 1. **DefiniciÃ³n:**

Una vez que has creado tus rebanadas individuales, necesitas combinarlas en un Ãºnico store "unido" que puedas usar en tus componentes React. Zustand hace que esto sea muy sencillo: Â¡simplemente usa el spread operator (`...`) dentro de la funciÃ³n de creaciÃ³n de tu store principal! ğŸ§©

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";
import { createBearSlice } from "./bearSlice"; // Importa las rebanadas individuales
import { createFishSlice } from "./fishSlice";

export const useBoundStore = create((...a) => ({
  // Crea el store "unido"
  ...createBearSlice(...a), // Incluye la rebanada de osos
  ...createFishSlice(...a), // Incluye la rebanada de peces
}));
```

**ExplicaciÃ³n del ejemplo:**

- **`create((...a) => ({ ... }))`:** Usamos la funciÃ³n `create` de Zustand para crear nuestro store "unido".
- **`...createBearSlice(...a), ...createFishSlice(...a)`:** Dentro de la funciÃ³n de creaciÃ³n del store, usamos el spread operator (`...`) para "esparcir" las propiedades y acciones de `createBearSlice(...a)` y `createFishSlice(...a)` dentro de un Ãºnico objeto. Â¡Esto combina efectivamente las dos rebanadas en un solo store!
- **`(...a)`:** Pasamos `(...a)` a cada `createBearSlice` y `createFishSlice`. Esto asegura que las funciones `set` y `get` de Zustand se pasen correctamente a cada rebanada.

#### 3. **Notas o advertencias:**

- **Spread Operator para Combinar:** El spread operator (`...`) es la clave para combinar las rebanadas. Â¡Es una forma muy concisa y elegante de juntar objetos en JavaScript! âœ¨
- **Un Ãšnico Hook `useBoundStore`:** DespuÃ©s de combinar las rebanadas, tendrÃ¡s un Ãºnico hook `useBoundStore` que puedes usar en tus componentes React para acceder a todas las partes del estado y acciones de todas las rebanadas.

## C - Usando el Store "Unido" en un Componente React

#### 1. **DefiniciÃ³n:**

Una vez que has creado tu store "unido" con rebanadas, usarlo en un componente React es exactamente igual que usar cualquier otro store de Zustand. Simplemente usa el hook `useBoundStore` para seleccionar las partes del estado y las acciones que necesitas en tu componente. âš›ï¸

#### 2. **Ejemplo:**

```typescript
import { useBoundStore } from "./stores/useBoundStore"; // Importa el store "unido"

function App() {
  const bears = useBoundStore((state) => state.bears); // Selecciona 'bears' del estado
  const fishes = useBoundStore((state) => state.fishes); // Selecciona 'fishes' del estado
  const addBear = useBoundStore((state) => state.addBear); // Selecciona la acciÃ³n 'addBear'
  return (
    <div>
      <h2>Number of bears: {bears}</h2>
      <h2>Number of fishes: {fishes}</h2>
      <button onClick={() => addBear()}>Add a bear</button>
    </div>
  );
}
```

**ExplicaciÃ³n del ejemplo:**

- **`useBoundStore((state) => state.bears)`:** Usamos `useBoundStore` para seleccionar la parte del estado `bears`. Zustand se encargarÃ¡ de re-renderizar el componente `App` solo cuando `bears` cambie.
- **`useBoundStore((state) => state.fishes)`:** Similarmente, seleccionamos `fishes`.
- **`useBoundStore((state) => state.addBear)`:** Seleccionamos la acciÃ³n `addBear`.
- **Componente React normal:** Dentro del componente `App`, usamos las partes del estado y la acciÃ³n seleccionadas para mostrar informaciÃ³n y permitir la interacciÃ³n del usuario. Â¡No hay nada especial aquÃ­ en comparaciÃ³n con stores de Zustand sin slices!

#### 3. **Notas o advertencias:**

- **Misma API de Zustand:** Desde la perspectiva del componente React, Â¡no hay diferencia entre usar un store con slices y un store sin slices! La API de Zustand sigue siendo la misma. Esto hace que el patrÃ³n de slices sea muy fÃ¡cil de adoptar en aplicaciones existentes de Zustand. ğŸ‘
- **SelecciÃ³n granular del estado:** Como siempre con Zustand, puedes seleccionar exactamente las partes del estado que necesita cada componente, optimizando las re-renderizaciones y el rendimiento. ğŸš€

## D - Actualizando MÃºltiples "Rebanadas" al Mismo Tiempo

#### 1. **DefiniciÃ³n:**

Una de las ventajas del patrÃ³n de slices es que puedes crear acciones que actualicen el estado en _mÃºltiples_ rebanadas al mismo tiempo. Esto es Ãºtil para acciones que afectan a varias partes del estado de forma coordinada. ğŸ¤

#### 2. **Ejemplo:**

Imagina que quieres crear una acciÃ³n que aÃ±ada un oso _y_ un pez al mismo tiempo. Puedes crear una nueva rebanada que combine acciones de las rebanadas de osos y peces:

```typescript
export const createBearFishSlice = (set, get) => ({
  addBearAndFish: () => {
    get().addBear(); // Â¡Llama a la acciÃ³n 'addBear' de la rebanada de osos!
    get().addFish(); // Â¡Llama a la acciÃ³n 'addFish' de la rebanada de peces!
  },
});
```

**ExplicaciÃ³n del ejemplo:**

- **`createBearFishSlice`:** Creamos una nueva rebanada llamada `createBearFishSlice`.
- **`addBearAndFish: () => { ... }`:** Esta rebanada define una acciÃ³n `addBearAndFish`.
- **`get().addBear(); get().addFish();`:** Dentro de `addBearAndFish`, usamos `get()` para acceder a _todas_ las acciones de _todas_ las rebanadas combinadas en nuestro store "unido". Llamamos a `get().addBear()` (de `createBearSlice`) y `get().addFish()` (de `createFishSlice`). Â¡Esto ejecuta las acciones de las otras rebanadas, actualizando el estado en ambas rebanadas al mismo tiempo!

#### 3. **Notas o advertencias:**

- **`get()` para acceder a otras rebanadas:** La funciÃ³n `get()` que Zustand proporciona a las funciones de creaciÃ³n de rebanadas es muy poderosa. Te permite acceder al estado y acciones de _todo_ el store "unido", Â¡incluyendo las de otras rebanadas! Esto facilita la creaciÃ³n de acciones coordinadas entre rebanadas. ğŸ”—
- **Combinando rebanadas en el store "unido":** Para que `createBearFishSlice` funcione, Â¡asegÃºrate de incluirla tambiÃ©n al combinar las rebanadas en tu `useBoundStore`! (ver el siguiente ejemplo).

## E - Combinando Todas las "Rebanadas" Juntas (Incluyendo la Nueva Rebanada Combinada)

#### 1. **DefiniciÃ³n:**

Para que la nueva rebanada `createBearFishSlice` y su acciÃ³n `addBearAndFish` estÃ©n disponibles en tu store "unido", necesitas incluirla al combinar las rebanadas, Â¡igual que hiciste con `createBearSlice` y `createFishSlice`! ğŸ§©

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";
import { createBearSlice } from "./bearSlice";
import { createFishSlice } from "./fishSlice";
import { createBearFishSlice } from "./createBearFishSlice"; // Â¡Importa la nueva rebanada combinada!

export const useBoundStore = create((...a) => ({
  ...createBearSlice(...a),
  ...createFishSlice(...a),
  ...createBearFishSlice(...a), // Â¡Incluye la nueva rebanada combinada aquÃ­!
}));
```

**ExplicaciÃ³n del ejemplo:**

- **`import { createBearFishSlice } from './createBearFishSlice';`:** Importa la nueva rebanada `createBearFishSlice`.
- **`...createBearFishSlice(...a),`:** AÃ±ade `...createBearFishSlice(...a)` al objeto que se devuelve en la funciÃ³n de creaciÃ³n de `useBoundStore`. Â¡Esto incluye la nueva rebanada y su acciÃ³n `addBearAndFish` en tu store "unido"!

#### 3. **Notas o advertencias:**

- **Orden de las rebanadas (generalmente) no importa:** En la mayorÃ­a de los casos, el orden en que combinas las rebanadas con el spread operator no importa. Las propiedades y acciones de todas las rebanadas se combinarÃ¡n en un Ãºnico objeto. Sin embargo, si tienes propiedades o acciones con el _mismo nombre_ en diferentes rebanadas, Â¡la rebanada que se incluya _Ãºltima_ en el spread operator "ganarÃ¡" y sobrescribirÃ¡ las anteriores! Ten cuidado con las colisiones de nombres si tienes rebanadas complejas. âš ï¸

## F - AÃ±adiendo Middlewares a Stores con "Rebanadas"

#### 1. **DefiniciÃ³n:**

AÃ±adir middlewares a un store que usa el patrÃ³n de slices es exactamente igual que aÃ±adir middlewares a cualquier otro store de Zustand. Simplemente envuelve la funciÃ³n de creaciÃ³n de tu store "unido" con el middleware que quieras usar (como `persist`, `devtools`, etc.). ğŸ”Œ

#### 2. **Ejemplo:**

Imagina que quieres usar el middleware `persist` para guardar el estado de tu store "unido" en el almacenamiento local del navegador:

```typescript
import { create } from "zustand";
import { createBearSlice } from "./bearSlice";
import { createFishSlice } from "./fishSlice";
import { persist } from "zustand/middleware"; // Importa el middleware 'persist'

export const useBoundStore = create(
  persist(
    // Â¡Envuelve la funciÃ³n de creaciÃ³n del store con 'persist'!
    (...a) => ({
      ...createBearSlice(...a),
      ...createFishSlice(...a),
    }),
    { name: "bound-store" } // ConfiguraciÃ³n del middleware 'persist' (nombre del store en el almacenamiento)
  )
);
```

**ExplicaciÃ³n del ejemplo:**

- **`import { persist } from 'zustand/middleware';`:** Importa el middleware `persist`.
- **`persist(/* funciÃ³n de creaciÃ³n del store */, /* opciones */)`:** Envolvemos la funciÃ³n de creaciÃ³n de nuestro store "unido" (la funciÃ³n que usa el spread operator para combinar las rebanadas) dentro de la funciÃ³n `persist(...)`.
- **`{ name: 'bound-store' }`:** Pasamos un objeto de opciones a `persist`, incluyendo el `name` para identificar el store en el almacenamiento local.

#### 3. **Notas o advertencias:**

- **Middlewares en el Store "Unido", No en las Rebanadas:** **Â¡Importante!** Aplica los middlewares **solo** en el store "unido" (el que combina todas las rebanadas), **no** dentro de las funciones de creaciÃ³n de rebanadas individuales (`createBearSlice`, `createFishSlice`, etc.). Aplicar middlewares dentro de las rebanadas puede llevar a comportamientos inesperados y errores. Â¡MantÃ©n los middlewares en el nivel superior del store "unido"! â˜ï¸
- **Mismos Middlewares, Misma ConfiguraciÃ³n:** Puedes usar cualquier middleware de Zustand (como `devtools`, `immer`, etc.) con stores que usan el patrÃ³n de slices, Â¡y la configuraciÃ³n es exactamente la misma que con stores sin slices! La compatibilidad con middlewares es una de las grandes ventajas de Zustand. ğŸ‘
