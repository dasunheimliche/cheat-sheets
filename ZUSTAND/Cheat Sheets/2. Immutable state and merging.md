## A - Estado Inmutable y Combinación en Zustand

#### 1. **Definición:**

Al igual que en React con `useState`, en Zustand, ¡el estado debe actualizarse de forma **inmutable**! Esto significa que cuando cambias el estado, no modificas el estado anterior directamente. En lugar de eso, ¡creas un **nuevo** estado con los cambios! Piensa en ello como si tuvieras un dibujo original y, en lugar de borrar y dibujar encima, haces una copia del dibujo y la modificas. ¡El original siempre se mantiene intacto!

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";

const useCountStore = create((set) => ({
  count: 0,
  inc: () => set((state) => ({ count: state.count + 1 })),
}));
```

**Explicación del ejemplo:**

Aquí, `inc` es una función que incrementa `count`. Usamos `set` para actualizar el estado. Dentro de `set`, recibimos el estado actual (`state`) y devolvemos un **nuevo objeto** `{ count: state.count + 1 }`. ¡Este nuevo objeto es el nuevo estado! El estado anterior no se ha cambiado directamente.

#### 3. **Notas o advertencias:**

- La inmutabilidad es clave para que Zustand y React funcionen correctamente y puedan detectar los cambios de estado de manera eficiente.

## B - Función `set` para actualizar

#### 1. **Definición:**

La función `set` es tu herramienta principal en Zustand para **actualizar el estado** dentro de tu store. `set` es una función que Zustand te proporciona cuando creas tu store con `create`. La usas para decirle a Zustand: "¡Oye, el estado ha cambiado, aquí tienes el nuevo estado!".

#### 2. **Ejemplo:**

Ya lo vimos en el ejemplo anterior:

```typescript
inc: () => set((state) => ({ count: state.count + 1 }));
```

**Explicación del ejemplo:**

`set` toma una función como argumento. Esta función recibe el estado actual (`state`) y debe **devolver el nuevo estado**. En este caso, devolvemos `{ count: state.count + 1 }`, que es el nuevo estado con `count` incrementado.

## C - Combinación automática de `set` (Merging)

#### 1. **Definición:**

Zustand es muy amigable y hace algo genial por ti: cuando usas `set`, ¡**combina automáticamente** el nuevo estado que le das con el estado anterior! Esto significa que no tienes que copiar manualmente todo el estado anterior cada vez que quieres actualizar solo una parte. Es como si Zustand dijera: "Ah, solo quieres cambiar esto, ¡yo me encargo de mantener el resto igual!".

#### 2. **Ejemplo:**

En lugar de escribir esto (que sería lo "normal" para la inmutabilidad):

```typescript
set((state) => ({ ...state, count: state.count + 1 })); // Copia todo el estado y luego cambia count
```

¡Puedes escribir simplemente esto, y funciona igual de bien!:

```typescript
set((state) => ({ count: state.count + 1 })); // ¡Más corto y claro!
```

**Explicación del ejemplo:**

En el primer caso, `...state` copia todas las propiedades del estado anterior al nuevo objeto, y luego solo cambiamos `count`. En el segundo caso, ¡solo le damos a `set` la parte que queremos cambiar (`count`)! Zustand **automáticamente** mantiene el resto del estado anterior. ¡Es una gran comodidad!

#### 3. **Notas o advertencias:**

- Esta combinación automática es **superficial** (shallow). Funciona bien para propiedades directas del estado, pero para objetos anidados, necesitas ser un poco más explícito, como veremos a continuación.

## D - Objetos Anidados y Combinación Explícita

#### 1. **Definición:**

Si tu estado tiene **objetos dentro de objetos** (anidados), la combinación automática de `set` solo funciona en el primer nivel. Para actualizar partes **dentro** de objetos anidados, necesitas usar el "spread operator" (`...`) **manualmente** para asegurarte de que la inmutabilidad se mantenga en todos los niveles. Es como si la combinación automática solo abriera la primera caja, pero si quieres cambiar algo dentro de una caja que está dentro de otra, ¡tienes que abrir las cajas tú mismo!

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";

const useCountStore = create((set) => ({
  nested: { count: 0 },
  inc: () =>
    set((state) => ({
      nested: { ...state.nested, count: state.nested.count + 1 }, // ¡Usamos ...state.nested!
    })),
}));
```

**Explicación del ejemplo:**

Aquí, el estado tiene un objeto `nested` que contiene `count`. Para actualizar `count`, dentro de `set`, creamos un nuevo objeto `nested`. Dentro de este nuevo `nested`, usamos `...state.nested` para **copiar** las propiedades del `nested` anterior, y luego **reemplazamos** `count` con el nuevo valor. ¡Así nos aseguramos de que `nested` también se actualice de forma inmutable!

#### 3. **Notas o advertencias:**

- Recuerda usar `...` para copiar los objetos anidados que necesitas actualizar. Si tienes objetos muy anidados, esto puede volverse un poco repetitivo. Para casos más complejos, ¡existen librerías que te pueden ayudar! (como vimos en la sección anterior sobre actualizaciones anidadas).

## E - Flag `replace` para `set`

#### 1. **Definición:**

Si **no quieres** la combinación automática de `set` (por alguna razón muy específica), puedes **desactivarla** usando un segundo argumento en `set`: el flag `replace` con valor `true`. Cuando `replace` es `true`, `set` **reemplaza completamente** el estado anterior con el nuevo estado que le das, ¡sin combinar nada! Es como si le dijeras a Zustand: "¡Olvida el estado anterior, este nuevo estado es todo lo que hay ahora!".

#### 2. **Ejemplo:**

```typescript
set((state) => newState, true); // El segundo argumento 'true' activa el modo 'replace'
```

**Explicación del ejemplo:**

En este ejemplo genérico, `newState` es el nuevo estado que quieres establecer. Al poner `true` como segundo argumento en `set`, le indicas a Zustand que **reemplace** el estado actual con `newState` por completo, sin intentar combinar nada del estado anterior.

#### 3. **Notas o advertencias:**

- En la mayoría de los casos, **no necesitarás** usar el flag `replace`. La combinación automática de `set` es muy útil y suele ser lo que quieres. Solo usa `replace: true` si tienes una razón muy clara para querer **reemplazar completamente** el estado.
- Usar `replace: true` puede ser útil en situaciones muy específicas donde realmente quieres "resetear" el estado a un valor completamente nuevo, sin mantener nada del estado anterior.
