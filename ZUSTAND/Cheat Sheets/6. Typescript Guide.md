## A - Uso Básico de TypeScript en Zustand

#### 1. **Definición:**

Cuando usas TypeScript con Zustand, en lugar de escribir `create(...)`, necesitas escribir `create<T>()(...)`. Esa `<T>` es para decirle a TypeScript de qué tipo es tu estado. ¡Piensa en ello como ponerle una etiqueta a tu caja de estado para que todos sepan qué hay dentro! 📦

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";

interface BearState {
  bears: number;
  increase: (by: number) => void;
}

const useBearStore = create<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}));
```

**Explicación del ejemplo:**
Aquí, `BearState` es como el plano de tu estado. Le decimos a Zustand (`create<BearState>()`) que nuestro store va a seguir este plano. Así, TypeScript sabe que `bears` es un número y `increase` es una función que toma un número. ¡Todo en orden y bien tipado! ✅

#### 3. **Notas o advertencias:**

- **Paréntesis extra `()`:** No olvides esos paréntesis extra `()` después de `create<T>()`. Son importantes para que TypeScript entienda todo correctamente.
- **¿Por qué no se infiere el tipo automáticamente?** TypeScript a veces se confunde un poco con la forma en que Zustand está construido internamente. Es como si le preguntaras "¿Qué fue primero, el huevo o la gallina?" 🐔🥚. Para evitar que se haga un lío, le damos una pista con `<T>`.

## B - ¿Por qué `create<T>()(...)` y no solo `create<T>(...)`?

#### 1. **Definición:**

Esa doble paréntesis `()(...)` es un truco ingenioso, una especie de "atajo" para un problema específico de TypeScript. Imagina que TypeScript necesita un poquito de ayuda para entender qué tipo de error podría ocurrir en ciertas situaciones. ¡Este truco le da esa ayuda extra! 🦸‍♂️

#### 2. **Ejemplo:**

Imagina que tienes una función que maneja errores en promesas:

```typescript
declare const withError: {
  <E>(): <T>(
    p: Promise<T>
  ) => Promise<[error: undefined, value: T] | [error: E, value: undefined]>;
  <T, E>(p: Promise<T>): Promise<
    [error: undefined, value: T] | [error: E, value: undefined]
  >;
};
declare const doSomething: () => Promise<string>;

interface Foo {
  bar: string;
}

const main = async () => {
  let [error, value] = await withError<Foo>()(doSomething());
};
```

**Explicación del ejemplo:**
Aquí, `withError<Foo>()(doSomething())` muestra el patrón `()(...)`. `withError<Foo>()` es como decir "quiero especificar el tipo de error `E` como `Foo`". El segundo paréntesis `(doSomething())` ya le pasa la promesa. ¡Es una forma de darle a TypeScript la información justa que necesita sin complicar las cosas! 🧩

#### 3. **Notas o advertencias:**

- **Problema de TypeScript:** Este patrón `()(...)` es una solución para un problema conocido en TypeScript ([microsoft/TypeScript#10571](https://github.com/microsoft/TypeScript/issues/10571)). No es algo específico de Zustand, ¡sino una forma inteligente de trabajar _con_ TypeScript!
- **Alternativa `combine`:** Si no quieres usar `()(...)`, Zustand te da otra opción: `combine`. Con `combine`, Zustand es lo suficientemente listo para inferir el tipo de estado por sí solo, ¡así que no necesitas especificarlo manualmente!

## C - Usando `combine` para inferir el tipo de estado

#### 1. **Definición:**

`combine` es como un "comodín" que te ofrece Zustand. Cuando lo usas, le dices: "Oye, Zustand, ¡encárgate tú de adivinar el tipo de estado! Yo te daré las partes, y tú las juntas". Es genial cuando quieres simplificar un poco las cosas y dejar que Zustand haga el trabajo pesado de los tipos. 💪

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";
import { combine } from "zustand/middleware";

const useBearStore = create(
  combine({ bears: 0 }, (set) => ({
    increase: (by: number) => set((state) => ({ bears: state.bears + by })),
  }))
);
```

**Explicación del ejemplo:**
Mira qué limpio se ve esto. Usamos `combine` para juntar `{ bears: 0 }` (nuestro estado inicial) y la función que define cómo cambia el estado. ¡Zustand usa `combine` para entender automáticamente que el estado tiene la forma `{ bears: number, increase: (by: number) => void }`! ✨

#### 3. **Notas o advertencias:**

- **Menos "seguridad" de tipo, más conveniencia:** `combine` es súper conveniente, pero hay una pequeña "trampa". Al confiar en la inferencia automática, podrías perder un poquito de la seguridad de tipo que te da TypeScript. Por ejemplo, si haces algo raro con `set` o `get`, TypeScript podría no avisarte tan rápido como lo haría si definieras el tipo explícitamente.
- **Cuidado con `replace` y `Object.keys`:** Si usas `combine`, ten cuidado al usar `set` con el argumento `replace: true` o al usar `Object.keys(get())`. Podrían comportarse de manera un poco inesperada porque TypeScript infiere el tipo de `get()` de una manera ligeramente "simplificada". ¡Pero en la mayoría de los casos, `combine` es tu amigo! 🐻🤝

## D - ¡Ojo con `combine`! Cosas que debes saber

#### 1. **Definición:**

Cuando usas `combine`, Zustand hace un pequeño "truco" con los tipos de `set`, `get` y `store` que recibes en tu función de creación de estado. Es como si te dijeran una pequeña "mentirilla piadosa" sobre el tipo de estado, ¡pero con buena intención! 😉

#### 2. **Ejemplo:**

Imagina que usas `combine` así:

```typescript
import { create } from "zustand";
import { combine } from "zustand/middleware";

const useBearStore = create(
  combine({ bears: 0 }, (set, get) => ({
    increase: (by: number) => set((state) => ({ bears: state.bears + by })),
  }))
);
```

**Explicación del ejemplo:**
Aquí, dentro de la función de `combine`, TypeScript piensa que `get()` solo te dará `{ bears: number }`. ¡Pero en realidad, `get()` te da el estado completo: `{ bears: number, increase: (by: number) => void }`! Es una "mentirilla" porque `{ bears: number }` es un "subtipo" de `{ bears: number, increase: (by: number) => void }`, así que en la mayoría de los casos, ¡no notarás la diferencia! 🤫

#### 3. **Notas o advertencias:**

- **`set({ bears: 0 }, true)` puede ser peligroso:** Si usas `set` con `replace: true` (el segundo argumento), ¡podrías borrar accidentalmente partes de tu estado! Por ejemplo, `set({ bears: 0 }, true)` podría eliminar la función `increase`, aunque TypeScript no te avise. ¡Ten cuidado! 🐻🚧
- **`Object.keys(get())` te dará sorpresas:** `Object.keys(get())` te dará `["bears", "increase"]`, ¡no solo `["bears"]`! El tipo "simplificado" de `get()` podría confundirte si no estás al tanto de este detalle.
- **`combine` es genial, pero con precaución:** `combine` es muy útil para no tener que escribir tipos de estado manualmente, ¡y funciona bien en la mayoría de los casos! Solo recuerda estas pequeñas "peculiaridades" para evitar sorpresas.

## E - Usando Middlewares con TypeScript

#### 1. **Definición:**

Los middlewares en Zustand son como "enchufes" que puedes conectar a tu store para añadirle funcionalidades extra, como guardar el estado en el navegador (`persist`) o usar las herramientas de desarrollo de Redux (`devtools`). ¡Con TypeScript, usarlos es súper sencillo! 🔌

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";

interface BearState {
  bears: number;
  increase: (by: number) => void;
}

const useBearStore = create<BearState>()(
  devtools(
    persist(
      (set) => ({
        bears: 0,
        increase: (by) => set((state) => ({ bears: state.bears + by })),
      }),
      { name: "bearStore" }
    )
  )
);
```

**Explicación del ejemplo:**
Aquí, envolvemos nuestra función de creación de estado con `persist(...)` y luego con `devtools(...)`. ¡Es como poner capas a una cebolla! 🧅 TypeScript entiende todo perfectamente porque estamos usando los middlewares justo dentro de `create`. ¡Magia de tipos! ✨

#### 3. **Notas o advertencias:**

- **¡Directamente dentro de `create`!** Asegúrate de usar los middlewares _inmediatamente_ dentro de `create`. Si intentas hacer algo más "sofisticado" (como crear una función que combine middlewares), ¡podrías necesitar tipos más avanzados! 🤯
- **Orden de los middlewares: `devtools` al final:** Se recomienda poner `devtools` _al final_ de la cadena de middlewares. Por ejemplo, si usas `immer` y `devtools`, haz `devtools(immer(...))` y no `immer(devtools(...))`. Esto asegura que `devtools` funcione correctamente y no se pierdan los tipos. ¡El orden importa! ☝️

## F - Middlewares Avanzados y "Mutar" el Store

#### 1. **Definición:**

Los middlewares de Zustand no solo "envuelven" tu store, ¡también pueden _cambiarlo_! Pueden añadir propiedades nuevas o modificar las existentes. Esto es muy potente, pero ¿cómo le decimos a TypeScript sobre estos cambios? ¡Aquí viene la magia de los "mutadores de tipo de orden superior"! 🧙‍♂️

#### 2. **Ejemplo (hipotético):**

Imagina que quieres crear un middleware `foo` que añade una propiedad `foo` a tu store:

```typescript
import { create } from "zustand";

const foo = (f, bar) => (set, get, store) => {
  store.foo = bar; // ¡Middleware mutando el store!
  return f(set, get, store);
};

const useBearStore = create(foo(() => ({ bears: 0 }), "hello"));
console.log(useBearStore.foo.toUpperCase()); // ¡Funciona!
```

**Explicación del ejemplo:**
El middleware `foo` toma una función `f` (que crea el estado) y un valor `bar`. Dentro del middleware, _modificamos_ el objeto `store` directamente, añadiéndole `store.foo = bar`. ¡Esto cambia la forma del store! Zustand tiene un sistema de tipos muy avanzado que permite que TypeScript entienda estos cambios. ¡Es como si los tipos pudieran "mutar" junto con el store! 🤯

#### 3. **Notas o advertencias:**

- **"Mutadores de tipo de orden superior":** Este nombre suena complicado, ¡pero es la clave para que TypeScript entienda los middlewares que cambian el store! Si estás creando middlewares complejos o usando `StateCreator` directamente, ¡quizás quieras investigar sobre esto! 🤓
- **Magia de TypeScript:** En lenguajes de programación normales, esto sería casi imposible de tipar correctamente. ¡Pero gracias a las características avanzadas de TypeScript, Zustand lo hace posible! ✨

## G - Manejando el Flag `replace` Dinámico en `setState`

#### 1. **Definición:**

A veces, no sabes si vas a usar `replace: true` en `setState` hasta que el código se está ejecutando. Si el valor de `replace` se decide "en el último momento", TypeScript podría confundirse un poco con los tipos. ¡Pero hay un truco para solucionarlo! 🪄

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";

interface BearState {
  bears: number;
  increase: (by: number) => void;
}

const useBearStore = create<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}));

const replaceFlag = Math.random() > 0.5; // ¡`replaceFlag` se decide en tiempo de ejecución!
const args = [{ bears: 5 }, replaceFlag] as Parameters<
  typeof useBearStore.setState
>;
useBearStore.setState(...args); // ¡Usando el truco!
```

**Explicación del ejemplo:**
Aquí, `replaceFlag` es `true` o `false` al azar. Para que TypeScript no se queje, creamos `args` usando `as Parameters<typeof useBearStore.setState>`. Esto le dice a TypeScript: "Confía en mí, sé lo que estoy haciendo. Estos argumentos son válidos para `setState`". ¡Y funciona! 👍

#### 3. **Notas o advertencias:**

- **`as Parameters<typeof useBearStore.setState>` es el truco:** Esta parte `as Parameters<typeof useBearStore.setState>` es la clave. Le decimos a TypeScript que `args` tiene la misma forma que los argumentos que `setState` espera. ¡Es como darle un "comodín" a TypeScript! 🃏
- **Workaround, no solución perfecta:** Esto es un "workaround", una solución ingeniosa para un problema específico. No es la forma más "elegante" de hacerlo, ¡pero funciona para salir del paso cuando necesitas `replace` dinámico! 😉

## H - Recetas Comunes: Middleware Logger (sin cambiar el tipo del store)

#### 1. **Definición:**

Un middleware "logger" es como un "espía" que observa cada vez que el estado de tu store cambia y muestra información en la consola. Es muy útil para depurar y entender qué está pasando en tu aplicación. Este ejemplo muestra cómo crear un logger que _no_ cambia el tipo del store. 🕵️‍♂️

#### 2. **Ejemplo:**

```typescript
import { create, StateCreator, StoreMutatorIdentifier } from "zustand";

type Logger = <
  T,
  Mps extends [StoreMutatorIdentifier, unknown][] = [],
  Mcs extends [StoreMutatorIdentifier, unknown][] = []
>(
  f: StateCreator<T, Mps, Mcs>,
  name?: string
) => StateCreator<T, Mps, Mcs>;

const loggerImpl = (f, name) => (set, get, store) => {
  const loggedSet: typeof set = (...a) => {
    set(...(a as Parameters<typeof set>));
    console.log(...(name ? [`${name}:`] : []), get()); // ¡Logueando el estado!
  };
  const setState = store.setState;
  store.setState = (...a) => {
    setState(...(a as Parameters<typeof setState>));
    console.log(...(name ? [`${name}:`] : []), store.getState()); // ¡También logueando con setState!
  };

  return f(loggedSet, get, store);
};

export const logger = loggerImpl as unknown as Logger;

// ---

interface BearState {
  bears: number;
  increase: (by: number) => void;
}

const useBearStore = create<BearState>()(
  logger(
    (set) => ({
      bears: 0,
      increase: (by) => set((state) => ({ bears: state.bears + by })),
    }),
    "bear-store"
  )
);
```

**Explicación del ejemplo:**
Este código crea un middleware `logger` que puedes usar con `create`. El `logger` "envuelve" las funciones `set` y `setState` del store. Cada vez que llamas a `set` o `setState`, el logger primero hace lo que normalmente harían, ¡y luego muestra el estado actual en la consola! 📝

#### 3. **Notas o advertencias:**

- **Tipos complejos, ¡pero no te asustes!** Los tipos `Logger`, `LoggerImpl` y toda esa "parafernalia" de tipos avanzados son necesarios para que TypeScript entienda que este middleware _no_ cambia la forma del store. Si estás empezando, ¡puedes usar este código como plantilla y adaptarlo! 🛠️
- **`console.log` para depurar:** La clave del logger es el `console.log(...)`. Puedes personalizar lo que se muestra en la consola para que te dé la información que necesitas para depurar tu aplicación. 🐛➡️🦋

## I - Recetas Comunes: Middleware que _Sí_ Cambia el Tipo del Store

#### 1. **Definición:**

Este es un ejemplo de un middleware que _sí_ modifica el tipo del store, añadiéndole una nueva propiedad llamada `foo`. Es un ejemplo más avanzado que muestra cómo usar los "mutadores de tipo" de Zustand para que TypeScript entienda estos cambios. 🧰

#### 2. **Ejemplo:**

```typescript
import {
  create,
  StateCreator,
  StoreMutatorIdentifier,
  Mutate,
  StoreApi,
} from "zustand";

type Foo = <
  T,
  A,
  Mps extends [StoreMutatorIdentifier, unknown][] = [],
  Mcs extends [StoreMutatorIdentifier, unknown][] = []
>(
  f: StateCreator<T, [...Mps, ["foo", A]], Mcs>,
  bar: A
) => StateCreator<T, Mps, [["foo", A], ...Mcs]>;

declare module "zustand" {
  interface StoreMutators<S, A> {
    foo: Write<Cast<S, object>, { foo: A }>;
  }
}

const fooImpl = (f, bar) => (set, get, _store) => {
  type T = ReturnType<typeof f>;
  type A = typeof bar;

  const store = _store as Mutate<StoreApi<T>, [["foo", A]]>;
  store.foo = bar; // ¡Middleware añadiendo `store.foo`!
  return f(set, get, _store);
};

export const foo = fooImpl as unknown as Foo;

type Write<T extends object, U extends object> = Omit<T, keyof U> & U;
type Cast<T, U> = T extends U ? T : U;

// ---

const useBearStore = create(foo(() => ({ bears: 0 }), "hello"));
console.log(useBearStore.foo.toUpperCase()); // ¡`useBearStore.foo` existe y es de tipo string!
```

**Explicación del ejemplo:**
Este código crea un middleware `foo` que, cuando lo usas, añade una propiedad `foo` a tu store. La parte clave aquí son los tipos avanzados (`Foo`, `StoreMutators`, `Mutate`, etc.). Estos tipos le dicen a TypeScript: "Oye, este middleware va a cambiar el tipo del store, ¡añadiéndole una propiedad `foo` de tipo `A`!". ¡Así, TypeScript sabe que `useBearStore.foo` existe y es del tipo correcto! 🤯

#### 3. **Notas o advertencias:**

- **Tipos muy avanzados:** Este ejemplo es para usuarios avanzados que necesitan crear middlewares que modifican la estructura del store. Los tipos son bastante complejos, ¡pero son necesarios para que TypeScript entienda la "mutación" del store! 🤯
- **`declare module 'zustand'`:** Esta línea es crucial. Le dice a TypeScript que estamos "extendiendo" la definición de tipos de Zustand, añadiendo la posibilidad de que los middlewares "muten" el store. ¡Es como "enseñarle" a TypeScript nuevas "trucos"! 🧙‍♂️

## J - `create` sin el "Truco" de Currying `()(...)`

#### 1. **Definición:**

Normalmente, se recomienda usar `create<T>()(...)` para que TypeScript pueda inferir el tipo de tu store. Pero si por alguna razón _no_ quieres usar este "truco" de currying, ¡también hay una manera de hacerlo! Eso sí, ten cuidado, ¡podría ser un poco más "delicado"! ⚠️

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";

interface BearState {
  bears: number;
  increase: (by: number) => void;
}

const useBearStore = create<
  BearState,
  [["zustand/persist", BearState], ["zustand/devtools", never]]
>(
  devtools(
    persist(
      (set) => (
        {
          bears: 0,
          increase: (by) => set((state) => ({ bears: state.bears + by })),
        },
        { name: "bearStore" }
      )
    )
  )
);
```

**Explicación del ejemplo:**
Aquí, en lugar de `create<BearState>()(...)`, usamos `create<BearState, [['zustand/persist', BearState], ['zustand/devtools', never]]>(...)`. Le estamos dando a `create` _dos_ parámetros de tipo: `BearState` (el tipo de estado) y `[['zustand/persist', BearState], ['zustand/devtools', never]]` (información sobre los middlewares). ¡Es una forma más "directa" de decirle a TypeScript todo lo que necesita saber! 🎯

#### 3. **Notas o advertencias:**

- **Menos recomendado:** Aunque funciona, esta forma de usar `create` es menos recomendada que el "truco" `()(...)`. En algunos casos, podría comportarse más como una "afirmación de tipo" (como decirle a TypeScript "¡confía en mí, este tipo es correcto!") que como una "anotación de tipo" (darle información para que TypeScript _infiera_ el tipo). ¡Así que úsalo con precaución! 🚧
- **Complejidad extra:** Tener que especificar los tipos de los middlewares (`[['zustand/persist', BearState], ['zustand/devtools', never]]`) puede ser más complicado y propenso a errores. El "truco" `()(...)` suele ser más sencillo y robusto. 👍

## K - Patrón de "Slices" (Rebanadas) para organizar tu estado

#### 1. **Definición:**

Cuando tu store de Zustand empieza a crecer y tener muchas partes diferentes, puede ser útil organizarlo en "slices" o "rebanadas". Cada "slice" se encarga de una parte específica del estado y de las funciones que la modifican. ¡Es como dividir un pastel grande en porciones más pequeñas y manejables! 🍰

#### 2. **Ejemplo:**

```typescript
import { create, StateCreator } from "zustand";

interface BearSlice {
  bears: number;
  addBear: () => void;
  eatFish: () => void;
}

interface FishSlice {
  fishes: number;
  addFish: () => void;
}

interface SharedSlice {
  addBoth: () => void;
  getBoth: () => void;
}

const createBearSlice: StateCreator<
  BearSlice & FishSlice,
  [],
  [],
  BearSlice
> = (set) => ({
  bears: 0,
  addBear: () => set((state) => ({ bears: state.bears + 1 })),
  eatFish: () => set((state) => ({ fishes: state.fishes - 1 })),
});

const createFishSlice: StateCreator<
  BearSlice & FishSlice,
  [],
  [],
  FishSlice
> = (set) => ({
  fishes: 0,
  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),
});

const createSharedSlice: StateCreator<
  BearSlice & FishSlice,
  [],
  [],
  SharedSlice
> = (set, get) => ({
  addBoth: () => {
    get().addBear(); // ¡Reutilizando funciones de otros slices!
    get().addFish();
  },
  getBoth: () => get().bears + get().fishes,
});

const useBoundStore = create<BearSlice & FishSlice & SharedSlice>()((...a) => ({
  ...createBearSlice(...a),
  ...createFishSlice(...a),
  ...createSharedSlice(...a),
}));
```

**Explicación del ejemplo:**
Aquí, dividimos nuestro estado en tres "slices": `BearSlice`, `FishSlice` y `SharedSlice`. Cada `create...Slice` es una función que crea una parte del estado y sus funciones relacionadas. Luego, en `create<...>()(...)`, ¡juntamos todos los slices con el spread operator (`...`)! Es una forma muy organizada de manejar estados complejos. 🗂️

#### 3. **Notas o advertencias:**

- **Organización y reutilización:** El patrón de slices te ayuda a mantener tu código de Zustand organizado y facilita la reutilización de funciones entre diferentes partes del estado. ¡Es como tener cajones separados para tus calcetines, camisetas y pantalones! 🧦👕👖
- **Tipos `StateCreator`:** Fíjate en los tipos `StateCreator<...>` que usamos para cada slice. Son un poco más complejos, pero le dicen a TypeScript cómo se combinan los diferentes slices y qué tipo de estado espera cada uno. Si usas middlewares, ¡tendrás que ajustar estos tipos! 🛠️

## L - Hook `useStore` "Acotado" (Bounded) para Vanilla Stores

#### 1. **Definición:**

Si estás usando `createStore` de Zustand (la versión "vanilla", sin React), quizás quieras crear tu propio hook `useStore` personalizado que esté "acotado" a tu tipo de estado específico. Esto te da la misma comodidad de tipo que el `useStore` normal de Zustand, ¡pero para vanilla stores! 🎣

#### 2. **Ejemplo:**

```typescript
import { useStore } from "zustand";
import { createStore } from "zustand/vanilla";

interface BearState {
  bears: number;
  increase: (by: number) => void;
}

const bearStore = createStore<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}));

function useBearStore(): BearState; // ¡Firma sin selector!
function useBearStore<T>(selector: (state: BearState) => T): T; // ¡Firma con selector!
function useBearStore<T>(selector?: (state: BearState) => T) {
  return useStore(bearStore, selector!);
}
```

**Explicación del ejemplo:**
Aquí, creamos un hook `useBearStore` específico para nuestro `bearStore` vanilla. Usamos "sobrecarga de funciones" (las dos primeras líneas `function useBearStore()...`) para definir dos "firmas" diferentes para el hook: una sin selector (que devuelve todo el estado `BearState`) y otra con selector (que devuelve solo una parte del estado, de tipo `T`). ¡Así, `useBearStore` es tan cómodo de usar como el `useStore` normal, pero con tipos específicos para tu store vanilla! 🎣✨

#### 3. **Notas o advertencias:**

- **Tipado fuerte para vanilla stores:** Este patrón te permite tener un tipado fuerte y seguro incluso cuando usas vanilla stores de Zustand (que no están directamente conectados a React). ¡Es genial si quieres usar Zustand en otros contextos además de React! 🌐
- **`createBoundedUseStore` para reutilizar:** Si creas muchos vanilla stores y quieres hooks `useStore` acotados para cada uno, puedes crear una función `createBoundedUseStore` "abstracta" para reutilizar el código y no tener que repetir todo esto cada vez. ¡DRY (Don't Repeat Yourself) es un buen principio! 💧

## M - Referencia Rápida: Middlewares y sus "Mutadores"

#### 1. **Definición:**

Cuando usas middlewares con Zustand y TypeScript, a veces necesitas decirle a TypeScript qué "mutadores" (cambios de tipo) introduce cada middleware. Aquí tienes una lista rápida de los mutadores de los middlewares más comunes de Zustand: 📝

#### 2. **Lista de Middlewares y Mutadores:**

- **`devtools`**: `["zustand/devtools", never]`
- **`persist`**: `["zustand/persist", YourPersistedState]`. `YourPersistedState` es el tipo de estado que vas a guardar (si usas `partialize`, es el tipo que devuelve `partialize`; si no, suele ser `Partial<YourState>`). A veces, si tienes problemas, prueba a usar `unknown` en lugar de `PersistedState`. 💾
- **`immer`**: `["zustand/immer", never]`
- **`subscribeWithSelector`**: `["zustand/subscribeWithSelector", never]`
- **`redux`**: `["zustand/redux", YourAction]`. `YourAction` es el tipo de las acciones de Redux que vas a usar. 🔄
- **`combine`**: `combine` _no_ introduce ningún mutador, ¡porque no cambia el tipo del store! 🤝

#### 3. **Notas o advertencias:**

- **`never` significa "sin cambio de tipo":** Cuando ves `never` como mutador, significa que ese middleware _no_ cambia el tipo del store en sí mismo. Solo añade funcionalidades extra sin modificar la estructura del estado. 🧘‍♂️
- **`YourPersistedState` y `YourAction`:** Para `persist` y `redux`, necesitas especificar el tipo de estado que se guarda (`YourPersistedState`) o el tipo de acciones de Redux (`YourAction`). ¡Asegúrate de usar los tipos correctos para que TypeScript esté contento! 🤓
