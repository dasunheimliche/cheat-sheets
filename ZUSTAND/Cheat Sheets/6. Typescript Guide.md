## A - Uso BÃ¡sico de TypeScript en Zustand

#### 1. **DefiniciÃ³n:**

Cuando usas TypeScript con Zustand, en lugar de escribir `create(...)`, necesitas escribir `create<T>()(...)`. Esa `<T>` es para decirle a TypeScript de quÃ© tipo es tu estado. Â¡Piensa en ello como ponerle una etiqueta a tu caja de estado para que todos sepan quÃ© hay dentro! ğŸ“¦

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";

interface BearState {
  bears: number;
  increase: (by: number) => void;
}

const useBearStore = create<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}));
```

**ExplicaciÃ³n del ejemplo:**
AquÃ­, `BearState` es como el plano de tu estado. Le decimos a Zustand (`create<BearState>()`) que nuestro store va a seguir este plano. AsÃ­, TypeScript sabe que `bears` es un nÃºmero y `increase` es una funciÃ³n que toma un nÃºmero. Â¡Todo en orden y bien tipado! âœ…

#### 3. **Notas o advertencias:**

- **ParÃ©ntesis extra `()`:** No olvides esos parÃ©ntesis extra `()` despuÃ©s de `create<T>()`. Son importantes para que TypeScript entienda todo correctamente.
- **Â¿Por quÃ© no se infiere el tipo automÃ¡ticamente?** TypeScript a veces se confunde un poco con la forma en que Zustand estÃ¡ construido internamente. Es como si le preguntaras "Â¿QuÃ© fue primero, el huevo o la gallina?" ğŸ”ğŸ¥š. Para evitar que se haga un lÃ­o, le damos una pista con `<T>`.

## B - Â¿Por quÃ© `create<T>()(...)` y no solo `create<T>(...)`?

#### 1. **DefiniciÃ³n:**

Esa doble parÃ©ntesis `()(...)` es un truco ingenioso, una especie de "atajo" para un problema especÃ­fico de TypeScript. Imagina que TypeScript necesita un poquito de ayuda para entender quÃ© tipo de error podrÃ­a ocurrir en ciertas situaciones. Â¡Este truco le da esa ayuda extra! ğŸ¦¸â€â™‚ï¸

#### 2. **Ejemplo:**

Imagina que tienes una funciÃ³n que maneja errores en promesas:

```typescript
declare const withError: {
  <E>(): <T>(
    p: Promise<T>
  ) => Promise<[error: undefined, value: T] | [error: E, value: undefined]>;
  <T, E>(p: Promise<T>): Promise<
    [error: undefined, value: T] | [error: E, value: undefined]
  >;
};
declare const doSomething: () => Promise<string>;

interface Foo {
  bar: string;
}

const main = async () => {
  let [error, value] = await withError<Foo>()(doSomething());
};
```

**ExplicaciÃ³n del ejemplo:**
AquÃ­, `withError<Foo>()(doSomething())` muestra el patrÃ³n `()(...)`. `withError<Foo>()` es como decir "quiero especificar el tipo de error `E` como `Foo`". El segundo parÃ©ntesis `(doSomething())` ya le pasa la promesa. Â¡Es una forma de darle a TypeScript la informaciÃ³n justa que necesita sin complicar las cosas! ğŸ§©

#### 3. **Notas o advertencias:**

- **Problema de TypeScript:** Este patrÃ³n `()(...)` es una soluciÃ³n para un problema conocido en TypeScript ([microsoft/TypeScript#10571](https://github.com/microsoft/TypeScript/issues/10571)). No es algo especÃ­fico de Zustand, Â¡sino una forma inteligente de trabajar _con_ TypeScript!
- **Alternativa `combine`:** Si no quieres usar `()(...)`, Zustand te da otra opciÃ³n: `combine`. Con `combine`, Zustand es lo suficientemente listo para inferir el tipo de estado por sÃ­ solo, Â¡asÃ­ que no necesitas especificarlo manualmente!

## C - Usando `combine` para inferir el tipo de estado

#### 1. **DefiniciÃ³n:**

`combine` es como un "comodÃ­n" que te ofrece Zustand. Cuando lo usas, le dices: "Oye, Zustand, Â¡encÃ¡rgate tÃº de adivinar el tipo de estado! Yo te darÃ© las partes, y tÃº las juntas". Es genial cuando quieres simplificar un poco las cosas y dejar que Zustand haga el trabajo pesado de los tipos. ğŸ’ª

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";
import { combine } from "zustand/middleware";

const useBearStore = create(
  combine({ bears: 0 }, (set) => ({
    increase: (by: number) => set((state) => ({ bears: state.bears + by })),
  }))
);
```

**ExplicaciÃ³n del ejemplo:**
Mira quÃ© limpio se ve esto. Usamos `combine` para juntar `{ bears: 0 }` (nuestro estado inicial) y la funciÃ³n que define cÃ³mo cambia el estado. Â¡Zustand usa `combine` para entender automÃ¡ticamente que el estado tiene la forma `{ bears: number, increase: (by: number) => void }`! âœ¨

#### 3. **Notas o advertencias:**

- **Menos "seguridad" de tipo, mÃ¡s conveniencia:** `combine` es sÃºper conveniente, pero hay una pequeÃ±a "trampa". Al confiar en la inferencia automÃ¡tica, podrÃ­as perder un poquito de la seguridad de tipo que te da TypeScript. Por ejemplo, si haces algo raro con `set` o `get`, TypeScript podrÃ­a no avisarte tan rÃ¡pido como lo harÃ­a si definieras el tipo explÃ­citamente.
- **Cuidado con `replace` y `Object.keys`:** Si usas `combine`, ten cuidado al usar `set` con el argumento `replace: true` o al usar `Object.keys(get())`. PodrÃ­an comportarse de manera un poco inesperada porque TypeScript infiere el tipo de `get()` de una manera ligeramente "simplificada". Â¡Pero en la mayorÃ­a de los casos, `combine` es tu amigo! ğŸ»ğŸ¤

## D - Â¡Ojo con `combine`! Cosas que debes saber

#### 1. **DefiniciÃ³n:**

Cuando usas `combine`, Zustand hace un pequeÃ±o "truco" con los tipos de `set`, `get` y `store` que recibes en tu funciÃ³n de creaciÃ³n de estado. Es como si te dijeran una pequeÃ±a "mentirilla piadosa" sobre el tipo de estado, Â¡pero con buena intenciÃ³n! ğŸ˜‰

#### 2. **Ejemplo:**

Imagina que usas `combine` asÃ­:

```typescript
import { create } from "zustand";
import { combine } from "zustand/middleware";

const useBearStore = create(
  combine({ bears: 0 }, (set, get) => ({
    increase: (by: number) => set((state) => ({ bears: state.bears + by })),
  }))
);
```

**ExplicaciÃ³n del ejemplo:**
AquÃ­, dentro de la funciÃ³n de `combine`, TypeScript piensa que `get()` solo te darÃ¡ `{ bears: number }`. Â¡Pero en realidad, `get()` te da el estado completo: `{ bears: number, increase: (by: number) => void }`! Es una "mentirilla" porque `{ bears: number }` es un "subtipo" de `{ bears: number, increase: (by: number) => void }`, asÃ­ que en la mayorÃ­a de los casos, Â¡no notarÃ¡s la diferencia! ğŸ¤«

#### 3. **Notas o advertencias:**

- **`set({ bears: 0 }, true)` puede ser peligroso:** Si usas `set` con `replace: true` (el segundo argumento), Â¡podrÃ­as borrar accidentalmente partes de tu estado! Por ejemplo, `set({ bears: 0 }, true)` podrÃ­a eliminar la funciÃ³n `increase`, aunque TypeScript no te avise. Â¡Ten cuidado! ğŸ»ğŸš§
- **`Object.keys(get())` te darÃ¡ sorpresas:** `Object.keys(get())` te darÃ¡ `["bears", "increase"]`, Â¡no solo `["bears"]`! El tipo "simplificado" de `get()` podrÃ­a confundirte si no estÃ¡s al tanto de este detalle.
- **`combine` es genial, pero con precauciÃ³n:** `combine` es muy Ãºtil para no tener que escribir tipos de estado manualmente, Â¡y funciona bien en la mayorÃ­a de los casos! Solo recuerda estas pequeÃ±as "peculiaridades" para evitar sorpresas.

## E - Usando Middlewares con TypeScript

#### 1. **DefiniciÃ³n:**

Los middlewares en Zustand son como "enchufes" que puedes conectar a tu store para aÃ±adirle funcionalidades extra, como guardar el estado en el navegador (`persist`) o usar las herramientas de desarrollo de Redux (`devtools`). Â¡Con TypeScript, usarlos es sÃºper sencillo! ğŸ”Œ

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";
import { devtools, persist } from "zustand/middleware";

interface BearState {
  bears: number;
  increase: (by: number) => void;
}

const useBearStore = create<BearState>()(
  devtools(
    persist(
      (set) => ({
        bears: 0,
        increase: (by) => set((state) => ({ bears: state.bears + by })),
      }),
      { name: "bearStore" }
    )
  )
);
```

**ExplicaciÃ³n del ejemplo:**
AquÃ­, envolvemos nuestra funciÃ³n de creaciÃ³n de estado con `persist(...)` y luego con `devtools(...)`. Â¡Es como poner capas a una cebolla! ğŸ§… TypeScript entiende todo perfectamente porque estamos usando los middlewares justo dentro de `create`. Â¡Magia de tipos! âœ¨

#### 3. **Notas o advertencias:**

- **Â¡Directamente dentro de `create`!** AsegÃºrate de usar los middlewares _inmediatamente_ dentro de `create`. Si intentas hacer algo mÃ¡s "sofisticado" (como crear una funciÃ³n que combine middlewares), Â¡podrÃ­as necesitar tipos mÃ¡s avanzados! ğŸ¤¯
- **Orden de los middlewares: `devtools` al final:** Se recomienda poner `devtools` _al final_ de la cadena de middlewares. Por ejemplo, si usas `immer` y `devtools`, haz `devtools(immer(...))` y no `immer(devtools(...))`. Esto asegura que `devtools` funcione correctamente y no se pierdan los tipos. Â¡El orden importa! â˜ï¸

## F - Middlewares Avanzados y "Mutar" el Store

#### 1. **DefiniciÃ³n:**

Los middlewares de Zustand no solo "envuelven" tu store, Â¡tambiÃ©n pueden _cambiarlo_! Pueden aÃ±adir propiedades nuevas o modificar las existentes. Esto es muy potente, pero Â¿cÃ³mo le decimos a TypeScript sobre estos cambios? Â¡AquÃ­ viene la magia de los "mutadores de tipo de orden superior"! ğŸ§™â€â™‚ï¸

#### 2. **Ejemplo (hipotÃ©tico):**

Imagina que quieres crear un middleware `foo` que aÃ±ade una propiedad `foo` a tu store:

```typescript
import { create } from "zustand";

const foo = (f, bar) => (set, get, store) => {
  store.foo = bar; // Â¡Middleware mutando el store!
  return f(set, get, store);
};

const useBearStore = create(foo(() => ({ bears: 0 }), "hello"));
console.log(useBearStore.foo.toUpperCase()); // Â¡Funciona!
```

**ExplicaciÃ³n del ejemplo:**
El middleware `foo` toma una funciÃ³n `f` (que crea el estado) y un valor `bar`. Dentro del middleware, _modificamos_ el objeto `store` directamente, aÃ±adiÃ©ndole `store.foo = bar`. Â¡Esto cambia la forma del store! Zustand tiene un sistema de tipos muy avanzado que permite que TypeScript entienda estos cambios. Â¡Es como si los tipos pudieran "mutar" junto con el store! ğŸ¤¯

#### 3. **Notas o advertencias:**

- **"Mutadores de tipo de orden superior":** Este nombre suena complicado, Â¡pero es la clave para que TypeScript entienda los middlewares que cambian el store! Si estÃ¡s creando middlewares complejos o usando `StateCreator` directamente, Â¡quizÃ¡s quieras investigar sobre esto! ğŸ¤“
- **Magia de TypeScript:** En lenguajes de programaciÃ³n normales, esto serÃ­a casi imposible de tipar correctamente. Â¡Pero gracias a las caracterÃ­sticas avanzadas de TypeScript, Zustand lo hace posible! âœ¨

## G - Manejando el Flag `replace` DinÃ¡mico en `setState`

#### 1. **DefiniciÃ³n:**

A veces, no sabes si vas a usar `replace: true` en `setState` hasta que el cÃ³digo se estÃ¡ ejecutando. Si el valor de `replace` se decide "en el Ãºltimo momento", TypeScript podrÃ­a confundirse un poco con los tipos. Â¡Pero hay un truco para solucionarlo! ğŸª„

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";

interface BearState {
  bears: number;
  increase: (by: number) => void;
}

const useBearStore = create<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}));

const replaceFlag = Math.random() > 0.5; // Â¡`replaceFlag` se decide en tiempo de ejecuciÃ³n!
const args = [{ bears: 5 }, replaceFlag] as Parameters<
  typeof useBearStore.setState
>;
useBearStore.setState(...args); // Â¡Usando el truco!
```

**ExplicaciÃ³n del ejemplo:**
AquÃ­, `replaceFlag` es `true` o `false` al azar. Para que TypeScript no se queje, creamos `args` usando `as Parameters<typeof useBearStore.setState>`. Esto le dice a TypeScript: "ConfÃ­a en mÃ­, sÃ© lo que estoy haciendo. Estos argumentos son vÃ¡lidos para `setState`". Â¡Y funciona! ğŸ‘

#### 3. **Notas o advertencias:**

- **`as Parameters<typeof useBearStore.setState>` es el truco:** Esta parte `as Parameters<typeof useBearStore.setState>` es la clave. Le decimos a TypeScript que `args` tiene la misma forma que los argumentos que `setState` espera. Â¡Es como darle un "comodÃ­n" a TypeScript! ğŸƒ
- **Workaround, no soluciÃ³n perfecta:** Esto es un "workaround", una soluciÃ³n ingeniosa para un problema especÃ­fico. No es la forma mÃ¡s "elegante" de hacerlo, Â¡pero funciona para salir del paso cuando necesitas `replace` dinÃ¡mico! ğŸ˜‰

## H - Recetas Comunes: Middleware Logger (sin cambiar el tipo del store)

#### 1. **DefiniciÃ³n:**

Un middleware "logger" es como un "espÃ­a" que observa cada vez que el estado de tu store cambia y muestra informaciÃ³n en la consola. Es muy Ãºtil para depurar y entender quÃ© estÃ¡ pasando en tu aplicaciÃ³n. Este ejemplo muestra cÃ³mo crear un logger que _no_ cambia el tipo del store. ğŸ•µï¸â€â™‚ï¸

#### 2. **Ejemplo:**

```typescript
import { create, StateCreator, StoreMutatorIdentifier } from "zustand";

type Logger = <
  T,
  Mps extends [StoreMutatorIdentifier, unknown][] = [],
  Mcs extends [StoreMutatorIdentifier, unknown][] = []
>(
  f: StateCreator<T, Mps, Mcs>,
  name?: string
) => StateCreator<T, Mps, Mcs>;

const loggerImpl = (f, name) => (set, get, store) => {
  const loggedSet: typeof set = (...a) => {
    set(...(a as Parameters<typeof set>));
    console.log(...(name ? [`${name}:`] : []), get()); // Â¡Logueando el estado!
  };
  const setState = store.setState;
  store.setState = (...a) => {
    setState(...(a as Parameters<typeof setState>));
    console.log(...(name ? [`${name}:`] : []), store.getState()); // Â¡TambiÃ©n logueando con setState!
  };

  return f(loggedSet, get, store);
};

export const logger = loggerImpl as unknown as Logger;

// ---

interface BearState {
  bears: number;
  increase: (by: number) => void;
}

const useBearStore = create<BearState>()(
  logger(
    (set) => ({
      bears: 0,
      increase: (by) => set((state) => ({ bears: state.bears + by })),
    }),
    "bear-store"
  )
);
```

**ExplicaciÃ³n del ejemplo:**
Este cÃ³digo crea un middleware `logger` que puedes usar con `create`. El `logger` "envuelve" las funciones `set` y `setState` del store. Cada vez que llamas a `set` o `setState`, el logger primero hace lo que normalmente harÃ­an, Â¡y luego muestra el estado actual en la consola! ğŸ“

#### 3. **Notas o advertencias:**

- **Tipos complejos, Â¡pero no te asustes!** Los tipos `Logger`, `LoggerImpl` y toda esa "parafernalia" de tipos avanzados son necesarios para que TypeScript entienda que este middleware _no_ cambia la forma del store. Si estÃ¡s empezando, Â¡puedes usar este cÃ³digo como plantilla y adaptarlo! ğŸ› ï¸
- **`console.log` para depurar:** La clave del logger es el `console.log(...)`. Puedes personalizar lo que se muestra en la consola para que te dÃ© la informaciÃ³n que necesitas para depurar tu aplicaciÃ³n. ğŸ›â¡ï¸ğŸ¦‹

## I - Recetas Comunes: Middleware que _SÃ­_ Cambia el Tipo del Store

#### 1. **DefiniciÃ³n:**

Este es un ejemplo de un middleware que _sÃ­_ modifica el tipo del store, aÃ±adiÃ©ndole una nueva propiedad llamada `foo`. Es un ejemplo mÃ¡s avanzado que muestra cÃ³mo usar los "mutadores de tipo" de Zustand para que TypeScript entienda estos cambios. ğŸ§°

#### 2. **Ejemplo:**

```typescript
import {
  create,
  StateCreator,
  StoreMutatorIdentifier,
  Mutate,
  StoreApi,
} from "zustand";

type Foo = <
  T,
  A,
  Mps extends [StoreMutatorIdentifier, unknown][] = [],
  Mcs extends [StoreMutatorIdentifier, unknown][] = []
>(
  f: StateCreator<T, [...Mps, ["foo", A]], Mcs>,
  bar: A
) => StateCreator<T, Mps, [["foo", A], ...Mcs]>;

declare module "zustand" {
  interface StoreMutators<S, A> {
    foo: Write<Cast<S, object>, { foo: A }>;
  }
}

const fooImpl = (f, bar) => (set, get, _store) => {
  type T = ReturnType<typeof f>;
  type A = typeof bar;

  const store = _store as Mutate<StoreApi<T>, [["foo", A]]>;
  store.foo = bar; // Â¡Middleware aÃ±adiendo `store.foo`!
  return f(set, get, _store);
};

export const foo = fooImpl as unknown as Foo;

type Write<T extends object, U extends object> = Omit<T, keyof U> & U;
type Cast<T, U> = T extends U ? T : U;

// ---

const useBearStore = create(foo(() => ({ bears: 0 }), "hello"));
console.log(useBearStore.foo.toUpperCase()); // Â¡`useBearStore.foo` existe y es de tipo string!
```

**ExplicaciÃ³n del ejemplo:**
Este cÃ³digo crea un middleware `foo` que, cuando lo usas, aÃ±ade una propiedad `foo` a tu store. La parte clave aquÃ­ son los tipos avanzados (`Foo`, `StoreMutators`, `Mutate`, etc.). Estos tipos le dicen a TypeScript: "Oye, este middleware va a cambiar el tipo del store, Â¡aÃ±adiÃ©ndole una propiedad `foo` de tipo `A`!". Â¡AsÃ­, TypeScript sabe que `useBearStore.foo` existe y es del tipo correcto! ğŸ¤¯

#### 3. **Notas o advertencias:**

- **Tipos muy avanzados:** Este ejemplo es para usuarios avanzados que necesitan crear middlewares que modifican la estructura del store. Los tipos son bastante complejos, Â¡pero son necesarios para que TypeScript entienda la "mutaciÃ³n" del store! ğŸ¤¯
- **`declare module 'zustand'`:** Esta lÃ­nea es crucial. Le dice a TypeScript que estamos "extendiendo" la definiciÃ³n de tipos de Zustand, aÃ±adiendo la posibilidad de que los middlewares "muten" el store. Â¡Es como "enseÃ±arle" a TypeScript nuevas "trucos"! ğŸ§™â€â™‚ï¸

## J - `create` sin el "Truco" de Currying `()(...)`

#### 1. **DefiniciÃ³n:**

Normalmente, se recomienda usar `create<T>()(...)` para que TypeScript pueda inferir el tipo de tu store. Pero si por alguna razÃ³n _no_ quieres usar este "truco" de currying, Â¡tambiÃ©n hay una manera de hacerlo! Eso sÃ­, ten cuidado, Â¡podrÃ­a ser un poco mÃ¡s "delicado"! âš ï¸

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";

interface BearState {
  bears: number;
  increase: (by: number) => void;
}

const useBearStore = create<
  BearState,
  [["zustand/persist", BearState], ["zustand/devtools", never]]
>(
  devtools(
    persist(
      (set) => (
        {
          bears: 0,
          increase: (by) => set((state) => ({ bears: state.bears + by })),
        },
        { name: "bearStore" }
      )
    )
  )
);
```

**ExplicaciÃ³n del ejemplo:**
AquÃ­, en lugar de `create<BearState>()(...)`, usamos `create<BearState, [['zustand/persist', BearState], ['zustand/devtools', never]]>(...)`. Le estamos dando a `create` _dos_ parÃ¡metros de tipo: `BearState` (el tipo de estado) y `[['zustand/persist', BearState], ['zustand/devtools', never]]` (informaciÃ³n sobre los middlewares). Â¡Es una forma mÃ¡s "directa" de decirle a TypeScript todo lo que necesita saber! ğŸ¯

#### 3. **Notas o advertencias:**

- **Menos recomendado:** Aunque funciona, esta forma de usar `create` es menos recomendada que el "truco" `()(...)`. En algunos casos, podrÃ­a comportarse mÃ¡s como una "afirmaciÃ³n de tipo" (como decirle a TypeScript "Â¡confÃ­a en mÃ­, este tipo es correcto!") que como una "anotaciÃ³n de tipo" (darle informaciÃ³n para que TypeScript _infiera_ el tipo). Â¡AsÃ­ que Ãºsalo con precauciÃ³n! ğŸš§
- **Complejidad extra:** Tener que especificar los tipos de los middlewares (`[['zustand/persist', BearState], ['zustand/devtools', never]]`) puede ser mÃ¡s complicado y propenso a errores. El "truco" `()(...)` suele ser mÃ¡s sencillo y robusto. ğŸ‘

## K - PatrÃ³n de "Slices" (Rebanadas) para organizar tu estado

#### 1. **DefiniciÃ³n:**

Cuando tu store de Zustand empieza a crecer y tener muchas partes diferentes, puede ser Ãºtil organizarlo en "slices" o "rebanadas". Cada "slice" se encarga de una parte especÃ­fica del estado y de las funciones que la modifican. Â¡Es como dividir un pastel grande en porciones mÃ¡s pequeÃ±as y manejables! ğŸ°

#### 2. **Ejemplo:**

```typescript
import { create, StateCreator } from "zustand";

interface BearSlice {
  bears: number;
  addBear: () => void;
  eatFish: () => void;
}

interface FishSlice {
  fishes: number;
  addFish: () => void;
}

interface SharedSlice {
  addBoth: () => void;
  getBoth: () => void;
}

const createBearSlice: StateCreator<
  BearSlice & FishSlice,
  [],
  [],
  BearSlice
> = (set) => ({
  bears: 0,
  addBear: () => set((state) => ({ bears: state.bears + 1 })),
  eatFish: () => set((state) => ({ fishes: state.fishes - 1 })),
});

const createFishSlice: StateCreator<
  BearSlice & FishSlice,
  [],
  [],
  FishSlice
> = (set) => ({
  fishes: 0,
  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),
});

const createSharedSlice: StateCreator<
  BearSlice & FishSlice,
  [],
  [],
  SharedSlice
> = (set, get) => ({
  addBoth: () => {
    get().addBear(); // Â¡Reutilizando funciones de otros slices!
    get().addFish();
  },
  getBoth: () => get().bears + get().fishes,
});

const useBoundStore = create<BearSlice & FishSlice & SharedSlice>()((...a) => ({
  ...createBearSlice(...a),
  ...createFishSlice(...a),
  ...createSharedSlice(...a),
}));
```

**ExplicaciÃ³n del ejemplo:**
AquÃ­, dividimos nuestro estado en tres "slices": `BearSlice`, `FishSlice` y `SharedSlice`. Cada `create...Slice` es una funciÃ³n que crea una parte del estado y sus funciones relacionadas. Luego, en `create<...>()(...)`, Â¡juntamos todos los slices con el spread operator (`...`)! Es una forma muy organizada de manejar estados complejos. ğŸ—‚ï¸

#### 3. **Notas o advertencias:**

- **OrganizaciÃ³n y reutilizaciÃ³n:** El patrÃ³n de slices te ayuda a mantener tu cÃ³digo de Zustand organizado y facilita la reutilizaciÃ³n de funciones entre diferentes partes del estado. Â¡Es como tener cajones separados para tus calcetines, camisetas y pantalones! ğŸ§¦ğŸ‘•ğŸ‘–
- **Tipos `StateCreator`:** FÃ­jate en los tipos `StateCreator<...>` que usamos para cada slice. Son un poco mÃ¡s complejos, pero le dicen a TypeScript cÃ³mo se combinan los diferentes slices y quÃ© tipo de estado espera cada uno. Si usas middlewares, Â¡tendrÃ¡s que ajustar estos tipos! ğŸ› ï¸

## L - Hook `useStore` "Acotado" (Bounded) para Vanilla Stores

#### 1. **DefiniciÃ³n:**

Si estÃ¡s usando `createStore` de Zustand (la versiÃ³n "vanilla", sin React), quizÃ¡s quieras crear tu propio hook `useStore` personalizado que estÃ© "acotado" a tu tipo de estado especÃ­fico. Esto te da la misma comodidad de tipo que el `useStore` normal de Zustand, Â¡pero para vanilla stores! ğŸ£

#### 2. **Ejemplo:**

```typescript
import { useStore } from "zustand";
import { createStore } from "zustand/vanilla";

interface BearState {
  bears: number;
  increase: (by: number) => void;
}

const bearStore = createStore<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}));

function useBearStore(): BearState; // Â¡Firma sin selector!
function useBearStore<T>(selector: (state: BearState) => T): T; // Â¡Firma con selector!
function useBearStore<T>(selector?: (state: BearState) => T) {
  return useStore(bearStore, selector!);
}
```

**ExplicaciÃ³n del ejemplo:**
AquÃ­, creamos un hook `useBearStore` especÃ­fico para nuestro `bearStore` vanilla. Usamos "sobrecarga de funciones" (las dos primeras lÃ­neas `function useBearStore()...`) para definir dos "firmas" diferentes para el hook: una sin selector (que devuelve todo el estado `BearState`) y otra con selector (que devuelve solo una parte del estado, de tipo `T`). Â¡AsÃ­, `useBearStore` es tan cÃ³modo de usar como el `useStore` normal, pero con tipos especÃ­ficos para tu store vanilla! ğŸ£âœ¨

#### 3. **Notas o advertencias:**

- **Tipado fuerte para vanilla stores:** Este patrÃ³n te permite tener un tipado fuerte y seguro incluso cuando usas vanilla stores de Zustand (que no estÃ¡n directamente conectados a React). Â¡Es genial si quieres usar Zustand en otros contextos ademÃ¡s de React! ğŸŒ
- **`createBoundedUseStore` para reutilizar:** Si creas muchos vanilla stores y quieres hooks `useStore` acotados para cada uno, puedes crear una funciÃ³n `createBoundedUseStore` "abstracta" para reutilizar el cÃ³digo y no tener que repetir todo esto cada vez. Â¡DRY (Don't Repeat Yourself) es un buen principio! ğŸ’§

## M - Referencia RÃ¡pida: Middlewares y sus "Mutadores"

#### 1. **DefiniciÃ³n:**

Cuando usas middlewares con Zustand y TypeScript, a veces necesitas decirle a TypeScript quÃ© "mutadores" (cambios de tipo) introduce cada middleware. AquÃ­ tienes una lista rÃ¡pida de los mutadores de los middlewares mÃ¡s comunes de Zustand: ğŸ“

#### 2. **Lista de Middlewares y Mutadores:**

- **`devtools`**: `["zustand/devtools", never]`
- **`persist`**: `["zustand/persist", YourPersistedState]`. `YourPersistedState` es el tipo de estado que vas a guardar (si usas `partialize`, es el tipo que devuelve `partialize`; si no, suele ser `Partial<YourState>`). A veces, si tienes problemas, prueba a usar `unknown` en lugar de `PersistedState`. ğŸ’¾
- **`immer`**: `["zustand/immer", never]`
- **`subscribeWithSelector`**: `["zustand/subscribeWithSelector", never]`
- **`redux`**: `["zustand/redux", YourAction]`. `YourAction` es el tipo de las acciones de Redux que vas a usar. ğŸ”„
- **`combine`**: `combine` _no_ introduce ningÃºn mutador, Â¡porque no cambia el tipo del store! ğŸ¤

#### 3. **Notas o advertencias:**

- **`never` significa "sin cambio de tipo":** Cuando ves `never` como mutador, significa que ese middleware _no_ cambia el tipo del store en sÃ­ mismo. Solo aÃ±ade funcionalidades extra sin modificar la estructura del estado. ğŸ§˜â€â™‚ï¸
- **`YourPersistedState` y `YourAction`:** Para `persist` y `redux`, necesitas especificar el tipo de estado que se guarda (`YourPersistedState`) o el tipo de acciones de Redux (`YourAction`). Â¡AsegÃºrate de usar los tipos correctos para que TypeScript estÃ© contento! ğŸ¤“
