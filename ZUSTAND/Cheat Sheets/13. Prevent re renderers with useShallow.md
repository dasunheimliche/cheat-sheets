## A - ¿Qué es `useShallow` y por qué lo necesitas?

#### 1. **Definición:**

`useShallow` es un hook de Zustand que te ayuda a **prevenir re-renderizados innecesarios** en tus componentes React cuando usas selectores para obtener datos de tu store. Normalmente, Zustand usa `Object.is` para comparar si el valor devuelto por un selector ha cambiado y necesita re-renderizar el componente. Pero a veces, quieres una comparación más "superficial" (shallow) para evitar re-renderizados cuando el valor _superficialmente_ no ha cambiado, ¡aunque `Object.is` diga que sí! 🧐

#### 2. **Ejemplo:**

Imagina que tienes un store con información sobre las comidas de diferentes osos, y quieres mostrar una lista con los nombres de los osos.

```typescript
import { create } from "zustand";

const useMeals = create(() => ({
  papaBear: "large porridge-pot",
  mamaBear: "middle-size porridge pot",
  littleBear: "A little, small, wee pot",
}));

export const BearNames = () => {
  const names = useMeals((state) => Object.keys(state)); // Selector que obtiene los nombres de los osos (claves del objeto)

  return <div>{names.join(", ")}</div>;
};
```

**Explicación del ejemplo:**

- **`useMeals`:** Crea un store de Zustand que guarda las comidas de los osos (papaBear, mamaBear, littleBear).
- **`BearNames`:** Componente React que usa `useMeals` con un selector: `(state) => Object.keys(state)`. Este selector extrae las **claves** del objeto de estado (`papaBear`, `mamaBear`, `littleBear`), que son los nombres de los osos, y las guarda en la variable `names`. Luego, muestra estos nombres separados por comas.

#### 3. **Notas o advertencias:**

- **`Object.is` por defecto:** Por defecto, Zustand usa `Object.is` para comparar los valores devueltos por los selectores. `Object.is` es una comparación estricta que comprueba si dos valores son _exactamente_ el mismo valor. Para objetos y arrays, `Object.is` compara por _referencia_, no por contenido.
- **Re-renderizados innecesarios:** El problema es que si el _contenido_ de un objeto o array no cambia superficialmente, pero se crea un _nuevo_ objeto o array (con una referencia diferente), `Object.is` dirá que ha cambiado, ¡y Zustand re-renderizará el componente, aunque no sea necesario! 😫

## B - Ejemplo: Re-renderizados Innecesarios sin `useShallow`

#### 1. **Escenario:**

En el ejemplo anterior, si cambiamos la comida de Papa Oso, ¡el componente `BearNames` se re-renderizará! Pero, ¿realmente necesitamos re-renderizar `BearNames` si solo ha cambiado la comida de un oso? Los _nombres_ de los osos (la lista que muestra `BearNames`) **no han cambiado**.

#### 2. **Código (sin `useShallow`):**

(El código del ejemplo anterior, `useMeals` y `BearNames` sin `useShallow`)

#### 3. **El Problema:**

```typescript
useMeals.setState({
  papaBear: "a large pizza", // ¡Cambiamos la comida de Papa Oso!
});
```

Aunque solo hemos cambiado `papaBear`, esta llamada a `setState` provocará una re-renderización del componente `BearNames`. ¿Por qué?

- El selector `(state) => Object.keys(state)` en `BearNames` devuelve un **nuevo array** cada vez que el estado de `useMeals` cambia, ¡incluso si las claves (los nombres de los osos) siguen siendo las mismas!
- Como se crea un nuevo array, `Object.is` compara la _referencia_ del array anterior con la referencia del nuevo array. ¡Las referencias son diferentes!
- Zustand piensa que el valor del selector ha cambiado (porque `Object.is` dice que sí), y re-renderiza `BearNames`.

¡Pero esto es un re-renderizado **innecesario**! El array de nombres de osos (superficialmente) **no ha cambiado**. Solo ha cambiado la comida de un oso, ¡que no afecta a la lista de nombres!

## C - Solución: Usando `useShallow` para Prevenir Re-renderizados

#### 1. **La Solución: `useShallow`**

Para solucionar este problema de re-renderizados innecesarios, Zustand proporciona el hook `useShallow`. `useShallow` **envuelve tu selector** y hace que Zustand use una **comparación shallow** (superficial) en lugar de `Object.is` para determinar si el valor del selector ha cambiado. La comparación shallow comprueba si las propiedades de los objetos o los elementos de los arrays son _superficialmente iguales_.

#### 2. **Código (con `useShallow`):**

```typescript
import { create } from "zustand";
import { useShallow } from "zustand/react/shallow"; // ¡Importa useShallow!

const useMeals = create(() => ({
  papaBear: "large porridge-pot",
  mamaBear: "middle-size porridge pot",
  littleBear: "A little, small, wee pot",
}));

export const BearNames = () => {
  const names = useMeals(useShallow((state) => Object.keys(state))); // ¡Envuelve el selector con useShallow!

  return <div>{names.join(", ")}</div>;
};
```

**Explicación del ejemplo:**

- **`import { useShallow } from 'zustand/react/shallow';`:** Importa `useShallow` desde `zustand/react/shallow`.
- **`useMeals(useShallow((state) => Object.keys(state)))`:** Envolvemos nuestro selector `(state) => Object.keys(state)` dentro de `useShallow(...)`. Esto le dice a Zustand que use la comparación shallow para este selector.

#### 3. **Resultado:**

Ahora, al ejecutar:

```typescript
useMeals.setState({
  papaBear: "a large pizza",
});
```

¡El componente `BearNames` **ya no se re-renderizará**! ¿Por qué?

- `useShallow` hace que Zustand use una comparación shallow para el array de nombres.
- La comparación shallow comprueba si los _elementos_ del array anterior y el nuevo array son superficialmente iguales. En este caso, los elementos (los nombres de los osos: "papaBear", "mamaBear", "littleBear") **son los mismos** en ambos arrays, ¡aunque los arrays en sí sean objetos diferentes en memoria!
- La comparación shallow dice que el valor del selector **no ha cambiado superficialmente**.
- Zustand **no re-renderiza** `BearNames`, ¡evitando un re-renderizado innecesario! 🎉

## D - ¿Cuándo usar `useShallow`?

#### 1. **Cuándo usar `useShallow`:**

Usa `useShallow` cuando:

- Tu selector devuelve un **valor calculado** (computed value) que es un **objeto** o un **array**.
- Quieres **evitar re-renderizados innecesarios** cuando el valor calculado **superficialmente no ha cambiado**, pero `Object.is` diría que sí (porque se crea un nuevo objeto o array en cada re-renderizado).
- Estás seguro de que una **comparación shallow** es suficiente para determinar si el valor calculado ha cambiado _de forma significativa_ para tu componente.

#### 2. **Beneficios de `useShallow`:**

- **Optimización del rendimiento:** Previene re-renderizados innecesarios, especialmente en componentes que se re-renderizan con frecuencia o que son costosos de re-renderizar. 🚀
- **Mejora la eficiencia:** Reduce el trabajo innecesario de React, haciendo que tu aplicación sea más rápida y eficiente. 💨

#### 3. **Notas o advertencias:**

- **No siempre es necesario:** En muchos casos, los re-renderizados innecesarios no son un problema de rendimiento significativo, y usar `useShallow` podría ser una micro-optimización innecesaria. Usa `useShallow` solo cuando realmente necesites optimizar el rendimiento en componentes específicos.
- **Comparación Shallow vs Deep:** `useShallow` realiza una comparación **shallow**. Si necesitas una comparación **deep** (profunda) para objetos o arrays anidados, `useShallow` no será suficiente. En esos casos, podrías necesitar usar una función de igualdad personalizada más compleja o considerar si realmente necesitas seleccionar estructuras de datos tan complejas en tus selectores.
