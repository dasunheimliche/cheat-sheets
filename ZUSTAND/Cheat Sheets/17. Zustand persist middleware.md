## A - Persist Middleware: Guardando tu Estado

#### 1. **Definición:**

El middleware `persist` de Zustand te permite guardar automáticamente parte o todo el estado de tu store en un almacenamiento (como `localStorage` o `sessionStorage`). Imagina que es como guardar la partida de un videojuego para que puedas continuar donde lo dejaste.

#### 2. **Ejemplo:**

```javascript
import { create } from "zustand";
import { persist, createJSONStorage } from "zustand/middleware";

export const useBearStore = create()(
  persist(
    (set, get) => ({
      bears: 0,
      addABear: () => set({ bears: get().bears + 1 }),
    }),
    {
      name: "food-storage",
      storage: createJSONStorage(() => sessionStorage),
    }
  )
);
```

**Explicación del ejemplo:**
Este código crea un store de Zustand llamado `useBearStore` y usa `persist` para guardar el estado. `name: 'food-storage'` le da un nombre único a tus datos guardados. `storage: createJSONStorage(() => sessionStorage)` dice que use `sessionStorage` para guardar la info (se borra al cerrar el navegador).

#### 3. **Notas o advertencias:**

- Necesitas instalar `zustand/middleware` para usar `persist`.
- El `name` debe ser único para cada store que quieras persistir.

## B - Ejemplo con TypeScript

#### 1. **Definición:**

Si usas TypeScript, puedes definir la estructura de tu store con una interfaz para que todo esté bien tipado y sin errores.

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";
import { persist, createJSONStorage } from "zustand/middleware";

type BearStore = {
  bears: number;
  addABear: () => void;
};

export const useBearStore = create<BearStore>()(
  persist(
    (set, get) => ({
      bears: 0,
      addABear: () => set({ bears: get().bears + 1 }),
    }),
    {
      name: "food-storage",
      storage: createJSONStorage(() => sessionStorage),
    }
  )
);
```

**Explicación del ejemplo:**
¡Es casi igual que el ejemplo en JavaScript! La diferencia es `create<BearStore>()` que le dice a Zustand que este store tiene la forma definida en `BearStore`.

#### 3. **Notas o advertencias:**

- Usar TypeScript te ayuda a evitar errores y tener un código más robusto.

## C - Opciones de Persist

#### 1. **Definición:**

El objeto de opciones en `persist` te permite personalizar cómo se guarda y se recupera tu estado.

#### 2. **Opciones Principales:**

- **`name`**: (Obligatorio) El nombre único para guardar tus datos en el almacenamiento. ¡Como el nombre de la carpeta donde guardas tus archivos!

- **`storage`**: Define dónde se guardan los datos. Por defecto usa `localStorage`. Puedes usar `sessionStorage` o incluso bases de datos más complejas. Usa `createJSONStorage(() => tuStorage)` para configurarlo.

- **`partialize`**: Una función para elegir qué partes del estado quieres guardar. Útil si no quieres guardar todo.

- **`onRehydrateStorage`**: Una función que se ejecuta cuando empieza la carga de datos guardados (hidratación). Puedes usarla para mostrar un "Cargando..."

- **`version`**: Un número para controlar cambios grandes en tu store. Si cambias la estructura de tus datos guardados, aumenta la versión.

- **`migrate`**: Función para actualizar datos guardados de versiones antiguas a la versión actual. ¡Para que los cambios no rompan la persistencia!

- **`merge`**: Función para combinar los datos guardados con el estado actual. Por defecto, simplemente los mezcla superficialmente.

- **`skipHydration`**: Si es `true`, evita que `persist` cargue los datos guardados al inicio. Útil si quieres controlar cuándo se cargan los datos manualmente.

#### 3. **Ejemplos de Opciones:**

**`partialize` (omitir campos):**

```javascript
partialize: (state) =>
  Object.fromEntries(
    Object.entries(state).filter(([key]) => !['foo'].includes(key)),
  ),
```

_Guarda todo el estado menos la propiedad `foo`._

**`partialize` (solo ciertos campos):**

```javascript
partialize: (state) => ({ foo: state.foo }),
```

_Solo guarda la propiedad `foo`._

**`onRehydrateStorage`:**

```javascript
onRehydrateStorage: (state) => {
  console.log('La hidratación ha comenzado');
  return (state, error) => {
    if (error) {
      console.log('Error durante la hidratación', error);
    } else {
      console.log('Hidratación completada');
    }
  };
},
```

_Muestra mensajes en la consola al inicio y final de la hidratación._

**`version` y `migrate` (renombrar un campo):**

```javascript
version: 1,
migrate: (persistedState, version) => {
  if (version === 0) {
    persistedState.newField = persistedState.oldField;
    delete persistedState.oldField;
  }
  return persistedState;
},
```

_Si la versión guardada es 0, renombra `oldField` a `newField`._

**`merge` (merge profundo):**

```javascript
merge: (persistedState, currentState) =>
  deepMerge(currentState, persistedState), // Necesitarías una función deepMerge
```

_Usa una función `deepMerge` (que tendrías que definir o importar) para combinar estados anidados correctamente._

**`skipHydration`:**

```javascript
skipHydration: true,
```

_Evita la hidratación automática al inicio._

## D - API de Persist

#### 1. **Definición:**

El API de `persist` te da funciones para controlar la persistencia desde fuera de tu componente React.

#### 2. **Funciones Principales:**

- **`getOptions()`**: Devuelve las opciones que configuraste en `persist`. Útil para ver el `name` o el `storage`.

- **`setOptions(newOptions)`**: Cambia las opciones de `persist` después de haberlo creado. ¡Puedes cambiar el nombre o el storage en tiempo de ejecución!

- **`clearStorage()`**: Borra todos los datos guardados con el `name` que definiste. ¡Como limpiar la carpeta de guardado!

- **`rehydrate()`**: Fuerza la carga de datos guardados desde el storage. Útil si usaste `skipHydration: true`.

- **`hasHydrated()`**: Te dice si la hidratación ya se completó. Devuelve `true` o `false`.

- **`onHydrate(listener)`**: Añade una función que se ejecuta cuando empieza la hidratación. Devuelve una función para dejar de escuchar (unsubscribe).

- **`onFinishHydration(listener)`**: Añade una función que se ejecuta cuando termina la hidratación. Devuelve una función para dejar de escuchar (unsubscribe).

- **`createJSONStorage(getStorage, options?)`**: Función para crear un objeto `storage` compatible con `persist`. `getStorage` debe devolver tu storage (ej: `() => localStorage`). `options` te permite personalizar la serialización/deserialización JSON.

#### 3. **Ejemplos de API:**

```javascript
useBearStore.persist.getOptions().name; // Obtener el nombre del storage

useBearStore.persist.setOptions({ name: "new-bear-storage" }); // Cambiar el nombre del storage

useBearStore.persist.clearStorage(); // Borrar los datos guardados

await useBearStore.persist.rehydrate(); // Forzar la hidratación

useBearStore.persist.hasHydrated(); // Comprobar si ya se hidrató

const unsubscribeHydrate = useBearStore.persist.onHydrate(() =>
  console.log("Hidratación empezando")
); // Escuchar inicio de hidratación
unsubscribeHydrate(); // Dejar de escuchar

const storage = createJSONStorage(() => sessionStorage, {
  reviver: (key, value) => {
    /* ... */
  }, // Personalizar deserialización
  replacer: (key, value) => {
    /* ... */
  }, // Personalizar serialización
}); // Crear storage personalizado
```

## E - Hydration y Storages Asíncronos

#### 1. **Definición:**

La hidratación es el proceso de cargar los datos guardados en tu store. Puede ser síncrona (rápida, como con `localStorage`) o asíncrona (más lenta, como con `AsyncStorage`).

#### 2. **Asíncrono vs Síncrono:**

- **Síncrono (ej: `localStorage`):** La hidratación ocurre al crear el store. El store ya tiene los datos guardados desde el principio.

- **Asíncrono (ej: `AsyncStorage`):** La hidratación ocurre después, en una "microtarea". El store **no** tiene los datos guardados al inicio.

#### 3. **El "Problema" de lo Asíncrono:**

Si usas un storage asíncrono, tu store no tendrá los datos guardados al renderizar la página por primera vez. Esto puede causar problemas si tu app depende de esos datos desde el inicio (ej: saber si el usuario está logueado). ¡Puede que tu app piense que no está logueado hasta que se complete la hidratación!

#### 4. **Solución:**

Espera a que la hidratación se complete antes de mostrar contenido que dependa de los datos persistidos. Usa `useBoundStore.persist.hasHydrated()` o los listeners `onHydrate` y `onFinishHydration` para saber cuándo está listo.

#### 5. **Uso en Next.js:**

Next.js usa Server Side Rendering (SSR). Si usas `persist` directamente, puede haber errores de "hydration mismatch" porque el contenido del servidor no coincide con el del cliente (ya que los datos persistidos no están disponibles en el servidor).

#### 6. **Hook Personalizado para Next.js:**

Para solucionar esto en Next.js, crea un hook como este `useStore.ts`:

```typescript
// useStore.ts
import { useState, useEffect } from "react";

const useStore = <T, F>(
  store: (callback: (state: T) => unknown) => unknown,
  callback: (state: T) => F
) => {
  const result = store(callback) as F;
  const [data, setData] = useState<F>();

  useEffect(() => {
    setData(result);
  }, [result]);

  return data;
};

export default useStore;
```

Y úsalo en tus componentes así:

```typescript jsx
// yourComponent.tsx
import useStore from "./useStore";
import { useBearStore } from "./stores/useBearStore";

const bears = useStore(useBearStore, (state) => state.bears);
```

_Este hook hace que el componente espere un poco antes de usar los datos del store, evitando los errores de hidratación en Next.js._

## F - FAQ (Preguntas Frecuentes)

#### 1. **¿Cómo comprobar si mi store se ha hidratado?**

**Opción 1: Usar `onRehydrateStorage` y un estado en el store:**

```javascript
const useBoundStore = create(
  persist(
    (set, get) => ({
      _hasHydrated: false,
      setHasHydrated: (state) => {
        set({ _hasHydrated: state });
      },
    }),
    {
      onRehydrateStorage: (state) => {
        return () => state.setHasHydrated(true);
      },
    }
  )
);

function App() {
  const hasHydrated = useBoundStore((state) => state._hasHydrated);
  if (!hasHydrated) {
    return <p>Cargando...</p>;
  }
  // ... tu app
}
```

**Opción 2: Hook `useHydration` personalizado:**

```javascript
const useBoundStore = create(persist(...))

const useHydration = () => {
  const [hydrated, setHydrated] = useState(false)

  useEffect(() => {
    const unsubHydrate = useBoundStore.persist.onHydrate(() => setHydrated(false))
    const unsubFinishHydration = useBoundStore.persist.onFinishHydration(() => setHydrated(true))
    setHydrated(useBoundStore.persist.hasHydrated())

    return () => {
      unsubHydrate()
      unsubFinishHydration()
    }
  }, [])

  return hydrated
}
```

#### 2. **¿Cómo usar un storage engine personalizado?**

Si quieres usar algo diferente a `localStorage` o `sessionStorage` (ej: IndexedDB), crea tu propio objeto `storage` que tenga las funciones `getItem`, `setItem` y `removeItem`.

**Ejemplo con `idb-keyval` (IndexedDB):**

```javascript
import { get, set, del } from 'idb-keyval'

const storage = {
  getItem: async (name) => (await get(name)) || null,
  setItem: async (name, value) => await set(name, value),
  removeItem: async (name) => await del(name),
}

// ... en tu persist options:
{
  storage: createJSONStorage(() => storage),
}
```

#### 3. **¿Cómo rehidratar al detectar un evento de storage?**

Puedes usar el API de `persist` para rehidratar cuando detectes un evento `storage` (ej: si otra pestaña del navegador cambia los datos).

```javascript
export const withStorageDOMEvents = (store) => {
  const storageEventCallback = (e) => {
    if (e.key === store.persist.getOptions().name && e.newValue) {
      store.persist.rehydrate()
    }
  }
  window.addEventListener('storage', storageEventCallback)
  return () => {
    window.removeEventListener('storage', storageEventCallback)
  }
}

const useBoundStore = create(persist(...))
withStorageDOMEvents(useBoundStore)
```

#### 4. **¿Cómo usarlo con TypeScript?**

¡Ya lo vimos en el ejemplo B! Simplemente usa `create<MyState>()(...)` y define una interfaz `MyState` para tu store.

#### 5. **¿Cómo usarlo con Map y Set?**

`Map` y `Set` no se guardan bien en JSON por defecto. Necesitas convertirlos a `Array` al guardar y viceversa al cargar. Crea un `storage` personalizado para esto.

**Ejemplo (guardando `Map` como `Array`):**

```javascript
storage: {
  getItem: (name) => { /* ... */
    return {
      ...existingValue,
      state: {
        ...existingValue.state,
        transactions: new Map(existingValue.state.transactions), // Convertir Array a Map al cargar
      }
    }
  },
  setItem: (name, newValue) => { /* ... */
    const str = JSON.stringify({
      ...newValue,
      state: {
        ...newValue.state,
        transactions: Array.from(newValue.state.transactions.entries()), // Convertir Map a Array al guardar
      },
    })
    // ...
  },
  // ...
},
```
