## A - Immer Middleware

#### 1. **Definición:**

Immer middleware es una herramienta que se integra con Zustand para que trabajar con estados inmutables sea más fácil y directo. En lugar de tener que crear copias de tus objetos y arrays manualmente cada vez que quieres cambiar algo, Immer te permite escribir código como si estuvieras mutando el estado directamente. ¡Pero tranquilo! Por debajo, Immer se encarga de hacer todo el trabajo duro de forma inmutable.

#### 2. **Ejemplo:**

Imagina que tienes un estado con un contador:

```typescript
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";

type State = {
  count: number;
};

type Actions = {
  increment: (qty: number) => void;
  decrement: (qty: number) => void;
};

export const useCountStore = create<State & Actions>()(
  immer((set) => ({
    count: 0,
    increment: (qty: number) =>
      set((state) => {
        state.count += qty; // ¡Parece que mutamos directamente!
      }),
    decrement: (qty: number) =>
      set((state) => {
        state.count -= qty; // ¡Y aquí también!
      }),
  }))
);
```

**Explicación del ejemplo:**

Fíjate en las funciones `increment` y `decrement`. Dentro de `set`, parece que estamos modificando `state.count` directamente con `+=` y `-=`. Normalmente, en estados inmutables, ¡esto estaría prohibido! Pero gracias a `immer()`, Zustand entiende que quieres actualizar el estado de forma inmutable, y Immer hace la magia por ti. Él crea una "copia borrador" del estado, te deja "mutarla" como si nada, y luego genera un nuevo estado inmutable basado en tus "mutaciones". ¡Así de fácil!

#### 3. **Notas o advertencias:**

- Recuerda instalar `immer` como dependencia de tu proyecto: `npm install immer`.
- Fíjate en los paréntesis extra `()` después de `<State & Actions>` en `create<State & Actions>()()`. Es un detalle de TypeScript, ¡no te olvides de ellos!

## B - Actualizando Estados Complejos

#### 1. **Definición:**

Immer brilla especialmente cuando tienes estados más complicados, como objetos anidados o arrays dentro de objetos. Te evita tener que escribir código engorroso para actualizar partes específicas de estos estados de forma inmutable.

#### 2. **Ejemplo:**

Vamos a ver un ejemplo con una lista de tareas (todos):

```typescript
import { create } from "zustand";
import { immer } from "zustand/middleware/immer";

interface Todo {
  id: string;
  title: string;
  done: boolean;
}

type State = {
  todos: Record<string, Todo>; // Un objeto donde las claves son IDs de todos
};

type Actions = {
  toggleTodo: (todoId: string) => void;
};

export const useTodoStore = create<State & Actions>()(
  immer((set) => ({
    todos: {
      // Estado inicial con algunos todos
      "82471c5f-4207-4b1d-abcb-b98547e01a3e": {
        id: "82471c5f-4207-4b1d-abcb-b98547e01a3e",
        title: "Learn Zustand",
        done: false,
      },
      "354ee16c-bfdd-44d3-afa9-e93679bda367": {
        id: "354ee16c-bfdd-44d3-afa9-e93679bda367",
        title: "Learn Jotai",
        done: false,
      },
      "771c85c5-46ea-4a11-8fed-36cc2c7be344": {
        id: "771c85c5-46ea-4a11-8fed-36cc2c7be344",
        title: "Learn Valtio",
        done: false,
      },
      "363a4bac-083f-47f7-a0a2-aeeee153a99c": {
        id: "363a4bac-083f-47f7-a0a2-aeeee153a99c",
        title: "Learn Signals",
        done: false,
      },
    },
    toggleTodo: (todoId: string) =>
      set((state) => {
        state.todos[todoId].done = !state.todos[todoId].done; // ¡Modificamos una propiedad dentro de un objeto anidado!
      }),
  }))
);
```

**Explicación del ejemplo:**

En `toggleTodo`, queremos cambiar la propiedad `done` de un todo específico. Con Immer, simplemente accedemos a `state.todos[todoId].done` y la cambiamos directamente. ¡No necesitamos crear copias de `state.todos`, ni del objeto todo en sí! Immer se encarga de que la actualización sea inmutable, creando un nuevo estado con el todo modificado, pero manteniendo el resto del estado intacto (inmutablemente).

#### 3. **Notas o advertencias:**

- Immer te ahorra mucho código repetitivo y reduce la posibilidad de errores al manejar estados complejos inmutables.

## C - ¡Ojo! Cositas a tener en cuenta con Immer

#### 1. **Definición:**

Aunque Immer es genial, hay algunas cosillas que debes recordar para que todo funcione a la perfección, especialmente si usas clases en tu estado.

#### 2. **Problema común: "¡Mis suscripciones no se actualizan!"**

Si notas que tus componentes no se re-renderizan cuando esperas que lo hagan después de actualizar el estado con Immer, puede que estés olvidando algo importante sobre cómo funciona Immer con objetos de clase.

#### 3. **La solución: `[immerable] = true` para clases**

Si usas clases en tu estado y quieres que Immer las gestione correctamente, necesitas añadir `[immerable] = true` a tus clases. Esto le dice a Immer cómo trabajar con ellas.

**Ejemplo:**

Imagina que tienes una clase `Task` para tus todos:

```typescript
import { immerable } from "immer";

class Task {
  [immerable] = true; // ¡Importante!

  id: string;
  title: string;
  done: boolean;

  constructor(id: string, title: string, done: boolean) {
    this.id = id;
    this.title = title;
    this.done = done;
  }
}
```

**Explicación del ejemplo:**

Al añadir `[immerable] = true` dentro de la clase `Task`, le indicas a Immer que puede "immerizar" instancias de esta clase. Si olvidas esto, Immer podría seguir "mutando" el objeto, pero no de la forma que Zustand espera para detectar cambios. Zustand comprueba si el estado realmente ha cambiado para notificar a los componentes suscritos. Si Immer no está funcionando correctamente con tus clases (por falta de `[immerable]`), Zustand podría pensar que el estado no ha cambiado, ¡y tus componentes no se actualizarían!

#### 4. **Notas o advertencias:**

- Si usas objetos planos (literales) o arrays en tu estado, ¡no necesitas preocuparte por `[immerable]`! Solo es necesario para clases.
- Si tienes dudas, revisa la [documentación de Immer sobre objetos complejos](https://immerjs.github.io/immer/complex-objects) para entender mejor cómo funciona con clases y otros tipos de objetos.
