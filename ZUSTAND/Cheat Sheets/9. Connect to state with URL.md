## A - Conectando el Estado de Zustand con el Hash de la URL

#### 1. **Definición:**

Si quieres que el estado de tu store de Zustand se guarde en el **hash** de la URL (la parte que va después del `#` en la dirección web), puedes crear tu propio "almacenamiento hash" personalizado. Esto es útil para compartir el estado actual de tu aplicación a través de un enlace, ¡y el estado se restaurará cuando alguien abra ese enlace! ⚓

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";
import { persist, StateStorage, createJSONStorage } from "zustand/middleware";

const hashStorage: StateStorage = {
  getItem: (key): string => {
    const searchParams = new URLSearchParams(location.hash.slice(1));
    const storedValue = searchParams.get(key) ?? "";
    return JSON.parse(storedValue);
  },
  setItem: (key, newValue): void => {
    const searchParams = new URLSearchParams(location.hash.slice(1));
    searchParams.set(key, JSON.stringify(newValue));
    location.hash = searchParams.toString();
  },
  removeItem: (key): void => {
    const searchParams = new URLSearchParams(location.hash.slice(1));
    searchParams.delete(key);
    location.hash = searchParams.toString();
  },
};

export const useBoundStore = create(
  persist(
    (set, get) => ({
      fishes: 0,
      addAFish: () => set({ fishes: get().fishes + 1 }),
    }),
    {
      name: "food-storage", // nombre único
      storage: createJSONStorage(() => hashStorage),
    }
  )
);
```

**Explicación del ejemplo:**

- **`hashStorage`:** Este objeto define cómo Zustand va a guardar y leer el estado desde el hash de la URL.
  - **`getItem`:** Lee el valor del hash, lo parsea de JSON y lo devuelve.
  - **`setItem`:** Convierte el nuevo valor a JSON, lo guarda en el hash de la URL.
  - **`removeItem`:** Elimina el valor del hash.
- **`create(persist(...))`:** Usamos el middleware `persist` de Zustand para guardar el estado.
  - **`storage: createJSONStorage(() => hashStorage)`:** Le decimos a `persist` que use nuestro `hashStorage` personalizado para guardar el estado en formato JSON en el hash de la URL.
  - **`name: 'food-storage'`:** Un nombre único para identificar este store en el almacenamiento.

#### 3. **Notas o advertencias:**

- **`URLSearchParams`:** Usamos `URLSearchParams` para manipular fácilmente el hash de la URL como si fuera un conjunto de parámetros. ¡Es una herramienta muy útil para trabajar con URLs! 🛠️
- **`location.hash`:** `location.hash` es la propiedad de JavaScript que nos permite acceder y modificar el hash de la URL.
- **`createJSONStorage`:** Este helper de Zustand convierte el estado a JSON antes de guardarlo y lo parsea de JSON al leerlo. ¡Así podemos guardar objetos y arrays en la URL! ⚙️
- **Demo en CodeSandbox:** Puedes ver un ejemplo funcionando aquí: [https://codesandbox.io/s/zustand-state-with-url-hash-demo-f29b88?file=/src/store/index.ts](https://codesandbox.io/s/zustand-state-with-url-hash-demo-f29b88?file=/src/store/index.ts) 💻

## B - Persistiendo y Conectando el Estado con Parámetros de la URL (Ejemplo: Query Parameters)

#### 1. **Definición:**

A veces, quieres guardar el estado de Zustand en los **parámetros de consulta** de la URL (la parte después del `?` en la dirección web). Este método es útil para compartir el estado y también para que el estado sea indexable por motores de búsqueda (si es relevante para tu caso). Además, puedes combinar esto con otro tipo de persistencia, como `localStorage`, ¡para tener lo mejor de ambos mundos! 🌍

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";
import { persist, StateStorage, createJSONStorage } from "zustand/middleware";

const getUrlSearch = () => {
  return window.location.search.slice(1);
};

const persistentStorage: StateStorage = {
  getItem: (key): string => {
    // Primero revisa la URL
    if (getUrlSearch()) {
      const searchParams = new URLSearchParams(getUrlSearch());
      const storedValue = searchParams.get(key);
      return JSON.parse(storedValue as string);
    } else {
      // Si no hay parámetros en la URL, carga desde localStorage
      return JSON.parse(localStorage.getItem(key) as string);
    }
  },
  setItem: (key, newValue): void => {
    // Si hay parámetros en la URL, actualízalos
    if (getUrlSearch()) {
      const searchParams = new URLSearchParams(getUrlSearch());
      searchParams.set(key, JSON.stringify(newValue));
      window.history.replaceState(null, "", `?${searchParams.toString()}`); // Actualiza la URL sin recargar la página
    }

    localStorage.setItem(key, JSON.stringify(newValue)); // Siempre guarda en localStorage también
  },
  removeItem: (key): void => {
    const searchParams = new URLSearchParams(getUrlSearch());
    searchParams.delete(key);
    window.location.search = searchParams.toString();
  },
};

type LocalAndUrlStore = {
  typesOfFish: string[];
  addTypeOfFish: (fishType: string) => void;
  numberOfBears: number;
  setNumberOfBears: (newNumber: number) => void;
};

const storageOptions = {
  name: "fishAndBearsStore",
  storage: createJSONStorage<LocalAndUrlStore>(() => persistentStorage),
};

const useLocalAndUrlStore = create(
  persist<LocalAndUrlStore>(
    (set) => ({
      typesOfFish: [],
      addTypeOfFish: (fishType) =>
        set((state) => ({ typesOfFish: [...state.typesOfFish, fishType] })),

      numberOfBears: 0,
      setNumberOfBears: (numberOfBears) => set(() => ({ numberOfBears })),
    }),
    storageOptions
  )
);

export default useLocalAndUrlStore;
```

**Explicación del ejemplo:**

- **`getUrlSearch`:** Función auxiliar para obtener la parte de "query" de la URL (después del `?`).
- **`persistentStorage`:** Este almacenamiento personalizado ahora revisa _primero_ si hay parámetros en la URL.
  - **`getItem`:** Si hay parámetros en la URL, lee de ahí. Si no, lee de `localStorage`.
  - **`setItem`:** Si hay parámetros en la URL, los actualiza _y_ también guarda en `localStorage`.
  - **`removeItem`:** Elimina el parámetro de la URL.
- **`window.history.replaceState`:** Esta función mágica actualiza la URL en la barra de direcciones del navegador **sin recargar la página**. ¡Así la experiencia del usuario es mucho mejor! ✨
- **`localStorage.setItem`:** Siempre guardamos en `localStorage` también, ¡así el estado persiste incluso si el usuario cierra la pestaña y vuelve a abrir la aplicación! 💾

#### 3. **Notas o advertencias:**

- **Persistencia Híbrida:** Este ejemplo muestra cómo combinar la persistencia en la URL con `localStorage`. Puedes adaptarlo para usar otros tipos de almacenamiento persistente si lo necesitas. ibrido 🧬
- **`window.location.search`:** `window.location.search` nos da acceso a la parte de "query" de la URL.
- **`window.history.replaceState` vs `window.location.search = ...`:** `window.history.replaceState` es preferible para actualizar la URL sin recargar la página. `window.location.search = ...` también funciona, pero podría causar una recarga en algunos casos. ¡`replaceState` es más suave y eficiente! 💨
- **Condicional `getUrlSearch()`:** El código revisa `getUrlSearch()` antes de leer y escribir en la URL. Puedes quitar estas revisiones si _siempre_ quieres que el estado se sincronice con la URL, ¡sin importar si hay parámetros o no! 🚦

## C - Generando URLs Compartibles con el Estado de Zustand

#### 1. **Definición:**

Una vez que estás guardando el estado de Zustand en la URL, ¡querrás poder generar URLs que incluyan ese estado para compartir con otros! Aquí te mostramos cómo crear funciones para construir URLs compartibles que codifiquen el estado actual de tu store. 📤

#### 2. **Ejemplo:**

```typescript
const buildURLSuffix = (params, version = 0) => {
  const searchParams = new URLSearchParams();

  const zustandStoreParams = {
    state: {
      typesOfFish: params.typesOfFish,
      numberOfBears: params.numberOfBears,
    },
    version: version, // version se incluye porque Zustand la guarda en el estado persistido
  };

  // La clave del parámetro de la URL debe coincidir con el nombre del store (storageOptions.name)
  searchParams.set("fishAndBearsStore", JSON.stringify(zustandStoreParams));
  return searchParams.toString();
};

export const buildShareableUrl = (params, version) => {
  return `${window.location.origin}?${buildURLSuffix(params, version)}`;
};
```

**Explicación del ejemplo:**

- **`buildURLSuffix`:** Esta función toma un objeto `params` (con el estado que quieres compartir) y una `version` (que Zustand usa internamente).
  - Crea un `URLSearchParams`.
  - Crea un objeto `zustandStoreParams` que contiene el estado y la versión (¡importante incluir la versión!).
  - Guarda este objeto en los `searchParams` usando la clave `'fishAndBearsStore'` (¡asegúrate de que coincida con `storageOptions.name`!).
  - Devuelve la cadena de parámetros de consulta (`searchParams.toString()`).
- **`buildShareableUrl`:** Esta función toma los mismos `params` y `version`, usa `buildURLSuffix` para crear la parte de los parámetros de consulta, y luego construye la URL completa, ¡incluyendo el origen de la página (`window.location.origin`) y el `?`! 🌐

#### 3. **Notas o advertencias:**

- **`storageOptions.name` es clave:** Asegúrate de que la clave que usas en `searchParams.set('fishAndBearsStore', ...)` en `buildURLSuffix` **coincida exactamente** con el `name` que definiste en `storageOptions` al configurar `persist`. ¡Si no coinciden, Zustand no sabrá qué estado buscar en la URL! 🔑
- **Incluye la `version`:** Zustand guarda una `version` en el estado persistido. Es importante incluirla también en la URL al generar enlaces compartibles, ¡para que Zustand pueda restaurar el estado correctamente! 🔢
- **URL codificada:** La URL generada estará codificada (por ejemplo, los espacios se convierten en `%20`, etc.). Esto es normal y necesario para que las URLs sean válidas. Cuando `URLSearchParams` parsea la URL, ¡descodifica todo automáticamente! 🛡️
- **Ejemplo de URL generada:** La URL generada se verá algo así: `https://localhost/search?fishAndBearsStore={"state":{"typesOfFish":["tilapia","salmon"],"numberOfBears":15},"version":0}}` (sin codificar para que sea más legible). 🔗
