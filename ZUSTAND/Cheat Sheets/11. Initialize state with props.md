## A - Creando un Store con `createStore` que Acepta Props

#### 1. **Definici√≥n:**

Cuando quieres que tu store de Zustand se inicialice con datos que vienen desde fuera, como props de un componente React, la mejor manera es usar `createStore` en lugar de `create`. `createStore` te permite crear una funci√≥n que _crea_ el store, y esta funci√≥n puede aceptar props como argumentos. ¬°Es como tener un "constructor" para tu store! üõ†Ô∏è

#### 2. **Ejemplo:**

```typescript
import { createStore } from "zustand";

interface BearProps {
  bears: number; // Props que puede recibir el store
}

interface BearState extends BearProps {
  addBear: () => void; // Estado y acciones del store
}

type BearStore = ReturnType<typeof createBearStore>; // Tipo para el store creado

const createBearStore = (initProps?: Partial<BearProps>) => {
  // Funci√≥n que crea el store y acepta props opcionales
  const DEFAULT_PROPS: BearProps = {
    // Props por defecto
    bears: 0,
  };
  return createStore<BearState>()((set) => ({
    // Crea el store vanilla con createStore
    ...DEFAULT_PROPS, // Aplica props por defecto primero
    ...initProps, // Luego, sobreescribe con las props iniciales que se pasaron
    addBear: () => set((state) => ({ bears: ++state.bears })), // Acci√≥n para a√±adir osos
  }));
};
```

**Explicaci√≥n del ejemplo:**

- **`BearProps`:** Define la interfaz para las props que puede recibir el store (en este caso, `bears`).
- **`BearState`:** Define la interfaz del estado del store, extendiendo `BearProps` e incluyendo las acciones (`addBear`).
- **`createBearStore`:** Esta funci√≥n es la que _crea_ el store.
  - Acepta `initProps` (props iniciales) como argumento opcional.
  - Define `DEFAULT_PROPS` para valores por defecto.
  - Usa `createStore<BearState>()(...)` para crear un store vanilla.
  - Dentro de la funci√≥n de creaci√≥n del store, usa el spread operator (`...`) para combinar `DEFAULT_PROPS` y `initProps`. ¬°Las `initProps` sobreescriben los valores por defecto si se proporcionan!
  - Define la acci√≥n `addBear`.

#### 3. **Notas o advertencias:**

- **`createStore` para vanilla stores:** Recuerda que `createStore` crea un store "vanilla", que no est√° directamente conectado a React. Necesitar√°s usar Context API para conectarlo a tus componentes React.
- **Props opcionales (`Partial<BearProps>`)**: Hacer `initProps` opcional (`?`) y de tipo `Partial<BearProps>` permite que la funci√≥n `createBearStore` se llame sin props, usando solo los valores por defecto. ¬°Flexibilidad es clave! üîë

## B - Creando un Contexto con `React.createContext`

#### 1. **Definici√≥n:**

Para que tus componentes React puedan acceder al store que creaste con `createStore`, necesitas usar `React.createContext`. El Context API de React te permite "compartir" datos (en este caso, tu store de Zustand) a trav√©s del √°rbol de componentes, sin tener que pasar props manualmente a cada nivel. ¬°Es como crear un "conducto" para tu store! üö∞

#### 2. **Ejemplo:**

```typescript
import { createContext } from "react";

export const BearContext = createContext<BearStore | null>(null); // Crea el contexto para el BearStore
```

**Explicaci√≥n del ejemplo:**

- **`createContext<BearStore | null>(null)`:** Creamos un contexto llamado `BearContext` usando `React.createContext`.
  - `<BearStore | null>`: Especificamos que el valor que se va a guardar en este contexto ser√° de tipo `BearStore` (el tipo de store que creamos en el paso anterior) o `null` (por si acaso el provider no se ha configurado correctamente).
  - `null`: Establecemos el valor por defecto del contexto a `null`.

#### 3. **Notas o advertencias:**

- **Tipo del Contexto:** Es importante tipar correctamente el contexto con `<BearStore | null>`. Esto ayuda a TypeScript a entender qu√© tipo de datos se est√°n compartiendo a trav√©s del contexto y a detectar errores de tipo.
- **Valor por defecto `null`:** El valor por defecto `null` es una convenci√≥n com√∫n para los contextos de Zustand. Permite detectar f√°cilmente si un componente est√° intentando usar el contexto fuera de un `Provider`.

## C - Uso B√°sico del Componente: Provider y Consumer

#### 1. **Definici√≥n:**

Para usar tu store inicializado con props en componentes React, necesitas dos cosas: un **Provider** y un **Consumer**.

- **Provider:** El `Provider` envuelve una parte del √°rbol de componentes y "provee" el store a todos los componentes dentro de √©l. Es como "abrir el grifo" del conducto de datos. üöø
- **Consumer:** Los componentes "Consumer" (o componentes que usan un hook personalizado basado en el contexto) pueden "consumir" el store que se provee a trav√©s del contexto. Es como "conectar una tuber√≠a" al conducto para obtener los datos. üîå

#### 2. **Ejemplo:**

**Provider:**

```typescript
// Provider implementation
import { useRef } from "react";
import { BearContext, createBearStore } from "./BearContext"; // Importa el Contexto y la funci√≥n createBearStore

function App() {
  const store = useRef(createBearStore()).current; // Crea el store usando createBearStore (sin props iniciales aqu√≠)
  return (
    <BearContext.Provider value={store}>
      {" "}
      {/* Usa BearContext.Provider para proveer el store */}
      <BasicConsumer /> {/* Componente Consumer dentro del Provider */}
    </BearContext.Provider>
  );
}
```

**Consumer:**

```typescript
// Consumer component
import { useContext } from "react";
import { useStore } from "zustand";
import { BearContext } from "./BearContext"; // Importa el Contexto

function BasicConsumer() {
  const store = useContext(BearContext); // Usa useContext para acceder al store desde el Contexto
  if (!store) throw new Error("Missing BearContext.Provider in the tree"); // Error si no hay Provider
  const bears = useStore(store, (s) => s.bears); // Usa useStore para seleccionar partes del estado
  const addBear = useStore(store, (s) => s.addBear);
  return (
    <>
      <div>{bears} Bears.</div>
      <button onClick={addBear}>Add bear</button>
    </>
  );
}
```

**Explicaci√≥n del ejemplo:**

- **`App` (Provider):**
  - Usa `useRef` para crear el store **solo una vez** durante el ciclo de vida del componente `App`. Esto es importante para evitar recrear el store en cada re-renderizado.
  - `createBearStore()` se llama **sin props iniciales** en este ejemplo. El estado inicial ser√° el definido en `DEFAULT_PROPS` en `createBearStore`.
  - `<BearContext.Provider value={store}>` envuelve `<BasicConsumer />` y provee el `store` a trav√©s del contexto.
- **`BasicConsumer` (Consumer):**
  - `useContext(BearContext)` usa el hook `useContext` de React para acceder al `store` que se provee a trav√©s de `BearContext.Provider`.
  - `if (!store) throw new Error(...)` Comprueba si el `store` se ha obtenido correctamente del contexto. Si no, lanza un error, indicando que el componente `BasicConsumer` se est√° usando fuera de un `BearContext.Provider`.
  - `useStore(store, (s) => s.bears)` y `useStore(store, (s) => s.addBear)` usan el hook `useStore` de Zustand (¬°pero ahora le pasamos el `store` vanilla como primer argumento!) para seleccionar partes del estado y acciones del store.

#### 3. **Notas o advertencias:**

- **`useRef` para crear el store una vez:** Usar `useRef` es crucial para asegurar que el store se cree solo una vez y se mantenga el mismo a trav√©s de re-renderizados del Provider.
- **Error si falta el Provider:** La comprobaci√≥n `if (!store) throw new Error(...)` en el Consumer es una buena pr√°ctica para detectar errores de configuraci√≥n y guiar a los desarrolladores a usar el componente Consumer dentro del Provider correcto.
- **`useStore(store, selector)` con store vanilla:** Cuando usas `useStore` con un store vanilla (creado con `createStore`), el primer argumento de `useStore` es _el store vanilla en s√≠_, no la funci√≥n de creaci√≥n del store como cuando usas `create`. ¬°Recuerda esta diferencia! ‚òùÔ∏è

## D - Patrones Comunes: Envolviendo el Provider

#### 1. **Definici√≥n:**

Para hacer que el Provider sea m√°s reutilizable y f√°cil de usar, es com√∫n crear un **componente wrapper** para el Provider. Este wrapper se encarga de crear el store y de aceptar props que se pasar√°n al `createBearStore` para inicializar el estado. ¬°Es como crear un componente "Provider configurado"! üéÅ

#### 2. **Ejemplo:**

```typescript
// Provider wrapper
import { useRef } from "react";
import { BearContext, createBearStore, BearStore } from "./BearContext"; // Importa BearStore para tipar props

type BearProviderProps = React.PropsWithChildren<BearProps>; // Define props para el Provider wrapper, incluyendo children y BearProps

function BearProvider({ children, ...props }: BearProviderProps) {
  // Componente Provider wrapper que acepta props
  const storeRef = useRef<BearStore>(); // useRef para el store
  if (!storeRef.current) {
    storeRef.current = createBearStore(props); // Crea el store, pasando las props al createBearStore
  }
  return (
    <BearContext.Provider value={storeRef.current}>
      {" "}
      {/* Usa BearContext.Provider */}
      {children}
    </BearContext.Provider>
  );
}
```

**Explicaci√≥n del ejemplo:**

- **`BearProviderProps`:** Define las props para el componente `BearProvider`.
  - `React.PropsWithChildren<BearProps>`: Incluye `children` (para poder envolver otros componentes dentro del Provider) y extiende `BearProps` (para aceptar las props espec√≠ficas del store, como `bears`).
- **`BearProvider`:** El componente Provider wrapper.
  - Acepta props que cumplen con `BearProviderProps`.
  - Usa `useRef` y `createBearStore(props)` para crear el store, **pasando las props recibidas al `createBearStore`**. ¬°Aqu√≠ es donde se inicializa el estado con props!
  - Renderiza `BearContext.Provider`, proveyendo el store y renderizando los `children`.

#### 3. **Notas o advertencias:**

- **Props para el Provider wrapper:** Ahora, en lugar de pasar props directamente al `createBearStore` en el componente `App` (como en el ejemplo b√°sico), pasas las props al componente `BearProvider`. ¬°Esto es mucho m√°s limpio y reutilizable! ‚ú®
- **`React.PropsWithChildren`:** Usar `React.PropsWithChildren` es una buena pr√°ctica para componentes Provider wrappers, ya que permite que acepten cualquier tipo de contenido hijo.

## E - Patrones Comunes: Extrayendo la L√≥gica del Contexto a un Hook Personalizado

#### 1. **Definici√≥n:**

Para simplificar a√∫n m√°s el uso del contexto en los componentes Consumer, puedes extraer la l√≥gica de `useContext` y `useStore` a un **hook personalizado**. Este hook personalizado "imita" el hook que Zustand crea autom√°ticamente cuando usas `create` (como `useBearStore` en ejemplos anteriores), pero ahora funciona con tu Context API y stores vanilla. ¬°Es como crear tu propio `useBearStore` basado en Context! üé£

#### 2. **Ejemplo:**

**Hook Personalizado:**

```typescript
// Mimic the hook returned by `create`
import { useContext } from "react";
import { useStore } from "zustand";
import { BearContext, BearState } from "./BearContext"; // Importa BearContext y BearState

function useBearContext<T>(selector: (state: BearState) => T): T {
  // Hook personalizado useBearContext que acepta un selector
  const store = useContext(BearContext); // Usa useContext para obtener el store del Contexto
  if (!store) throw new Error("Missing BearContext.Provider in the tree"); // Error si no hay Provider
  return useStore(store, selector); // Usa useStore con el store vanilla y el selector
}
```

**Uso del Hook Personalizado en el Consumer:**

```typescript
// Consumer usage of the custom hook
import { useBearContext } from "./useBearContext"; // Importa el hook personalizado

function CommonConsumer() {
  const bears = useBearContext((s) => s.bears); // Usa el hook personalizado useBearContext para seleccionar el estado
  const addBear = useBearContext((s) => s.addBear);
  return (
    <>
      <div>{bears} Bears.</div>
      <button onClick={addBear}>Add bear</button>
    </>
  );
}
```

**Explicaci√≥n del ejemplo:**

- **`useBearContext<T>(selector: (state: BearState) => T): T`:** El hook personalizado `useBearContext`.
  - Acepta un `selector` (igual que el hook `useStore` de Zustand).
  - Usa `useContext(BearContext)` para obtener el store del contexto.
  - Usa `useStore(store, selector)` para seleccionar y suscribirse a partes del estado del store vanilla.
  - Devuelve el valor seleccionado (`T`).
- **`CommonConsumer`:** El componente Consumer ahora usa el hook personalizado `useBearContext` para acceder al estado y acciones del store. ¬°El c√≥digo del componente se vuelve mucho m√°s limpio y similar a como usar√≠as `useBearStore` con stores creados con `create`! ‚ú®

#### 3. **Notas o advertencias:**

- **Abstracci√≥n y Reutilizaci√≥n:** El hook personalizado `useBearContext` encapsula toda la l√≥gica de acceso al contexto y selecci√≥n del estado. Esto hace que los componentes Consumer sean m√°s f√°ciles de leer y mantener, y el hook se puede reutilizar en m√∫ltiples componentes. ‚ôªÔ∏è
- **Interfaz similar a `useStore`:** El hook `useBearContext` est√° dise√±ado para tener una interfaz similar al hook `useStore` de Zustand (aceptando un selector). Esto facilita la migraci√≥n de componentes que usan stores vanilla con Context API a stores creados directamente con `create` (o viceversa) si es necesario en el futuro.

## F - Patrones Comunes: Permitiendo Opcionalmente una Funci√≥n de Igualdad Personalizada

#### 1. **Definici√≥n:**

Para optimizar a√∫n m√°s las re-renderizaciones en tus componentes Consumer, puedes permitir opcionalmente pasar una **funci√≥n de igualdad personalizada** al hook `useBearContext`. Esta funci√≥n de igualdad se usar√° en `useStoreWithEqualityFn` (en lugar de `useStore`) para determinar si el valor seleccionado del estado ha cambiado realmente antes de provocar una re-renderizaci√≥n. ¬°Es como afinar el "sensor de cambios" para evitar re-renderizados innecesarios! ‚öôÔ∏è

#### 2. **Ejemplo:**

```typescript
// Allow custom equality function by using useStoreWithEqualityFn instead of useStore
import { useContext } from "react";
import { useStoreWithEqualityFn } from "zustand/traditional"; // Importa useStoreWithEqualityFn
import { BearContext, BearState } from "./BearContext"; // Importa BearContext y BearState

function useBearContext<T>(
  selector: (state: BearState) => T,
  equalityFn?: (left: T, right: T) => boolean // A√±ade equalityFn como argumento opcional
): T {
  const store = useContext(BearContext);
  if (!store) throw new Error("Missing BearContext.Provider in the tree");
  return useStoreWithEqualityFn(store, selector, equalityFn); // Usa useStoreWithEqualityFn, pasando equalityFn
}
```

**Explicaci√≥n del ejemplo:**

- **`equalityFn?: (left: T, right: T) => boolean`:** A√±adimos un segundo argumento opcional `equalityFn` al hook `useBearContext`. Este argumento es una funci√≥n que compara dos valores y devuelve `true` si son iguales, `false` si no.
- **`useStoreWithEqualityFn(store, selector, equalityFn)`:** En lugar de `useStore`, ahora usamos `useStoreWithEqualityFn`. Le pasamos el `store` vanilla, el `selector` y el `equalityFn` (que puede ser `undefined` si no se proporciona, en cuyo caso `useStoreWithEqualityFn` usar√° la funci√≥n de igualdad por defecto de Zustand, que es `Object.is`).

#### 3. **Notas o advertencias:**

- **`useStoreWithEqualityFn` para optimizaci√≥n:** `useStoreWithEqualityFn` es una versi√≥n m√°s avanzada de `useStore` que te da control sobre cu√°ndo se re-renderizan los componentes. Usar una funci√≥n de igualdad personalizada puede ser √∫til para optimizar el rendimiento en casos donde las re-renderizaciones son costosas o innecesarias. üöÄ
- **Funci√≥n de igualdad por defecto:** Si no se proporciona `equalityFn`, `useStoreWithEqualityFn` usa `Object.is` por defecto, que es una funci√≥n de igualdad estricta (`===`) para valores primitivos y comparaci√≥n por referencia para objetos. En muchos casos, la funci√≥n de igualdad por defecto es suficiente.

## G - Ejemplo Completo: Provider Wrapper y Hook Consumer

#### 1. **Definici√≥n:**

Para ver c√≥mo encajan todas las piezas, aqu√≠ tienes un ejemplo completo que muestra c√≥mo usar el Provider wrapper (`BearProvider`) y el hook personalizado Consumer (`useBearContext`) juntos en un componente `App2`. ¬°Ver√°s c√≥mo pasar props al Provider wrapper inicializa el estado del store! üß©

#### 2. **Ejemplo:**

```typescript
// Provider wrapper & custom hook consumer
import { BearProvider } from "./BearProvider"; // Importa el Provider wrapper
import { HookConsumer } from "./HookConsumer"; // Importa un componente Consumer que usa el hook personalizado

function App2() {
  return (
    <BearProvider bears={2}>
      {" "}
      {/* Usa BearProvider, pasando la prop 'bears={2}' */}
      <HookConsumer /> {/* Componente Consumer dentro del Provider */}
    </BearProvider>
  );
}
```

**Explicaci√≥n del ejemplo:**

- **`BearProvider bears={2}`:** En el componente `App2`, usamos el componente `BearProvider` y le pasamos la prop `bears={2}`. Esta prop `bears` se pasar√° a la funci√≥n `createBearStore` dentro de `BearProvider`, ¬°inicializando el estado del store con `bears: 2`!
- **`HookConsumer`:** Dentro de `BearProvider`, renderizamos un componente `HookConsumer` (que ser√≠a un componente como `CommonConsumer` del ejemplo anterior, usando el hook `useBearContext`). Este componente `HookConsumer` y todos sus descendientes podr√°n acceder al store inicializado con `bears: 2` a trav√©s del contexto.

#### 3. **Notas o advertencias:**

- **Props iniciales desde el Provider:** Este ejemplo muestra c√≥mo las props que pasas al componente Provider wrapper (`BearProvider`) se usan para inicializar el estado del store. ¬°Esta es la clave para inicializar el estado de Zustand con props! üîë
- **Flexibilidad y Reutilizaci√≥n:** Con el Provider wrapper y el hook personalizado, tienes una forma muy flexible y reutilizable de crear stores de Zustand que se inicializan con props y se conectan a tus componentes React a trav√©s del Context API. ¬°Este patr√≥n es muy √∫til para aplicaciones complejas que necesitan inyecci√≥n de dependencias o configuraci√≥n inicial del estado! üöÄ
