## A - Zustand y Next.js: Desafíos Especiales

#### 1. **Definición:**

Usar Zustand con Next.js tiene sus cositas porque Next.js es un framework para React que renderiza las páginas en el servidor (SSR). Esto nos presenta algunos retos únicos para manejar el estado de nuestra aplicación con Zustand, que normalmente es global.

#### 2. **Puntos Clave:**

- **Tienda por petición (Per-request store):** En Next.js, el servidor puede recibir muchas peticiones a la vez. ¡Imagínate un restaurante en hora punta! Cada petición necesita su propia "cocina" (tienda de Zustand) para no mezclar los pedidos. No podemos usar una tienda global única para todos.
- **Amigable con SSR:** Next.js renderiza las páginas dos veces: primero en el servidor y luego en el navegador. Si los datos de nuestra tienda son diferentes en estos dos momentos, ¡boom! Error de hidratación. Necesitamos que la tienda se inicialice en el servidor y luego se "rehidrate" en el cliente con los mismos datos.
- **Routing SPA:** Next.js permite navegar entre páginas sin recargar toda la página (como una aplicación SPA). Para que Zustand funcione bien en este modo, a veces necesitamos "resetear" la tienda cuando cambiamos de página.
- **Caché del servidor:** Las versiones más nuevas de Next.js son muy buenas guardando cosas en caché en el servidor. ¡Y buenas noticias! Zustand se lleva bien con esto porque nuestra tienda es como una "variable dentro de un módulo", lo que encaja perfecto con el sistema de caché de Next.js.

#### 3. **Notas o advertencias:**

- Si no manejamos bien estos puntos, podemos tener errores raros y comportamientos inesperados en nuestra app. ¡Pero no te preocupes! Para eso estamos aquí, para entender cómo hacerlo bien.

## B - Recomendaciones Clave para Zustand en Next.js

#### 1. **Definición:**

Para evitar problemas y sacarle el máximo partido a Zustand en Next.js, hay un par de recomendaciones muy importantes que debemos seguir.

#### 2. **Puntos Clave:**

- **¡No a las tiendas globales!** Como dijimos antes, cada petición necesita su propia tienda. Así que, ¡olvídate de crear la tienda de Zustand como una variable global fuera de todo! En lugar de eso, la crearemos dentro de cada petición.
- **Componentes del Servidor React (RSC) y Zustand: ¡Mezcla explosiva!** Los RSC son un tipo especial de componentes en Next.js que se ejecutan solo en el servidor. ¡Ojo! Los RSC no pueden usar hooks (como `useState` o `useContext`) ni leer o escribir en la tienda de Zustand directamente. Los RSC están pensados para ser "estateless" (sin estado). Si intentamos que un RSC toque la tienda de Zustand, vamos a romper la arquitectura de Next.js.

#### 3. **Notas o advertencias:**

- Recuerda: Si necesitas usar Zustand, hazlo en componentes de cliente (los que sí pueden usar hooks) y asegúrate de crear una tienda por cada petición. ¡Así evitamos líos!

## C - Creando una Tienda por Petición (Per-Request Store)

#### 1. **Definición:**

Para que cada petición en Next.js tenga su propia tienda de Zustand, necesitamos una función que cree una nueva tienda cada vez. A esta función la llamaremos "fábrica de tiendas".

#### 2. **Ejemplo:**

**Código:**

```typescript
// src/stores/counter-store.ts
import { createStore } from "zustand/vanilla";

export type CounterState = {
  count: number;
};

export type CounterActions = {
  decrementCount: () => void;
  incrementCount: () => void;
};

export type CounterStore = CounterState & CounterActions;

export const defaultInitState: CounterState = {
  count: 0,
};

export const createCounterStore = (
  initState: CounterState = defaultInitState
) => {
  return createStore<CounterStore>()((set) => ({
    ...initState,
    decrementCount: () => set((state) => ({ count: state.count - 1 })),
    incrementCount: () => set((state) => ({ count: state.count + 1 })),
  }));
};
```

**Explicación del ejemplo:**

- Hemos creado un archivo `counter-store.ts` donde definimos cómo será nuestra tienda para un contador.
- `CounterState`: Define la forma del estado, en este caso, solo tiene un `count` (número).
- `CounterActions`: Define las acciones que podemos realizar en la tienda, `incrementCount` y `decrementCount`.
- `CounterStore`: Combina el estado y las acciones.
- `defaultInitState`: Define el estado inicial por defecto, `count` empieza en 0.
- `createCounterStore`: ¡Aquí está la magia! Esta función es nuestra fábrica de tiendas. Usa `createStore` de Zustand para crear una nueva tienda cada vez que la llamamos. Recibe un `initState` (estado inicial) opcional. Dentro de `createStore`, definimos cómo se actualiza el estado con `set`.

#### 3. **Notas o advertencias:**

- Fíjate que estamos usando `zustand/vanilla`. Esto es importante para crear tiendas que funcionen bien en el servidor y en el cliente en Next.js.
- Esta función `createCounterStore` no crea la tienda directamente, ¡solo la define! La tienda se creará realmente cuando llamemos a esta función en nuestros componentes.

## D - Proveyendo la Tienda con Context

#### 1. **Definición:**

Ahora que tenemos nuestra función para crear tiendas por petición, necesitamos una forma de que nuestros componentes puedan acceder a esa tienda. La manera más elegante en React es usar **Context**. Vamos a crear un "proveedor de contexto" (`Provider`) que envuelva nuestros componentes y les dé acceso a la tienda.

#### 2. **Ejemplo:**

**Código:**

```typescript
// src/providers/counter-store-provider.tsx
"use client";

import { type ReactNode, createContext, useRef, useContext } from "react";
import { useStore } from "zustand";

import { type CounterStore, createCounterStore } from "@/stores/counter-store";

export type CounterStoreApi = ReturnType<typeof createCounterStore>;

export const CounterStoreContext = createContext<CounterStoreApi | undefined>(
  undefined
);

export interface CounterStoreProviderProps {
  children: ReactNode;
}

export const CounterStoreProvider = ({
  children,
}: CounterStoreProviderProps) => {
  const storeRef = useRef<CounterStoreApi>(null);
  if (!storeRef.current) {
    storeRef.current = createCounterStore();
  }

  return (
    <CounterStoreContext.Provider value={storeRef.current}>
      {children}
    </CounterStoreContext.Provider>
  );
};

export const useCounterStore = <T>(selector: (store: CounterStore) => T): T => {
  const counterStoreContext = useContext(CounterStoreContext);

  if (!counterStoreContext) {
    throw new Error(`useCounterStore must be used within CounterStoreProvider`);
  }

  return useStore(counterStoreContext, selector);
};
```

**Explicación del ejemplo:**

- `'use client'`: ¡Importantísimo! Este componente es de cliente, así que puede usar hooks.
- `CounterStoreContext = createContext(...)`: Creamos un Context de React para nuestra tienda.
- `CounterStoreProvider`: Este es nuestro componente proveedor.
  - `storeRef = useRef(null)`: Usamos `useRef` para guardar la tienda. `useRef` crea una referencia que persiste entre renders del componente.
  - `if (!storeRef.current)`: Comprobamos si `storeRef.current` está vacío. Si lo está (la primera vez que se renderiza el proveedor), creamos una nueva tienda con `createCounterStore()` y la guardamos en `storeRef.current`. ¡Así nos aseguramos de que la tienda se cree solo una vez por petición!
  - `<CounterStoreContext.Provider value={storeRef.current}>`: Envolvemos los `children` (los componentes que estarán dentro del proveedor) con el `Provider` del Context. Le pasamos la tienda (`storeRef.current`) como `value`. ¡Ahora todos los componentes dentro de este proveedor pueden acceder a la tienda!
- `useCounterStore`: Este es un hook personalizado para que los componentes "consuman" la tienda.
  - `const counterStoreContext = useContext(CounterStoreContext)`: Usamos `useContext` para acceder al valor del Context (nuestra tienda).
  - `if (!counterStoreContext)`: Comprobamos si el Context está definido. Si no, significa que estamos intentando usar `useCounterStore` fuera del `CounterStoreProvider`, ¡y eso no está permitido! Lanzamos un error para avisar.
  - `return useStore(counterStoreContext, selector)`: Usamos `useStore` de Zustand. Le pasamos el `counterStoreContext` (la tienda) y un `selector`. El `selector` es una función que elige qué parte del estado de la tienda queremos usar en nuestro componente. `useStore` se encarga de que el componente se re-renderice solo cuando la parte del estado que seleccionamos cambia.

#### 3. **Notas o advertencias:**

- El `useRef` es clave para asegurarnos de que la tienda se cree solo una vez por petición, incluso si el `CounterStoreProvider` se re-renderiza.
- El hook `useCounterStore` hace que sea muy fácil y seguro usar la tienda en nuestros componentes.

## E - Inicializando la Tienda

#### 1. **Definición:**

A veces queremos que nuestra tienda empiece con un estado inicial diferente al por defecto. Por ejemplo, podríamos querer que el contador empiece con el año actual. Vamos a ver cómo inicializar la tienda con datos personalizados.

#### 2. **Ejemplo:**

**Código (cambios en `counter-store.ts`):**

```typescript
// src/stores/counter-store.ts
import { createStore } from "zustand/vanilla";

export type CounterState = {
  count: number;
};

export type CounterActions = {
  decrementCount: () => void;
  incrementCount: () => void;
};

export type CounterStore = CounterState & CounterActions;

export const initCounterStore = (): CounterState => {
  return { count: new Date().getFullYear() };
};

export const defaultInitState: CounterState = {
  count: 0,
};

export const createCounterStore = (
  initState: CounterState = defaultInitState
) => {
  return createStore<CounterStore>()((set) => ({
    ...initState,
    decrementCount: () => set((state) => ({ count: state.count - 1 })),
    incrementCount: () => set((state) => ({ count: state.count + 1 })),
  }));
};
```

**Código (cambios en `counter-store-provider.tsx`):**

```typescript
// src/providers/counter-store-provider.tsx
"use client";

import { type ReactNode, createContext, useRef, useContext } from "react";
import { useStore } from "zustand";

import {
  type CounterStore,
  createCounterStore,
  initCounterStore,
} from "@/stores/counter-store";

export type CounterStoreApi = ReturnType<typeof createCounterStore>;

export const CounterStoreContext = createContext<CounterStoreApi | undefined>(
  undefined
);

export interface CounterStoreProviderProps {
  children: ReactNode;
}

export const CounterStoreProvider = ({
  children,
}: CounterStoreProviderProps) => {
  const storeRef = useRef<CounterStoreApi>(null);
  if (!storeRef.current) {
    storeRef.current = createCounterStore(initCounterStore()); // ¡Aquí cambiamos!
  }

  return (
    <CounterStoreContext.Provider value={storeRef.current}>
      {children}
    </CounterStoreContext.Provider>
  );
};

export const useCounterStore = <T>(selector: (store: CounterStore) => T): T => {
  const counterStoreContext = useContext(CounterStoreContext);

  if (!counterStoreContext) {
    throw new Error(`useCounterStore must be used within CounterStoreProvider`);
  }

  return useStore(counterStoreContext, selector);
};
```

**Explicación del ejemplo:**

- **`initCounterStore` en `counter-store.ts`:** Hemos creado una nueva función `initCounterStore` que define cómo queremos inicializar el estado. En este caso, devuelve un objeto con `count` igual al año actual.
- **Cambio en `CounterStoreProvider`:** En el `CounterStoreProvider`, ahora llamamos a `createCounterStore` pasando `initCounterStore()` como argumento: `storeRef.current = createCounterStore(initCounterStore())`. Esto hace que la tienda se cree con el estado inicial definido en `initCounterStore()`.

#### 3. **Notas o advertencias:**

- Ahora podemos personalizar fácilmente el estado inicial de nuestra tienda creando diferentes funciones `initCounterStore` o pasando diferentes argumentos a `createCounterStore`.

## F - Usando la Tienda con Diferentes Arquitecturas de Next.js

#### 1. **Definición:**

Next.js tiene dos formas principales de organizar las rutas de tu aplicación: el **Pages Router** (más antiguo) y el **App Router** (más nuevo y recomendado). La forma de usar Zustand es muy similar en ambos, pero hay pequeñas diferencias en cómo se configuran las rutas.

#### 2. **Arquitecturas:**

- **Pages Router:** Las páginas se definen dentro del directorio `pages`. Usa un sistema de rutas basado en archivos.
- **App Router:** Las páginas se definen dentro del directorio `app`. Ofrece más flexibilidad y nuevas características como Server Components.

#### 3. **Notas o advertencias:**

- ¡No te preocupes! El código de Zustand que hemos creado (la fábrica de tiendas, el proveedor de contexto, el hook) funciona igual de bien en ambas arquitecturas. Solo cambia un poco la estructura de los archivos y cómo se definen las páginas.

## G - Pages Router: Ejemplo Práctico

#### 1. **Definición:**

Veamos cómo usar nuestra tienda de contador en una aplicación Next.js que usa el Pages Router.

#### 2. **Ejemplo:**

**Código (`src/components/pages/home-page.tsx`):**

```typescript
// src/components/pages/home-page.tsx
import { useCounterStore } from "@/providers/counter-store-provider.ts";

export const HomePage = () => {
  const { count, incrementCount, decrementCount } = useCounterStore(
    (state) => state
  );

  return (
    <div>
      Count: {count}
      <hr />
      <button type="button" onClick={incrementCount}>
        Increment Count
      </button>
      <button type="button" onClick={decrementCount}>
        Decrement Count
      </button>
    </div>
  );
};
```

**Código (`src/_app.tsx`):**

```typescript
// src/_app.tsx
import type { AppProps } from "next/app";

import { CounterStoreProvider } from "@/providers/counter-store-provider.tsx";

export default function App({ Component, pageProps }: AppProps) {
  return (
    <CounterStoreProvider>
      <Component {...pageProps} />
    </CounterStoreProvider>
  );
}
```

**Código (`src/pages/index.tsx`):**

```typescript
// src/pages/index.tsx
import { HomePage } from "@/components/pages/home-page.tsx";

export default function Home() {
  return <HomePage />;
}
```

**Explicación del ejemplo:**

- **`HomePage`:** Este es nuestro componente de página. Usa el hook `useCounterStore` para acceder al `count` y a las acciones `incrementCount` y `decrementCount` de la tienda. Muestra el contador y dos botones para incrementarlo y decrementarlo.
- **`_app.tsx`:** En el Pages Router, `_app.tsx` es un componente especial que envuelve todas las páginas. Aquí es donde colocamos nuestro `CounterStoreProvider` para que la tienda esté disponible en toda la aplicación.
- **`pages/index.tsx`:** Esta es la página principal (ruta `/`). Simplemente renderiza nuestro componente `HomePage`.

#### 3. **Notas o advertencias:**

- En el Pages Router, envolver la aplicación con el `Provider` en `_app.tsx` es la forma más común de compartir la tienda en toda la app.

## H - App Router: Ejemplo Práctico

#### 1. **Definición:**

Ahora veamos cómo usar nuestra tienda de contador en una aplicación Next.js que usa el App Router.

#### 2. **Ejemplo:**

**Código (`src/components/pages/home-page.tsx`):**

```typescript
// src/components/pages/home-page.tsx
"use client";

import { useCounterStore } from "@/providers/counter-store-provider";

export const HomePage = () => {
  const { count, incrementCount, decrementCount } = useCounterStore(
    (state) => state
  );

  return (
    <div>
      Count: {count}
      <hr />
      <button type="button" onClick={incrementCount}>
        Increment Count
      </button>
      <button type="button" onClick={decrementCount}>
        Decrement Count
      </button>
    </div>
  );
};
```

**Código (`src/app/layout.tsx`):**

```typescript
// src/app/layout.tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

import { CounterStoreProvider } from "@/providers/counter-store-provider";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <CounterStoreProvider>{children}</CounterStoreProvider>
      </body>
    </html>
  );
}
```

**Código (`src/app/page.tsx`):**

```typescript
// src/app/page.tsx
import { HomePage } from "@/components/pages/home-page";

export default function Home() {
  return <HomePage />;
}
```

**Explicación del ejemplo:**

- **`HomePage`:** ¡Es idéntico al ejemplo del Pages Router! Funciona igual.
- **`app/layout.tsx`:** En el App Router, `layout.tsx` dentro del directorio `app` es como `_app.tsx` en el Pages Router. Define la estructura común de todas las páginas. Aquí colocamos nuestro `CounterStoreProvider` para que la tienda esté disponible en toda la aplicación.
- **`app/page.tsx`:** Esta es la página principal (ruta `/`) en el App Router. También renderiza nuestro componente `HomePage`.

#### 3. **Notas o advertencias:**

- En el App Router, envolver la aplicación con el `Provider` en `layout.tsx` es la forma de compartir la tienda en toda la app.
- Fíjate que el componente `HomePage` (que usa Zustand) tiene `'use client'` al principio. Esto es necesario en el App Router porque por defecto los componentes dentro de `app` son Server Components. Necesitamos marcar `HomePage` como Client Component para poder usar hooks y Zustand.
