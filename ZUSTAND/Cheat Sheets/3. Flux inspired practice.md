## A - Prácticas inspiradas en Flux en Zustand

#### 1. **Definición:**

Zustand, aunque es una librería muy flexible y sin muchas reglas estrictas, se inspira en ideas que vienen de **Flux** y **Redux**. Flux y Redux son como "guías" sobre cómo organizar el estado de tu aplicación de manera clara y predecible. Zustand toma algunas de estas ideas, pero las hace más sencillas y fáciles de usar. Si ya conoces Flux o Redux, ¡te sentirás como en casa con algunas cosas de Zustand!

#### 2. **Notas o advertencias:**

- Zustand no te obliga a seguir estas prácticas al pie de la letra, ¡es flexible! Pero estas ideas pueden ayudarte a organizar mejor tu código, especialmente en aplicaciones grandes.
- Aunque se inspira en Flux y Redux, Zustand es diferente en algunas cosas importantes. Así que algunos nombres o ideas pueden sonar parecidos, ¡pero no son exactamente iguales!

## B - Patrones Recomendados en Zustand

#### 1. **Definición:**

Hay algunas formas de usar Zustand que se recomiendan para que tu código sea más fácil de entender y mantener, especialmente cuando tu aplicación crece. Son como "consejos de buenas prácticas" para usar Zustand de la mejor manera.

## C - Un solo Store (Single Store)

#### 1. **Definición:**

La recomendación principal es que **todo el estado global** de tu aplicación viva en **un único store de Zustand**. Imagina que tienes una caja grande donde guardas todas las cosas importantes de tu aplicación, ¡ese es tu store de Zustand!

#### 2. **Notas o advertencias:**

- Tener un solo store ayuda a tener una visión clara de todo el estado de tu aplicación en un solo lugar.
- Si tu aplicación es muy, muy grande, Zustand te permite **dividir tu store en "pedazos" más pequeños** llamados "slices". Es como si tu caja grande tuviera compartimentos para organizar mejor las cosas, ¡pero sigue siendo una sola caja! Más info sobre slices [aquí](https://zustand.docs.pmnd.rs/guides/slices-pattern).

## D - Usar `set` (o `setState`) para actualizar el Store

#### 1. **Definición:**

Siempre, **siempre** usa la función `set` (o `setState`) para cambiar el estado en tu store de Zustand. `set` es como la "llave mágica" que abre la puerta para actualizar el estado de forma correcta.

#### 2. **Razón:**

`set` se asegura de dos cosas importantes:

1.  Que la actualización del estado se haga de forma correcta, **combinando** el nuevo estado con el anterior (como vimos antes).
2.  Que todos los "escuchas" (componentes que están usando partes del estado) se enteren de que el estado ha cambiado y se actualicen.

#### 3. **Notas o advertencias:**

- Nunca intentes cambiar el estado directamente "por fuera" de `set`. ¡Podría no funcionar bien y causar problemas! `set` es el camino correcto.

## E - Colocar las Acciones del Store juntas (Colocate store actions)

#### 1. **Definición:**

En Zustand, puedes actualizar el estado **sin necesidad de usar "acciones" y "reducers"** como en otras librerías tipo Flux (como Redux). En Zustand, las "acciones" (las funciones que cambian el estado) pueden vivir **directamente dentro de tu store**. Es como tener los "botones" para cambiar las cosas justo al lado de las cosas que quieres cambiar, ¡todo en el mismo lugar!

#### 2. **Ejemplo:**

```typescript
const useBoundStore = create((set) => ({
  storeSliceA: /* ... */,
  storeSliceB: /* ... */,
  storeSliceC: /* ... */,
  updateX: () => set(/* ... */), // ¡Acción dentro del store!
  updateY: () => set(/* ... */), // ¡Otra acción dentro del store!
}))
```

**Explicación del ejemplo:**

Aquí, `updateX` y `updateY` son **funciones directamente dentro del store** `useBoundStore`. Estas funciones usan `set` para actualizar el estado. ¡Es una forma muy directa y sencilla de organizar las actualizaciones de estado en Zustand!

#### 3. **Notas o advertencias:**

- Esta forma de colocar las acciones dentro del store es muy común y recomendada en Zustand. Hace que el código sea más fácil de leer y entender.
- Si prefieres, también puedes definir las acciones **fuera del store** usando `setState`. Más info [aquí](https://zustand.docs.pmd.rs/guides/practice-with-no-store-actions). Pero la forma más común es colocarlas dentro.

## F - Patrones tipo Redux (Redux-like Patterns)

#### 1. **Definición:**

Si vienes de Redux y te gustan sus ideas, ¡puedes usar patrones parecidos en Zustand! Aunque Zustand no te obliga a usarlos, te da la flexibilidad de hacerlo si te sientes más cómodo así.

## G - Función `dispatch` tipo Redux

#### 1. **Definición:**

Si te gusta la idea de usar un `dispatch` para enviar "acciones" y que un "reducer" se encargue de actualizar el estado (como en Redux), ¡puedes hacerlo en Zustand! Puedes añadir una función `dispatch` **directamente a tu store**.

#### 2. **Ejemplo:**

```typescript
const types = { increase: "INCREASE", decrease: "DECREASE" };

const reducer = (state, { type, by = 1 }) => {
  switch (type) {
    case types.increase:
      return { grumpiness: state.grumpiness + by };
    case types.decrease:
      return { grumpiness: state.grumpiness - by };
  }
};

const useGrumpyStore = create((set) => ({
  grumpiness: 0,
  dispatch: (args) => set((state) => reducer(state, args)), // ¡Dispatch en el store!
}));

const dispatch = useGrumpyStore((state) => state.dispatch);
dispatch({ type: types.increase, by: 2 }); // ¡Usando dispatch para enviar una acción!
```

**Explicación del ejemplo:**

Aquí, definimos un `reducer` como en Redux. Luego, en `useGrumpyStore`, añadimos una función `dispatch`. Esta función `dispatch` toma un "argumento" (`args`), y usa `set` para actualizar el estado **usando el reducer**. Después, puedes usar `dispatch` desde fuera del store para enviar "acciones" (como `{ type: types.increase, by: 2 }`) y que el reducer se encargue de actualizar el estado.

#### 3. **Notas o advertencias:**

- Este patrón te permite usar la idea de "acciones" y "reducers" de Redux en Zustand, si te resulta familiar o útil.

## H - Middleware `redux` de Zustand

#### 1. **Definición:**

Zustand incluso tiene un **middleware llamado `redux`** que hace que usar reducers al estilo Redux sea aún más fácil. Un middleware en Zustand es como una "pieza extra" que puedes añadir a tu store para darle más funcionalidades. El middleware `redux` te ayuda a conectar tu reducer de Redux con Zustand de forma sencilla.

#### 2. **Ejemplo:**

```typescript
import { redux } from "zustand/middleware";

const useReduxStore = create(redux(reducer, initialState)); // ¡Usando el middleware redux!
```

**Explicación del ejemplo:**

Aquí, importamos `redux` desde `zustand/middleware`. Cuando creamos el store con `create`, usamos `redux(reducer, initialState)` como primer argumento. Esto le dice a Zustand que use el middleware `redux`, usando el `reducer` y el `initialState` que le pasamos. ¡Ahora tu store `useReduxStore` funcionará con un reducer al estilo Redux!

## I - Funciones que envuelven las funciones de estado

#### 1. **Definición:**

Otra forma de actualizar el store es usando **funciones que "envuelven" las funciones de estado** (como `set`). Estas funciones pueden hacer más cosas además de actualizar el estado, como por ejemplo, hacer llamadas a un servidor (side-effects). Es como si tuvieras funciones "más inteligentes" que no solo cambian el estado, sino que también hacen otras cosas importantes al mismo tiempo.

#### 2. **Ejemplo:**

Imagina que quieres actualizar el estado y también guardar ese cambio en un servidor. Podrías crear una función que haga ambas cosas:

```typescript
const updateAndSave = (newValue) => {
  set({ value: newValue }); // Actualiza el estado localmente
  fetch("/api/save", {
    method: "POST",
    body: JSON.stringify({ value: newValue }),
  }); // Llama al servidor
};
```

**Explicación del ejemplo:**

`updateAndSave` es una función que primero usa `set` para actualizar el estado `value` en Zustand, y luego hace una llamada a un servidor para guardar el nuevo valor. ¡Así puedes manejar tanto la actualización del estado como otras acciones relacionadas en un solo lugar!

#### 3. **Notas o advertencias:**

- Este patrón es útil para manejar **side-effects** (acciones que ocurren "fuera" de la actualización del estado, como llamadas a APIs, etc.) junto con las actualizaciones de estado en Zustand.
- Si quieres usar Zustand de una forma que no dependa de React (non-reactive), puedes mirar [la documentación de Zustand](https://github.com/pmndrs/zustand#readingwriting-state-and-reacting-to-changes-outside-of-components).
