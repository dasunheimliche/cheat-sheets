## A - Configurando el Entorno de Pruebas

#### 1. **DefiniciÃ³n:**

Antes de empezar a probar tu cÃ³digo Zustand, necesitas preparar el terreno. Esto significa configurar tu **test runner** (la herramienta que ejecuta tus pruebas) para que entienda JavaScript/TypeScript y, si estÃ¡s probando componentes de interfaz de usuario, Â¡para que simule un navegador web! ğŸŒ

#### 2. **Ejemplo:**

Imagina que tu test runner es como un director de orquesta ğŸ¼. Necesita saber quÃ© instrumentos (JavaScript/TypeScript) va a usar y dÃ³nde va a tocar (entorno DOM simulado para UI).

- **Test Runners Populares:**
  - **Jest:** Muy popular en el mundo de React. Necesita configuraciÃ³n para TypeScript y JSDOM.
    - [Jest: Getting Started](https://jestjs.io/docs/getting-started)
    - [Jest: Configuration - Test Environment](https://jestjs.io/docs/configuration#testenvironment-string)
  - **Vitest:** Un test runner mÃ¡s nuevo, Â¡rÃ¡pido y diseÃ±ado para Vite! TambiÃ©n necesita configuraciÃ³n.
    - [Vitest: Getting Started](https://vitest.dev/guide)
    - [Vitest: Configuration - Test Environment](https://vitest.dev/config/#environment)

#### 3. **Notas o advertencias:**

- **JSDOM es clave para UI:** Si estÃ¡s probando componentes React que usan Zustand, asegÃºrate de que tu test runner estÃ© configurado para usar JSDOM. Â¡Es como darle un "cerebro" de navegador a tus pruebas! ğŸ§ 
- **DocumentaciÃ³n es tu amiga:** Los enlaces de arriba te llevarÃ¡n a las guÃ­as oficiales de Jest y Vitest. Â¡SÃ­guelas para configurar tu entorno correctamente! ğŸ“–

## B - Herramientas Ãštiles para Pruebas de UI y Red

#### 1. **DefiniciÃ³n:**

Para probar componentes React que se conectan a Zustand, **React Testing Library (RTL)** es tu mejor aliado. RTL te anima a escribir buenas pruebas que se centran en cÃ³mo el usuario interactÃºa con tu interfaz, Â¡en lugar de en los detalles internos de tu cÃ³digo! ğŸ­

Para simular peticiones de red (APIs), **Mock Service Worker (MSW)** es genial. MSW te permite crear "imitaciones" de tus APIs, Â¡asÃ­ tus pruebas no dependen de APIs reales y pueden ser mÃ¡s rÃ¡pidas y predecibles! ğŸŒâ¡ï¸ğŸ­

#### 2. **Ejemplo:**

Piensa en RTL como si estuvieras probando una obra de teatro desde el punto de vista del pÃºblico ğŸª. Te preocupas de que los actores (componentes) hagan lo que se espera cuando el pÃºblico (usuario) interactÃºa con la obra (interfaz).

MSW es como tener dobles de acciÃ³n para tus APIs ğŸ¬. En lugar de usar las APIs reales (que podrÃ­an fallar o ser lentas), usas "dobles" que siempre responden como esperas, Â¡haciendo tus pruebas mÃ¡s fiables!

- **Herramientas Recomendadas:**
  - **React Testing Library (RTL):** Para probar componentes React.
    - [DOM Testing Library: Setup](https://testing-library.com/docs/dom-testing-library/setup)
    - [React Testing Library: Setup](https://testing-library.com/docs/react-testing-library/setup)
    - [Testing Library Jest-DOM Matchers](https://testing-library.com/docs/ecosystem-jest-dom)
  - **Native Testing Library (RNTL):** Para componentes React Native (apps mÃ³viles).
    - [Native Testing Library: Setup](https://testing-library.com/docs/react-native-testing-library/setup)
  - **User Event Testing Library:** Para simular interacciones del usuario (clics, escritura, etc.).
    - [User Event Testing Library: Setup](https://testing-library.com/docs/user-event/setup)
  - **Mock Service Worker (MSW):** Para simular APIs.
    - [MSW: Installation](https://mswjs.io/docs/getting-started/install)
    - [MSW: Setting up mock requests](https://mswjs.io/docs/getting-started/mocks/rest-api)
    - [MSW: Mock server configuration for Node](https://mswjs.io/docs/getting-started/integrate/node)

#### 3. **Notas o advertencias:**

- **RTL para buenas prÃ¡cticas:** RTL te guÃ­a para escribir pruebas que se centran en el comportamiento de tu UI desde la perspectiva del usuario, Â¡lo cual es genial! ğŸ‘
- **MSW para pruebas aisladas:** MSW te permite aislar tus pruebas de las APIs reales, haciÃ©ndolas mÃ¡s rÃ¡pidas, fiables y fÃ¡ciles de escribir. ğŸš€
- **TypeScript y Jest/Node:** Si usas TypeScript, tambiÃ©n hay guÃ­as para configurarlo con Jest y Node.
  - [TypeScript for Jest: Setup](https://kulshekhar.github.io/ts-jest/docs/getting-started/installation)
  - [TypeScript for Node: Setup](https://typestrong.org/ts-node/docs/installation)

## C - Preparando Zustand para Pruebas

#### 1. **DefiniciÃ³n:**

Para probar tus stores de Zustand de forma efectiva, necesitas asegurarte de que cada prueba empieza con un estado "limpio". Esto significa **resetear** tus stores despuÃ©s de cada prueba para evitar que el estado de una prueba afecte a las siguientes. Zustand proporciona un mecanismo para hacer esto, Â¡y aquÃ­ te explicamos cÃ³mo configurarlo para Jest y Vitest! ğŸ§¼

#### 2. **Ejemplo:**

Imagina que tus stores de Zustand son como pizarras pizarra ğŸ“. DespuÃ©s de cada prueba, quieres borrar la pizarra para que la siguiente prueba empiece con una pizarra en blanco. Â¡AsÃ­ evitas confusiones y resultados inesperados!

#### 3. **Notas o advertencias:**

- **Jest vs Vitest:** Jest y Vitest son un poco diferentes internamente (mÃ³dulos CommonJS vs ES modules). Ten esto en cuenta al configurar el "mock" de Zustand para cada uno.
- **CÃ³digo compartido `counter-store-creator.ts`:** El ejemplo usa un archivo `counter-store-creator.ts` para compartir la lÃ³gica de creaciÃ³n del store de contador entre diferentes ejemplos (con y sin Context API). Â¡Es solo para evitar repetir cÃ³digo en la demo! â™»ï¸

## D - CÃ³digo Compartido para Pruebas: `counter-store-creator.ts`

#### 1. **DefiniciÃ³n:**

Este archivo `counter-store-creator.ts` es un ejemplo de cÃ³digo **compartido** que se usa en las demos de prueba. Define la estructura de un store de contador (`CounterStore`) y una funciÃ³n para crearlo (`counterStoreCreator`). Â¡No es esencial para la configuraciÃ³n de pruebas de Zustand en general, sino solo para los ejemplos de este documento! ğŸ§©

#### 2. **Ejemplo:**

```typescript
// shared/counter-store-creator.ts
import { type StateCreator } from "zustand";

export type CounterStore = {
  count: number;
  inc: () => void;
};

export const counterStoreCreator: StateCreator<CounterStore> = (set) => ({
  count: 1,
  inc: () => set((state) => ({ count: state.count + 1 })),
});
```

**ExplicaciÃ³n del ejemplo:**
Este cÃ³digo define un tipo `CounterStore` con un `count` (nÃºmero) y una funciÃ³n `inc` (para incrementar el contador). `counterStoreCreator` es la funciÃ³n que realmente crea el store, usando `set` para actualizar el estado. Â¡Es una forma sencilla de crear un store de contador! ğŸ”¢

#### 3. **Notas o advertencias:**

- **ReutilizaciÃ³n en demos:** Este archivo se reutiliza en los ejemplos de Jest y Vitest para evitar duplicar la definiciÃ³n del store de contador. Â¡En tus propios proyectos, podrÃ­as tener una estructura diferente! ğŸ“‚
- **`StateCreator`:** `StateCreator` es un tipo de Zustand que se usa para definir cÃ³mo se crea el estado de un store. Â¡Es parte de la magia de Zustand! âœ¨

## E - Configurando Jest para Pruebas de Zustand

#### 1. **DefiniciÃ³n:**

Para que Jest pueda resetear tus stores de Zustand despuÃ©s de cada prueba, necesitas crear un **"mock"** de la librerÃ­a `zustand`. Un "mock" es como una "imitaciÃ³n" que reemplaza la librerÃ­a real en tus pruebas. En este caso, el mock de Zustand intercepta la creaciÃ³n de stores y guarda funciones para resetearlos. ğŸ­

#### 2. **Ejemplo:**

Crea un archivo `__mocks__/zustand.ts` con este contenido:

```typescript
// __mocks__/zustand.ts
import { act } from "@testing-library/react";
import type * as ZustandExportedTypes from "zustand";
export * from "zustand";

const { create: actualCreate, createStore: actualCreateStore } =
  jest.requireActual<typeof ZustandExportedTypes>("zustand");

// Guarda funciones de reset para todos los stores
export const storeResetFns = new Set<() => void>();

const createUncurried = <T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>
) => {
  const store = actualCreate(stateCreator);
  const initialState = store.getInitialState();
  storeResetFns.add(() => {
    store.setState(initialState, true);
  });
  return store;
};

export const create = (<T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>
) => {
  console.log("zustand create mock");

  return typeof stateCreator === "function"
    ? createUncurried(stateCreator)
    : createUncurried;
}) as typeof ZustandExportedTypes.create;

const createStoreUncurried = <T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>
) => {
  const store = actualCreateStore(stateCreator);
  const initialState = store.getInitialState();
  storeResetFns.add(() => {
    store.setState(initialState, true);
  });
  return store;
};

export const createStore = (<T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>
) => {
  console.log("zustand createStore mock");

  return typeof stateCreator === "function"
    ? createStoreUncurried(stateCreator)
    : createStoreUncurried;
}) as typeof ZustandExportedTypes.createStore;

// Resetea todos los stores despuÃ©s de cada prueba
afterEach(() => {
  act(() => {
    storeResetFns.forEach((resetFn) => {
      resetFn();
    });
  });
});
```

TambiÃ©n necesitas un archivo `setup-jest.ts`:

```typescript
// setup-jest.ts
import "@testing-library/jest-dom";
```

Y configura `jest.config.ts`:

```typescript
// jest.config.ts
import type { JestConfigWithTsJest } from "ts-jest";

const config: JestConfigWithTsJest = {
  preset: "ts-jest",
  testEnvironment: "jsdom",
  setupFilesAfterEnv: ["./setup-jest.ts"],
};

export default config;
```

**ExplicaciÃ³n del ejemplo:**

- **`__mocks__/zustand.ts`:** Este archivo reemplaza la librerÃ­a `zustand` real en tus pruebas. Intercepta las funciones `create` y `createStore`, guarda las funciones de reset en `storeResetFns`, y las ejecuta despuÃ©s de cada prueba en `afterEach`. Â¡Es el corazÃ³n del "reseteo" de Zustand en Jest! â¤ï¸
- **`setup-jest.ts`:** Importa `@testing-library/jest-dom` para tener "matchers" de Jest Ãºtiles para pruebas de DOM (como `toBeInTheDocument()`).
- **`jest.config.ts`:** Configura Jest para usar `ts-jest` (para TypeScript), `jsdom` (entorno DOM), y `setupFilesAfterEnv` para ejecutar `setup-jest.ts` antes de las pruebas.

#### 3. **Notas o advertencias:**

- **`__mocks__` es especial:** Jest busca automÃ¡ticamente archivos en la carpeta `__mocks__` para usarlos como mocks. Â¡AsegÃºrate de que el nombre de la carpeta y el archivo sean correctos! ğŸ“
- **`jest.requireActual`:** Este cÃ³digo usa `jest.requireActual` para obtener las funciones `create` y `createStore` _reales_ de Zustand. El mock solo "envuelve" estas funciones para aÃ±adir la funcionalidad de reseteo, Â¡pero sigue usando la lÃ³gica de Zustand real! ğŸ”„
- **`afterEach` y `act`:** `afterEach` asegura que el reseteo se ejecute despuÃ©s de cada prueba. `act` de `@testing-library/react` es importante para envolver las actualizaciones de estado en React en pruebas. âš›ï¸
- **`ts-jest` y `ts-node`:** Para usar TypeScript en Jest, necesitas instalar `ts-jest` y `ts-node`. Â¡No olvides instalarlos! ğŸ“¦

## F - Configurando Vitest para Pruebas de Zustand

#### 1. **DefiniciÃ³n:**

La configuraciÃ³n para Vitest es muy similar a la de Jest, pero hay algunas diferencias clave debido a cÃ³mo Vitest maneja los mÃ³dulos y los mocks. Al igual que con Jest, el objetivo es crear un "mock" de Zustand que permita resetear los stores despuÃ©s de cada prueba. ğŸ­

#### 2. **Ejemplo:**

Crea un archivo `__mocks__/zustand.ts` (Â¡ojo con la ubicaciÃ³n en Vitest!):

```typescript
// __mocks__/zustand.ts
import { act } from "@testing-library/react";
import type * as ZustandExportedTypes from "zustand";
export * from "zustand";

const { create: actualCreate, createStore: actualCreateStore } =
  await vi.importActual<typeof ZustandExportedTypes>("zustand"); // Â¡`vi.importActual` en Vitest!

// Guarda funciones de reset para todos los stores
export const storeResetFns = new Set<() => void>();

const createUncurried = <T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>
) => {
  const store = actualCreate(stateCreator);
  const initialState = store.getInitialState();
  storeResetFns.add(() => {
    store.setState(initialState, true);
  });
  return store;
};

export const create = (<T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>
) => {
  console.log("zustand create mock");

  return typeof stateCreator === "function"
    ? createUncurried(stateCreator)
    : createUncurried;
}) as typeof ZustandExportedTypes.create;

const createStoreUncurried = <T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>
) => {
  const store = actualCreateStore(stateCreator);
  const initialState = store.getInitialState();
  storeResetFns.add(() => {
    store.setState(initialState, true);
  });
  return store;
};

export const createStore = (<T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>
) => {
  console.log("zustand createStore mock");

  return typeof stateCreator === "function"
    ? createStoreUncurried(stateCreator)
    : createStoreUncurried;
}) as typeof ZustandExportedTypes.createStore;

// Resetea todos los stores despuÃ©s de cada prueba
afterEach(() => {
  act(() => {
    storeResetFns.forEach((resetFn) => {
      resetFn();
    });
  });
});
```

Archivo `global.d.ts` (opcional, si no tienes globals configurado en Vitest):

```typescript
// global.d.ts
/// <reference types="vite/client" />
/// <reference types="vitest/globals" />
```

Archivo `setup-vitest.ts`:

```typescript
// setup-vitest.ts
import "@testing-library/jest-dom";

vi.mock("zustand"); // Â¡`vi.mock` en Vitest para auto-mocking!
```

Y configura `vitest.config.ts`:

```typescript
// vitest.config.ts
import { defineConfig, mergeConfig } from "vitest/config";
import viteConfig from "./vite.config";

export default mergeConfig(
  viteConfig,
  defineConfig({
    test: {
      globals: true, // Â¡Opcional, pero simplifica!
      environment: "jsdom",
      setupFiles: ["./setup-vitest.ts"],
    },
  })
);
```

**ExplicaciÃ³n del ejemplo:**

- **`__mocks__/zustand.ts`:** Similar al de Jest, pero usa `vi.importActual` (en lugar de `jest.requireActual`) para importar el Zustand real, y `vi` en lugar de `jest` en general. **Â¡OJO!** En Vitest, la carpeta `__mocks__` debe estar en el lugar correcto (a veces dentro de `src` si has cambiado la raÃ­z de Vitest). ğŸ“
- **`global.d.ts`:** Si no tienes la opciÃ³n `globals: true` en `vitest.config.ts`, necesitas este archivo para que Vitest reconozca las funciones globales como `describe`, `test`, `expect`, `afterEach`, `vi`. Si usas `globals: true`, Â¡no necesitas `global.d.ts`! ğŸŒ
- **`setup-vitest.ts`:** Similar a `setup-jest.ts`, pero ademÃ¡s usa `vi.mock('zustand')`. Esto activa el "auto-mocking" de Zustand en Vitest, Â¡haciendo que el mock en `__mocks__/zustand.ts` se use automÃ¡ticamente! ğŸª„
- **`vitest.config.ts`:** Configura Vitest para usar `jsdom`, `setupFiles` para ejecutar `setup-vitest.ts`, y opcionalmente `globals: true` para simplificar el cÃ³digo de prueba.

#### 3. **Notas o advertencias:**

- **`vi.importActual` y `vi.mock`:** Vitest usa `vi.importActual` y `vi.mock` en lugar de `jest.requireActual` y `jest.mock`. Â¡Recuerda usar las versiones de Vitest en tu configuraciÃ³n de mock! ğŸ”„
- **UbicaciÃ³n de `__mocks__` en Vitest: Â¡Cuidado!** En Vitest, la carpeta `__mocks__` se busca en relaciÃ³n a la "root" de tu proyecto, que puedes cambiar en `vitest.config.ts`. Si tienes problemas, asegÃºrate de que `__mocks__/zustand.ts` estÃ© en el lugar correcto. Por ejemplo, si tu `root` es `./src`, `__mocks__` deberÃ­a estar en `./src/__mocks__`. ğŸ“
- **`globals: true` en Vitest:** Activar `globals: true` en `vitest.config.ts` simplifica tus archivos de prueba, ya que no necesitas importar `describe`, `test`, `expect`, `afterEach`, `vi` en cada archivo. Â¡Pero es una opciÃ³n, no un requisito! ğŸŒ
- **`import { afterEach, vi } from 'vitest'` (sin globals):** Si no usas `globals: true`, recuerda importar `afterEach` y `vi` de `vitest` en los archivos donde los uses (como en `__mocks__/zustand.ts` y `setup-vitest.ts`). ğŸ“¦

## G - Probando Componentes React con Zustand

#### 1. **DefiniciÃ³n:**

Una vez que has configurado tu entorno de pruebas y el mock de Zustand, Â¡estÃ¡s listo para probar tus componentes React que usan Zustand! AquÃ­ te mostramos ejemplos de cÃ³mo probar componentes que usan `useCounterStore` (store simple) y `useCounterStoreContext` (store con Context API). âš›ï¸

#### 2. **Ejemplo:**

Primero, veamos el cÃ³digo de ejemplo del store y los componentes:

**`shared/counter-store-creator.ts`:** (Ya lo vimos antes, define `CounterStore` y `counterStoreCreator`)

**`stores/use-counter-store.ts`:** (Store simple con `create`)

```typescript
// stores/use-counter-store.ts
import { create } from "zustand";

import {
  type CounterStore,
  counterStoreCreator,
} from "../shared/counter-store-creator";

export const useCounterStore = create<CounterStore>()(counterStoreCreator);
```

**`contexts/use-counter-store-context.tsx`:** (Store con Context API y `createStore`)

```typescript
// contexts/use-counter-store-context.tsx
import { type ReactNode, createContext, useContext, useRef } from "react";
import { createStore } from "zustand";
import { useStoreWithEqualityFn } from "zustand/traditional";
import { shallow } from "zustand/shallow";

import {
  type CounterStore,
  counterStoreCreator,
} from "../shared/counter-store-creator";

export const createCounterStore = () => {
  return createStore<CounterStore>(counterStoreCreator);
};

export type CounterStoreApi = ReturnType<typeof createCounterStore>;

export const CounterStoreContext = createContext<CounterStoreApi | undefined>(
  undefined
);

export interface CounterStoreProviderProps {
  children: ReactNode;
}

export const CounterStoreProvider = ({
  children,
}: CounterStoreProviderProps) => {
  const counterStoreRef = useRef<CounterStoreApi>(null);
  if (!counterStoreRef.current) {
    counterStoreRef.current = createCounterStore();
  }

  return (
    <CounterStoreContext.Provider value={counterStoreRef.current}>
      {children}
    </CounterStoreContext.Provider>
  );
};

export type UseCounterStoreContextSelector<T> = (store: CounterStore) => T;

export const useCounterStoreContext = <T>(
  selector: UseCounterStoreContextSelector<T>
): T => {
  const counterStoreContext = useContext(CounterStoreContext);

  if (counterStoreContext === undefined) {
    throw new Error(
      "useCounterStoreContext must be used within CounterStoreProvider"
    );
  }

  return useStoreWithEqualityFn(counterStoreContext, selector, shallow);
};
```

**`components/counter/counter.tsx`:** (Component que usa `useCounterStore`)

```typescript
// components/counter/counter.tsx
import { useCounterStore } from "../../stores/use-counter-store";

export function Counter() {
  const { count, inc } = useCounterStore();

  return (
    <div>
      <h2>Counter Store</h2>
      <h4>{count}</h4>
      <button onClick={inc}>One Up</button>
    </div>
  );
}
```

**`components/counter-with-context/counter-with-context.tsx`:** (Component que usa `useCounterStoreContext` y `CounterStoreProvider`)

```typescript
// components/counter-with-context/counter-with-context.tsx
import {
  CounterStoreProvider,
  useCounterStoreContext,
} from "../../contexts/use-counter-store-context";

const Counter = () => {
  const { count, inc } = useCounterStoreContext((state) => state);

  return (
    <div>
      <h2>Counter Store Context</h2>
      <h4>{count}</h4>
      <button onClick={inc}>One Up</button>
    </div>
  );
};

export const CounterWithContext = () => {
  return (
    <CounterStoreProvider>
      <Counter />
    </CounterStoreProvider>
  );
};
```

#### 3. **Notas o advertencias:**

- **Ejemplos de stores y componentes:** Estos son solo ejemplos sencillos para demostrar las pruebas. Tus stores y componentes reales serÃ¡n probablemente mÃ¡s complejos. ğŸ§±
- **`useStoreWithEqualityFn` y `shallow`:** En `useCounterStoreContext`, se usa `useStoreWithEqualityFn` y `shallow` para optimizar las re-renderizaciones. No es esencial para las pruebas, pero es una buena prÃ¡ctica en componentes React que usan Zustand. ğŸš€

## H - Ejemplos de Pruebas de Componentes con RTL

#### 1. **DefiniciÃ³n:**

AquÃ­ tienes ejemplos de cÃ³mo escribir pruebas para los componentes `Counter` y `CounterWithContext` usando React Testing Library (RTL). VerÃ¡s cÃ³mo renderizar los componentes, interactuar con ellos (simular clics) y verificar que el estado de Zustand se actualiza correctamente. ğŸ­

#### 2. **Ejemplo:**

**`components/counter/counter.test.tsx`:** (Pruebas para `Counter` - store simple)

```typescript
// components/counter/counter.test.tsx
import { act, render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";

import { Counter } from "./counter";

describe("Counter", () => {
  test("deberÃ­a renderizar con el estado inicial de 1", async () => {
    renderCounter();

    expect(await screen.findByText(/^1$/)).toBeInTheDocument(); // Verifica que el contador empieza en 1
    expect(
      await screen.findByRole("button", { name: /one up/i }) // Verifica que el botÃ³n "One Up" estÃ¡ presente
    ).toBeInTheDocument();
  });

  test("deberÃ­a incrementar el contador al hacer clic en el botÃ³n", async () => {
    const user = userEvent.setup(); // Configura userEvent para simular interacciones del usuario

    renderCounter();

    expect(await screen.findByText(/^1$/)).toBeInTheDocument(); // Verifica que el contador empieza en 1

    await act(async () => {
      await user.click(await screen.findByRole("button", { name: /one up/i })); // Simula un clic en el botÃ³n "One Up"
    });

    expect(await screen.findByText(/^2$/)).toBeInTheDocument(); // Verifica que el contador se incrementÃ³ a 2
  });
});

const renderCounter = () => {
  return render(<Counter />); // FunciÃ³n auxiliar para renderizar el componente Counter
};
```

**`components/counter-with-context/counter-with-context.test.tsx`:** (Pruebas para `CounterWithContext` - store con Context API)

```typescript
// components/counter-with-context/counter-with-context.test.tsx
import { act, render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";

import { CounterWithContext } from "./counter-with-context";

describe("CounterWithContext", () => {
  test("deberÃ­a renderizar con el estado inicial de 1", async () => {
    renderCounterWithContext();

    expect(await screen.findByText(/^1$/)).toBeInTheDocument(); // Verifica que el contador empieza en 1
    expect(
      await screen.findByRole("button", { name: /one up/i }) // Verifica que el botÃ³n "One Up" estÃ¡ presente
    ).toBeInTheDocument();
  });

  test("deberÃ­a incrementar el contador al hacer clic en el botÃ³n", async () => {
    const user = userEvent.setup(); // Configura userEvent para simular interacciones del usuario

    renderCounterWithContext();

    expect(await screen.findByText(/^1$/)).toBeInTheDocument(); // Verifica que el contador empieza en 1

    await act(async () => {
      await user.click(await screen.findByRole("button", { name: /one up/i })); // Simula un clic en el botÃ³n "One Up"
    });

    expect(await screen.findByText(/^2$/)).toBeInTheDocument(); // Verifica que el contador se incrementÃ³ a 2
  });
});

const renderCounterWithContext = () => {
  return render(<CounterWithContext />); // FunciÃ³n auxiliar para renderizar el componente CounterWithContext
};
```

**ExplicaciÃ³n del ejemplo:**

- **`renderCounter` y `renderCounterWithContext`:** Funciones auxiliares para renderizar los componentes usando `render` de RTL.
- **`screen.findByText` y `screen.findByRole`:** Funciones de RTL para buscar elementos en el DOM por texto o rol (accesibilidad). `findBy...` espera a que el elemento aparezca en el DOM (Ãºtil para actualizaciones asÃ­ncronas).
- **`userEvent.setup()` y `user.click()`:** `userEvent` de `@testing-library/user-event` se usa para simular interacciones del usuario, como clics en botones. `act` es necesario para envolver las interacciones que actualizan el estado de React.
- **`expect(...).toBeInTheDocument()`:** "Matcher" de `@testing-library/jest-dom` para verificar que un elemento estÃ¡ presente en el DOM.

#### 3. **Notas o advertencias:**

- **RTL para pruebas centradas en el usuario:** Estas pruebas se centran en el comportamiento del componente desde la perspectiva del usuario: Â¿se renderiza el estado inicial correctamente? Â¿Se actualiza el contador al hacer clic en el botÃ³n? Â¡Esto es lo que RTL te anima a hacer! ğŸ‘
- **`act` es importante:** No olvides usar `act` al simular interacciones que actualizan el estado de React. Sin `act`, podrÃ­as tener errores o comportamientos inesperados en tus pruebas. âš›ï¸
- **Ejemplos sencillos, pero base sÃ³lida:** Estos ejemplos son sencillos, pero te dan una base sÃ³lida para empezar a probar tus propios componentes React que usan Zustand. Â¡Adapta estos patrones a tus necesidades! ğŸ› ï¸
