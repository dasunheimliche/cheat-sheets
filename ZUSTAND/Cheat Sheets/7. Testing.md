## A - Configurando el Entorno de Pruebas

#### 1. **Definici√≥n:**

Antes de empezar a probar tu c√≥digo Zustand, necesitas preparar el terreno. Esto significa configurar tu **test runner** (la herramienta que ejecuta tus pruebas) para que entienda JavaScript/TypeScript y, si est√°s probando componentes de interfaz de usuario, ¬°para que simule un navegador web! üåê

#### 2. **Ejemplo:**

Imagina que tu test runner es como un director de orquesta üéº. Necesita saber qu√© instrumentos (JavaScript/TypeScript) va a usar y d√≥nde va a tocar (entorno DOM simulado para UI).

- **Test Runners Populares:**
  - **Jest:** Muy popular en el mundo de React. Necesita configuraci√≥n para TypeScript y JSDOM.
    - [Jest: Getting Started](https://jestjs.io/docs/getting-started)
    - [Jest: Configuration - Test Environment](https://jestjs.io/docs/configuration#testenvironment-string)
  - **Vitest:** Un test runner m√°s nuevo, ¬°r√°pido y dise√±ado para Vite! Tambi√©n necesita configuraci√≥n.
    - [Vitest: Getting Started](https://vitest.dev/guide)
    - [Vitest: Configuration - Test Environment](https://vitest.dev/config/#environment)

#### 3. **Notas o advertencias:**

- **JSDOM es clave para UI:** Si est√°s probando componentes React que usan Zustand, aseg√∫rate de que tu test runner est√© configurado para usar JSDOM. ¬°Es como darle un "cerebro" de navegador a tus pruebas! üß†
- **Documentaci√≥n es tu amiga:** Los enlaces de arriba te llevar√°n a las gu√≠as oficiales de Jest y Vitest. ¬°S√≠guelas para configurar tu entorno correctamente! üìñ

## B - Herramientas √ötiles para Pruebas de UI y Red

#### 1. **Definici√≥n:**

Para probar componentes React que se conectan a Zustand, **React Testing Library (RTL)** es tu mejor aliado. RTL te anima a escribir buenas pruebas que se centran en c√≥mo el usuario interact√∫a con tu interfaz, ¬°en lugar de en los detalles internos de tu c√≥digo! üé≠

Para simular peticiones de red (APIs), **Mock Service Worker (MSW)** es genial. MSW te permite crear "imitaciones" de tus APIs, ¬°as√≠ tus pruebas no dependen de APIs reales y pueden ser m√°s r√°pidas y predecibles! üåê‚û°Ô∏èüé≠

#### 2. **Ejemplo:**

Piensa en RTL como si estuvieras probando una obra de teatro desde el punto de vista del p√∫blico ü™û. Te preocupas de que los actores (componentes) hagan lo que se espera cuando el p√∫blico (usuario) interact√∫a con la obra (interfaz).

MSW es como tener dobles de acci√≥n para tus APIs üé¨. En lugar de usar las APIs reales (que podr√≠an fallar o ser lentas), usas "dobles" que siempre responden como esperas, ¬°haciendo tus pruebas m√°s fiables!

- **Herramientas Recomendadas:**
  - **React Testing Library (RTL):** Para probar componentes React.
    - [DOM Testing Library: Setup](https://testing-library.com/docs/dom-testing-library/setup)
    - [React Testing Library: Setup](https://testing-library.com/docs/react-testing-library/setup)
    - [Testing Library Jest-DOM Matchers](https://testing-library.com/docs/ecosystem-jest-dom)
  - **Native Testing Library (RNTL):** Para componentes React Native (apps m√≥viles).
    - [Native Testing Library: Setup](https://testing-library.com/docs/react-native-testing-library/setup)
  - **User Event Testing Library:** Para simular interacciones del usuario (clics, escritura, etc.).
    - [User Event Testing Library: Setup](https://testing-library.com/docs/user-event/setup)
  - **Mock Service Worker (MSW):** Para simular APIs.
    - [MSW: Installation](https://mswjs.io/docs/getting-started/install)
    - [MSW: Setting up mock requests](https://mswjs.io/docs/getting-started/mocks/rest-api)
    - [MSW: Mock server configuration for Node](https://mswjs.io/docs/getting-started/integrate/node)

#### 3. **Notas o advertencias:**

- **RTL para buenas pr√°cticas:** RTL te gu√≠a para escribir pruebas que se centran en el comportamiento de tu UI desde la perspectiva del usuario, ¬°lo cual es genial! üëç
- **MSW para pruebas aisladas:** MSW te permite aislar tus pruebas de las APIs reales, haci√©ndolas m√°s r√°pidas, fiables y f√°ciles de escribir. üöÄ
- **TypeScript y Jest/Node:** Si usas TypeScript, tambi√©n hay gu√≠as para configurarlo con Jest y Node.
  - [TypeScript for Jest: Setup](https://kulshekhar.github.io/ts-jest/docs/getting-started/installation)
  - [TypeScript for Node: Setup](https://typestrong.org/ts-node/docs/installation)

## C - Preparando Zustand para Pruebas

#### 1. **Definici√≥n:**

Para probar tus stores de Zustand de forma efectiva, necesitas asegurarte de que cada prueba empieza con un estado "limpio". Esto significa **resetear** tus stores despu√©s de cada prueba para evitar que el estado de una prueba afecte a las siguientes. Zustand proporciona un mecanismo para hacer esto, ¬°y aqu√≠ te explicamos c√≥mo configurarlo para Jest y Vitest! üßº

#### 2. **Ejemplo:**

Imagina que tus stores de Zustand son como pizarras pizarra üìù. Despu√©s de cada prueba, quieres borrar la pizarra para que la siguiente prueba empiece con una pizarra en blanco. ¬°As√≠ evitas confusiones y resultados inesperados!

#### 3. **Notas o advertencias:**

- **Jest vs Vitest:** Jest y Vitest son un poco diferentes internamente (m√≥dulos CommonJS vs ES modules). Ten esto en cuenta al configurar el "mock" de Zustand para cada uno.
- **C√≥digo compartido `counter-store-creator.ts`:** El ejemplo usa un archivo `counter-store-creator.ts` para compartir la l√≥gica de creaci√≥n del store de contador entre diferentes ejemplos (con y sin Context API). ¬°Es solo para evitar repetir c√≥digo en la demo! ‚ôªÔ∏è

## D - C√≥digo Compartido para Pruebas: `counter-store-creator.ts`

#### 1. **Definici√≥n:**

Este archivo `counter-store-creator.ts` es un ejemplo de c√≥digo **compartido** que se usa en las demos de prueba. Define la estructura de un store de contador (`CounterStore`) y una funci√≥n para crearlo (`counterStoreCreator`). ¬°No es esencial para la configuraci√≥n de pruebas de Zustand en general, sino solo para los ejemplos de este documento! üß©

#### 2. **Ejemplo:**

```typescript
// shared/counter-store-creator.ts
import { type StateCreator } from "zustand";

export type CounterStore = {
  count: number;
  inc: () => void;
};

export const counterStoreCreator: StateCreator<CounterStore> = (set) => ({
  count: 1,
  inc: () => set((state) => ({ count: state.count + 1 })),
});
```

**Explicaci√≥n del ejemplo:**
Este c√≥digo define un tipo `CounterStore` con un `count` (n√∫mero) y una funci√≥n `inc` (para incrementar el contador). `counterStoreCreator` es la funci√≥n que realmente crea el store, usando `set` para actualizar el estado. ¬°Es una forma sencilla de crear un store de contador! üî¢

#### 3. **Notas o advertencias:**

- **Reutilizaci√≥n en demos:** Este archivo se reutiliza en los ejemplos de Jest y Vitest para evitar duplicar la definici√≥n del store de contador. ¬°En tus propios proyectos, podr√≠as tener una estructura diferente! üìÇ
- **`StateCreator`:** `StateCreator` es un tipo de Zustand que se usa para definir c√≥mo se crea el estado de un store. ¬°Es parte de la magia de Zustand! ‚ú®

## E - Configurando Jest para Pruebas de Zustand

#### 1. **Definici√≥n:**

Para que Jest pueda resetear tus stores de Zustand despu√©s de cada prueba, necesitas crear un **"mock"** de la librer√≠a `zustand`. Un "mock" es como una "imitaci√≥n" que reemplaza la librer√≠a real en tus pruebas. En este caso, el mock de Zustand intercepta la creaci√≥n de stores y guarda funciones para resetearlos. üé≠

#### 2. **Ejemplo:**

Crea un archivo `__mocks__/zustand.ts` con este contenido:

```typescript
// __mocks__/zustand.ts
import { act } from "@testing-library/react";
import type * as ZustandExportedTypes from "zustand";
export * from "zustand";

const { create: actualCreate, createStore: actualCreateStore } =
  jest.requireActual<typeof ZustandExportedTypes>("zustand");

// Guarda funciones de reset para todos los stores
export const storeResetFns = new Set<() => void>();

const createUncurried = <T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>
) => {
  const store = actualCreate(stateCreator);
  const initialState = store.getInitialState();
  storeResetFns.add(() => {
    store.setState(initialState, true);
  });
  return store;
};

export const create = (<T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>
) => {
  console.log("zustand create mock");

  return typeof stateCreator === "function"
    ? createUncurried(stateCreator)
    : createUncurried;
}) as typeof ZustandExportedTypes.create;

const createStoreUncurried = <T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>
) => {
  const store = actualCreateStore(stateCreator);
  const initialState = store.getInitialState();
  storeResetFns.add(() => {
    store.setState(initialState, true);
  });
  return store;
};

export const createStore = (<T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>
) => {
  console.log("zustand createStore mock");

  return typeof stateCreator === "function"
    ? createStoreUncurried(stateCreator)
    : createStoreUncurried;
}) as typeof ZustandExportedTypes.createStore;

// Resetea todos los stores despu√©s de cada prueba
afterEach(() => {
  act(() => {
    storeResetFns.forEach((resetFn) => {
      resetFn();
    });
  });
});
```

Tambi√©n necesitas un archivo `setup-jest.ts`:

```typescript
// setup-jest.ts
import "@testing-library/jest-dom";
```

Y configura `jest.config.ts`:

```typescript
// jest.config.ts
import type { JestConfigWithTsJest } from "ts-jest";

const config: JestConfigWithTsJest = {
  preset: "ts-jest",
  testEnvironment: "jsdom",
  setupFilesAfterEnv: ["./setup-jest.ts"],
};

export default config;
```

**Explicaci√≥n del ejemplo:**

- **`__mocks__/zustand.ts`:** Este archivo reemplaza la librer√≠a `zustand` real en tus pruebas. Intercepta las funciones `create` y `createStore`, guarda las funciones de reset en `storeResetFns`, y las ejecuta despu√©s de cada prueba en `afterEach`. ¬°Es el coraz√≥n del "reseteo" de Zustand en Jest! ‚ù§Ô∏è
- **`setup-jest.ts`:** Importa `@testing-library/jest-dom` para tener "matchers" de Jest √∫tiles para pruebas de DOM (como `toBeInTheDocument()`).
- **`jest.config.ts`:** Configura Jest para usar `ts-jest` (para TypeScript), `jsdom` (entorno DOM), y `setupFilesAfterEnv` para ejecutar `setup-jest.ts` antes de las pruebas.

#### 3. **Notas o advertencias:**

- **`__mocks__` es especial:** Jest busca autom√°ticamente archivos en la carpeta `__mocks__` para usarlos como mocks. ¬°Aseg√∫rate de que el nombre de la carpeta y el archivo sean correctos! üìÅ
- **`jest.requireActual`:** Este c√≥digo usa `jest.requireActual` para obtener las funciones `create` y `createStore` _reales_ de Zustand. El mock solo "envuelve" estas funciones para a√±adir la funcionalidad de reseteo, ¬°pero sigue usando la l√≥gica de Zustand real! üîÑ
- **`afterEach` y `act`:** `afterEach` asegura que el reseteo se ejecute despu√©s de cada prueba. `act` de `@testing-library/react` es importante para envolver las actualizaciones de estado en React en pruebas. ‚öõÔ∏è
- **`ts-jest` y `ts-node`:** Para usar TypeScript en Jest, necesitas instalar `ts-jest` y `ts-node`. ¬°No olvides instalarlos! üì¶

## F - Configurando Vitest para Pruebas de Zustand

#### 1. **Definici√≥n:**

La configuraci√≥n para Vitest es muy similar a la de Jest, pero hay algunas diferencias clave debido a c√≥mo Vitest maneja los m√≥dulos y los mocks. Al igual que con Jest, el objetivo es crear un "mock" de Zustand que permita resetear los stores despu√©s de cada prueba. üé≠

#### 2. **Ejemplo:**

Crea un archivo `__mocks__/zustand.ts` (¬°ojo con la ubicaci√≥n en Vitest!):

```typescript
// __mocks__/zustand.ts
import { act } from "@testing-library/react";
import type * as ZustandExportedTypes from "zustand";
export * from "zustand";

const { create: actualCreate, createStore: actualCreateStore } =
  await vi.importActual<typeof ZustandExportedTypes>("zustand"); // ¬°`vi.importActual` en Vitest!

// Guarda funciones de reset para todos los stores
export const storeResetFns = new Set<() => void>();

const createUncurried = <T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>
) => {
  const store = actualCreate(stateCreator);
  const initialState = store.getInitialState();
  storeResetFns.add(() => {
    store.setState(initialState, true);
  });
  return store;
};

export const create = (<T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>
) => {
  console.log("zustand create mock");

  return typeof stateCreator === "function"
    ? createUncurried(stateCreator)
    : createUncurried;
}) as typeof ZustandExportedTypes.create;

const createStoreUncurried = <T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>
) => {
  const store = actualCreateStore(stateCreator);
  const initialState = store.getInitialState();
  storeResetFns.add(() => {
    store.setState(initialState, true);
  });
  return store;
};

export const createStore = (<T>(
  stateCreator: ZustandExportedTypes.StateCreator<T>
) => {
  console.log("zustand createStore mock");

  return typeof stateCreator === "function"
    ? createStoreUncurried(stateCreator)
    : createStoreUncurried;
}) as typeof ZustandExportedTypes.createStore;

// Resetea todos los stores despu√©s de cada prueba
afterEach(() => {
  act(() => {
    storeResetFns.forEach((resetFn) => {
      resetFn();
    });
  });
});
```

Archivo `global.d.ts` (opcional, si no tienes globals configurado en Vitest):

```typescript
// global.d.ts
/// <reference types="vite/client" />
/// <reference types="vitest/globals" />
```

Archivo `setup-vitest.ts`:

```typescript
// setup-vitest.ts
import "@testing-library/jest-dom";

vi.mock("zustand"); // ¬°`vi.mock` en Vitest para auto-mocking!
```

Y configura `vitest.config.ts`:

```typescript
// vitest.config.ts
import { defineConfig, mergeConfig } from "vitest/config";
import viteConfig from "./vite.config";

export default mergeConfig(
  viteConfig,
  defineConfig({
    test: {
      globals: true, // ¬°Opcional, pero simplifica!
      environment: "jsdom",
      setupFiles: ["./setup-vitest.ts"],
    },
  })
);
```

**Explicaci√≥n del ejemplo:**

- **`__mocks__/zustand.ts`:** Similar al de Jest, pero usa `vi.importActual` (en lugar de `jest.requireActual`) para importar el Zustand real, y `vi` en lugar de `jest` en general. **¬°OJO!** En Vitest, la carpeta `__mocks__` debe estar en el lugar correcto (a veces dentro de `src` si has cambiado la ra√≠z de Vitest). üìç
- **`global.d.ts`:** Si no tienes la opci√≥n `globals: true` en `vitest.config.ts`, necesitas este archivo para que Vitest reconozca las funciones globales como `describe`, `test`, `expect`, `afterEach`, `vi`. Si usas `globals: true`, ¬°no necesitas `global.d.ts`! üåê
- **`setup-vitest.ts`:** Similar a `setup-jest.ts`, pero adem√°s usa `vi.mock('zustand')`. Esto activa el "auto-mocking" de Zustand en Vitest, ¬°haciendo que el mock en `__mocks__/zustand.ts` se use autom√°ticamente! ü™Ñ
- **`vitest.config.ts`:** Configura Vitest para usar `jsdom`, `setupFiles` para ejecutar `setup-vitest.ts`, y opcionalmente `globals: true` para simplificar el c√≥digo de prueba.

#### 3. **Notas o advertencias:**

- **`vi.importActual` y `vi.mock`:** Vitest usa `vi.importActual` y `vi.mock` en lugar de `jest.requireActual` y `jest.mock`. ¬°Recuerda usar las versiones de Vitest en tu configuraci√≥n de mock! üîÑ
- **Ubicaci√≥n de `__mocks__` en Vitest: ¬°Cuidado!** En Vitest, la carpeta `__mocks__` se busca en relaci√≥n a la "root" de tu proyecto, que puedes cambiar en `vitest.config.ts`. Si tienes problemas, aseg√∫rate de que `__mocks__/zustand.ts` est√© en el lugar correcto. Por ejemplo, si tu `root` es `./src`, `__mocks__` deber√≠a estar en `./src/__mocks__`. üìç
- **`globals: true` en Vitest:** Activar `globals: true` en `vitest.config.ts` simplifica tus archivos de prueba, ya que no necesitas importar `describe`, `test`, `expect`, `afterEach`, `vi` en cada archivo. ¬°Pero es una opci√≥n, no un requisito! üåê
- **`import { afterEach, vi } from 'vitest'` (sin globals):** Si no usas `globals: true`, recuerda importar `afterEach` y `vi` de `vitest` en los archivos donde los uses (como en `__mocks__/zustand.ts` y `setup-vitest.ts`). üì¶

## G - Probando Componentes React con Zustand

#### 1. **Definici√≥n:**

Una vez que has configurado tu entorno de pruebas y el mock de Zustand, ¬°est√°s listo para probar tus componentes React que usan Zustand! Aqu√≠ te mostramos ejemplos de c√≥mo probar componentes que usan `useCounterStore` (store simple) y `useCounterStoreContext` (store con Context API). ‚öõÔ∏è

#### 2. **Ejemplo:**

Primero, veamos el c√≥digo de ejemplo del store y los componentes:

**`shared/counter-store-creator.ts`:** (Ya lo vimos antes, define `CounterStore` y `counterStoreCreator`)

**`stores/use-counter-store.ts`:** (Store simple con `create`)

```typescript
// stores/use-counter-store.ts
import { create } from "zustand";

import {
  type CounterStore,
  counterStoreCreator,
} from "../shared/counter-store-creator";

export const useCounterStore = create<CounterStore>()(counterStoreCreator);
```

**`contexts/use-counter-store-context.tsx`:** (Store con Context API y `createStore`)

```typescript
// contexts/use-counter-store-context.tsx
import { type ReactNode, createContext, useContext, useRef } from "react";
import { createStore } from "zustand";
import { useStoreWithEqualityFn } from "zustand/traditional";
import { shallow } from "zustand/shallow";

import {
  type CounterStore,
  counterStoreCreator,
} from "../shared/counter-store-creator";

export const createCounterStore = () => {
  return createStore<CounterStore>(counterStoreCreator);
};

export type CounterStoreApi = ReturnType<typeof createCounterStore>;

export const CounterStoreContext = createContext<CounterStoreApi | undefined>(
  undefined
);

export interface CounterStoreProviderProps {
  children: ReactNode;
}

export const CounterStoreProvider = ({
  children,
}: CounterStoreProviderProps) => {
  const counterStoreRef = useRef<CounterStoreApi>(null);
  if (!counterStoreRef.current) {
    counterStoreRef.current = createCounterStore();
  }

  return (
    <CounterStoreContext.Provider value={counterStoreRef.current}>
      {children}
    </CounterStoreContext.Provider>
  );
};

export type UseCounterStoreContextSelector<T> = (store: CounterStore) => T;

export const useCounterStoreContext = <T>(
  selector: UseCounterStoreContextSelector<T>
): T => {
  const counterStoreContext = useContext(CounterStoreContext);

  if (counterStoreContext === undefined) {
    throw new Error(
      "useCounterStoreContext must be used within CounterStoreProvider"
    );
  }

  return useStoreWithEqualityFn(counterStoreContext, selector, shallow);
};
```

**`components/counter/counter.tsx`:** (Component que usa `useCounterStore`)

```typescript
// components/counter/counter.tsx
import { useCounterStore } from "../../stores/use-counter-store";

export function Counter() {
  const { count, inc } = useCounterStore();

  return (
    <div>
      <h2>Counter Store</h2>
      <h4>{count}</h4>
      <button onClick={inc}>One Up</button>
    </div>
  );
}
```

**`components/counter-with-context/counter-with-context.tsx`:** (Component que usa `useCounterStoreContext` y `CounterStoreProvider`)

```typescript
// components/counter-with-context/counter-with-context.tsx
import {
  CounterStoreProvider,
  useCounterStoreContext,
} from "../../contexts/use-counter-store-context";

const Counter = () => {
  const { count, inc } = useCounterStoreContext((state) => state);

  return (
    <div>
      <h2>Counter Store Context</h2>
      <h4>{count}</h4>
      <button onClick={inc}>One Up</button>
    </div>
  );
};

export const CounterWithContext = () => {
  return (
    <CounterStoreProvider>
      <Counter />
    </CounterStoreProvider>
  );
};
```

#### 3. **Notas o advertencias:**

- **Ejemplos de stores y componentes:** Estos son solo ejemplos sencillos para demostrar las pruebas. Tus stores y componentes reales ser√°n probablemente m√°s complejos. üß±
- **`useStoreWithEqualityFn` y `shallow`:** En `useCounterStoreContext`, se usa `useStoreWithEqualityFn` y `shallow` para optimizar las re-renderizaciones. No es esencial para las pruebas, pero es una buena pr√°ctica en componentes React que usan Zustand. üöÄ

## H - Ejemplos de Pruebas de Componentes con RTL

#### 1. **Definici√≥n:**

Aqu√≠ tienes ejemplos de c√≥mo escribir pruebas para los componentes `Counter` y `CounterWithContext` usando React Testing Library (RTL). Ver√°s c√≥mo renderizar los componentes, interactuar con ellos (simular clics) y verificar que el estado de Zustand se actualiza correctamente. üé≠

#### 2. **Ejemplo:**

**`components/counter/counter.test.tsx`:** (Pruebas para `Counter` - store simple)

```typescript
// components/counter/counter.test.tsx
import { act, render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";

import { Counter } from "./counter";

describe("Counter", () => {
  test("deber√≠a renderizar con el estado inicial de 1", async () => {
    renderCounter();

    expect(await screen.findByText(/^1$/)).toBeInTheDocument(); // Verifica que el contador empieza en 1
    expect(
      await screen.findByRole("button", { name: /one up/i }) // Verifica que el bot√≥n "One Up" est√° presente
    ).toBeInTheDocument();
  });

  test("deber√≠a incrementar el contador al hacer clic en el bot√≥n", async () => {
    const user = userEvent.setup(); // Configura userEvent para simular interacciones del usuario

    renderCounter();

    expect(await screen.findByText(/^1$/)).toBeInTheDocument(); // Verifica que el contador empieza en 1

    await act(async () => {
      await user.click(await screen.findByRole("button", { name: /one up/i })); // Simula un clic en el bot√≥n "One Up"
    });

    expect(await screen.findByText(/^2$/)).toBeInTheDocument(); // Verifica que el contador se increment√≥ a 2
  });
});

const renderCounter = () => {
  return render(<Counter />); // Funci√≥n auxiliar para renderizar el componente Counter
};
```

**`components/counter-with-context/counter-with-context.test.tsx`:** (Pruebas para `CounterWithContext` - store con Context API)

```typescript
// components/counter-with-context/counter-with-context.test.tsx
import { act, render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";

import { CounterWithContext } from "./counter-with-context";

describe("CounterWithContext", () => {
  test("deber√≠a renderizar con el estado inicial de 1", async () => {
    renderCounterWithContext();

    expect(await screen.findByText(/^1$/)).toBeInTheDocument(); // Verifica que el contador empieza en 1
    expect(
      await screen.findByRole("button", { name: /one up/i }) // Verifica que el bot√≥n "One Up" est√° presente
    ).toBeInTheDocument();
  });

  test("deber√≠a incrementar el contador al hacer clic en el bot√≥n", async () => {
    const user = userEvent.setup(); // Configura userEvent para simular interacciones del usuario

    renderCounterWithContext();

    expect(await screen.findByText(/^1$/)).toBeInTheDocument(); // Verifica que el contador empieza en 1

    await act(async () => {
      await user.click(await screen.findByRole("button", { name: /one up/i })); // Simula un clic en el bot√≥n "One Up"
    });

    expect(await screen.findByText(/^2$/)).toBeInTheDocument(); // Verifica que el contador se increment√≥ a 2
  });
});

const renderCounterWithContext = () => {
  return render(<CounterWithContext />); // Funci√≥n auxiliar para renderizar el componente CounterWithContext
};
```

**Explicaci√≥n del ejemplo:**

- **`renderCounter` y `renderCounterWithContext`:** Funciones auxiliares para renderizar los componentes usando `render` de RTL.
- **`screen.findByText` y `screen.findByRole`:** Funciones de RTL para buscar elementos en el DOM por texto o rol (accesibilidad). `findBy...` espera a que el elemento aparezca en el DOM (√∫til para actualizaciones as√≠ncronas).
- **`userEvent.setup()` y `user.click()`:** `userEvent` de `@testing-library/user-event` se usa para simular interacciones del usuario, como clics en botones. `act` es necesario para envolver las interacciones que actualizan el estado de React.
- **`expect(...).toBeInTheDocument()`:** "Matcher" de `@testing-library/jest-dom` para verificar que un elemento est√° presente en el DOM.

#### 3. **Notas o advertencias:**

- **RTL para pruebas centradas en el usuario:** Estas pruebas se centran en el comportamiento del componente desde la perspectiva del usuario: ¬øse renderiza el estado inicial correctamente? ¬øSe actualiza el contador al hacer clic en el bot√≥n? ¬°Esto es lo que RTL te anima a hacer! üëç
- **`act` es importante:** No olvides usar `act` al simular interacciones que actualizan el estado de React. Sin `act`, podr√≠as tener errores o comportamientos inesperados en tus pruebas. ‚öõÔ∏è
- **Ejemplos sencillos, pero base s√≥lida:** Estos ejemplos son sencillos, pero te dan una base s√≥lida para empezar a probar tus propios componentes React que usan Zustand. ¬°Adapta estos patrones a tus necesidades! üõ†Ô∏è
