## A - Actualización plana (Flat Updates)

#### 1. **Definición:**

En Zustand, actualizar el estado de forma plana es muy sencillo. Usas la función `set` que Zustand te da, y le pasas el nuevo estado. Zustand se encarga de combinar superficialmente este nuevo estado con el estado que ya tenías en tu store. Imagina que tienes una lista de cosas y solo quieres cambiar una cosa de esa lista, la actualización plana te permite hacerlo fácil.

#### 2. **Ejemplo:**

```typescript
import { create } from "zustand";

type State = {
  firstName: string;
  lastName: string;
};

type Action = {
  updateFirstName: (firstName: State["firstName"]) => void;
  updateLastName: (lastName: State["lastName"]) => void;
};

// Crea tu store, que incluye el estado y (opcionalmente) acciones
const usePersonStore = create<State & Action>((set) => ({
  firstName: "",
  lastName: "",
  updateFirstName: (firstName) => set(() => ({ firstName: firstName })),
  updateLastName: (lastName) => set(() => ({ lastName: lastName })),
}));

// En tu componente de React
function App() {
  const firstName = usePersonStore((state) => state.firstName);
  const updateFirstName = usePersonStore((state) => state.updateFirstName);

  return (
    <main>
      <label>
        First name
        <input
          onChange={(e) => updateFirstName(e.currentTarget.value)}
          value={firstName}
        />
      </label>

      <p>
        Hello, <strong>{firstName}!</strong>
      </p>
    </main>
  );
}
```

**Explicación del ejemplo:**

Aquí creamos un store `usePersonStore` con `create`. Dentro, definimos el estado inicial (`firstName` y `lastName` vacíos) y las acciones para actualizar cada uno. `updateFirstName` usa `set` para actualizar solo `firstName`. En el componente `App`, usamos `usePersonStore` para obtener `firstName` y `updateFirstName`. Cuando escribes en el input, `onChange` llama a `updateFirstName` con el nuevo valor, ¡y Zustand actualiza el `firstName` en el store!

#### 3. **Notas o advertencias:**

- Recuerda que esta actualización es "superficial" (shallow). Esto significa que si tu estado es un objeto complejo, solo la primera capa se actualiza directamente. Para objetos anidados, mira la siguiente sección.

## B - Objeto anidado profundamente (Deeply nested object)

#### 1. **Definición:**

Cuando tu estado en Zustand tiene objetos dentro de objetos (anidados), actualizar una parte profunda de este estado se complica un poco. Necesitas asegurarte de que los cambios se hagan de forma "inmutable". Inmutabilidad significa que no cambias el objeto original directamente, sino que creas una copia con los cambios. Esto es importante para que React y Zustand puedan detectar los cambios correctamente.

#### 2. **Ejemplo:**

Imagina que tienes este estado:

```typescript
type State = {
  deep: {
    nested: {
      obj: { count: number };
    };
  };
};
```

Si quieres aumentar `count`, necesitas actualizar `obj`, `nested`, y `deep` de forma inmutable.

## C - Enfoque normal (Normal approach)

#### 1. **Definición:**

La forma "normal" de actualizar objetos anidados en JavaScript (y en React o Redux también) es copiar cada nivel del objeto usando el "spread operator" (`...`). Es como hacer copias de cada caja dentro de una caja, hasta llegar a la caja que quieres cambiar.

#### 2. **Ejemplo:**

```typescript
  normalInc: () =>
    set((state) => ({
      deep: {
        ...state.deep,
        nested: {
          ...state.deep.nested,
          obj: {
            ...state.deep.nested.obj,
            count: state.deep.nested.obj.count + 1
          }
        }
      }
    })),
```

**Explicación del ejemplo:**

Para aumentar `count`, con `set` recibimos el estado anterior (`state`). Luego, creamos un nuevo objeto estado. Dentro, copiamos `state.deep` con `...state.deep`, pero reemplazamos `nested` con un nuevo objeto. Dentro de este nuevo `nested`, copiamos `state.deep.nested` y reemplazamos `obj` con un nuevo objeto, y así hasta llegar a `count` que finalmente incrementamos. ¡Es un poco largo y repetitivo!

#### 3. **Notas o advertencias:**

- Este método funciona, ¡pero es muy verboso! Si tienes objetos muy anidados, el código se vuelve difícil de leer y mantener. Por suerte, hay mejores maneras.

## D - Con Immer

#### 1. **Definición:**

[Immer](https://github.com/immerjs/immer) es una librería que te ayuda a trabajar con inmutabilidad de forma mucho más sencilla. Con Immer, puedes escribir código como si estuvieras mutando el estado directamente, ¡pero Immer se encarga de hacer las copias inmutables por debajo! Es como tener un "borrador mágico" donde puedes cambiar cosas, y al final Immer te da la versión final inmutable.

#### 2. **Ejemplo:**

```typescript
import { produce } from 'immer'

immerInc: () =>
  set(produce((state: State) => { ++state.deep.nested.obj.count })),
```

**Explicación del ejemplo:**

¡Mira qué corto y claro! Importamos `produce` de Immer. Dentro de `set`, llamamos a `produce` y le pasamos una función. En esta función, recibimos un borrador (`state`) del estado actual. ¡Simplemente incrementamos `state.deep.nested.obj.count` directamente con `++`! Immer se encarga de convertir esta "mutación" en una actualización inmutable.

#### 3. **Notas o advertencias:**

- **¡Mucho más fácil!** Immer hace que actualizar estados anidados sea mucho más legible y sencillo.
- **Gotchas:** Es importante leer las [advertencias sobre Immer con Zustand](https://zustand.docs.pmd.rs/integrations/immer-middleware) para entender algunos detalles importantes sobre cómo funciona Immer con Zustand.

## E - Con optics-ts

#### 1. **Definición:**

[optics-ts](https://github.com/akheron/optics-ts/) es otra librería para trabajar con inmutabilidad, pero con un enfoque diferente a Immer. En lugar de usar "borradores" y proxies, optics-ts usa "ópticas" para enfocarse en partes específicas del estado y modificarlas de forma inmutable. Es una forma más funcional y declarativa de trabajar con la inmutabilidad.

#### 2. **Ejemplo:**

```typescript
import * as O from 'optics-ts'

opticsInc: () =>
  set(O.modify(O.optic<State>().path("deep.nested.obj.count"))((c) => c + 1)),
```

**Explicación del ejemplo:**

Aquí usamos `optics-ts` (importado como `O`). `O.optic<State>()` crea una "óptica" para nuestro estado `State`. `.path("deep.nested.obj.count")` enfoca esta óptica en la parte específica de nuestro estado que queremos cambiar: `deep.nested.obj.count`. `O.modify(...)((c) => c + 1)` modifica la parte enfocada por la óptica, en este caso, incrementando el valor actual (`c`) en 1. Finalmente, `set(...)` actualiza el estado en Zustand con el resultado de la modificación.

#### 3. **Notas o advertencias:**

- **Sin proxies ni mutación:** A diferencia de Immer, optics-ts no usa proxies ni sintaxis de mutación. Puede ser una buena opción si prefieres un enfoque más funcional.
- **Tipado:** optics-ts también funciona muy bien con TypeScript y te ayuda a mantener la seguridad de tipos al actualizar el estado.

## F - Con Ramda

#### 1. **Definición:**

[Ramda](https://ramdajs.com/) es una librería de utilidades funcionales para JavaScript. Entre muchas otras cosas, Ramda ofrece funciones para trabajar con objetos y arrays de forma inmutable, incluyendo la modificación de partes anidadas de objetos.

#### 2. **Ejemplo:**

```typescript
import * as R from 'ramda'

ramdaInc: () =>
  set(R.modifyPath(["deep", "nested", "obj", "count"], (c) => c + 1)),
```

**Explicación del ejemplo:**

Importamos Ramda como `R`. `R.modifyPath(["deep", "nested", "obj", "count"], ...)` es la función de Ramda que nos permite modificar una parte anidada de un objeto especificada por la ruta `["deep", "nested", "obj", "count"]`. El segundo argumento es una función `(c) => c + 1` que se aplica al valor actual en esa ruta (`c` será el valor actual de `count`), y devuelve el nuevo valor (incrementado en 1). `set(...)` actualiza el estado en Zustand con el objeto modificado por Ramda.

#### 3. **Notas o advertencias:**

- **Librería funcional:** Ramda es una librería muy completa para programación funcional en JavaScript. Si ya la usas en tu proyecto, puede ser una buena opción para actualizaciones inmutables de estado.
- **Tipado:** Al igual que optics-ts, Ramda también funciona bien con TypeScript y mantiene la seguridad de tipos.
