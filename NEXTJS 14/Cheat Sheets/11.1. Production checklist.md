## A - Optimizaciones Automáticas en Next.js

#### 1. **Definición:**

Next.js viene con un montón de optimizaciones activadas por defecto, ¡sin que tengas que configurar nada! Estas mejoras hacen que tu aplicación sea más rápida y eficiente desde el principio.

#### 2. **Ejemplos:**

Imagina que tienes una casa (tu aplicación web). Next.js automáticamente:

- **Divide la casa en habitaciones (Code-splitting):** Solo carga las habitaciones que necesitas en cada momento, no toda la casa entera de golpe.
- **Prepara el camino (Prefetching):** Cuando ves una puerta a otra habitación, Next.js la prepara en segundo plano para que entrar sea casi instantáneo.
- **Construye partes de la casa de forma anticipada (Static Rendering):** Construye algunas partes de la casa (páginas) antes de que lleguen los visitantes, para que se vean súper rápido.
- **Guarda cosas en la nevera (Caching):** Guarda datos y elementos comunes para no tener que buscarlos o pedirlos de nuevo cada vez, ¡ahorrando tiempo y recursos!
- **Usa materiales modernos y ligeros (Server Components):** Utiliza componentes que se procesan en el servidor, lo que reduce el peso de la casa (menos JavaScript en el navegador del usuario).

#### 3. **Notas o advertencias:**

- Estas optimizaciones son geniales por defecto, pero a veces puedes querer desactivar alguna (como el prefetching en ciertas páginas) si tienes necesidades muy específicas.
- No te preocupes demasiado por configurarlas al principio, ¡Next.js ya hace un gran trabajo por ti!

## B - Componentes del Servidor (Server Components)

#### 1. **Definición:**

Son componentes de React que se ejecutan en el servidor, no en el navegador del usuario. Piensa en ellos como la "cocina" de tu aplicación web, donde se preparan las cosas antes de servirlas al cliente.

#### 2. **Ejemplo:**

Imagina una receta (un componente).

```jsx
// Este componente se ejecuta en el SERVIDOR
import React from "react";

async function DatosDelServidor() {
  const datos = await obtenerDatosDeLaBaseDeDatos(); // Datos desde el servidor
  return <div>{datos.nombre}</div>;
}

export default DatosDelServidor;
```

**Explicación del ejemplo:**
`DatosDelServidor` se ejecuta en el servidor. Puede acceder directamente a la base de datos y preparar la información antes de enviarla al navegador. ¡Menos trabajo para el navegador y más rápido para el usuario!

#### 3. **Notas o advertencias:**

- Los Server Components son el valor por defecto en Next.js.
- Son ideales para buscar datos, acceder a bases de datos y lógica del servidor.
- No incluyen JavaScript en el lado del cliente por defecto, lo que hace que las páginas sean más ligeras y rápidas.

## C - División de Código (Code-splitting)

#### 1. **Definición:**

Es como dividir tu aplicación en pequeños trozos (o "paquetes") y solo enviar al navegador del usuario los trozos que necesita para la página que está viendo en ese momento.

#### 2. **Ejemplo:**

Imagina un libro muy gordo (tu aplicación).

- **Sin Code-splitting:** Entregas todo el libro entero al lector, aunque solo quiera leer un capítulo. ¡Lento y pesado!
- **Con Code-splitting:** Entregas solo el capítulo que quiere leer. ¡Rápido y eficiente!

En Next.js, cada "ruta" (cada página) es como un capítulo diferente. Solo se carga el código necesario para esa página.

#### 3. **Notas o advertencias:**

- Next.js hace code-splitting automáticamente, ¡genial!
- Ayuda a que las páginas se carguen más rápido, especialmente al principio.
- Puedes optimizarlo aún más usando "carga perezosa" (lazy loading) para componentes más grandes o librerías de terceros.

## D - Prefetching

#### 1. **Definición:**

Es como "preparar el camino" para que la navegación entre páginas sea súper rápida. Cuando Next.js detecta un enlace (`<Link>`) que está a la vista del usuario, empieza a cargar la página a la que apunta ese enlace en segundo plano, ¡antes de que el usuario haga clic!

#### 2. **Ejemplo:**

Imagina que estás en un museo (tu web) y ves un cartel que indica "Sala de Arte Moderno" (un `<Link>`).

- **Sin Prefetching:** Hasta que no hagas clic en el cartel, no se prepara nada. Al hacer clic, tienes que esperar a que se cargue la sala.
- **Con Prefetching:** En cuanto ves el cartel, el museo empieza a preparar la "Sala de Arte Moderno" en segundo plano. Cuando haces clic, ¡entras casi al instante!

#### 3. **Notas o advertencias:**

- El prefetching está activado por defecto en Next.js para los componentes `<Link>`.
- Hace que la navegación sea mucho más fluida y rápida para el usuario.
- Puedes desactivar el prefetching en enlaces específicos si es necesario.

## E - Renderizado Estático (Static Rendering)

#### 1. **Definición:**

Es cuando Next.js genera el HTML de tus páginas en el servidor **durante el proceso de construcción** (build time), no cada vez que un usuario visita la página. Es como hacer una "foto" de la página y servir esa foto a todos los usuarios.

#### 2. **Ejemplo:**

Imagina hacer fotos para un catálogo de productos (tu web).

- **Renderizado Dinámico (sin Static Rendering):** Cada vez que alguien pide ver una página del catálogo, tienes que montar la página desde cero, buscar los datos del producto, etc. ¡Lento!
- **Renderizado Estático:** Haces fotos de todas las páginas del catálogo **una sola vez**, antes de publicarlo. Cuando alguien pide una página, simplemente le entregas la foto. ¡Mucho más rápido!

#### 3. **Notas o advertencias:**

- El Renderizado Estático es el comportamiento por defecto en Next.js para Server Components y Client Components.
- Es ideal para páginas que no cambian mucho o que pueden ser predecibles.
- Hace que las páginas se carguen muy rápido y mejora el SEO.
- Puedes usar Renderizado Dinámico para páginas que necesitan datos actualizados o contenido personalizado.

## F - Caching (Caché)

#### 1. **Definición:**

Es como guardar copias de cosas (datos, páginas, imágenes...) en lugares "rápidos" para no tener que pedirlas o generarlas de nuevo cada vez. Es como tener una "nevera" para tu aplicación web.

#### 2. **Ejemplo:**

Imagina pedir comida a domicilio (datos de tu base de datos).

- **Sin Caché:** Cada vez que pides lo mismo, el restaurante tiene que cocinarlo desde cero. ¡Lento y repetitivo!
- **Con Caché:** El restaurante puede tener algunos platos ya preparados en la "nevera" (caché). Si pides algo que está en la nevera, te lo sirven al instante. ¡Mucho más rápido!

Next.js usa caché para:

- **Datos:** Resultados de peticiones a bases de datos o APIs.
- **Componentes:** HTML generado de Server y Client Components.
- **Assets estáticos:** Imágenes, archivos CSS, etc.

#### 3. **Notas o advertencias:**

- Next.js utiliza caché de forma automática en muchos niveles.
- Reduce la carga en tu servidor, base de datos y servicios externos.
- Hace que las páginas se carguen más rápido y mejora la experiencia del usuario.
- Puedes controlar el caché (cuánto tiempo se guarda, cómo se invalida) si necesitas más control.

## G - Layouts

#### 1. **Definición:**

Son componentes de React que te permiten definir una estructura visual común (como un encabezado y un pie de página) que se comparte entre varias páginas de tu aplicación. Piensa en ellos como la "plantilla" de tus páginas.

#### 2. **Ejemplo:**

Imagina un periódico (tu web).

- **Sin Layouts:** Cada página del periódico tiene que repetir el encabezado, el pie de página, la barra de navegación, etc. ¡Repetitivo y difícil de mantener!
- **Con Layouts:** Defines un "layout" con el encabezado, pie de página, etc., y todas las páginas del periódico usan ese mismo layout. ¡Organizado y fácil de actualizar!

En Next.js, los Layouts se definen en la carpeta `app` y se aplican a las páginas dentro de esa carpeta.

#### 3. **Notas o advertencias:**

- Los Layouts son muy útiles para mantener la consistencia visual y la estructura de tu aplicación.
- Permiten la "renderización parcial" (partial rendering) en la navegación, lo que significa que solo se actualiza la parte de la página que cambia al navegar, ¡haciendo la navegación más rápida!

## H - Componente `<Link>`

#### 1. **Definición:**

Es un componente especial de Next.js que se usa para crear enlaces entre páginas de tu aplicación. Es como el `<a>` de HTML, pero con superpoderes para la navegación en aplicaciones Next.js.

#### 2. **Ejemplo:**

```jsx
import Link from "next/link";

function MiPagina() {
  return (
    <div>
      <Link href="/otra-pagina">
        <a>Ir a otra página</a>
      </Link>
    </div>
  );
}
```

**Explicación del ejemplo:**
En lugar de usar `<a>` directamente, usamos `<Link>` de Next.js. Esto habilita la navegación del lado del cliente y el prefetching automático.

#### 3. **Notas o advertencias:**

- **Navegación del lado del cliente:** `<Link>` evita recargar toda la página al navegar, haciendo la navegación mucho más rápida y fluida.
- **Prefetching automático:** Activa el prefetching automático para la página enlazada, como vimos antes.
- **Usar siempre `<Link>` para navegación interna:** Para enlaces dentro de tu propia aplicación Next.js, usa siempre `<Link>` en lugar de `<a>` directamente.

## I - Manejo de Errores

#### 1. **Definición:**

Es la forma en que tu aplicación web reacciona y muestra información cuando algo sale mal, como errores inesperados o páginas que no se encuentran (errores 404).

#### 2. **Ejemplo:**

Imagina que un usuario intenta acceder a una página que no existe en tu web (por ejemplo, `/pagina-inexistente`).

- **Sin Manejo de Errores Personalizado:** El usuario podría ver una página de error fea y genérica del navegador o del servidor. ¡Mala experiencia!
- **Con Manejo de Errores Personalizado:** Puedes crear páginas de error personalizadas (como `error.js` para errores generales y `not-found.js` para 404) que sean más amigables y útiles para el usuario.

#### 3. **Notas o advertencias:**

- Es importante tener un buen manejo de errores en producción para mejorar la experiencia del usuario y dar información útil en caso de problemas.
- Next.js te permite crear páginas de error personalizadas fácilmente.
- Considera manejar tanto errores generales como errores 404 (páginas no encontradas).

## J - Patrones de Composición (Server y Client Components)

#### 1. **Definición:**

Se refiere a cómo combinar y organizar Server Components y Client Components dentro de tu aplicación Next.js para optimizar el rendimiento y evitar problemas.

#### 2. **Ejemplo:**

Imagina construir una casa con diferentes tipos de bloques (componentes).

- **Server Components (bloques de piedra):** Pesados, robustos, ideales para la estructura principal (datos, lógica del servidor).
- **Client Components (bloques de madera):** Ligeros, interactivos, para detalles y partes que necesitan JavaScript en el navegador (botones, formularios).

**Patrón recomendado:** Mantener los Client Components lo más "abajo" posible en el árbol de componentes. Es decir, usar Server Components para la estructura principal y "envolver" solo las partes interactivas con Client Components.

#### 3. **Notas o advertencias:**

- Colocar `"use client"` (que marca un componente como Client Component) en la parte superior de un componente hace que todo ese componente y sus hijos sean Client Components.
- Si pones `"use client"` demasiado "arriba" en el árbol, puedes aumentar innecesariamente el tamaño de tu JavaScript del lado del cliente.
- Revisa bien dónde colocas tus `"use client"` para optimizar el rendimiento.

## K - Funciones Dinámicas

#### 1. **Definición:**

Son funciones en Next.js que introducen un comportamiento dinámico en tus rutas, como `cookies()` (para acceder a las cookies) y `searchParams` (para acceder a los parámetros de la URL).

#### 2. **Ejemplo:**

Imagina una página que muestra contenido diferente según las cookies del usuario o los parámetros en la URL.

```jsx
// Ejemplo usando cookies() - FUNCIÓN DINÁMICA
import { cookies } from "next/headers";

async function PaginaConCookies() {
  const cookieStore = cookies();
  const tema = cookieStore.get("tema")?.value;
  return <div>Tema seleccionado: {tema || "Claro"}</div>;
}
```

**Explicación del ejemplo:**
`cookies()` es una función dinámica. Al usarla en un componente, toda la ruta (o incluso toda la aplicación si se usa en el Root Layout) se convierte en **Renderizado Dinámico**.

#### 3. **Notas o advertencias:**

- **Renderizado Dinámico:** El uso de funciones dinámicas hace que la ruta se renderice dinámicamente en cada petición, no estáticamente en el build time.
- **Impacto en el rendimiento:** El Renderizado Dinámico puede ser más lento que el Renderizado Estático.
- **Uso intencional:** Asegúrate de usar funciones dinámicas solo cuando sea realmente necesario.
- **`<Suspense>`:** Si usas funciones dinámicas, considera usar `<Suspense>` para mejorar la experiencia de carga.

## L - Componentes del Servidor para Obtención de Datos

#### 1. **Definición:**

Aprovechar los Server Components para realizar la obtención de datos directamente en el servidor. Esto significa que la lógica de acceso a datos se ejecuta en el backend, no en el navegador del usuario.

#### 2. **Ejemplo:**

```jsx
// Server Component que obtiene datos del servidor
async function PaginaDeProductos() {
  const productos = await obtenerProductosDeLaAPI(); // Fetch en el servidor
  return (
    <ul>
      {productos.map((producto) => (
        <li key={producto.id}>{producto.nombre}</li>
      ))}
    </ul>
  );
}
```

**Explicación del ejemplo:**
`PaginaDeProductos` es un Server Component. La función `obtenerProductosDeLaAPI()` se ejecuta en el servidor, busca los datos y los pasa al componente para renderizar la lista.

#### 3. **Notas o advertencias:**

- **Beneficios:** Seguridad (código de acceso a datos no expuesto al cliente), rendimiento (menos JavaScript en el cliente), acceso directo a recursos del backend.
- **Recomendado:** Usar Server Components como la forma principal de obtener datos en Next.js.

## M - Route Handlers

#### 1. **Definición:**

Son funciones en Next.js que se ejecutan en el servidor y te permiten crear APIs personalizadas dentro de tu aplicación. Piensa en ellos como "mini-servidores" dentro de tu proyecto Next.js.

#### 2. **Ejemplo:**

Crea un archivo `app/api/productos/route.js` (o `.ts`) con el siguiente código:

```javascript
// app/api/productos/route.js
import { NextResponse } from "next/server";

export async function GET() {
  const productos = await obtenerProductosDeLaBaseDeDatos();
  return NextResponse.json(productos);
}
```

**Explicación del ejemplo:**
Este Route Handler define una API en `/api/productos` que responde a peticiones `GET` y devuelve una lista de productos en formato JSON.

#### 3. **Notas o advertencias:**

- **Acceso al backend desde Client Components:** Los Route Handlers son la forma recomendada de acceder a recursos del backend (bases de datos, APIs externas) desde Client Components.
- **No llamar Route Handlers desde Server Components:** Evita llamar a Route Handlers desde Server Components, ya que esto crea una petición de red innecesaria dentro del servidor. Si estás en un Server Component, accede directamente a los datos.

## N - Streaming (Transmisión)

#### 1. **Definición:**

Es una técnica para enviar la interfaz de usuario (UI) de tu página web al navegador del usuario en partes, de forma progresiva, en lugar de esperar a que toda la página esté lista. Es como servir un plato por partes en lugar de esperar a que esté completo.

#### 2. **Ejemplo:**

Imagina una página con un encabezado, una barra lateral y una lista de productos que tarda en cargar.

- **Sin Streaming:** El usuario ve una pantalla en blanco hasta que todos los datos de los productos se cargan y toda la página se renderiza. ¡Lento y frustrante!
- **Con Streaming:** Primero se envía el encabezado y la barra lateral (que son rápidos de renderizar). El usuario ya ve algo en la pantalla. Luego, cuando los datos de los productos están listos, se envía la lista. ¡Mejor experiencia, la página parece cargar más rápido!

#### 3. **Notas o advertencias:**

- **Loading UI y React Suspense:** Next.js facilita el streaming con Loading UI (para mostrar un estado de carga) y React Suspense (para manejar la carga asíncrona de componentes).
- **Mejora la percepción de velocidad:** El streaming hace que las páginas parezcan cargar más rápido, especialmente cuando hay datos que tardan en obtenerse.
- **Evita bloqueos:** Previene que toda la página se bloquee mientras se esperan datos.

## O - Obtención de Datos en Paralelo

#### 1. **Definición:**

Es la técnica de realizar múltiples peticiones de datos al mismo tiempo, en lugar de una tras otra (en serie). Es como pedir varios platos a la vez en un restaurante en lugar de esperar a que te sirvan uno para pedir el siguiente.

#### 2. **Ejemplo:**

Imagina una página que necesita mostrar información del perfil del usuario y una lista de sus últimas publicaciones.

- **Obtención de Datos en Serie (secuencial):** Primero se pide la información del perfil, se espera a que llegue, y luego se pide la lista de publicaciones. ¡Lento!
- **Obtención de Datos en Paralelo:** Se piden la información del perfil y la lista de publicaciones **al mismo tiempo**. Se espera a que lleguen ambas (o la que llegue primero). ¡Más rápido!

```jsx
async function PaginaDePerfil() {
  const [perfil, publicaciones] = await Promise.all([
    obtenerPerfilUsuario(), // Petición 1
    obtenerPublicacionesUsuario(), // Petición 2 - ¡EN PARALELO!
  ]);

  return <div>{/* ... mostrar perfil y publicaciones ... */}</div>;
}
```

#### 3. **Notas o advertencias:**

- **Reduce "waterfalls" de red:** La obtención en paralelo evita las "cascadas" de peticiones, donde una petición tiene que esperar a que termine la anterior.
- **Mejora el tiempo de carga:** Puede reducir significativamente el tiempo total de carga de la página.
- **`Promise.all()`:** En JavaScript, `Promise.all()` es una forma común de realizar peticiones en paralelo.

## P - Caching de Datos (Data Caching)

#### 1. **Definición:**

Asegurarte de que las peticiones de datos en tu aplicación Next.js se están guardando en caché (data cache) cuando sea apropiado. Esto evita peticiones repetidas a la base de datos o APIs externas, mejorando el rendimiento.

#### 2. **Ejemplo:**

Imagina que tu aplicación pide la lista de categorías de productos varias veces.

- **Sin Caché de Datos:** Cada vez que se pide la lista de categorías, se hace una nueva petición a la base de datos. ¡Ineficiente!
- **Con Caché de Datos:** La primera vez que se pide la lista, se guarda en caché. Las siguientes veces, se usa la copia en caché en lugar de volver a la base de datos. ¡Más rápido y menos carga en la base de datos!

#### 3. **Notas o advertencias:**

- **`fetch` por defecto con caché:** En Next.js, las peticiones realizadas con la función `fetch` se guardan en caché por defecto.
- **Verificar el caché:** Asegúrate de que tus peticiones `fetch` se están beneficiando del caché.
- **`unstable_cache`:** Para peticiones que no usan `fetch`, puedes usar la función `unstable_cache` para habilitar el caché.
- **Optar por no usar caché:** En algunos casos, puedes querer desactivar el caché para datos que deben ser siempre frescos.

## Q - Imágenes Estáticas

#### 1. **Definición:**

Utilizar el directorio `public` en tu proyecto Next.js para almacenar imágenes y otros archivos estáticos (como iconos, fuentes, etc.). Next.js sirve estos archivos directamente y los guarda en caché automáticamente.

#### 2. **Ejemplo:**

Coloca tus imágenes en la carpeta `public/images/`. Luego, puedes acceder a ellas en tu código así:

```jsx
<img src="/images/mi-imagen.jpg" alt="Mi imagen" />
```

**Explicación del ejemplo:**
Los archivos en `public` se sirven directamente desde la raíz de tu dominio (ej. `/images/mi-imagen.jpg`). Next.js se encarga de la caché y de servirlos de forma eficiente.

#### 3. **Notas o advertencias:**

- **Caché automático:** Los archivos en `public` se guardan en caché automáticamente por los navegadores y por la CDN de Vercel (si usas Vercel).
- **Ruta base:** La ruta base para acceder a los archivos en `public` es `/`.
- **Ideal para assets estáticos:** Usa `public` para imágenes, iconos, fuentes y otros archivos que no cambian con frecuencia.

## R - Formularios y Validación

#### 1. **Definición:**

Utilizar Server Actions para manejar el envío de formularios, la validación de datos en el servidor y el manejo de errores en formularios de tu aplicación Next.js.

#### 2. **Ejemplo:**

```jsx
// Componente de formulario (Client Component)
"use client";
import { useState } from "react";
import { crearUsuario } from "./actions"; // Server Action

function FormularioRegistro() {
  const [nombre, setNombre] = useState("");
  const [email, setEmail] = useState("");
  const [error, setError] = useState("");

  async function handleSubmit(event) {
    event.preventDefault();
    const resultado = await crearUsuario({ nombre, email }); // Llama al Server Action
    if (resultado.error) {
      setError(resultado.error);
    } else {
      // Registro exitoso
      alert("Usuario registrado!");
    }
  }

  return (
    <form onSubmit={handleSubmit}>
      {/* ... campos del formulario ... */}
      {error && <p className="error">{error}</p>}
      <button type="submit">Registrarse</button>
    </form>
  );
}

export default FormularioRegistro;

// Server Action (en actions.js o similar)
("use server");
export async function crearUsuario(formData) {
  const { nombre, email } = formData;

  // Validación en el servidor
  if (!nombre || !email) {
    return { error: "Nombre y email son obligatorios" };
  }

  // ... lógica para crear usuario en la base de datos ...

  return { success: true };
}
```

**Explicación del ejemplo:**
El formulario es un Client Component (por el `'use client'`). El envío del formulario llama a la Server Action `crearUsuario`, que se ejecuta en el servidor. La Server Action valida los datos y crea el usuario.

#### 3. **Notas o advertencias:**

- **Server Actions para lógica del servidor:** Mueve la lógica de procesamiento de formularios y validación al servidor usando Server Actions.
- **Seguridad:** Server Actions son más seguros para manejar datos sensibles y lógica de backend.
- **Validación en el servidor:** Siempre valida los datos del formulario en el servidor, no solo en el cliente.
- **Manejo de errores:** Maneja los errores que puedan ocurrir en el servidor y muéstralos al usuario en el formulario.

## S - Módulo de Fuentes (Font Module)

#### 1. **Definición:**

Es una forma optimizada de usar fuentes web en Next.js. El Font Module descarga las fuentes durante el build, las aloja localmente (con tus assets estáticos) y elimina peticiones de red externas para las fuentes.

#### 2. **Ejemplo:**

```javascript
// app/layout.js (o _layout.js en pages)
import { Inter } from "next/font/google";

const inter = Inter({ subsets: ["latin"] });

export default function RootLayout({ children }) {
  return (
    <html lang="en" className={inter.className}>
      <body>{children}</body>
    </html>
  );
}
```

**Explicación del ejemplo:**
Importamos la fuente `Inter` desde `next/font/google`. Next.js se encarga de optimizar la fuente y aplicarla a tu aplicación usando `inter.className`.

#### 3. **Notas o advertencias:**

- **Optimización automática:** El Font Module optimiza automáticamente las fuentes para rendimiento y privacidad.
- **Elimina peticiones externas:** Aloja las fuentes localmente, eliminando peticiones a servidores de Google Fonts u otros proveedores.
- **Reduce layout shift:** Ayuda a prevenir el "layout shift" (CLS) al cargar las fuentes.
- **Soporte para Google Fonts y fuentes locales:** Funciona con Google Fonts y también con fuentes locales.

## T - Componente `<Image>`

#### 1. **Definición:**

Es un componente de Next.js diseñado específicamente para optimizar imágenes. Automáticamente optimiza las imágenes, previene el "layout shift" y las sirve en formatos modernos como WebP o AVIF (si el navegador los soporta).

#### 2. **Ejemplo:**

```jsx
import Image from "next/image";
import miImagen from "./mi-imagen.jpg"; // Importa la imagen

function MiComponente() {
  return (
    <Image
      src={miImagen} // Usa la imagen importada
      alt="Descripción de la imagen"
      width={500} // Ancho deseado
      height={300} // Alto deseado
    />
  );
}
```

**Explicación del ejemplo:**
En lugar de usar `<img>` directamente, usamos `<Image>` de Next.js. Le pasamos la imagen importada, un `alt` y las dimensiones deseadas. Next.js se encarga de la optimización.

#### 3. **Notas o advertencias:**

- **Optimización automática de imágenes:** `<Image>` optimiza las imágenes para diferentes tamaños de pantalla y formatos.
- **Previene layout shift:** Evita el "layout shift" reservando espacio para la imagen antes de que se cargue.
- **Formatos modernos:** Sirve imágenes en formatos WebP o AVIF si el navegador los soporta, que son más eficientes que JPEG o PNG.
- **Carga perezosa (lazy loading) por defecto:** Las imágenes con `<Image>` se cargan de forma perezosa por defecto, mejorando el rendimiento inicial de la página.

## U - Componente `<Script>`

#### 1. **Definición:**

Es un componente de Next.js para optimizar la carga de scripts de terceros (como scripts de analítica, widgets de redes sociales, etc.). Permite controlar cómo y cuándo se cargan estos scripts para evitar que bloqueen el hilo principal del navegador y afecten al rendimiento.

#### 2. **Ejemplo:**

```jsx
import Script from "next/script";

function MiComponente() {
  return (
    <div>
      {/* ... contenido de tu componente ... */}
      <Script
        src="https://widget-de-terceros.com/script.js"
        strategy="lazyOnload"
      />
    </div>
  );
}
```

**Explicación del ejemplo:**
Usamos `<Script>` para incluir un script de terceros. El atributo `strategy="lazyOnload"` indica que el script se cargará de forma perezosa, después de que la página principal se haya cargado.

#### 3. **Notas o advertencias:**

- **Estrategias de carga:** `<Script>` ofrece diferentes estrategias de carga (`beforeInteractive`, `lazyOnload`, `afterInteractive`) para controlar cuándo se ejecutan los scripts.
- **Evita bloquear el hilo principal:** Usar `<Script>` con estrategias de carga diferida ayuda a evitar que los scripts de terceros bloqueen el hilo principal del navegador y afecten al rendimiento de la página.
- **Optimización de scripts de terceros:** Esencial para optimizar el rendimiento cuando usas scripts de terceros en tu aplicación.

## V - ESLint y Accesibilidad

#### 1. **Definición:**

Utilizar ESLint (un linter de JavaScript) con el plugin `eslint-plugin-jsx-a11y` para detectar problemas de accesibilidad en tu código JSX durante el desarrollo.

#### 2. **Ejemplo:**

Asegúrate de tener ESLint configurado en tu proyecto Next.js (viene configurado por defecto). Instala el plugin de accesibilidad:

```bash
npm install eslint-plugin-jsx-a11y --save-dev
# o
yarn add eslint-plugin-jsx-a11y --dev
```

Y añade el plugin a tu configuración de ESLint (`.eslintrc.json` o similar):

```json
{
  "plugins": ["jsx-a11y"],
  "extends": [
    "plugin:jsx-a11y/recommended"
    // ... otras configuraciones ...
  ]
}
```

Ahora, ESLint te avisará de problemas de accesibilidad en tu código, como atributos `alt` faltantes en imágenes, problemas de contraste, etc.

#### 3. **Notas o advertencias:**

- **Accesibilidad temprana:** Detectar problemas de accesibilidad durante el desarrollo es mucho más fácil y barato que corregirlos después.
- **`eslint-plugin-jsx-a11y`:** Este plugin es muy útil para identificar problemas comunes de accesibilidad en JSX.
- **Mejora la accesibilidad de tu web:** Usar ESLint con este plugin te ayuda a crear aplicaciones web más accesibles para todos los usuarios, incluyendo personas con discapacidades.

## W - Tainting (Contaminación de Datos)

#### 1. **Definición:**

Es una técnica para marcar datos sensibles como "tainted" (contaminados) en el servidor. Esto ayuda a prevenir que datos sensibles se filtren accidentalmente al cliente (navegador del usuario).

#### 2. **Ejemplo:**

Imagina que tienes un objeto `usuario` con información sensible como su `passwordHash`.

```javascript
// En el servidor
const usuario = await obtenerUsuarioDeLaBaseDeDatos(userId);
// ...
// Quieres pasar 'usuario' a un componente, pero NO el passwordHash
taintObject(usuario, "No enviar passwordHash al cliente", ["passwordHash"]);
// ...
return <MiComponente usuario={usuario} />;
```

**Explicación del ejemplo:**
`taintObject` (o una función similar) marca el campo `passwordHash` del objeto `usuario` como "tainted". Si intentas enviar `usuario` al cliente (por ejemplo, como props de un Client Component), Next.js detectará que contiene datos "tainted" y puede prevenir la filtración (dependiendo de la configuración y el entorno).

#### 3. **Notas o advertencias:**

- **Seguridad de datos sensibles:** Tainting es una medida de seguridad adicional para proteger datos sensibles.
- **Prevención de filtraciones:** Ayuda a evitar que datos como contraseñas, tokens de API, etc., se envíen accidentalmente al cliente.
- **Herramienta avanzada:** Tainting es una técnica más avanzada y puede requerir configuración adicional.

## X - Server Actions y Autorización

#### 1. **Definición:**

Asegurarte de que los usuarios estén autorizados para llamar a Server Actions. Es decir, verificar que solo los usuarios permitidos puedan ejecutar ciertas acciones en el servidor.

#### 2. **Ejemplo:**

```javascript
// Server Action para borrar un producto (solo para administradores)
"use server";
import { auth } from "@/auth"; // Tu sistema de autenticación

export async function borrarProducto(productoId) {
  const session = await auth(); // Obtener la sesión del usuario
  if (!session?.user?.isAdmin) {
    // Verificar si es administrador
    throw new Error("No autorizado"); // Si no es admin, error
  }

  // ... lógica para borrar el producto (solo si es admin) ...
}
```

**Explicación del ejemplo:**
Antes de ejecutar la lógica para borrar el producto, la Server Action `borrarProducto` verifica si el usuario actual (obtenido de la sesión de autenticación) es administrador. Si no lo es, lanza un error de "No autorizado".

#### 3. **Notas o advertencias:**

- **Seguridad en Server Actions:** Es crucial implementar autorización en Server Actions para proteger acciones sensibles.
- **Verificación de roles/permisos:** Verifica los roles o permisos del usuario antes de ejecutar la lógica de la Server Action.
- **Prácticas de seguridad recomendadas:** Revisa las prácticas de seguridad recomendadas para Server Components y Server Actions de Next.js.

## Y - Variables de Entorno

#### 1. **Definición:**

Utilizar variables de entorno para configurar tu aplicación Next.js, especialmente para información sensible o que varía entre entornos (desarrollo, producción, etc.).

#### 2. **Ejemplo:**

Crea archivos `.env.local` (para desarrollo), `.env.production` (para producción), etc. Dentro de estos archivos, define tus variables:

```
# .env.local
DATABASE_URL=mongodb://localhost:27017/mi-db
API_KEY=clave-de-desarrollo
```

```
# .env.production
DATABASE_URL=mongodb+srv://... # URL de producción
API_KEY=clave-de-produccion
```

En tu código, accede a las variables con `process.env`:

```javascript
const databaseUrl = process.env.DATABASE_URL;
const apiKey = process.env.API_KEY;
```

#### 3. **Notas o advertencias:**

- **Seguridad y configuración:** Las variables de entorno son ideales para guardar información sensible (claves de API, URLs de bases de datos) y configuración que cambia entre entornos.
- **`.gitignore` para archivos `.env.*`:** Asegúrate de añadir tus archivos `.env.*` a `.gitignore` para no subirlos al repositorio (especialmente los de producción).
- **Prefijo `NEXT_PUBLIC_` para variables públicas:** Solo las variables que empiezan con `NEXT_PUBLIC_` estarán disponibles en el navegador. Usa este prefijo solo para variables que sean seguras para exponer en el cliente.

## Z - Content Security Policy (CSP)

#### 1. **Definición:**

Es una política de seguridad que puedes configurar en tu servidor web para ayudar a proteger tu aplicación contra ataques como Cross-Site Scripting (XSS), clickjacking y otros ataques de inyección de código.

#### 2. **Ejemplo:**

Puedes configurar la CSP en el encabezado HTTP de tus respuestas del servidor. Un ejemplo básico de CSP podría ser:

```
Content-Security-Policy: default-src 'self'; script-src 'self'; img-src 'self'; style-src 'self'
```

**Explicación del ejemplo:**
Esta CSP básica indica:

- `default-src 'self'`: Por defecto, solo cargar recursos desde el mismo origen (dominio) de tu web.
- `script-src 'self'`: Solo permitir la ejecución de scripts desde el mismo origen.
- `img-src 'self'`: Solo permitir la carga de imágenes desde el mismo origen.
- `style-src 'self'`: Solo permitir la carga de estilos desde el mismo origen.

Esto ayuda a prevenir que se carguen scripts, imágenes o estilos maliciosos desde fuentes externas no confiables.

#### 3. **Notas o advertencias:**

- **Seguridad contra ataques:** CSP es una herramienta importante para mejorar la seguridad de tu aplicación web.
- **Configuración compleja:** Configurar una CSP efectiva puede ser complejo y requiere entender bien las directivas y las necesidades de tu aplicación.
- **Pruebas:** Es importante probar tu CSP cuidadosamente para asegurarte de que no bloquea funcionalidades legítimas de tu web.

## AA - Metadata API y SEO

#### 1. **Definición:**

Utilizar la Metadata API de Next.js para mejorar el Search Engine Optimization (SEO) de tu aplicación. La Metadata API te permite definir títulos de página, descripciones, meta tags y otras informaciones que ayudan a los motores de búsqueda a entender y indexar tu contenido.

#### 2. **Ejemplo:**

Crea un archivo `metadata.js` (o `.ts`) en la carpeta de una ruta (ej. `app/blog/[slug]/metadata.js`):

```javascript
// app/blog/[slug]/metadata.js
export async function generateMetadata({ params }) {
  const post = await obtenerPostPorSlug(params.slug);
  return {
    title: post.titulo,
    description: post.resumen,
    openGraph: {
      title: post.titulo,
      description: post.resumen,
      images: [`/images/posts/${post.imagen}.jpg`],
    },
  };
}
```

**Explicación del ejemplo:**
`generateMetadata` es una función especial que Next.js usa para obtener los metadatos de la página. En este ejemplo, obtiene un post de blog y define el `title`, `description` y metadatos de Open Graph para la página del post.

#### 3. **Notas o advertencias:**

- **Mejora el SEO:** La Metadata API es fundamental para mejorar el SEO de tu aplicación Next.js.
- **Títulos, descripciones, meta tags:** Permite definir todos los metadatos importantes para SEO.
- **Dinámico y estático:** Puedes generar metadatos de forma estática (en build time) o dinámica (en cada petición).
- **Open Graph:** También puedes definir metadatos de Open Graph para redes sociales.

## AB - Imágenes Open Graph (OG)

#### 1. **Definición:**

Crear imágenes Open Graph (OG) para tus páginas web. Estas imágenes se muestran cuando se comparte un enlace de tu página en redes sociales como Facebook, Twitter, LinkedIn, etc., haciendo que los enlaces sean más atractivos y informativos.

#### 2. **Ejemplo:**

Puedes crear archivos `opengraph-image.js` (o `.ts`, `.jpg`, `.png`, `.svg`) en la carpeta de una ruta (ej. `app/blog/[slug]/opengraph-image.js`).

**Ejemplo con generación dinámica de imagen (usando `@vercel/og`):**

```javascript
// app/blog/[slug]/opengraph-image.js
import { ImageResponse } from "@vercel/og";

export const contentType = "image/png";
export const cache = "public";
export const fetchCache = "force-no-store";

export async function GET({ params }) {
  const post = await obtenerPostPorSlug(params.slug);

  return new ImageResponse(
    (
      <div
        style={
          {
            /* ... estilos para la imagen OG ... */
          }
        }
      >
        <h1>{post.titulo}</h1>
        <p>{post.resumen}</p>
      </div>
    ),
    {
      width: 1200,
      height: 630,
    }
  );
}
```

**Explicación del ejemplo:**
`opengraph-image.js` define una ruta que genera dinámicamente una imagen PNG para Open Graph. Usa la librería `@vercel/og` para crear la imagen con texto y estilos basados en los datos del post.

#### 3. **Notas o advertencias:**

- **Mejora el compartimiento en redes sociales:** Las imágenes OG hacen que tus enlaces se vean mucho mejor al compartirlos en redes sociales.
- **Tamaño recomendado:** El tamaño recomendado para imágenes OG suele ser 1200x630 píxeles.
- **Generación dinámica o estática:** Puedes generar imágenes OG de forma estática (archivos de imagen) o dinámica (con código).
- **Librerías como `@vercel/og`:** Librerías como `@vercel/og` facilitan la generación dinámica de imágenes OG.

## AC - Sitemaps y Robots

#### 1. **Definición:**

Generar sitemaps y archivos `robots.txt` para ayudar a los motores de búsqueda (como Google, Bing, etc.) a rastrear e indexar las páginas de tu aplicación web de forma eficiente.

#### 2. **Ejemplo:**

**Sitemap (ejemplo con generación dinámica en `sitemap.xml.js`):**

```javascript
// app/sitemap.xml.js
import { getServerSideSitemap } from "next-sitemap";
import { obtenerPosts } from "./utils/posts"; // Función para obtener posts

export async function GET(request) {
  const posts = await obtenerPosts();
  const fields = posts.map((post) => ({
    loc: `https://tu-dominio.com/blog/${post.slug}`,
    lastmod: new Date().toISOString(),
  }));

  return getServerSideSitemap(fields);
}
```

**Robots.txt (archivo estático `robots.txt` en `public/`):**

```
User-agent: *
Disallow: /privado/
Allow: /
Sitemap: https://tu-dominio.com/sitemap.xml
```

**Explicación del ejemplo:**

- **Sitemap:** `sitemap.xml.js` genera dinámicamente un sitemap XML con URLs de tus posts de blog. El sitemap ayuda a los motores de búsqueda a descubrir todas las páginas de tu web.
- **Robots.txt:** `robots.txt` es un archivo estático en `public/` que da instrucciones a los robots de los motores de búsqueda sobre qué partes de tu web pueden rastrear y cuáles no. En el ejemplo, se prohíbe rastrear `/privado/` y se permite el resto (`/`). También se indica la ubicación del sitemap.

#### 3. **Notas o advertencias:**

- **SEO:** Sitemaps y `robots.txt` son importantes para SEO.
- **Sitemap para indexación:** El sitemap ayuda a los motores de búsqueda a indexar todas tus páginas, especialmente si tienes muchas o si la estructura de tu web es compleja.
- **`robots.txt` para control de rastreo:** `robots.txt` te permite controlar qué partes de tu web quieres que rastreen los motores de búsqueda y cuáles no.
- **Librería `next-sitemap`:** La librería `next-sitemap` facilita la generación de sitemaps en Next.js.

## AD - TypeScript y TS Plugin

#### 1. **Definición:**

Utilizar TypeScript (un superset de JavaScript que añade tipado estático) y el TypeScript plugin de Next.js para mejorar la seguridad de tipos (type safety) en tu código y detectar errores en tiempo de desarrollo.

#### 2. **Ejemplo:**

**Ejemplo de código TypeScript:**

```typescript
interface Producto {
  id: number;
  nombre: string;
  precio: number;
}

async function obtenerProducto(id: number): Promise<Producto> {
  // ... lógica para obtener producto ...
}

function MostrarProducto(producto: Producto) {
  return (
    <div>
      <h1>{producto.nombre}</h1>
      <p>Precio: ${producto.precio}</p>
    </div>
  );
}
```

**Explicación del ejemplo:**
TypeScript añade tipos a JavaScript. En el ejemplo, se define una interfaz `Producto` para describir la estructura de un producto. La función `obtenerProducto` se declara que devuelve una `Promise<Producto>`, y `MostrarProducto` recibe un argumento de tipo `Producto`. TypeScript ayuda a detectar errores de tipo en tiempo de desarrollo.

#### 3. **Notas o advertencias:**

- **Seguridad de tipos:** TypeScript mejora la seguridad de tipos en tu código, ayudando a prevenir errores comunes.
- **Detección temprana de errores:** TypeScript te permite detectar errores de tipo durante el desarrollo, antes de que lleguen a producción.
- **Mejor refactorización y mantenimiento:** El tipado estático facilita la refactorización y el mantenimiento del código a largo plazo.
- **TS Plugin de Next.js:** El plugin de TypeScript de Next.js facilita la integración de TypeScript en proyectos Next.js.

## AE - Lighthouse

#### 1. **Definición:**

Utilizar Lighthouse, una herramienta de Google, para analizar el rendimiento de tu sitio web y obtener recomendaciones para mejorarlo. Lighthouse simula la experiencia de usuario y te da métricas como Core Web Vitals, rendimiento, accesibilidad, SEO y buenas prácticas.

#### 2. **Ejemplo:**

Puedes ejecutar Lighthouse en Chrome DevTools (pestaña "Lighthouse") o como una extensión de Chrome. También puedes usar la versión de línea de comandos o la API.

**Ejecutar Lighthouse en Chrome DevTools:**

1.  Abre Chrome DevTools (clic derecho en la página, "Inspeccionar" o F12).
2.  Ve a la pestaña "Lighthouse".
3.  Selecciona las categorías que quieres analizar (Performance, Accessibility, Best practices, SEO, PWA).
4.  Haz clic en "Generate report".

Lighthouse generará un informe con puntuaciones y recomendaciones para cada categoría.

#### 3. **Notas o advertencias:**

- **Análisis de rendimiento:** Lighthouse es una herramienta muy útil para analizar y mejorar el rendimiento de tu web.
- **Core Web Vitals:** Lighthouse incluye métricas de Core Web Vitals, que son importantes para la experiencia de usuario y el SEO.
- **Simulación, no datos reales:** Lighthouse es una simulación, no datos reales de usuarios. Es importante complementarlo con datos de campo (como Core Web Vitals reales).
- **Ejecutar en modo incógnito:** Para obtener resultados más precisos, ejecuta Lighthouse en modo incógnito para evitar interferencias de extensiones del navegador.

## AF - Hook `useReportWebVitals`

#### 1. **Definición:**

Utilizar el hook `useReportWebVitals` de Next.js para enviar datos de Core Web Vitals (métricas de rendimiento clave) a herramientas de analítica. Esto te permite monitorizar el rendimiento real de tu sitio web basado en la experiencia de usuarios reales.

#### 2. **Ejemplo:**

Crea un archivo `app/layout.js` (o `_document.js` en `pages`) y usa el hook `useReportWebVitals`:

```javascript
// app/layout.js
"use client"; // Debe ser Client Component para usar hooks
import { useReportWebVitals } from "next/web-vitals";

export default function RootLayout({ children }) {
  useReportWebVitals((metric) => {
    console.log("Métrica Web Vitals:", metric);
    // Aquí puedes enviar 'metric' a tu herramienta de analítica
    // ej. enviar a Google Analytics, Vercel Analytics, etc.
  });

  return (
    <html>
      <body>{children}</body>
    </html>
  );
}
```

**Explicación del ejemplo:**
`useReportWebVitals` es un hook que se ejecuta en el cliente y te da acceso a las métricas de Core Web Vitals (LCP, FID, CLS, etc.) cuando se miden en el navegador del usuario. En el ejemplo, se registra la métrica en la consola, pero normalmente la enviarías a una herramienta de analítica.

#### 3. **Notas o advertencias:**

- **Monitorización de rendimiento real:** `useReportWebVitals` te da datos de rendimiento reales de usuarios, a diferencia de las simulaciones de Lighthouse.
- **Core Web Vitals reales:** Obtén datos reales de LCP, FID, CLS y otras métricas importantes.
- **Integración con analítica:** Úsalo para enviar datos de rendimiento a tus herramientas de analítica (Google Analytics, Vercel Analytics, etc.) para monitorizar y mejorar el rendimiento de tu web en producción.
- **Client Component:** `useReportWebVitals` es un hook, por lo que debe usarse en un Client Component (añade `'use client'` al inicio del archivo).

## AG - Plugin `@next/bundle-analyzer`

#### 1. **Definición:**

Utilizar el plugin `@next/bundle-analyzer` para analizar el tamaño de los bundles (paquetes) de JavaScript de tu aplicación Next.js. Te ayuda a identificar módulos y dependencias grandes que pueden estar afectando al rendimiento de carga de tu página.

#### 2. **Ejemplo:**

1.  Instala el plugin:

    ```bash
    npm install @next/bundle-analyzer --save-dev
    # o
    yarn add @next/bundle-analyzer --dev
    ```

2.  Modifica tu archivo `next.config.js`:

    ```javascript
    // next.config.js
    const withBundleAnalyzer = require("@next/bundle-analyzer")({
      enabled: process.env.ANALYZE === "true", // Activar con variable de entorno ANALYZE=true
    });

    module.exports = withBundleAnalyzer({});
    ```

3.  Ejecuta el build de Next.js con la variable de entorno `ANALYZE=true`:

    ```bash
    ANALYZE=true npm run build
    # o
    ANALYZE=true yarn build
    ```

Después del build, el plugin abrirá una visualización interactiva en tu navegador que muestra el tamaño de los bundles y los módulos que los componen.

#### 3. **Notas o advertencias:**

- **Análisis de bundles:** `@next/bundle-analyzer` es una herramienta muy útil para entender qué está contribuyendo al tamaño de tus bundles de JavaScript.
- **Identificar módulos grandes:** Te ayuda a identificar dependencias o módulos grandes que podrías optimizar o eliminar.
- **Optimización del tamaño de bundles:** Reducir el tamaño de los bundles de JavaScript mejora el tiempo de carga de la página, especialmente en conexiones lentas o dispositivos móviles.
- **Visualización interactiva:** La visualización interactiva facilita la exploración de los bundles y la identificación de áreas de mejora.

## AH - Herramientas para Analizar Dependencias

#### 1. **Definición:**

Utilizar herramientas como "Import Cost", "Package Phobia", "Bundle Phobia" y "bundlejs" para entender el impacto de añadir nuevas dependencias a tu aplicación Next.js. Estas herramientas te ayudan a evaluar el tamaño, el coste de importación y otras características de las librerías de JavaScript antes de añadirlas a tu proyecto.

#### 2. **Ejemplos:**

- **Import Cost (extensión de VS Code):** Muestra el tamaño de las dependencias importadas directamente en tu editor de código.
- **Package Phobia (website):** Te dice el tamaño de una dependencia npm antes de instalarla.
- **Bundle Phobia (website):** Analiza el tamaño de una dependencia y sus dependencias en un bundle.
- **bundlejs (website):** Te permite crear bundles de prueba con diferentes dependencias y analizar su tamaño.

**Ejemplo de uso de Package Phobia:**

1.  Ve al sitio web de Package Phobia ([https://packagephobia.com/](https://packagephobia.com/)).
2.  Busca el nombre de la librería npm que estás considerando usar (ej. `lodash`).
3.  Package Phobia te mostrará información sobre el tamaño de la librería (tamaño instalado, tamaño minificado, tamaño gzip).

#### 3. **Notas o advertencias:**

- **Evaluar dependencias:** Estas herramientas te ayudan a tomar decisiones informadas sobre qué dependencias añadir a tu proyecto, considerando su impacto en el tamaño del bundle y el rendimiento.
- **Tamaño y coste de importación:** Te dan información sobre el tamaño de las dependencias y el "coste" de importarlas en tu aplicación.
- **Optimización de dependencias:** Usar estas herramientas te ayuda a mantener el tamaño de tu bundle lo más pequeño posible y a optimizar el uso de dependencias.

## AI - Analytics (Vercel)

#### 1. **Definición:**

Utilizar Vercel Analytics (si despliegas en Vercel) para monitorizar el tráfico de tu aplicación web. Vercel Analytics te proporciona un panel de control integrado con información sobre visitantes únicos, páginas vistas y otras métricas de tráfico.

#### 2. **Ejemplo:**

Si despliegas tu aplicación Next.js en Vercel, Vercel Analytics se activa automáticamente. Puedes acceder al panel de control de Analytics desde el dashboard de tu proyecto en Vercel.

El panel de Analytics te mostrará información como:

- **Unique Visitors:** Visitantes únicos a tu sitio web.
- **Page Views:** Número total de páginas vistas.
- **Visit Duration:** Duración media de las visitas.
- **Bounce Rate:** Porcentaje de visitantes que abandonan la página después de ver solo una página.
- **Top Pages:** Páginas más visitadas.
- **Referrers:** Fuentes de tráfico (de dónde vienen los visitantes).
- **Countries:** Países de origen de los visitantes.

#### 3. **Notas o advertencias:**

- **Monitorización de tráfico:** Vercel Analytics es una forma fácil de monitorizar el tráfico de tu web si usas Vercel.
- **Panel integrado:** El panel de Analytics está integrado directamente en el dashboard de Vercel.
- **Métricas clave:** Proporciona métricas clave para entender el tráfico y el comportamiento de los usuarios en tu web.
- **Específico de Vercel:** Vercel Analytics solo está disponible si despliegas tu aplicación en Vercel.

## AJ - Speed Insights (Vercel)

#### 1. **Definición:**

Utilizar Vercel Speed Insights (si despliegas en Vercel) para obtener información sobre el rendimiento real de tu sitio web basada en datos de visitantes reales. Speed Insights te da una visión práctica de cómo experimentan los usuarios tu web en términos de Core Web Vitals y otras métricas de rendimiento.

#### 2. **Ejemplo:**

Si despliegas tu aplicación Next.js en Vercel, Vercel Speed Insights se activa automáticamente (puedes necesitar habilitarlo en la configuración del proyecto). Puedes acceder al panel de Speed Insights desde el dashboard de tu proyecto en Vercel.

Speed Insights te muestra información como:

- **Core Web Vitals (LCP, FID, CLS):** Métricas de Core Web Vitals medidas en usuarios reales.
- **Performance Score:** Puntuación de rendimiento basada en Core Web Vitals.
- **Breakdown por métrica:** Detalle de cada métrica de Core Web Vitals (distribución, percentiles, etc.).
- **Breakdown por página:** Rendimiento por página individual.
- **Breakdown por dispositivo/navegador/país:** Rendimiento segmentado por diferentes dimensiones.
- **Recomendaciones de mejora:** Sugerencias para mejorar el rendimiento basadas en los datos de Speed Insights.

#### 3. **Notas o advertencias:**

- **Rendimiento real de usuarios:** Speed Insights te da datos de rendimiento basados en la experiencia real de usuarios, no simulaciones.
- **Core Web Vitals reales:** Monitoriza tus Core Web Vitals reales en producción.
- **Panel integrado en Vercel:** El panel de Speed Insights está integrado en el dashboard de Vercel.
- **Recomendaciones prácticas:** Ofrece recomendaciones prácticas para mejorar el rendimiento basadas en los datos.
- **Específico de Vercel:** Vercel Speed Insights solo está disponible si despliegas en Vercel.

## AK - Logging (Vercel)

#### 1. **Definición:**

Utilizar Logging (registro de logs) en Vercel (si despliegas en Vercel) para depurar problemas y monitorizar tu aplicación en producción. Vercel Logging te proporciona logs de runtime (logs de ejecución de tu código) y logs de actividad (logs de eventos de la plataforma Vercel).

#### 2. **Ejemplo:**

Si despliegas tu aplicación Next.js en Vercel, Vercel Logging está disponible automáticamente. Puedes acceder a los logs desde el dashboard de tu proyecto en Vercel, en la sección "Logs".

**Tipos de logs en Vercel Logging:**

- **Runtime Logs:** Logs generados por tu código de backend (Server Components, Route Handlers, API Routes, etc.). Puedes usar `console.log()`, `console.error()`, etc., en tu código y estos logs aparecerán en Vercel Logging.
- **Activity Logs:** Logs de eventos de la plataforma Vercel, como despliegues, escalado, errores de infraestructura, etc.

**Ejemplo de uso de Runtime Logs:**

```javascript
// app/api/mi-api/route.js
export async function GET() {
  console.log("Petición a /api/mi-api recibida"); // Log en Vercel Logging
  // ... lógica de la API ...
  return Response.json({ data: "ok" });
}
```

#### 3. **Notas o advertencias:**

- **Depuración y monitorización:** Vercel Logging es esencial para depurar problemas en producción y monitorizar el comportamiento de tu aplicación.
- **Runtime y Activity Logs:** Proporciona logs de ejecución de tu código y logs de la plataforma Vercel.
- **Panel integrado en Vercel:** Los logs se pueden ver directamente en el dashboard de Vercel.
- **Alternativas de terceros:** Si no usas Vercel, puedes usar herramientas de logging de terceros (como Sentry, Datadog, etc.).
- **Específico de Vercel:** Vercel Logging es específico de la plataforma Vercel.
