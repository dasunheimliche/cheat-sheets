## A - Fetching de Datos en el Servidor (Server Components)

#### 1. **DefiniciÃ³n:**

Es la forma **recomendada** de traer datos en Next.js. En lugar de pedirlos desde el navegador (cliente), los buscas directamente desde el servidor. Â¡Piensa en el servidor como el "backstage" de tu app, donde estÃ¡n los datos importantes!

#### 2. **Beneficios:**

- **Acceso Directo:** Puedes hablar directamente con bases de datos y otros recursos del backend. Â¡Como tener un acceso VIP a la informaciÃ³n!
- **Seguridad:** Las claves secretas y datos sensibles se quedan en el servidor, Â¡lejos de miradas indiscretas en el navegador! ğŸ”’
- **Eficiencia:** Traer y mostrar datos ocurre en el mismo lugar (el servidor). Menos viajes de ida y vuelta entre el navegador y el servidor, Â¡mÃ¡s rÃ¡pido todo! ğŸš€
- **Menos Espera:** Puedes hacer varias peticiones de datos a la vez en el servidor, en lugar de una por una desde el navegador. Â¡Como pedir varios platos a la vez en un restaurante! ğŸ½ï¸
- **Evita "Waterfalls":** Reduce las esperas innecesarias entre peticiones de datos. Â¡Fluye la informaciÃ³n como una cascada suave en lugar de un atasco! ğŸï¸
- **CercanÃ­a a los Datos:** Si tu servidor estÃ¡ cerca de donde se guardan los datos, Â¡la bÃºsqueda es aÃºn mÃ¡s rÃ¡pida! ğŸŒ

#### 3. **MutaciÃ³n de Datos:**

Para cambiar o actualizar datos, usa **Server Actions**. Â¡Son como "botones mÃ¡gicos" en el servidor que modifican la informaciÃ³n!

## B - Fetching de Datos Donde se Necesitan (Component-Level Fetching)

#### 1. **DefiniciÃ³n:**

En lugar de traer todos los datos al principio o pasarlos entre componentes como un "telÃ©fono roto", Â¡cada componente pide los datos que realmente necesita!

#### 2. **Â¿Por quÃ© es bueno?**

- **Simplicidad:** Cada componente es responsable de sus propios datos. Â¡MÃ¡s fÃ¡cil de entender y mantener! ğŸ§©
- **No te preocupes por repetir peticiones:** Si varios componentes necesitan los mismos datos (por ejemplo, la informaciÃ³n del usuario actual), `fetch` es inteligente y **recuerda** las peticiones anteriores. Â¡No pide lo mismo una y otra vez! ğŸ§  Esto se llama **memoizaciÃ³n de peticiones**.

#### 3. **Importante:**

Esto tambiÃ©n funciona genial en los **layouts** (la estructura base de tus pÃ¡ginas), Â¡incluso si no puedes pasar datos directamente de un layout padre a sus hijos!

## C - Streaming y Suspense

#### 1. **DefiniciÃ³n:**

Son "superpoderes" de React que hacen que tu pÃ¡gina web se cargue y se muestre **poco a poco**, como si fuera "transmitiÃ©ndose" en vivo. Â¡AsÃ­ la gente no tiene que esperar a que todo estÃ© listo para empezar a usar la pÃ¡gina! ğŸš€

#### 2. **Â¿CÃ³mo funciona?**

- **Carga Progresiva:** Primero se muestra lo que no necesita datos, y luego, mientras se cargan los datos, se muestra un **estado de carga** (como un "cargando..."). Â¡AsÃ­ la pÃ¡gina se siente mucho mÃ¡s rÃ¡pida! ğŸ’¨
- **Server Components + Layouts Anidados:** Con la combinaciÃ³n de Server Components y layouts dentro de layouts, puedes mostrar partes de la pÃ¡gina al instante y solo poner "cargando..." en las partes que faltan datos.

#### 3. **VisualizaciÃ³n:**

![Server Rendering with Streaming](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fserver-rendering-with-streaming.png&w=3840&q=75)![Server Rendering with Streaming](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fserver-rendering-with-streaming.png&w=3840&q=75)

#### 4. **MÃ¡s info:**

Si quieres saber mÃ¡s, mira las pÃ¡ginas de [Loading UI](https://nextjs.org/docs/14/app/building-your-application/routing/loading-ui-and-streaming) y [Streaming and Suspense](https://nextjs.org/docs/14/app/building-your-application/routing/loading-ui-and-streaming#streaming-with-suspense).

## D - Parallel vs Sequential Data Fetching (Fetching de Datos en Paralelo vs Secuencial)

#### 1. **DefiniciÃ³n:**

Cuando pides datos dentro de componentes, puedes hacerlo de dos maneras principales:

- **Secuencial (Uno tras otro):** Una peticiÃ³n de datos espera a que termine la anterior. Â¡Como una fila india! ğŸš¶â€â™‚ï¸ğŸš¶â€â™‚ï¸ğŸš¶â€â™‚ï¸
- **Paralelo (Todos a la vez):** Varias peticiones de datos se hacen al mismo tiempo. Â¡Como una carrera! ğŸƒâ€â™‚ï¸ğŸƒâ€â™‚ï¸ğŸƒâ€â™‚ï¸

#### 2. **VisualizaciÃ³n:**

![Sequential and Parallel Data Fetching](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fsequential-parallel-data-fetching.png&w=3840&q=75)![Sequential and Parallel Data Fetching](https://nextjs.org/_next/image?url=%2Fdocs%2Fdark%2Fsequential-parallel-data-fetching.png&w=3840&q=75)

#### 3. **Sequential Data Fetching (Fetching Secuencial):**

##### a. **DefiniciÃ³n:**

Si tienes componentes dentro de otros componentes, y cada uno pide sus propios datos, las peticiones se harÃ¡n **en orden**, una despuÃ©s de otra, si son datos diferentes. (Recuerda que si son los mismos datos, `fetch` los recuerda y no los pide de nuevo).

##### b. **Ejemplo:**

```typescript
// app/artist/[username]/page.tsx
async function Playlists({ artistID }: { artistID: string }) {
  // Espera a que lleguen las playlists
  const playlists = await getArtistPlaylists(artistID);

  return (
    <ul>
      {playlists.map((playlist) => (
        <li key={playlist.id}>{playlist.name}</li>
      ))}
    </ul>
  );
}

export default async function Page({
  params: { username },
}: {
  params: { username: string };
}) {
  // Espera a que llegue el artista
  const artist = await getArtist(username);

  return (
    <>
      <h1>{artist.name}</h1>
      <Suspense fallback={<div>Cargando...</div>}>
        <Playlists artistID={artist.id} />
      </Suspense>
    </>
  );
}
```

**ExplicaciÃ³n del ejemplo:**
AquÃ­, `Playlists` espera a que `Artist` termine de buscar los datos del artista (`artist`) porque necesita el `artistID`. Â¡Es como esperar el ingrediente principal antes de cocinar el plato! ğŸ²

##### c. **SoluciÃ³n:**

Usa [`loading.js`](https://nextjs.org/docs/14/app/building-your-application/routing/loading-ui-and-streaming) o [`<Suspense>`](https://react.dev/reference/react/Suspense) para mostrar un "cargando..." mientras llegan los datos. Â¡AsÃ­ la pÃ¡gina no se queda "congelada" esperando! ğŸ§Š

##### d. **Advertencia sobre "Blocking Data Requests":**

Traer todos los datos "de golpe" al principio puede hacer que la pÃ¡gina tarde mÃ¡s en mostrarse. Â¡Es como esperar a tener todos los ingredientes para empezar a cocinar, en lugar de ir preparando cosas mientras tanto! â³ Evita usar `await` sin `Suspense` o `loading.js` si no quieres bloquear la pÃ¡gina.

#### 4. **Parallel Data Fetching (Fetching en Paralelo):**

##### a. **DefiniciÃ³n:**

Para pedir datos en paralelo, inicia las peticiones **fuera** de los componentes y luego Ãºsalas dentro. Â¡AsÃ­ empiezan a buscar datos al mismo tiempo! ğŸš€

##### b. **Ejemplo:**

```typescript
// app/artist/[username]/page.tsx
import Albums from "./albums";

async function getArtist(username: string) {
  const res = await fetch(`https://api.example.com/artist/${username}`);
  return res.json();
}

async function getArtistAlbums(username: string) {
  const res = await fetch(`https://api.example.com/artist/${username}/albums`);
  return res.json();
}

export default async function Page({
  params: { username },
}: {
  params: { username: string };
}) {
  // Inicia ambas peticiones en paralelo
  const artistData = getArtist(username);
  const albumsData = getArtistAlbums(username);

  // Espera a que ambas promesas se resuelvan
  const [artist, albums] = await Promise.all([artistData, albumsData]);

  return (
    <>
      <h1>{artist.name}</h1>
      <Albums list={albums}></Albums>
    </>
  );
}
```

**ExplicaciÃ³n del ejemplo:**
AquÃ­, `getArtist` y `getArtistAlbums` se inician **antes** de que React espere los resultados con `Promise.all`. Â¡Es como pedir el plato principal y el postre al mismo tiempo! ğŸ°

##### c. **Mejora la experiencia:**

Usa [`Suspense Boundary`](https://nextjs.org/docs/14/app/building-your-application/routing/loading-ui-and-streaming) para mostrar partes de la pÃ¡gina antes, mientras se cargan los datos. Â¡AsÃ­ la gente ve algo rÃ¡pido y no espera en blanco! âœ¨

## E - Preloading Data (Precarga de Datos)

#### 1. **DefiniciÃ³n:**

Una forma aÃºn mejor de evitar "waterfalls" es **precargar** los datos. Es como "preparar los ingredientes" antes de que el componente los necesite. ğŸ§‘â€ğŸ³

#### 2. **Â¿CÃ³mo funciona?**

Crea una funciÃ³n `preload` (o como quieras llamarla) que inicie la peticiÃ³n de datos. Puedes llamarla antes de que el componente se muestre.

#### 3. **Ejemplo:**

```typescript
// components/Item.tsx
import { getItem } from "@/utils/get-item";

export const preload = (id: string) => {
  // void getItem(id)  <-  'void' simplemente ejecuta getItem(id) sin esperar el resultado.
  void getItem(id);
};
export default async function Item({ id }: { id: string }) {
  const result = await getItem(id);
  // ...
}
```

```typescript
// app/item/[id]/page.tsx
import Item, { preload, checkIsAvailable } from "@/components/Item";

export default async function Page({
  params: { id },
}: {
  params: { id: string };
}) {
  // Inicia la carga de datos del item
  preload(id);
  // Haz otra tarea asÃ­ncrona (que no depende de los datos del item)
  const isAvailable = await checkIsAvailable();

  return isAvailable ? <Item id={id} /> : null;
}
```

**ExplicaciÃ³n del ejemplo:**
En `page.tsx`, `preload(id)` empieza a buscar los datos del `Item` **antes** de que el componente `Item` se renderice. Mientras tanto, se ejecuta `checkIsAvailable()`. Â¡AsÃ­, cuando `Item` se muestra, los datos ya estÃ¡n casi listos! ğŸš€

## F - Usando React `cache`, `server-only` y Preload Pattern

#### 1. **DefiniciÃ³n:**

Combina estas herramientas para crear una forma **segura, eficiente y reutilizable** de traer datos en tu app.

- **`cache`:** FunciÃ³n de React que **guarda en memoria** los resultados de las peticiones. Si pides los mismos datos otra vez, te los da directamente de la memoria, Â¡sin volver a pedirlos al servidor! ğŸ§ 
- **`server-only`:** Paquete que asegura que ciertas funciones solo se ejecuten en el **servidor**, nunca en el navegador. Â¡Perfecto para proteger datos sensibles! ğŸ”’
- **Preload Pattern:** Ya lo vimos, para iniciar las peticiones de datos **antes** de que se necesiten.

#### 2. **Ejemplo:**

```typescript
// utils/get-item.ts
import { cache } from "react";
import "server-only";

export const preload = (id: string) => {
  void getItem(id);
};

export const getItem = cache(async (id: string) => {
  // ... (tu cÃ³digo para buscar el item)
});
```

**ExplicaciÃ³n del ejemplo:**
`getItem` usa `cache` para guardar los resultados y `server-only` para asegurar que solo se ejecuta en el servidor. `preload` inicia la peticiÃ³n. Â¡AsÃ­ tienes una utilidad para buscar items de forma rÃ¡pida, segura y reutilizable! ğŸ› ï¸

#### 3. **Importante:**

Usa el paquete [`server-only`](https://nextjs.org/docs/14/app/building-your-application/rendering/composition-patterns#keeping-server-only-code-out-of-the-client-environment) para proteger tus funciones de fetching de datos en el servidor.

## G - Previniendo la ExposiciÃ³n de Datos Sensibles al Cliente (Tainting)

#### 1. **DefiniciÃ³n:**

Usa las APIs de "tainting" de React (`taintObjectReference` y `taintUniqueValue`) para **marcar** datos sensibles y evitar que se pasen accidentalmente al navegador (cliente). Â¡Es como poner una etiqueta de "PELIGRO: SENSIBLE" a tus datos! âš ï¸

#### 2. **Â¿CÃ³mo activarlo?**

Activa la opciÃ³n `experimental.taint: true` en tu `next.config.js`:

```javascript
// next.config.js
module.exports = {
  experimental: {
    taint: true,
  },
};
```

#### 3. **Ejemplo:**

```typescript
// app/utils.ts
import { queryDataFromDB } from "./api";
import {
  experimental_taintObjectReference,
  experimental_taintUniqueValue,
} from "react";

export async function getUserData() {
  const data = await queryDataFromDB();
  experimental_taintObjectReference(
    "No pases el objeto completo de usuario al cliente",
    data
  );
  experimental_taintUniqueValue(
    "No pases la direcciÃ³n del usuario al cliente",
    data,
    data.address
  );
  return data;
}
```

```typescript
// app/page.tsx
import { getUserData } from "./data";

export async function Page() {
  const userData = getUserData();
  return (
    <ClientComponent
      user={userData} // Â¡Esto darÃ¡ error por taintObjectReference!
      address={userData.address} // Â¡Esto darÃ¡ error por taintUniqueValue!
    />
  );
}
```

**ExplicaciÃ³n del ejemplo:**
`taintObjectReference` marca el objeto `data` completo como "sensible". `taintUniqueValue` marca especÃ­ficamente la propiedad `address` dentro de `data`. Si intentas pasar `user` o `address` a un componente de cliente (`ClientComponent`), Â¡React te avisarÃ¡ con un error! ğŸš¨

#### 4. **MÃ¡s info:**

Lee sobre [Security and Server Actions](https://nextjs.org/blog/security-nextjs-server-components-actions) para saber mÃ¡s sobre seguridad.
