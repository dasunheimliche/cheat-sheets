### **Paso 0: √çndice de Conceptos a Explorar**

1.  **Pruebas con JUnit (JUnit Testing):** La idea general de por qu√© y c√≥mo usamos herramientas para probar nuestro c√≥digo.
2.  **Enfoque de Cobertura de C√≥digo (Code Coverage):** Una estrategia para asegurarnos de que nuestras pruebas "visitan" cada rinc√≥n de nuestro c√≥digo.
3.  **Pruebas Modulares (Modular Tests):** El arte de mantener las cosas simples y ordenadas, creando una prueba para cada peque√±a pieza de tu programa.
4.  **Pruebas de Getters y Setters:** C√≥mo verificar que los m√©todos que guardan y recuperan informaci√≥n funcionan como un reloj suizo.
5.  **Pruebas de Casos L√≠mite (Edge Cases):** El superpoder de pensar como un villano para encontrar las debilidades de tu c√≥digo antes de que alguien m√°s lo haga.
6.  **Pruebas Significativas (Meaningful Tests):** El principio de que cada prueba debe tener una misi√≥n clara y no ser solo "ruido".
7.  **Pruebas Independientes (Independent Tests):** La regla de oro para que tus pruebas no se pisen entre s√≠ y te den resultados fiables.

¬°Listo! Este es nuestro plan de ataque. Ahora, vamos a por el primer punto con toda la energ√≠a. ¬°Empezamos!

---

## A - Pruebas con JUnit: Tu Red de Seguridad Personal üî¥

#### 1. **Introducci√≥n:**

JUnit es una herramienta (un "framework") que te permite escribir y ejecutar pruebas autom√°ticas para tu c√≥digo Java, ayud√°ndote a encontrar y aplastar "bugs" (errores) antes de que causen problemas.

#### 2. **Ejemplo:**

Imagina que tienes una clase `Calculadora` muy simple:

```java
// El c√≥digo que quieres probar
public class Calculadora {
    public int sumar(int a, int b) {
        return a + b;
    }
}
```

Ahora, escribes una "clase de prueba" para verificar que funciona:

```java
// Tu prueba con JUnit
import static org.junit.Assert.assertEquals;
import org.junit.Test;

public class CalculadoraTest {
    @Test
    public void testSumar() {
        Calculadora miCalculadora = new Calculadora();
        int resultado = miCalculadora.sumar(2, 3);
        // Verificamos si el resultado es 5, como esperamos.
        assertEquals(5, resultado);
    }
}
```

**Explicaci√≥n del ejemplo:**
Aqu√≠, `CalculadoraTest` es tu detective. El m√©todo `testSumar` crea una `Calculadora`, llama al m√©todo `sumar` con `2` y `3`, y luego usa `assertEquals` para comprobar si el resultado es `5`. Si es `5`, la prueba pasa (¬°luz verde!). Si no, la prueba falla (¬°luz roja!), y JUnit te avisa de que algo anda mal en tu m√©todo `sumar`. ¬°As√≠ de simple!

#### 3. **Desarrollo**:

Piensa en las pruebas como una red de seguridad cuando caminas por la cuerda floja de la programaci√≥n. Cada vez que cambias algo en tu c√≥digo, puedes ejecutar tus pruebas para asegurarte de que no rompiste nada sin querer. El texto lo dice claro: "errar es humano", y cometer errores es parte del proceso. JUnit no evita que cometas errores, pero te ayuda a encontrarlos de forma r√°pida y sistem√°tica. Es una pr√°ctica fundamental en el desarrollo de software moderno.

üî¥ **Fundamental**: No puedes considerarte un programador serio de Java si no sabes c√≥mo probar tu propio c√≥digo. Es como ser un chef que nunca prueba su propia comida. Aprender a usar JUnit (o un framework similar) es un paso esencial e innegociable en tu formaci√≥n.

## B - Cobertura de C√≥digo: No Dejes Ninguna Piedra sin Mover üü°

#### 1. **Introducci√≥n:**

La cobertura de c√≥digo es una m√©trica que te dice qu√© porcentaje de tu c√≥digo es "tocado" o ejecutado por tus pruebas.

#### 2. **Ejemplo:**

Imagina este m√©todo en una clase `Termostato`:

```java
public String getEstado(int temperatura) {
    if (temperatura < 18) {
        return "Frio"; // L√≠nea A
    } else {
        return "Agradable"; // L√≠nea B
    }
}
```

Y tienes esta prueba:

```java
@Test
public void testEstadoFrio() {
    Termostato term = new Termostato();
    assertEquals("Frio", term.getEstado(10));
}
```

**Explicaci√≥n del ejemplo:**
Esta prueba solo ejecuta la **L√≠nea A** del m√©todo `getEstado` porque le pasamos una temperatura de `10`. Nunca llega a la **L√≠nea B**. Por lo tanto, tu cobertura de c√≥digo para este m√©todo es solo del 50%. Para alcanzar el 100%, necesitar√≠as otra prueba que verifique el caso "Agradable", por ejemplo, con una temperatura de `22`.

#### 3. **Desarrollo**:

El objetivo de la cobertura de c√≥digo es simple: si una l√≠nea de tu c√≥digo nunca se ejecuta durante las pruebas, ¬øc√≥mo puedes estar seguro de que funciona correctamente? Es como revisar una casa para ver si hay goteras, pero solo miras la sala y te olvidas de los dormitorios y la cocina. Una alta cobertura (cercana al 100%) te da una buena indicaci√≥n (¬°ojo, no una garant√≠a absoluta!) de que has probado la mayor√≠a de los caminos posibles en tu programa.

üü° **Importante**: Aunque buscar un 100% de cobertura puede ser a veces poco pr√°ctico, entender este concepto te obliga a pensar en todos los posibles flujos de tu programa. Es una gu√≠a excelente para escribir pruebas m√°s completas y no dejar partes de tu l√≥gica a la suerte.

## C - Pruebas Modulares: Un Detective para Cada Sospechoso üü°

#### 1. **Introducci√≥n:**

Las pruebas modulares consisten en crear un m√©todo de prueba espec√≠fico y aislado para cada m√©todo de la clase que est√°s probando.

#### 2. **Ejemplo:**

Siguiendo el ejemplo del texto, si tienes una clase `Human`:

```java
public class Human {
    private String name;
    private int weight;

    public void setName(String name) { this.name = name; }
    public String getName() { return this.name; }
    public void setWeight(int weight) { this.weight = weight; }
    public int getWeight() { return this.weight; }
}
```

Una buena pr√°ctica de pruebas modulares ser√≠a tener una clase `HumanTest` as√≠:

```java
public class HumanTest {
    @Test
    public void testName() { // Prueba SOLO lo relacionado con el nombre
        Human person = new Human();
        person.setName("Ana");
        assertEquals("Ana", person.getName());
    }

    @Test
    public void testWeight() { // Prueba SOLO lo relacionado con el peso
        Human person = new Human();
        person.setWeight(60);
        assertEquals(60, person.getWeight());
    }
}
```

**Explicaci√≥n del ejemplo:**
F√≠jate bien: `testName` se enfoca _√∫nicamente_ en `setName` y `getName`. `testWeight` se enfoca _√∫nicamente_ en `setWeight` y `getWeight`. No mezclamos las cosas. Si la prueba `testWeight` falla, sabes inmediatamente que el problema est√° en los m√©todos del peso, no tienes que adivinar si el error vino de la l√≥gica del nombre.

#### 3. **Desarrollo**:

¬øPor qu√© esta obsesi√≥n con separar todo? ¬°Claridad! Cuando una prueba falla, quieres saber _exactamente_ qu√© se rompi√≥ y d√≥nde. Si metes 10 comprobaciones de 5 m√©todos distintos en una sola prueba, y esta falla, tendr√°s que investigar cu√°l de las 10 fue la culpable. Es ineficiente y confuso. Al mantener tus pruebas modulares, cada fallo apunta con un l√°ser directamente a la parte del c√≥digo que tiene el problema.

üü° **Importante**: Esta es una de las mejores pr√°cticas m√°s recomendadas. Te ahorra tiempo, reduce la frustraci√≥n y hace que tu conjunto de pruebas sea mucho m√°s f√°cil de leer y mantener. ¬°Hazle caso a tu yo del futuro y s√© modular!

## D - Pruebas de Getters y Setters: Verificando al Guardi√°n de los Datos üîµ

#### 1. **Introducci√≥n:**

Este es un tipo espec√≠fico de prueba modular enfocada en verificar que los m√©todos para establecer (`set`) y obtener (`get`) un valor funcionan correctamente.

#### 2. **Ejemplo:**

Usando la misma clase `Human` de antes, vamos a probar el `setter` y `getter` del nombre:

```java
@Test
public void testName() {
    Human persona = new Human();
    String nombreEsperado = "Carlos";

    // 1. Usamos el 'setter' para guardar el nombre
    persona.setName(nombreEsperado);

    // 2. Usamos el 'getter' para recuperarlo
    String nombreObtenido = persona.getName();

    // 3. Comparamos si lo que recuperamos es lo mismo que guardamos
    assertEquals(nombreEsperado, nombreObtenido);
}
```

**Explicaci√≥n del ejemplo:**
El flujo es muy simple pero poderoso: guardas un valor (`"Carlos"`) usando `setName`, lo recuperas usando `getName`, y luego verificas que el valor recuperado es id√©ntico al que guardaste. Parece obvio, ¬øverdad? Pero esta simple prueba te protege de errores tontos, como un error de tipeo dentro del m√©todo (`this.nane = name;`) que podr√≠a pasar desapercibido.

#### 3. **Desarrollo**:

Aunque los getters y setters suelen ser muy simples (una sola l√≠nea de c√≥digo), ¬°no te conf√≠es! A veces pueden tener l√≥gica adicional (por ejemplo, un `setter` que convierte el texto a may√∫sculas antes de guardarlo). Probarlos te asegura que cumplen su contrato: "lo que guardo es lo que obtengo". Adem√°s, como menciona el texto, te obliga a pensar en qu√© pasa si intentas "abusar" de ellos. Esto nos lleva directamente al siguiente concepto...

üîµ **Espec√≠fico**: Es un tipo de prueba muy com√∫n y una buena pr√°ctica, pero su complejidad depende de la l√≥gica interna de los getters/setters. Si son extremadamente simples, algunos programadores consideran estas pruebas opcionales, aunque para un principiante es una excelente forma de practicar.

## E - Pruebas de Casos L√≠mite: Pensando en los Extremos üî¥

#### 1. **Introducci√≥n:**

Los casos l√≠mite (o "edge cases") son pruebas que usan valores extremos, inusuales o inesperados para ver si tu c√≥digo se rompe o se comporta de forma extra√±a.

#### 2. **Ejemplo:**

Volvamos al `setWeight` de nuestra clase `Human`. ¬øQu√© pasar√≠a si alguien intenta poner un peso negativo o un nombre nulo (`null`)? ¬°Debemos probarlo!

```java
@Test
public void testWeight_NegativeValue() {
    Human persona = new Human();
    // ¬øQu√© deber√≠a pasar si le damos un peso negativo?
    // ¬øDeber√≠a ignorarlo? ¬øLanzar un error? ¬øPonerlo en 0?
    // Supongamos que nuestra regla es que no debe cambiar el peso si es negativo.
    persona.setWeight(70); // Peso inicial
    persona.setWeight(-10); // Intentamos poner un peso inv√°lido
    assertEquals(70, persona.getWeight()); // Verificamos que el peso no cambi√≥
}

@Test
public void testName_NullValue() {
    Human persona = new Human();
    // ¬øQu√© pasa si le pasamos 'null' como nombre?
    persona.setName(null);
    // Quiz√°s no deber√≠a ser null, sino una cadena vac√≠a ""
    assertNotNull(persona.getName()); // Verificamos que el nombre no es null
}
```

**Explicaci√≥n del ejemplo:**
En lugar de probar con un valor normal como `60`, probamos con `-10`, un valor que no tiene sentido en el mundo real para el peso. Tambi√©n probamos con `null` para el nombre. Estas no son operaciones "comunes", son precisamente los casos que un usuario (o otro programador) podr√≠a intentar por error y que podr√≠an hacer que tu programa falle estrepitosamente si no los has previsto.

#### 3. **Desarrollo**:

Aqu√≠ es donde te pones el sombrero de "hacker" (en el buen sentido). Tu misi√≥n es intentar romper tu propio c√≥digo. Piensa en los l√≠mites:

- **N√∫meros:** ¬øQu√© pasa con el 0, n√∫meros negativos, el n√∫mero m√°s grande o m√°s peque√±o posible?
- **Texto:** ¬øQu√© pasa con una cadena vac√≠a (`""`), un `null`, o un texto con caracteres extra√±os (`@#‚Ç¨%&`)?
- **Listas/Arrays:** ¬øQu√© pasa si est√°n vac√≠os, o si tienen un solo elemento?

Probar estos casos l√≠mite es lo que diferencia un c√≥digo fr√°gil de uno robusto y fiable. Un buen programador no solo se asegura de que el c√≥digo funcione en el "camino feliz", sino tambi√©n de que no se desmorone cuando las cosas se ponen raras.

üî¥ **Fundamental**: Ignorar los casos l√≠mite es una de las principales fuentes de bugs en el software. Es una habilidad cr√≠tica que debes desarrollar. Siempre preg√∫ntate: "¬øCu√°l es la forma m√°s extra√±a en que alguien podr√≠a usar este m√©todo?" y luego, ¬°escribe una prueba para ello!

## F - Pruebas Significativas: Calidad sobre Cantidad üü°

#### 1. **Introducci√≥n:**

Este principio dicta que tus pruebas deben ser dise√±adas con un prop√≥sito claro (probar condiciones comunes y casos l√≠mite), en lugar de simplemente ejecutar c√≥digo con valores aleatorios sin un objetivo.

#### 2. **Ejemplo:**

Imagina que est√°s probando el m√©todo `getEstado(temperatura)` de antes.

**Prueba POCO significativa (mala):**

```java
@Test
public void testEstadoRandom() {
    Termostato term = new Termostato();
    term.getEstado(20); // ¬øPor qu√© 20?
    term.getEstado(21); // ¬øY 21?
    term.getEstado(22); // ¬øY 22?
    // No hay una estrategia clara, solo se ejecutan valores.
    // Adem√°s, no se comprueba el resultado con assertEquals!
}
```

**Pruebas MUY significativas (buenas):**

```java
@Test
public void testEstado_JustoEnElLimiteFrio() {
    Termostato term = new Termostato();
    // 17 es el √∫ltimo n√∫mero entero que deber√≠a dar "Frio"
    assertEquals("Frio", term.getEstado(17));
}

@Test
public void testEstado_JustoEnElLimiteAgradable() {
    Termostato term = new Termostato();
    // 18 es el primer n√∫mero que deber√≠a dar "Agradable"
    assertEquals("Agradable", term.getEstado(18));
}
```

**Explicaci√≥n del ejemplo:**
La primera prueba es d√©bil. Simplemente llama al m√©todo con n√∫meros al azar. Las segundas pruebas son potentes y significativas. No eligen cualquier n√∫mero, eligen los n√∫meros _exactos_ donde el comportamiento del c√≥digo cambia (el l√≠mite entre `17` y `18`). Estas pruebas tienen una misi√≥n clara: verificar que la transici√≥n entre "Frio" y "Agradable" ocurra precisamente donde debe.

#### 3. **Desarrollo**:

No se trata de tener 500 pruebas que hacen lo mismo con peque√±as variaciones. Se trata de tener un conjunto m√°s peque√±o de pruebas inteligentes y bien dise√±adas que cubran los puntos cr√≠ticos de tu l√≥gica. Cada prueba debe responder a una pregunta: "¬øQu√© estoy tratando de verificar exactamente con este caso?". Si no puedes responder a esa pregunta, es probable que tu prueba no sea muy √∫til. ¬°Recuerda, calidad sobre cantidad!

üü° **Importante**: Este es un principio que te ahorrar√° much√≠simo tiempo. Escribir pruebas sin sentido es una p√©rdida de esfuerzo. Escribir pruebas significativas te da confianza real en tu c√≥digo y hace que el proceso de testing sea mucho m√°s efectivo.

## G - Pruebas Independientes: Cada Prueba en su Propio Mundo üîµ

#### 1. **Introducci√≥n:**

Una prueba independiente es aquella cuyo resultado no se ve afectado por otras pruebas, ni afecta a otras pruebas; puede ejecutarse en cualquier orden y siempre producir√° el mismo resultado.

#### 2. **Ejemplo:**

**Mal dise√±o (pruebas dependientes):**

```java
public class CarritoCompraTest {
    private static Carrito carrito = new Carrito(); // Un solo carrito para todas las pruebas

    @Test
    public void testAgregarProducto() {
        carrito.agregar("Manzana");
        assertEquals(1, carrito.getTotalItems()); // Pasa
    }

    @Test
    public void testVaciarCarrito() {
        // Esta prueba depende de que la anterior haya agregado algo
        carrito.vaciar();
        assertEquals(0, carrito.getTotalItems()); // Pasa
    }
}
```

**Problema:** Si ejecutas `testVaciarCarrito` _antes_ que `testAgregarProducto`, ¬°fallar√°! Porque el carrito ya estar√≠a vac√≠o. Su √©xito depende del orden.

**Buen dise√±o (pruebas independientes):**

```java
public class CarritoCompraTest {
    @Test
    public void testAgregarProducto() {
        Carrito carrito = new Carrito(); // ¬°Nuevo carrito para esta prueba!
        carrito.agregar("Manzana");
        assertEquals(1, carrito.getTotalItems());
    }

    @Test
    public void testVaciarCarrito() {
        Carrito carrito = new Carrito(); // ¬°Otro nuevo carrito para esta prueba!
        carrito.agregar("Pera"); // Preparamos el escenario
        carrito.vaciar();
        assertEquals(0, carrito.getTotalItems());
    }
}
```

**Explicaci√≥n del ejemplo:**
En el buen dise√±o, cada m√©todo de prueba crea su propio objeto `Carrito`. `testAgregarProducto` vive en su propio universo, y `testVaciarCarrito` en el suyo. No se conocen, no se afectan. Puedes ejecutarlos en el orden que quieras, un mill√≥n de veces, y el resultado ser√° siempre el mismo.

#### 3. **Desarrollo**:

La dependencia entre pruebas es una pesadilla. Genera resultados inconsistentes ("a veces pasa, a veces no") que son incre√≠blemente dif√≠ciles de depurar. La regla de oro es: cada prueba debe ser responsable de crear su propio estado inicial y no dejar "basura" para la siguiente. La mayor√≠a de los frameworks de testing, como JUnit, proporcionan herramientas (como los m√©todos `@BeforeEach`) para ayudarte a configurar un estado limpio antes de cada prueba, garantizando as√≠ su independencia.

üîµ **Espec√≠fico**: Aunque el concepto es fundamental para pruebas fiables, los principiantes a menudo caen en esta trampa sin darse cuenta, especialmente cuando usan variables est√°ticas o miembros de la clase de prueba. Es un concepto espec√≠fico que se vuelve m√°s evidente y crucial a medida que tus conjuntos de pruebas crecen en tama√±o y complejidad.
