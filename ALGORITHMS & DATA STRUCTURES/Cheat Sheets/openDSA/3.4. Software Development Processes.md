## A - Proceso de Desarrollo de Software (Software Development Process)

#### 1. **Definición:**

Un **proceso de desarrollo de software** es como dividir un proyecto grande en etapas más pequeñas y manejables. Imagina construir una casa: no empiezas por el tejado, ¿verdad? Primero los cimientos, luego las paredes, y así sucesivamente. Cada etapa tiene actividades específicas para planificar y controlar el progreso del proyecto.

En inglés se conoce como **Software Development Process**.

#### 2. **Ejemplo:**

Piensa en hacer una app para pedir comida. Podrías dividir el proceso en:

1.  **Planificación:** Decidir qué funcionalidades tendrá la app (pedir, pagar, etc.).
2.  **Diseño:** Crear cómo se verá la app y cómo funcionará.
3.  **Desarrollo:** Escribir el código de la app.
4.  **Pruebas:** Asegurarse de que la app funciona sin errores.
5.  **Entrega:** Lanzar la app para que la gente la use.

**Explicación del ejemplo:**
Cada uno de estos pasos es una etapa del proceso de desarrollo. Dividir el trabajo así nos ayuda a organizarnos y a que todo salga mejor.

#### 3. **Notas o advertencias:**

- Hay muchísimos procesos diferentes, ¡pero no te agobies! La idea principal es organizar el trabajo.
- El objetivo de usar un proceso es mejorar la calidad del software, reducir costes y cumplir con los plazos. ¡Ojalá siempre funcione!

## B - Planificar, Hacer, Verificar, Actuar (Plan-Do-Check-Act)

#### 1. **Definición:**

Este es el esquema básico detrás de casi todos los procesos de desarrollo de software. Es un ciclo simple pero poderoso:

1.  **Planificar (Plan):** Decidir qué se va a hacer y cómo.
2.  **Hacer (Do):** Poner manos a la obra y desarrollar el software.
3.  **Verificar (Check):** Revisar si lo que se hizo está funcionando como se esperaba y si cumple con los objetivos.
4.  **Actuar (Act):** Si hay problemas o mejoras, actuar para corregirlos y mejorar el proceso para el futuro.

Este ciclo **Plan-Do-Check-Act** es la base de muchos procesos, desde los más antiguos hasta los más modernos.

#### 2. **Ejemplo:**

Imagina que estás cocinando una nueva receta:

1.  **Planificar:** Lees la receta y planeas los pasos.
2.  **Hacer:** Cocinas siguiendo la receta.
3.  **Verificar:** Pruebas la comida para ver si está rica y bien hecha.
4.  **Actuar:** Si le falta sal, añades más. Si quedó muy picante, lo ajustas para la próxima vez.

**Explicación del ejemplo:**
Este ciclo te ayuda a mejorar continuamente, tanto en la cocina como en el desarrollo de software.

#### 3. **Notas o advertencias:**

- Este ciclo es súper antiguo, ¡de 1620! Francis Bacon ya lo describió. ¡La base de todo está inventada hace siglos!
- Todos los procesos de desarrollo son variaciones de este ciclo, con más o menos detalle.

## C - Procesos Dirigidos por Plan vs. Ágiles (Plan Driven vs. Agile)

#### 1. **Definición:**

Hoy en día, los procesos de desarrollo se dividen en dos grandes grupos:

1.  **Dirigidos por Plan (Plan Driven):** Se planifica todo al detalle al principio. Se intenta seguir el plan al pie de la letra. Son más "rígidos" pero buscan ser predecibles. Surgieron en los años 60.
2.  **Ágiles (Agile):** Se adaptan a los cambios rápidamente. Se valora más la flexibilidad y la colaboración. Son más "flexibles" y se adaptan mejor a entornos cambiantes. Surgieron en los años 90.

**En inglés:** **Plan Driven** y **Agile**.

#### 2. **Ejemplo:**

- **Dirigido por Plan:** Imagina construir un puente. Necesitas planos detallados, permisos, y seguir un plan estricto para que sea seguro y funcional.
- **Ágil:** Imagina crear una app nueva que nadie ha hecho antes. Empiezas con una idea básica, la desarrollas un poco, la pruebas con usuarios, y la vas cambiando según lo que aprendes.

**Explicación del ejemplo:**
Un puente necesita mucha planificación previa, mientras que una app nueva necesita adaptarse a medida que se desarrolla.

#### 3. **Notas o advertencias:**

- No hay uno mejor que otro, ¡depende del proyecto!
- A veces se mezclan ideas de ambos tipos de procesos. No todo es blanco o negro.
- Hay mitos sobre ambos tipos de procesos, ¡vamos a verlos!

## D - Mitos de los Procesos Dirigidos por Plan

#### 1. **Definición:**

Hay ideas equivocadas sobre los procesos dirigidos por plan. Algunos mitos comunes son:

1.  **"No se adaptan al cambio":** Se cree que son demasiado rígidos para cambiar de rumbo si es necesario.
2.  **"Son muy complejos":** Se piensa que son procesos enormes y difíciles de manejar.
3.  **"Son más caros":** Se asume que por la planificación inicial, terminan costando más.
4.  **"Solo para empresas grandes":** Se cree que solo las grandes organizaciones los pueden usar.
5.  **"Son antiguos":** Se les ve como métodos del pasado, obsoletos.
6.  **"Sirven para todo":** El mito de que un proceso específico (proceso X) mejora la predictibilidad y por lo tanto todos deberían usarlo.

#### 2. **Ejemplo:**

Imagina que planeas un viaje por carretera con todo reservado y detallado. Un mito sería pensar que si cambia el clima o encuentras un lugar inesperado que te gusta, no puedes desviarte del plan.

**Explicación del ejemplo:**
Aunque los procesos dirigidos por plan buscan la predictibilidad, no significa que sean totalmente inflexibles.

#### 3. **Notas o advertencias:**

- Estos son **mitos**, ¡no realidades! Los procesos dirigidos por plan tienen sus ventajas en ciertos contextos.
- No hay que creer todo lo que se dice, ¡hay que informarse bien!

## E - Mitos de los Procesos Ágiles

#### 1. **Definición:**

También hay ideas equivocadas sobre los procesos ágiles. Algunos mitos comunes son:

1.  **"Ágil es igual a 'hackear'":** Se piensa que es programar sin orden ni concierto, "a lo loco".
2.  **"Es la 'bala de plata'":** El mito de que es la solución mágica para todos los problemas, fácil de implementar y súper efectivo.
3.  **"Haz lo que quieras":** Se cree que no hay compromisos de tiempo ni coste, que todo vale.
4.  **"Incompatible con procesos tradicionales":** Se piensa que no se puede combinar con métodos más formales.
5.  **"Sin documentación, arquitectura ni planificación":** El mito de que en ágil no se planifica ni se documenta nada.
6.  **"No apto para proyectos de precio fijo":** Se cree que no se pueden usar en proyectos con presupuesto cerrado.
7.  **"Sirve para todo":** El mito de que como la tecnología cambia rápido, los métodos ágiles son la respuesta universal y dominarán el mundo IT.

#### 2. **Ejemplo:**

Imagina un equipo ágil creando una app. Un mito sería pensar que pueden cambiar de idea cada día sin consecuencias, sin planificar nada y sin preocuparse por el presupuesto.

**Explicación del ejemplo:**
Aunque los procesos ágiles son flexibles, no significa que sean caóticos o sin control.

#### 3. **Notas o advertencias:**

- ¡Ojo con estos **mitos** también! Los procesos ágiles tienen sus reglas y principios.
- No hay que caer en extremos, ¡la realidad es más compleja!

## F - El Continuo Ágil-Planificado (Agile-Plan-Driven Continuum)

#### 1. **Definición:**

En realidad, no es "o ágil o planificado", sino más bien un **continuo**. Los procesos se sitúan en algún punto entre dos extremos:

- **Un extremo:** Máxima disposición a **cambiar** y adaptarse (Agilidad).
- **Otro extremo:** Máxima importancia a la **planificación inicial** y seguir el plan (Planificación).

Ningún proceso es 100% puro en un extremo u otro.

#### 2. **Imagen:**

![_images/BackProcess-continuum.png](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_images/BackProcess-continuum.png)

**Explicación de la imagen:**
La línea representa el continuo. A la izquierda, más ágil; a la derecha, más planificado. Los procesos se ubican en diferentes puntos de esta línea.

#### 3. **Notas o advertencias:**

- Piensa en los procesos como un espectro, no como categorías separadas.
- La clave está en encontrar el **equilibrio** adecuado para cada proyecto.

## G - Cuándo usar Ágil vs. Planificado (Agile vs. Plan-Driven Sweet Spot)

#### 1. **Definición:**

Cada enfoque tiene situaciones donde funciona mejor. Aquí tienes un resumen:

| Característica | Ágil                                                 | Planificado                                           |
| :------------- | :--------------------------------------------------- | :---------------------------------------------------- |
| **Objetivos**  | Valor rápido, adaptarse al cambio                    | Previsibilidad, estabilidad, alta calidad             |
| **Tamaño**     | Equipos y proyectos pequeños                         | Equipos y proyectos grandes                           |
| **Entorno**    | Cambiante, enfocado en el proyecto                   | Estable, enfocado en la organización                  |
| **Requisitos** | Historias de usuario, cambio rápido esperado         | Especificaciones formales, cambio gradual esperado    |
| **Desarrollo** | Diseño simple, ciclos cortos, refactorización barata | Arquitectura y diseño detallado, refactorización cara |
| **Pruebas**    | Pruebas automáticas validan requisitos               | Planes de prueba documentados validan requisitos      |

#### 2. **Ejemplo:**

- **Ágil:** Ideal para startups que necesitan lanzar productos rápido y adaptarse a lo que el mercado demanda.
- **Planificado:** Mejor para proyectos grandes y complejos como sistemas bancarios o software médico, donde la fiabilidad y la planificación son cruciales.

**Explicación del ejemplo:**
La elección depende de las necesidades y el contexto del proyecto.

#### 3. **Notas o advertencias:**

- **Scrum** es solo para gestión de proyectos, no un proceso de desarrollo completo.
- **CMMI** es para mejorar procesos, no una metodología en sí, ¡pero a veces se confunde!
- ¡No hay una receta única! Cada proyecto es un mundo.

## H - Gráfico Radar Ágil vs. Planificado (Agile vs. Plan-Driven Radar Chart)

#### 1. **Definición:**

Este gráfico visualiza las ventajas de cada enfoque en diferentes aspectos:

#### 2. **Imagen:**

![_images/BackProcess-radar-chart.png](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_images/BackProcess-radar-chart.png)

**Explicación de la imagen:**
El gráfico muestra cómo se comparan Agile y Plan-Driven en diferentes dimensiones como "Adaptabilidad", "Previsibilidad", "Riesgo", etc. Ayuda a visualizar dónde destaca cada enfoque.

#### 3. **Notas o advertencias:**

- Este gráfico es una guía visual para entender las diferencias.
- La decisión final siempre depende del análisis específico del proyecto.

## I - Método Cascada (Waterfall Method)

#### 1. **Definición:**

El **Método Cascada** es un proceso de desarrollo **secuencial**. Imagina una cascada: el agua cae de una etapa a la siguiente, sin volver atrás. Cada fase se completa antes de pasar a la siguiente. Fue uno de los primeros procesos, adaptado de la manufactura y la construcción.

En inglés se conoce como **Waterfall Method**.

#### 2. **Imagen:**

![_images/BackWaterfall.png](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_images/BackWaterfall.png)

**Explicación de la imagen:**
La imagen muestra las fases en secuencia, como una cascada: Requisitos, Análisis, Diseño, Implementación, Verificación, Mantenimiento.

#### 3. **Fases del Método Cascada:**

1.  **Requisitos (Requirements):** Definir qué debe hacer el software. Documentado en un "Documento de Requisitos del Producto".
2.  **Análisis (Analysis):** Crear modelos, esquemas y reglas del negocio.
3.  **Diseño (Design):** Definir la arquitectura del software.
4.  **Implementación (Implementation):** Desarrollar y unir las partes del software (programar).
5.  **Verificación (Verification):** Buscar y corregir errores (pruebas).
6.  **Mantenimiento (Maintenance):** Instalar, actualizar, dar soporte y mantener el sistema funcionando.

#### 4. **Ejemplo:**

Construir un edificio siguiendo planos muy detallados. Cada etapa (cimientos, estructura, paredes, etc.) se completa antes de empezar la siguiente.

**Explicación del ejemplo:**
Una vez que se termina una fase, se considera cerrada y se pasa a la siguiente, como en una cascada.

#### 5. **Notas o advertencias:**

- Fue muy popular en los años 80 por ser fácil de entender.
- La principal crítica es su **falta de flexibilidad**. Si te equivocas al principio, ¡es difícil volver atrás!
- Aunque el Departamento de Defensa de EEUU lo usó, luego lo reemplazó por otros métodos más flexibles.

## J - Proceso Racional Unificado (Rational Unified Process - RUP)

#### 1. **Definición:**

El **Proceso Racional Unificado (RUP)** es un **marco de trabajo** de desarrollo de software **iterativo e incremental**. No es un proceso específico, sino una guía que se puede adaptar a cada proyecto. Es como un "kit de herramientas" que puedes personalizar.

En inglés se conoce como **Rational Unified Process (RUP)**. También se le llama **Unified Process**.

#### 2. **Conceptos Clave de RUP:**

- **Roles (Who - Quién):** Define los roles o "papeles" que las personas desempeñan en el proyecto (ej: analista, programador, tester). Cada rol tiene habilidades y responsabilidades.
- **Productos de Trabajo (What - Qué):** Son los "entregables" o resultados de cada tarea (ej: documentos, modelos, código).
- **Tareas (How - Cómo):** Son las unidades de trabajo asignadas a cada rol para lograr un resultado significativo.

#### 3. **Iteraciones en RUP:**

RUP organiza el proyecto en **iteraciones**. Una iteración es un periodo de tiempo (como un ciclo) donde se realizan tareas. Dentro de cada iteración, las tareas se agrupan en **disciplinas**.

#### 4. **Disciplinas RUP:**

- **Disciplinas de "Ingeniería":**
  1.  Modelado de Negocio (Business Modeling)
  2.  Requisitos (Requirements)
  3.  Análisis y Diseño (Analysis and Design)
  4.  Implementación (Implementation)
  5.  Pruebas (Test)
  6.  Despliegue (Deployment)
- **Disciplinas de "Soporte":**
  1.  Gestión de Configuración y Cambios (Configuration and Change Management)
  2.  Gestión de Proyecto (Project Management)
  3.  Entorno (Environment)

#### 5. **Imagen:**

![_images/BackRUPIterations.png](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_images/BackRUPIterations.png)

**Explicación de la imagen:**
Muestra cómo las disciplinas se repiten en cada iteración, pero con diferente intensidad según la fase del proyecto.

#### 6. **Ejemplo:**

Imagina construir una casa por fases. En cada fase (iteración), haces un poco de planificación, diseño, construcción y pruebas, pero te enfocas más en unas disciplinas que en otras según avanzas.

**Explicación del ejemplo:**
RUP es flexible y permite ir avanzando por partes, aprendiendo y adaptando el plan en cada iteración.

#### 7. **Notas o advertencias:**

- RUP es un **marco de trabajo adaptable**, no un proceso rígido. Se ajusta a las necesidades de cada proyecto.
- Fue creado por Rational Software Corporation en 1996.
- Hay otras variantes de Unified Process como OpenUP y Agile Unified Process.

## K - Otros Enfoques Dirigidos por Plan (Other Plan-Driven Approaches)

#### 1. **Definición:**

Además del Método Cascada y RUP, existen otros enfoques dirigidos por plan, muchos de ellos con origen en el ámbito militar o en estándares de calidad. Aquí tienes algunos ejemplos:

#### 2. **Métodos Militares (DoD - Departamento de Defensa de EEUU):**

- **DoD-STD-2167:** Enfoque basado en documentos, con muchas "Descripciones de Elementos de Datos" (deliverables). Se permitía adaptar, pero no se hacía mucho.
- **MIL-STD-1521:** Detalla revisiones y auditorías secuenciales requeridas.
- **MIL-STD-498:** Revisión del 2167 para dar más flexibilidad en ingeniería de sistemas, planificación, desarrollo e integración.
- **MIL-STD-499B:** Define el contenido de un plan de gestión de ingeniería de sistemas.

#### 3. **Estándares Generales de Proceso (ISO, EIA, IEEE):**

- **EIA/IEEE J-STD-016:** Generalización del MIL-STD-498 para incluir procesos de software comerciales.
- **ISO 9000:** Estándar de gestión de calidad que incluye software.
- **ISO 12207 y 15504:** Tratan el ciclo de vida del software y cómo evaluar procesos de software.

#### 4. **Cleanroom (Harlan Mills, IBM):**

- Usa control estadístico de procesos y verificación matemática para desarrollar software con alta fiabilidad.
- El nombre viene de los "cuartos limpios" para evitar defectos en electrónica de precisión.

#### 5. **Capability Maturity Model for Software (SW-CMM) (SEI, Fuerza Aérea de EEUU, otros):**

- Marco para mejorar procesos. Surgió para que la Fuerza Aérea eligiera desarrolladores de software cualificados.
- Organiza "Mejores Prácticas" en "Áreas Clave de Práctica" en cinco niveles de madurez creciente.

#### 6. **Software Factories (Hitachi, GE, otros):**

- Esfuerzo a largo plazo para mejorar calidad, reutilización y productividad del software.
- Muy basado en procesos, con énfasis en reducir defectos al principio.

#### 7. **CMM Integration (CMMI) (SEI, DoD, NDIA, otros):**

- Integró CMM de software y sistemas, y extendió el concepto CMM a otras disciplinas.
- Conjunto de modelos y métodos de evaluación para varias disciplinas, con arquitectura y vocabulario comunes.

#### 8. **Personal Software Process (PSP) / Team Software Process (TSP) (Watts Humphrey, SEI):**

- **PSP:** Marco estructurado con formularios, guías y procedimientos para desarrollar software. Para que cada programador mejore sus habilidades midiéndose a sí mismo.
- **TSP:** Se basa en PSP y apoya el desarrollo de software robusto en equipo, con planificación y control en equipo.

#### 9. **Notas o advertencias:**

- Esta lista muestra la variedad de enfoques dirigidos por plan que existen.
- Muchos de estos métodos son más formales y documentales que los ágiles.

## L - Programación Extrema (eXtreme Programming - XP)

#### 1. **Definición:**

**Programación Extrema (XP)** es un método **ágil** muy famoso, creado a finales de los 90 por Kent Beck. Fue de los primeros métodos ágiles en ganar atención en proyectos de software "normales". XP es bastante **prescriptivo** dentro de los métodos ágiles, es decir, tiene reglas bastante definidas.

En inglés se conoce como **eXtreme Programming (XP)**.

#### 2. **Filosofía de XP:**

XP busca reducir el coste de los cambios en los requisitos. En lugar de evitar los cambios, los considera **naturales y deseables**. Se planifican ciclos de desarrollo cortos para adaptarse a los cambios.

#### 3. **Imagen:**

![_images/Extreme_Programming.png](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_images/Extreme_Programming.png)

**Explicación de la imagen:**
Muestra los ciclos de planificación y retroalimentación cortos de XP.

#### 4. **Prácticas Centrales de XP:**

- **Historias de Usuario (Stories):** Requisitos expresados de forma sencilla desde la perspectiva del usuario.
- **Programación en Parejas (Pair Programming):** Dos programadores trabajan juntos en el mismo código.
- **Diseño Simple (Simple Design):** Buscar la solución más sencilla que funcione.
- **Desarrollo Dirigido por Pruebas (Test-First Development):** Escribir las pruebas antes de escribir el código.
- **Pruebas Unitarias (Unit Tests):** Pruebas automáticas para verificar que cada parte del código funciona bien.
- **Integración Continua (Continuous Integration):** Integrar y probar el código frecuentemente (idealmente varias veces al día).

#### 5. **Actividades Básicas de XP:**

1.  **Codificación (Coding):** Escribir código es la actividad principal. En XP, el código es la forma principal de comunicación y de resolver problemas.
2.  **Pruebas (Testing):** Escribir pruebas unitarias y de aceptación para asegurar la calidad.
3.  **Escucha (Listening):** Comunicación constante con el cliente para entender sus necesidades.
4.  **Diseño (Designing):** Diseñar el software, aunque en XP se busca un diseño simple y evolutivo.

#### 6. **Ejemplo:**

Un equipo XP creando una funcionalidad nueva para una app. Trabajan en parejas, escriben pruebas primero, integran el código a menudo y hablan constantemente con el cliente para asegurarse de que están en el camino correcto.

**Explicación del ejemplo:**
XP es muy práctico y se centra en la entrega continua de valor y la adaptación a los cambios.

#### 7. **Notas o advertencias:**

- Kent Beck, el creador de XP, dijo: "Si no haces las 12 prácticas, no estás haciendo XP". ¡Es bastante estricto!
- XP busca mejorar la calidad y la productividad del software.

## M - Crystal

#### 1. **Definición:**

**Crystal** es una familia de procesos de desarrollo de software ágiles, creada por Alistair Cockburn a finales de los 90. Se organiza por "colores" (Crystal Clear, Yellow, Orange, Red), cada uno con diferente "ceremonia" o formalidad. **Crystal Clear** es el más ligero y el mejor documentado.

En inglés se conoce como **Crystal**.

#### 2. **Enfoque de Crystal:**

Crystal adapta el proceso al **tamaño del equipo** y a la **criticidad del proyecto**. Combina ideas de métodos ágiles y planificados, así como de psicología y desarrollo organizacional.

#### 3. **Ejemplo:**

- **Crystal Clear:** Para equipos pequeños y proyectos no muy críticos. Proceso muy ligero y flexible.
- **Crystal Orange:** Para equipos más grandes y proyectos más críticos. Proceso con más "ceremonia" y documentación.

**Explicación del ejemplo:**
Crystal ofrece diferentes "sabores" de procesos ágiles, adaptados a diferentes situaciones.

#### 4. **Notas o advertencias:**

- Crystal busca el equilibrio entre flexibilidad y control, adaptándose a las necesidades del proyecto.
- La idea de los "colores" es facilitar la elección del proceso adecuado según el contexto.

## N - Scrum

#### 1. **Definición:**

**Scrum** es un proceso **ágil** de **gestión de proyectos de software**. Se centra en cómo organizar los equipos de desarrollo, pero **no define las actividades técnicas** de desarrollo en sí. Es como un "marco de gestión" para proyectos ágiles.

En inglés se conoce como **Scrum**.

#### 2. **Conceptos Clave de Scrum:**

- **Sprints:** Proyectos divididos en ciclos de trabajo cortos de 30 días (o menos), llamados "sprints".
- **Backlog:** Lista priorizada de requisitos o funcionalidades a implementar.
- **Reuniones Scrum Diarias (Daily Scrum Meetings):** Reuniones cortas (10-15 minutos) para coordinar el equipo y con los interesados.

#### 3. **Ejemplo:**

Un equipo Scrum trabajando en una app. Cada "sprint" se enfoca en implementar un conjunto de funcionalidades del "backlog". El equipo se reúne cada día para coordinarse y resolver problemas.

**Explicación del ejemplo:**
Scrum ayuda a organizar el trabajo en ciclos cortos y a mantener la comunicación y la coordinación dentro del equipo.

#### 4. **Notas o advertencias:**

- **Scrum es para gestionar el proyecto**, no para decirte cómo programar o diseñar.
- Usa la analogía de "cerdos y gallinas" (pigs and chickens) para diferenciar roles en el proyecto, aunque este concepto es menos usado hoy en día.

## O - Desarrollo Dirigido por Características (Feature-Driven Development - FDD)

#### 1. **Definición:**

**Desarrollo Dirigido por Características (FDD)** es un proceso **ágil** y **ligero**, basado en la **arquitectura** del software. Empieza por definir una arquitectura general y una lista de "características" (funcionalidades). Luego, el desarrollo se hace "por característica".

En inglés se conoce como **Feature-Driven Development (FDD)**.

#### 2. **Enfoque de FDD:**

- **Arquitectura Inicial:** Se establece una arquitectura general al principio.
- **Lista de Características:** Se crea una lista de funcionalidades que el software debe tener.
- **Desarrollo Incremental:** Se diseñan y construyen las funcionalidades de forma incremental, una a una.
- **UML:** FDD sugiere usar UML (Lenguaje de Modelado Unificado) u otros métodos de diseño orientado a objetos.

#### 3. **Ejemplo:**

Un equipo FDD creando una plataforma de comercio electrónico. Primero definen la arquitectura general (base de datos, servidor, interfaz, etc.) y luego dividen las funcionalidades (carrito de compra, gestión de usuarios, pagos, etc.) en "características" para desarrollar de forma incremental.

**Explicación del ejemplo:**
FDD combina la planificación inicial de la arquitectura con el desarrollo ágil e incremental de funcionalidades.

#### 4. **Notas o advertencias:**

- FDD es más **estructurado** que otros métodos ágiles como XP o Scrum, especialmente en la fase inicial de arquitectura.
- El nombre "Feature-Driven" (dirigido por características) indica que las funcionalidades son el centro del proceso de desarrollo.
