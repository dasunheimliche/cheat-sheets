## A - Recurrence Relation (Relación de Recurrencia)

#### 1. **Definición:**

Una **Recurrence Relation** (o **relación de recurrencia** en español) es como una receta que se define a sí misma. Es una forma de definir una función usando valores anteriores de la misma función. Imagina que estás construyendo una torre de bloques: cada nuevo bloque se coloca basándote en cómo colocaste los bloques anteriores. ¡Así funcionan las recurrence relations!

En términos más técnicos, es una ecuación que define una secuencia donde cada término se calcula a partir de uno o más términos precedentes.

#### 2. **Ejemplo:**

Piénsalo así: ¿Alguna vez has calculado el factorial de un número? (¡Seguro que sí, eres un crack!)

- **Factorial:** `n!` se define como `n * (n-1)!` para `n > 1`, y `1! = 0! = 1`.

  Esto es una recurrence relation. Para calcular el factorial de `n`, necesitas el factorial de `n-1`. ¡Es recursivo!

- **Fibonacci:** `Fib(n) = Fib(n-1) + Fib(n-2)` para `n > 2`, y `Fib(1) = Fib(2) = 1`.

  Para obtener un número de Fibonacci, sumas los dos anteriores. ¡Otro ejemplo genial de recurrence relation! Los primeros números de Fibonacci son: 1, 1, 2, 3, 5, 8, 13...

#### 3. **Notas o advertencias:**

- **Base Case (Caso Base):** Toda recurrence relation necesita un **caso base**. Es como el primer bloque de tu torre, ¡el punto de partida! Sin casos base, la definición sería infinita y no llegaríamos a ningún resultado concreto. En el factorial, los casos base son `1! = 1` y `0! = 1`. En Fibonacci, son `Fib(1) = 1` y `Fib(2) = 1`.
- **Recursive Part (Parte Recursiva):** Esta es la regla que te dice cómo calcular un término usando los anteriores. En el factorial, es `n! = n * (n-1)!`. En Fibonacci, es `Fib(n) = Fib(n-1) + Fib(n-2)`.

## B - Recurrence Relations y el Tiempo de Ejecución de Algoritmos Recursivos

#### 1. **Definición:**

Las recurrence relations son súper útiles para analizar algoritmos recursivos. ¿Por qué? Porque el tiempo que tarda un algoritmo recursivo en ejecutarse a menudo depende del tiempo que tardan sus llamadas recursivas. ¡Es como una muñeca rusa de tiempo!

Podemos usar recurrence relations para modelar este tiempo. La relación de recurrencia para el tiempo de ejecución describirá el tiempo total en función del tiempo de ejecución para entradas más pequeñas (las llamadas recursivas) y el trabajo adicional que se hace fuera de las llamadas recursivas.

#### 2. **Ejemplo:**

Imagina una función recursiva `factorial_recursivo(n)` que calcula el factorial. El número de multiplicaciones que hace esta función se puede describir con una recurrence relation:

- `T(n) = T(n-1) + 1` para `n > 1`
- `T(0) = T(1) = 0`

**Explicación del ejemplo:**

- `T(n)` representa el número de multiplicaciones para calcular el factorial de `n`.
- `T(n-1)` es el número de multiplicaciones para calcular el factorial de `n-1` (la llamada recursiva).
- `+ 1` representa la multiplicación adicional que hacemos (`n * (n-1)!`) fuera de la llamada recursiva.
- `T(0) = T(1) = 0` son los casos base: no necesitamos multiplicaciones para el factorial de 0 o 1.

#### 3. **Notas o advertencias:**

- **Costo de las Operaciones:** En este ejemplo, contamos multiplicaciones. Podríamos contar otras operaciones (sumas, comparaciones, etc.) dependiendo de lo que queramos analizar.
- **Análisis de Algoritmos:** Las recurrence relations son una herramienta clave en el análisis de algoritmos, especialmente para entender la eficiencia de algoritmos recursivos como Merge Sort, Quick Sort, y muchos otros.

## C - Closed-Form Solution (Solución en Forma Cerrada)

#### 1. **Definición:**

Una **Closed-Form Solution** (o **solución en forma cerrada**) es como encontrar un atajo. En lugar de tener una definición recursiva que depende de sí misma, queremos una fórmula directa que nos dé el resultado sin necesidad de calcular términos anteriores. Es como tener un mapa en lugar de tener que preguntar las indicaciones en cada esquina.

Para una recurrence relation, la closed-form solution es una expresión matemática que calcula directamente el valor de la función para cualquier entrada `n`, sin recurrencia.

#### 2. **Ejemplo:**

Volvamos a nuestro ejemplo del factorial recursivo y su recurrence relation para el número de multiplicaciones:

- `T(n) = T(n-1) + 1` para `n > 1`
- `T(0) = T(1) = 0`

Si expandimos esta recurrencia, podemos ver un patrón:

- `T(n) = T(n-1) + 1`
- `T(n) = (T(n-2) + 1) + 1 = T(n-2) + 2`
- `T(n) = (T(n-3) + 1) + 2 = T(n-3) + 3`
  ...
- `T(n) = T(1) + (n-1) = 0 + (n-1) = n - 1` (si empezamos en `T(1) = 0`)
- `T(n) = T(0) + n = 0 + n = n` (si empezamos en `T(0) = 0`)

¡La **closed-form solution** es simplemente `T(n) = n` (o `n-1` dependiendo de cómo definas el inicio)! Esto significa que para calcular el factorial de `n` de forma recursiva, hacemos aproximadamente `n` multiplicaciones.

#### 3. **Notas o advertencias:**

- **No siempre es fácil:** Encontrar la closed-form solution no siempre es trivial. A veces requiere técnicas más avanzadas.
- **Entender el Comportamiento:** La closed-form solution nos da una visión directa del comportamiento de la función. Por ejemplo, `T(n) = n` nos dice que el número de multiplicaciones crece linealmente con `n`.
- **Sumatorias:** A menudo, la expansión de una recurrence relation nos lleva a una sumatoria, y resolver esa sumatoria nos da la closed-form solution. ¡Como veremos en el siguiente ejemplo!

## D - Expansion (Expansión) para Resolver Recurrence Relations

#### 1. **Definición:**

**Expansion** (o **expansión**) es una técnica para encontrar la closed-form solution de una recurrence relation. La idea es simple: reemplazamos repetidamente la función en el lado derecho de la ecuación de recurrencia con su propia definición, hasta que veamos un patrón que podamos expresar como una sumatoria o una fórmula directa. ¡Es como desenrollar una alfombra para ver el diseño completo!

#### 2. **Ejemplo:**

Vamos a usar la expansión para encontrar la closed-form solution de:

- `T(n) = T(n-1) + 1` para `n > 1`
- `T(1) = 0`

**Pasos de Expansión:**

1.  **Empezamos con la recurrencia:** `T(n) = T(n-1) + 1`
2.  **Reemplazamos `T(n-1)` usando la misma recurrencia:** `T(n-1) = T(n-2) + 1`
    Entonces, `T(n) = (T(n-2) + 1) + 1 = T(n-2) + 2`
3.  **Reemplazamos `T(n-2)`:** `T(n-2) = T(n-3) + 1`
    Entonces, `T(n) = (T(n-3) + 1) + 2 = T(n-3) + 3`
4.  **Continuamos expandiendo hasta llegar al caso base `T(1)`:**

    ```
    T(n) = T(n-1) + 1
         = T(n-2) + 1 + 1
         = T(n-3) + 1 + 1 + 1
         ...
         = T(n-k) + k
         ...
         = T(1) + (n-1)   (cuando k = n-1, llegamos a T(1))
         = 0 + (n-1)       (porque T(1) = 0)
         = n - 1
    ```

5.  **Sumatoria:** Podemos expresar esto como una sumatoria:

    `T(n) =  ∑_(i=1)^(n-1) 1`

    Esta sumatoria significa "suma 1, desde i=1 hasta n-1", que es simplemente `n-1`.

**Resultado:** La closed-form solution es `T(n) = n - 1`.

#### 3. **Notas o advertencias:**

- **Patrones:** La clave de la expansión es reconocer el patrón que emerge al expandir repetidamente.
- **Sumatorias:** A menudo, la expansión lleva a una sumatoria. Necesitarás saber cómo resolver sumatorias para obtener la closed-form solution final.
- **No siempre funciona directamente:** Para recurrencias más complejas, la expansión directa puede ser más difícil y puede que necesites otras técnicas (como el método maestro o el método de sustitución).

**¡Mira esta imagen del texto que ilustra la expansión!**

![image](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_static/Images/green_check.png) Saving... ![Error Saving](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_static/Images/warning.png)
Server Error
[Resubmit](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/RecurrenceIntro.html#)

(Ups, parece que hay un problema con la imagen en el texto original, ¡pero la idea de la expansión queda clara!)

## E - Ejemplo Más Complicado: `T(n) = T(n-1) + n; T(1) = 1`

#### 1. **La Recurrencia:**

Ahora, vamos a ver una recurrence relation un poco más interesante:

- `T(n) = T(n-1) + n` para `n > 1`
- `T(1) = 1`

#### 2. **Expansión:**

Vamos a expandir esta recurrencia también:

1.  `T(n) = T(n-1) + n`
2.  `T(n) = (T(n-2) + (n-1)) + n = T(n-2) + (n-1) + n`
3.  `T(n) = (T(n-3) + (n-2)) + (n-1) + n = T(n-3) + (n-2) + (n-1) + n`
    ...
4.  `T(n) = T(1) + 2 + 3 + ... + (n-2) + (n-1) + n`
5.  `T(n) = 1 + 2 + 3 + ... + (n-2) + (n-1) + n` (porque `T(1) = 1`)

#### 3. **Sumatoria y Solución:**

¡Mira! Hemos llegado a la suma de los números desde 1 hasta `n`. ¿Recuerdas la fórmula para la suma de los primeros `n` números naturales? ¡Es una fórmula muy famosa!

- `∑_(i=1)^n i = n * (n+1) / 2`

Por lo tanto, la **closed-form solution** para nuestra recurrencia es:

- `T(n) = n * (n+1) / 2`

#### 4. **Ejemplo Numérico:**

Probemos con `n = 4`:

- **Recurrencia:**

  - `T(4) = T(3) + 4`
  - `T(3) = T(2) + 3`
  - `T(2) = T(1) + 2`
  - `T(1) = 1`
  - `T(2) = 1 + 2 = 3`
  - `T(3) = 3 + 3 = 6`
  - `T(4) = 6 + 4 = 10`

- **Closed-form solution:**
  - `T(4) = 4 * (4+1) / 2 = 4 * 5 / 2 = 10`

¡Funciona! Ambos métodos nos dan el mismo resultado.

#### 5. **Notas o advertencias:**

- **Suma de Series:** Resolver recurrence relations a menudo implica reconocer y resolver sumas de series aritméticas, geométricas, etc. ¡Repasar esas fórmulas puede ser muy útil!
- **Verificación:** Siempre es buena idea verificar tu closed-form solution con algunos ejemplos numéricos para asegurarte de que es correcta.
