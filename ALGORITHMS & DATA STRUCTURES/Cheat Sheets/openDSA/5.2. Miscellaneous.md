## A - Unidades de Medida

#### 1. **Definición:**

En OpenDSA, usamos abreviaciones estándar para medir datos y tiempo en computación. Es importante entender cómo se escriben para evitar confusiones, especialmente con las potencias de dos vs. decimales.

#### 2. **Ejemplos:**

- **Bytes y Bits:**

  - `B`: Bytes (la unidad básica de información)
  - `b`: bits (1 byte = 8 bits)

- **Múltiplos de Bytes (Potencias de 2):**

  - `KB`: Kilobyte (1024 bytes, o 2<sup>10</sup> bytes)
  - `MB`: Megabyte (1024 kilobytes, o 2<sup>20</sup> bytes)
  - `GB`: Gigabyte (1024 megabytes, o 2<sup>30</sup> bytes)

- **Tiempo:**

  - `ms`: milisegundos (1/1000 de segundo)

- **Espacios y Números:**
  - **Potencias de dos (sin espacio):** `25GB` (25 gigabytes, entendiendo gigabyte como 2<sup>30</sup> bytes)
  - **Decimales (con espacio):** `2 Kb` (2000 bits, 'K' aquí es kilo en decimal, 1000)
  - `2000 ms` (2000 milisegundos)

**Explicación del ejemplo:**
La clave está en el espacio. Si ves un espacio entre el número y la unidad (como `2 Kb`), generalmente se refiere a decimales (multiplicado por 1000, 1000000, etc.). Si no hay espacio (como `25GB`), se refiere a potencias de 2 (multiplicado por 1024, 1048576, etc.), que es muy común en informática para capacidades de memoria y almacenamiento.

#### 3. **Notas o advertencias:**

- En este libro, las cantidades grandes de almacenamiento casi siempre se miden en potencias de dos, mientras que el tiempo se mide en potencias de diez. ¡Tenlo presente!
- Confundir `Kb` con `KB` puede llevar a errores de cálculo grandes, ¡así que fíjate bien!

---

## B - Función Factorial

#### 1. **Definición:**

El factorial de un número entero positivo `n`, escrito como `n!`, es el producto de todos los enteros positivos desde 1 hasta `n`. Es decir, multiplicas todos los números desde 1 hasta ese número.

#### 2. **Ejemplo:**

- `5! = 1 * 2 * 3 * 4 * 5 = 120`
- Casos especiales: `0! = 1` (por definición) y `1! = 1`.

**Explicación del ejemplo:**
Para calcular `5!`, simplemente multiplicas 1, 2, 3, 4 y 5. El factorial crece muy rápido. Por ejemplo, ¡`10!` ya es 3,628,800!

#### 3. **Notas o advertencias:**

- **Crecimiento rápido:** El factorial crece ¡MUY rápido! Para números grandes, calcularlo directamente puede llevar mucho tiempo.
- **Aproximación de Stirling:** Para números grandes, podemos usar la aproximación de Stirling: `n! ≈ √(2πn) * (n/e)^n`, donde `e ≈ 2.71828`. Esta fórmula es útil para estimar factoriales grandes sin calcularlos directamente.
- Aunque `n!` crece más lento que `n^n`, crece más rápido que `c^n` para cualquier constante `c`. Esto significa que el factorial se dispara hacia el infinito más rápido que cualquier función exponencial simple.

---

## C - Permutaciones

#### 1. **Definición:**

Una permutación de una secuencia es simplemente reorganizar los elementos de esa secuencia en un orden diferente. Piensa en ello como todas las formas posibles de barajar un conjunto de cosas.

#### 2. **Ejemplo:**

Si tienes la secuencia de números `[1, 2, 3]`, las permutaciones posibles son:

- `[1, 2, 3]`
- `[1, 3, 2]`
- `[2, 1, 3]`
- `[2, 3, 1]`
- `[3, 1, 2]`
- `[3, 2, 1]`

**Explicación del ejemplo:**
Para 3 números distintos, hay 6 permutaciones posibles. Si tienes `n` elementos distintos, el número total de permutaciones es `n!`.

#### 3. **Permutación Aleatoria:**

A veces necesitamos una permutación aleatoria, donde cada posible orden tiene la misma probabilidad de ser elegido. El texto nos da un algoritmo sencillo para esto.

**Código de ejemplo (pseudocódigo):**

```
Función permutar(A): // A es un array
  para i desde longitud de A hasta 1 (descendiendo):
    intercambiar A[i-1] con A[posición aleatoria entre 0 y i-1]
```

**Explicación del código:**
Este algoritmo recorre el array desde el final hacia el principio. En cada paso `i`, elige una posición aleatoria entre el inicio del array y la posición actual `i-1`, e intercambia el elemento en `A[i-1]` con el elemento en la posición aleatoria. Esto asegura que cada permutación tenga la misma probabilidad de ocurrir.

#### 4. **Notas o advertencias:**

- **Número de permutaciones:** Para `n` elementos distintos, hay `n!` permutaciones. ¡Crece factorialmente!
- **Aplicaciones:** Las permutaciones son importantes en probabilidad, combinatoria y algoritmos (como generar casos de prueba aleatorios).

---

## D - Variables Booleanas

#### 1. **Definición:**

Una variable booleana (o lógica) es una variable que solo puede tener dos valores posibles: `Verdadero` (True) o `Falso` (False). Piensa en ellas como interruptores de "encendido" o "apagado".

#### 2. **Ejemplo:**

En muchos lenguajes de programación, podrías declarar una variable booleana así:

```
es_mayor_de_edad = Verdadero
tiene_permiso = Falso
```

**Explicación del ejemplo:**
`es_mayor_de_edad` es `Verdadero` porque la persona es mayor de edad. `tiene_permiso` es `Falso` porque no tiene permiso.

#### 3. **Asociación con 1 y 0:**

A menudo, `Verdadero` se asocia con el valor `1` y `Falso` con el valor `0`. Sin embargo, ¡no dependas de esto en tu código!

#### 4. **Notas o advertencias:**

- **No confundir con números:** Aunque a veces se usan `1` y `0`, `Verdadero` y `Falso` son tipos de datos lógicos distintos. Es mala práctica asumir que `0` es siempre `Falso` y `1` es siempre `Verdadero` en todos los contextos. ¡Mantenlos separados en tu mente y en tu código para evitar errores!

---

## E - Notación Lógica

#### 1. **Definición:**

Usamos símbolos para escribir expresiones lógicas de forma más corta y precisa. Aquí tienes los más comunes:

- **Implicación (⇒ o →):** `A ⇒ B` significa "A implica B" o "Si A entonces B". Es decir, si A es verdadero, entonces B también debe ser verdadero.
- **Equivalencia (⇔ o ↔):** `A ⇔ B` significa "A si y solo si B" o "A es equivalente a B". A es verdadero exactamente cuando B es verdadero, y falso exactamente cuando B es falso.
- **O lógico (∨):** `A ∨ B` significa "A o B". Es verdadero si A es verdadero, o si B es verdadero, o si ambos son verdaderos. Es falso solo si ambos A y B son falsos.
- **Y lógico (∧):** `A ∧ B` significa "A y B". Es verdadero solo si tanto A como B son verdaderos. Si alguno de los dos (o ambos) es falso, entonces `A ∧ B` es falso.
- **Negación (∼ o ¬ o ¯ ):** `∼A`, `¬A`, o `Ā` significan "no A" o la negación de A. Si A es verdadero, entonces `∼A` es falso, y viceversa.

#### 2. **Ejemplos:**

- "Si está lloviendo (L), entonces llevo un paraguas (P)": `L ⇒ P`
- "Apruebas el examen (A) si y solo si estudias (E)": `A ⇔ E`
- "Voy al cine (C) o me quedo en casa (Q)": `C ∨ Q`
- "Hace sol (S) y calor (H)": `S ∧ H`
- "No está lloviendo": `∼L` o `¬L` o `overline{L}`

**Explicación del ejemplo:**
Estos símbolos nos permiten escribir afirmaciones lógicas de manera concisa, como en matemáticas. Son muy útiles en informática para describir condiciones y reglas en algoritmos y lógica digital.

#### 3. **Notas o advertencias:**

- **Claridad:** Usar estos símbolos hace que las expresiones lógicas sean más cortas y a menudo más fáciles de entender para quienes están familiarizados con la notación.
- **Contexto:** `∨` y `∧` se usan tanto en lógica simbólica como en operaciones booleanas en programación.

---

## F - Funciones Piso (Floor) y Techo (Ceiling)

#### 1. **Definición:**

- **Función Piso (⌊x⌋):** Toma un número real `x` y devuelve el **mayor entero que es menor o igual a x**. Piensa en "redondear hacia abajo" al entero más cercano.
- **Función Techo (⌈x⌉):** Toma un número real `x` y devuelve el **menor entero que es mayor o igual a x**. Piensa en "redondear hacia arriba" al entero más cercano.

#### 2. **Ejemplos:**

**Función Piso:**

- `⌊3.4⌋ = 3` (El mayor entero menor o igual a 3.4 es 3)
- `⌊3.0⌋ = 3` (El mayor entero menor o igual a 3.0 es 3)
- `⌊-3.4⌋ = -4` (¡Ojo aquí! El mayor entero menor o igual a -3.4 es -4, no -3. Piensa en la recta numérica)
- `⌊-3.0⌋ = -3` (El mayor entero menor o igual a -3.0 es -3)

**Función Techo:**

- `⌈3.4⌉ = 4` (El menor entero mayor o igual a 3.4 es 4)
- `⌈4.0⌉ = 4` (El menor entero mayor o igual a 4.0 es 4)
- `⌈-3.4⌉ = -3` (El menor entero mayor o igual a -3.4 es -3)
- `⌈-3.0⌉ = -3` (El menor entero mayor o igual a -3.0 es -3)

**Explicación del ejemplo:**
Visualiza una recta numérica. La función piso te lleva al entero a la izquierda (o al mismo número si ya es entero). La función techo te lleva al entero a la derecha (o al mismo número si ya es entero).

#### 3. **Notas o advertencias:**

- **Números negativos:** ¡Presta especial atención a los números negativos! `⌊-3.4⌋` es `-4`, no `-3`. Es una confusión común.
- **Enteros:** Si el número ya es entero, tanto la función piso como la techo devuelven el mismo número.

---

## G - Función Módulo (Mod)

#### 1. **Definición:**

La función módulo (o "mod") te da el **resto** de una división entera. Cuando divides un número `n` por otro número `m`, el módulo es lo que "sobra" después de hacer la división entera.

En matemáticas, a veces se escribe `n mod m`. En muchos lenguajes de programación, se usa el operador `%`, como `n % m`.

#### 2. **Ejemplo:**

- `5 mod 3 = 2` (Porque 5 dividido por 3 es 1 con un resto de 2. 5 = 3 \* 1 + 2)
- `25 mod 3 = 1` (Porque 25 dividido por 3 es 8 con un resto de 1. 25 = 3 \* 8 + 1)
- `5 mod 7 = 5` (Porque 5 dividido por 7 es 0 con un resto de 5. 5 = 7 \* 0 + 5)
- `5 mod 5 = 0` (Porque 5 dividido por 5 es 1 con un resto de 0. 5 = 5 \* 1 + 0)

**Explicación del ejemplo:**
El resultado de `n mod m` siempre estará entre 0 y `m-1` (si `n` y `m` son positivos).

#### 3. **Módulo con números negativos:**

Aquí se pone un poco más complicado porque hay diferentes definiciones de cómo manejar el módulo con números negativos.

- **Definición matemática común:** `n mod m = n - m * ⌊n/m⌋`. Con esta definición, `-3 mod 5 = 2`.
- **Comportamiento en Java y C++ (truncamiento):** En Java y C++, y en muchos procesadores, se usa truncamiento en la división entera. Esto significa que `n mod m = n - m * (trunc(n/m))`. Con esta definición, `-3 mod 5 = -3`.

**Ejemplo de la diferencia:**

- **Matemáticamente:** `-3 mod 5 = 2`
- **En Java/C++ (típicamente):** `-3 mod 5 = -3`

#### 4. **Notas o advertencias:**

- **Resultados negativos:** ¡El resultado del módulo puede ser negativo en algunos lenguajes de programación cuando el primer número es negativo! Esto puede ser confuso si esperas siempre un resto positivo.
- **Hashing:** En sistemas de hashing (tablas hash), a menudo se usa el módulo para calcular índices dentro de la tabla. Se espera que el índice sea siempre positivo. Si usas el módulo con números negativos para hashing, ¡asegúrate de que el resultado sea siempre un índice válido (no negativo)! Una solución común es, si el resultado del módulo es negativo, sumarle el tamaño de la tabla hash para hacerlo positivo.
- **Lenguaje dependiente:** El comportamiento exacto del operador módulo puede depender del lenguaje de programación. ¡Siempre es bueno verificar la documentación si trabajas con números negativos!
