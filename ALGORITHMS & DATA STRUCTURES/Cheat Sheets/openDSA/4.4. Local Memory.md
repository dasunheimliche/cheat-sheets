## A - Variables Locales (Local Variables)

#### 1. **Definición:**

Las **variables locales** son como notas rápidas que usas dentro de una función en tu programa. Imagina que una función es como una pequeña receta de cocina. Necesitas ingredientes y utensilios solo para esa receta, ¿verdad? Las variables locales son esos "ingredientes" y "utensilios" que solo existen y son útiles dentro de esa función específica.

En términos técnicos, una variable local es una estructura de programación que representa un espacio de almacenamiento en la memoria del ordenador. Le das un nombre fácil de recordar, como `contador` o `nombre`, y la usas dentro de tu función.

#### 2. **Ejemplo:**

```java
int sumarUno(int numero) {
  int resultado; // 'resultado' es una variable local
  resultado = numero + 1;
  return resultado;
}
```

**Explicación del ejemplo:**
Aquí, `resultado` es una variable local dentro de la función `sumarUno`. Solo existe y la puedes usar dentro de esta función. Una vez que la función termina, `resultado` desaparece.

#### 3. **Notas o advertencias:**

- Piensa en las variables locales como **temporales**. Se crean cuando la función empieza y se destruyen cuando termina.
- El nombre original en inglés es **Local Variables**. Es bueno saberlo por si lees documentación en inglés.

## B - Asignación (Allocation) y Desasignación (Deallocation)

#### 1. **Definición:**

- **Asignación (Allocation):** Es como pedirle al ordenador un pedacito de memoria para guardar el valor de tu variable local. Cuando declaras una variable local dentro de una función, el sistema le asigna (o "aloca") un espacio en la memoria para que pueda guardar información.
- **Desasignación (Deallocation):** Es como devolver ese pedacito de memoria al ordenador cuando ya no necesitas la variable. Cuando la función termina, el sistema recupera (o "desaloca") la memoria que se usaba para las variables locales. ¡Es como si la memoria se reciclara!
- **Tiempo de vida (Lifetime):** Es el periodo desde que se asigna la memoria a una variable local hasta que se desasigna. En otras palabras, es el tiempo durante el cual la variable "vive" y puedes usarla.

#### 2. **Ejemplo:**

Imagina que llamas a la función `sumarUno(5)` del ejemplo anterior.

1.  **Asignación:** Al empezar a ejecutarse `sumarUno`, se asigna memoria para la variable local `resultado`.
2.  **Uso:** Dentro de la función, usas `resultado` para guardar la suma de `numero + 1`.
3.  **Desasignación:** Cuando `sumarUno` termina (después de `return resultado;`), la memoria asignada a `resultado` se desasigna. ¡`resultado` deja de existir!

#### 3. **Notas o advertencias:**

- La asignación y desasignación de variables locales es **automática**. No tienes que preocuparte por hacerlo manualmente en la mayoría de los lenguajes modernos. ¡Es una maravilla!
- En inglés, "Allocation" es asignación, "Deallocation" es desasignación, y "Lifetime" es tiempo de vida.

## C - Ámbito (Scope)

#### 1. **Definición:**

El **ámbito (scope)** de una variable local es como su "zona de influencia". Define qué partes de tu programa pueden "ver" y usar esa variable. Para las variables locales, su ámbito se limita a la función donde fueron declaradas. ¡Son como estrellas locales, solo brillan dentro de su propia función!

Esto se conoce como **ámbito léxico (lexical scoping)**. Significa que el ámbito de una variable se determina por dónde la escribes en el código.

#### 2. **Ejemplo:**

```java
void funcionA() {
  int x = 10; // 'x' es local a funcionA
  System.out.println(x); // ¡Funciona! 'x' está en el ámbito
}

void funcionB() {
  // System.out.println(x); // ¡Error! 'x' NO está en el ámbito de funcionB
}
```

**Explicación del ejemplo:**
La variable `x` se declara dentro de `funcionA`. Por lo tanto, solo `funcionA` puede usarla. Si intentas usar `x` en `funcionB`, ¡tendrás un error! `x` está fuera del ámbito de `funcionB`.

#### 3. **Notas o advertencias:**

- El ámbito léxico ayuda a mantener el código **organizado** y **evita confusiones** entre variables con el mismo nombre en diferentes partes del programa.
- "Scope" en inglés es ámbito. "Lexical Scoping" es ámbito léxico.

## D - Almacenamiento Local (Local Storage)

#### 1. **Definición:**

El **almacenamiento local (local storage)**, o simplemente "locales", se refiere al conjunto de todas las variables locales y parámetros de una función. Piensa en ello como el "espacio de trabajo" personal de cada función.

#### 2. **Ejemplo:**

En la función `Square` del texto:

```java
int Square(int num) { // 'num' es un parámetro (parte del almacenamiento local)
  int result;      // 'result' es una variable local (parte del almacenamiento local)
  result = num * num;
  return result;
}
```

Tanto `num` (el parámetro) como `result` (la variable local) forman parte del almacenamiento local de la función `Square`.

#### 3. **Notas o advertencias:**

- Los **parámetros** de una función también se consideran parte del almacenamiento local. La diferencia es que los parámetros reciben un valor desde fuera de la función cuando se llama, mientras que las variables locales normalmente se inicializan dentro de la función.
- "Local Storage" en inglés es almacenamiento local.

## E - Reglas del Almacenamiento Local

#### 1. **Definición (Reglas):**

Aquí te presento las reglas clave de cómo funciona el almacenamiento local, ¡como si fueran las reglas de un club exclusivo para variables dentro de funciones!

1.  **Asignación al inicio de la función:** Cuando llamas a una función, ¡BAM! Se asigna memoria para todas sus variables locales y parámetros. Es como preparar el escenario antes de que empiece la obra.
2.  **Persistencia durante la ejecución:** La memoria para las variables locales se mantiene asignada mientras la función se está ejecutando, ¡incluso si llama a otras funciones! Es como si tus "utensilios de cocina" siguieran ahí aunque uses el horno (otra función).
3.  **Desasignación al finalizar la función:** Cuando la función termina, ¡PUF! Se desasigna la memoria de todas sus variables locales. Es como recoger y limpiar todo después de cocinar.

#### 2. **Ejemplo:**

Revisa los diagramas del texto original. Muestran visualmente cómo se asignan y desasignan las variables locales cuando se llama a funciones. ¡Son muy útiles para entenderlo!

#### 3. **Notas o advertencias:**

- Recuerda que estas reglas aplican a **cualquier tipo de variable local**, incluyendo números, textos, arrays, ¡lo que sea!
- Entender estas reglas es **crucial** para entender conceptos más avanzados de programación, como la recursión y la gestión de memoria.

## F - Ventajas de las Variables Locales

#### 1. **Definición (Ventajas):**

Las variables locales son geniales por muchas razones. ¡Son como los superhéroes de la memoria en programación!

1.  **Comodidad:** Son súper **convenientes** para guardar información temporal que solo necesitas dentro de una función. ¡Como tener un bloc de notas a mano mientras resuelves un problema!
2.  **Eficiencia:** Son **eficientes** en tiempo y espacio. Asignar y desasignar memoria local es muy rápido, y la memoria se usa y se recicla de forma inteligente. ¡Son como usar contenedores reutilizables!
3.  **Copias Locales (Paso por valor - Pass by Value):** Los parámetros locales son **copias** de la información que les envías al llamar a la función. Esto significa que la función puede modificar sus copias locales sin afectar a los valores originales fuera de la función. ¡Es como trabajar con fotocopias para no dañar el original! Esto se conoce como **"pasar por valor" (pass by value)**.

#### 2. **Ejemplo:**

En el ejemplo de `Square(int num)`, `num` es una copia del valor que le pasas a la función. Si modificas `num` dentro de `Square`, ¡no cambiarás el valor original que usaste al llamar a `Square`!

#### 3. **Notas o advertencias:**

- El "paso por valor" es una forma de **proteger** los datos originales y mantener las funciones **independientes**. ¡Es una buena práctica de programación!
- "Pass by Value" en inglés es "pasar por valor".

## G - Desventajas de las Variables Locales

#### 1. **Definición (Desventajas):**

Aunque las variables locales son fantásticas, también tienen algunas limitaciones. ¡Como todo superhéroe, tienen su kriptonita!

1.  **Tiempo de vida corto:** Su tiempo de vida es **estricto**. Solo existen mientras la función se ejecuta. A veces, necesitas memoria que dure más allá de la función, ¡y las variables locales no sirven para eso!
2.  **Comunicación limitada:** Como son copias, las variables locales **no permiten que una función modifique directamente valores fuera de ella** (en la función que la llamó). A veces, necesitas que una función "devuelva" información modificada a quien la llamó, ¡y las variables locales por sí solas no son la mejor opción!

#### 2. **Ejemplo:**

Si quieres que una función cambie el valor de una variable que le pasaste, usar solo variables locales no será suficiente. Necesitarás otras técnicas que veremos más adelante (como punteros o referencias).

#### 3. **Notas o advertencias:**

- Estas "desventajas" no significan que las variables locales sean malas, ¡solo que **no son la solución para todo**!
- Para los casos donde necesitas memoria de mayor duración o comunicación bidireccional, existen otras herramientas como la **memoria heap** (que se menciona en el texto y aprenderás más adelante).

## H - Sinónimos de "Local"

#### 1. **Definición (Sinónimos):**

A veces, las variables locales se llaman de otras formas. ¡Es bueno conocer estos sinónimos para no confundirte!

- **Variables Automáticas (Automatic Variables):** Porque su asignación y desasignación es automática.
- **Variables de Pila (Stack Variables):** Porque a nivel interno, muchos lenguajes usan una estructura llamada "pila" (stack) para gestionar la memoria de las variables locales.

#### 2. **Ejemplo:**

Si lees documentación o libros de programación, podrías encontrar los términos "automatic variables" o "stack variables" refiriéndose a lo mismo que "local variables".

#### 3. **Notas o advertencias:**

- ¡No te asustes si ves estos nombres diferentes! Todos se refieren a las variables locales que hemos estado estudiando.
- "Automatic Variables" es variables automáticas y "Stack Variables" es variables de pila.

## I - Resumen de Memoria Local

#### 1. **Definición (Resumen):**

En resumen, la memoria local es una herramienta **conveniente** y **eficiente** para que las funciones tengan memoria temporal que solo existe mientras se ejecutan. Es ideal para la mayoría de las necesidades de memoria dentro de las funciones.

#### 2. **Ejemplo:**

Piensa en todas las variables que has usado dentro de funciones hasta ahora. ¡Probablemente la mayoría eran variables locales!

#### 3. **Notas o advertencias:**

- Aunque tienen limitaciones (tiempo de vida corto, comunicación limitada), las variables locales son **fundamentales** en la programación.
- En las siguientes secciones, aprenderás sobre cómo solucionar las limitaciones de la memoria local con otras técnicas.

## J - ¿Cómo Funciona la Pila de Llamadas a Funciones? (Function Call Stack)

#### 1. **Definición (Pila de Llamadas):**

La **pila de llamadas (call stack)** es como una torre de platos que usa el ordenador para gestionar las llamadas a funciones. Cuando llamas a una función, se añade un "plato" (llamado **marco de pila** o **registro de activación - stack frame/activation record**) a la pila, que contiene la información necesaria para esa función, ¡incluyendo sus variables locales! Cuando la función termina, se quita el "plato" de la pila.

#### 2. **Pasos Básicos:**

Cuando llamas a una función como `foo(6, x+1)`:

1.  **Evaluar parámetros:** Primero, se calculan los valores de los parámetros que le pasas a la función (como `x+1`).
2.  **Asignar memoria en la pila:** Se crea un "marco de pila" y se coloca en la cima de la pila de llamadas. Este marco tiene espacio para las variables locales de `foo()` y guarda los valores de los parámetros.
3.  **Guardar dirección de retorno y saltar a la función:** Se guarda la dirección de dónde venía la llamada (para saber a dónde volver después) y el programa empieza a ejecutar el código de `foo()`.
4.  **Ejecutar la función:** `foo()` se ejecuta usando su marco de pila en la cima de la pila.
5.  **Desasignar memoria y volver:** Cuando `foo()` termina, su marco de pila se quita de la pila, y el programa "vuelve" a la dirección guardada, justo después de donde se hizo la llamada a `foo()`.

#### 3. **Notas o advertencias:**

- **Error de "Stack Overflow":** Si una función se llama a sí misma sin parar (recursión infinita), se siguen añadiendo marcos de pila a la pila hasta que se acaba la memoria. ¡Esto causa un error llamado "Stack Overflow Error"!
- **Valores iniciales:** Cuando se asigna memoria en la pila, puede contener "basura" de usos anteriores. Por eso, es importante inicializar tus variables locales para darles un valor conocido.
- **Marco de pila/Registro de activación:** Son otros nombres para el "plato" que se añade a la pila por cada llamada a función. "Stack Frame" o "Activation Record" en inglés.
- **Multihilo:** En programas con varios hilos de ejecución, cada hilo tiene su propia pila de llamadas.
- **Optimización:** Algunos lenguajes pueden usar registros (memoria muy rápida dentro del procesador) para pasar parámetros en lugar de la pila para mejorar el rendimiento, pero la idea básica de la pila de llamadas sigue siendo la misma.
