## A - Preparando el Entorno de Pruebas con `setUp()`

#### 1. **Definición:**

`setUp()` es un método especial en JUnit que se ejecuta **antes de cada prueba individual**. Piensa en él como el momento de preparar el escenario antes de que empiece la función principal de una obra de teatro. Aquí inicializamos los objetos o variables que nuestras pruebas van a necesitar.

#### 2. **Ejemplo:**

```java
import student.TestCase;

public class TestBST extends TestCase{
   private BST<Integer> bst;

   public void setUp() {
      bst = new BST<Integer>();
   }

   // ... tus métodos de prueba irán aquí ...
}
```

**Explicación del ejemplo:**

- `private BST<Integer> bst;`: Declaramos una variable `bst` de tipo `BST<Integer>`, que asumimos es nuestra clase Binary Search Tree (Árbol Binario de Búsqueda). La hacemos `private` porque solo la vamos a usar dentro de esta clase de pruebas.
- `public void setUp() { ... }`: Este es el método `setUp()`. Dentro, creamos una **nueva instancia** de `BST<Integer>()` y la asignamos a nuestra variable `bst`. **Cada vez que se ejecute un método de prueba (como los que veremos después), ¡se creará un nuevo árbol BST fresquito!** Esto es crucial para que las pruebas no se interfieran entre sí.

#### 3. **Notas o advertencias:**

- **Importancia de la limpieza:** `setUp()` asegura que cada prueba comience con un estado **limpio y predecible**. Imagina que una prueba modifica el árbol y la siguiente prueba espera un árbol vacío... ¡sería un lío! `setUp()` evita estos problemas.
- **Nombre clave:** Recuerda el nombre `setUp` (así, todo junto y en minúsculas excepto la 'U' y 'P' en mayúscula). JUnit reconoce este nombre automáticamente.
- **`student.TestCase`:** Asegúrate de que tu clase de pruebas extienda de `student.TestCase`. Esto te da acceso a las herramientas de prueba de JUnit como `assertFuzzyEquals` y `systemOut()`.

## B - Probando la Inserción de Nodos con `testAdd()`

#### 1. **Definición:**

El método `testAdd()` (o como tú quieras llamarlo, siempre que empiece por `test`) se encarga de verificar que la función `insert()` de nuestro BST (Binary Search Tree) funciona correctamente. Queremos asegurarnos de que los nodos se añaden al árbol en la posición correcta.

#### 2. **Ejemplo:**

```java
   public void testAdd() {
      bst.insert(new Integer(8));
      bst.insert(new Integer(3));
      bst.insert(new Integer(1));
      bst.insert(new Integer(6));
      bst.insert(new Integer(4));
      bst.insert(new Integer(7));
      bst.insert(new Integer(10));
      bst.insert(new Integer(14));
      bst.insert(new Integer(13));
      bst.insert(new Integer(13));// Insertando un elemento duplicado
      bst.preOrderTraversal();
      assertFuzzyEquals("8 3 1 6 4 7 10 14 13", systemOut().getHistory());
      systemOut().clearHistory();
      bst.inOrderTraversal();
      assertFuzzyEquals("1 3 4 6 7 8 10 13 14", systemOut().getHistory());
   }
```

**Explicación del ejemplo:**

- **Inserciones:** Añadimos una serie de números al `bst` usando `bst.insert(new Integer(numero))`. Se usa `new Integer()` porque estamos trabajando con un `BST` de tipo `Integer` (números enteros como objetos). Los números elegidos (8, 3, 1, 6, etc.) están tomados de un ejemplo de árbol BST de Wikipedia, ¡así sabemos cómo debería ser el árbol resultante!
- **`preOrderTraversal()` y `inOrderTraversal()`:** Estos métodos (asumimos que están en la clase `BST`) recorren el árbol de dos maneras diferentes:
  - **Pre-Order (Preorden):** Visita el nodo raíz, luego el subárbol izquierdo, luego el subárbol derecho.
  - **In-Order (Inorden):** Visita el subárbol izquierdo, luego el nodo raíz, luego el subárbol derecho. Para un BST, el recorrido In-Order debe dar los nodos **ordenados de menor a mayor**.
- **`systemOut().getHistory()`:** Este método "captura" todo lo que se ha impreso en la consola (la salida estándar) desde que se inició la prueba. Asumimos que `preOrderTraversal()` e `inOrderTraversal()` imprimen los nodos del árbol en la consola.
- **`assertFuzzyEquals(esperado, actual)`:** Esta es una **afirmación** (assertion) de JUnit. Compara dos strings (`esperado` y `actual`) y verifica si son "parecidos" (fuzzy). "Parecidos" aquí significa que ignora espacios en blanco al principio y al final, y múltiples espacios entre palabras. Esto es útil porque a veces la salida de un programa puede tener pequeños detalles de formato diferentes, pero el contenido principal es el mismo.
  - En el primer `assertFuzzyEquals`, comparamos la salida del `preOrderTraversal()` con la string `"8 3 1 6 4 7 10 14 13"`, que es el resultado esperado del recorrido preorden para este árbol.
  - En el segundo `assertFuzzyEquals`, comparamos la salida del `inOrderTraversal()` con la string `"1 3 4 6 7 8 10 13 14"`, que es el resultado esperado del recorrido inorden (ordenado).
- **`systemOut().clearHistory()`:** Después de la primera prueba (`preOrderTraversal()`), limpiamos el historial de la consola. Así, cuando hagamos el `inOrderTraversal()`, solo capturaremos la salida de este segundo recorrido, y no se mezclará con la salida del recorrido anterior.

#### 3. **Notas o advertencias:**

- **Nombres de métodos de prueba:** Los métodos de prueba deben ser `public void` y su nombre debe empezar por `test`. JUnit los detecta automáticamente.
- **Afirmaciones (`assert`):** Las afirmaciones son el corazón de las pruebas JUnit. Usamos métodos `assert` para verificar que el comportamiento de nuestro código es el esperado. Si una afirmación falla, JUnit marca la prueba como fallida.
- **Cobertura de código:** Este ejemplo de `testAdd()` está diseñado para "tocar" todas las líneas de código importantes del método `insert()`. Esto es lo que se llama "cobertura de código" y es importante para asegurar que estamos probando diferentes caminos y casos dentro de nuestra función.
- **Elementos duplicados:** Fíjate que se inserta el número 13 dos veces. Es importante probar cómo maneja el `BST` los elementos duplicados (en este caso, parece que simplemente los ignora o los maneja de alguna manera, pero la salida esperada no los incluye duplicados).

## C - Probando la Eliminación de Nodos con `testRemove()` - Manejo de Excepciones

#### 1. **Definición:**

Ahora vamos a probar la función `delete()` (o `remove()`, como se llame en tu BST) que elimina nodos del árbol. Empezaremos por probar qué pasa cuando intentamos eliminar un nodo de un árbol **vacío**. En este caso, el código del BST debería lanzar una **excepción**.

#### 2. **Ejemplo:**

```java
   public void testRemove() {
      Exception d = null;
      try{
         bst.delete(new Integer(1));// Intentando borrar de un árbol vacío
      } catch(Exception e) {
         d = e;
         assertEquals(e.getMessage(), "cannot delete.");
         assertEquals(e.getClass(), RuntimeException.class);
      }
      assertNotNull(d);// Asegurándonos de que se lanzó una excepción
      // ... más pruebas de borrado ...
   }
```

**Explicación del ejemplo:**

- **`Exception d = null;`:** Declaramos una variable `d` de tipo `Exception` y la inicializamos a `null`. La usaremos para guardar la excepción que esperamos que se lance.
- **`try { ... } catch(Exception e) { ... }`:** Usamos un bloque `try-catch` para **capturar** la excepción que esperamos.
  - **`try { bst.delete(new Integer(1)); }`:** Dentro del bloque `try`, llamamos a `bst.delete(new Integer(1))` intentando borrar el nodo con valor 1. Como el árbol está vacío (porque creamos uno nuevo en `setUp()` y no hemos insertado nada), esperamos que `delete()` lance una excepción.
  - **`catch(Exception e) { ... }`:** Si `bst.delete()` lanza una excepción, el código dentro del bloque `catch` se ejecuta. La variable `e` **captura** la excepción lanzada.
    - `d = e;`: Guardamos la excepción capturada en nuestra variable `d`.
    - `assertEquals(e.getMessage(), "cannot delete.");`: Verificamos que el **mensaje** de la excepción sea el esperado, en este caso, `"cannot delete."`. `getMessage()` devuelve el mensaje de error de la excepción.
    - `assertEquals(e.getClass(), RuntimeException.class);`: Verificamos que la **clase** de la excepción sea la esperada, en este caso, `RuntimeException.class`. `getClass()` devuelve la clase de la excepción. `RuntimeException` es un tipo común de excepción para errores en tiempo de ejecución.
- **`assertNotNull(d);`:** Después del bloque `try-catch`, usamos `assertNotNull(d)` para asegurarnos de que **la variable `d` no es `null`**. Si `d` no es `null`, significa que **entramos en el bloque `catch` y se capturó una excepción**, que es lo que esperábamos. Si no se hubiera lanzado ninguna excepción, `d` seguiría siendo `null` y esta afirmación fallaría, indicando que la prueba ha fallado (porque esperábamos una excepción y no se lanzó).

#### 3. **Notas o advertencias:**

- **Prueba de excepciones:** Probar que el código lanza las excepciones correctas en situaciones de error es **muy importante**. Asegura que nuestro código maneja los errores de forma adecuada.
- **Múltiples formas de probar excepciones:** El ejemplo muestra dos formas de probar excepciones: verificando el mensaje y verificando la clase. A veces, solo verificar la clase es suficiente, especialmente si el mensaje puede cambiar. Pero en este caso, verificar ambos da más seguridad.
- **Valor "canario":** La variable `d` actúa como un "valor canario". La inicializamos a `null` antes del `try-catch`. Si al final de la prueba `d` ya no es `null`, sabemos que el bloque `catch` se ejecutó, lo que confirma que la excepción se lanzó y se capturó.

## D - Probando la Eliminación de Nodos con `testRemove()` - Funcionalidad Básica

#### 1. **Definición:**

Ahora vamos a probar la funcionalidad básica de `delete()` cuando el árbol **no está vacío**. Vamos a insertar una serie de nodos y luego eliminarlos uno a uno, verificando que el árbol se actualiza correctamente después de cada eliminación.

#### 2. **Ejemplo:**

```java
      // ... (código de la prueba de excepciones anterior) ...

      String tree = "";
      for(int i=10; i < 20; i++) {
         bst.insert(new Integer(i));
         tree += i+" ";
      }
      for(int k=9; k > -1; k--) {
         bst.insert(new Integer(k));
         tree = k+" "+tree;
      }
      for(int j=0; j < 10; j++) {
         bst.delete(new Integer(j));// Probando borrado básico
         tree = tree.replaceFirst(Integer.toString(j), "");
         systemOut().clearHistory();
         bst.inOrderTraversal();// Después de cada borrado
         assertFuzzyEquals(tree, systemOut().getHistory());// Verificando el árbol
      }
      for(int l=19; l > 9; l--) {
         bst.delete(new Integer(l));
         tree = tree.replaceFirst(Integer.toString(l), "");
         systemOut().clearHistory();
         bst.inOrderTraversal();
         assertFuzzyEquals(tree, systemOut().getHistory());
      }

      // ... (más pruebas de casos borde en la siguiente sección) ...
   }
```

**Explicación del ejemplo:**

- **Construcción del árbol inicial:**
  - `String tree = "";`: Inicializamos una string `tree` vacía. La usaremos para construir la representación esperada del árbol en recorrido inorden.
  - **Primer bucle `for (int i=10; i < 20; i++) { ... }`:** Insertamos los números del 10 al 19 en el `bst`. También construimos la string `tree` con estos números, separados por espacios, en orden ascendente (10 11 12 ... 19).
  - **Segundo bucle `for (int k=9; k > -1; k--) { ... }`:** Insertamos los números del 9 al 0 en el `bst`. También **prependemos** estos números a la string `tree` (anteponiéndolos al principio), de nuevo separados por espacios (0 1 2 ... 9 10 11 ... 19). Al final de estos dos bucles, `tree` contendrá la representación inorden de todos los números insertados (0 1 2 ... 19).
- **Prueba de borrado en orden ascendente (0 al 9):**
  - **Bucle `for (int j=0; j < 10; j++) { ... }`:** Iteramos del 0 al 9 (los primeros números que insertamos).
    - `bst.delete(new Integer(j));`: Borramos el nodo con valor `j` del `bst`.
    - `tree = tree.replaceFirst(Integer.toString(j), "");`: **Actualizamos la string `tree`** eliminando la **primera ocurrencia** del número `j` (convertido a string) y un espacio en blanco. `replaceFirst()` es importante para solo eliminar la primera coincidencia, por si acaso hubiera números repetidos (aunque en este caso no los hay). Esto mantiene `tree` siempre actualizada con la representación inorden esperada del árbol **después de la eliminación**.
    - `systemOut().clearHistory();`: Limpiamos el historial de la consola.
    - `bst.inOrderTraversal();`: Realizamos un recorrido inorden del árbol **después de la eliminación**.
    - `assertFuzzyEquals(tree, systemOut().getHistory());`: **Comparamos la string `tree` (la representación inorden esperada) con la salida del `inOrderTraversal()` (la representación inorden real del árbol después de la eliminación).** Si son "fuzzy equals", la prueba pasa para esta eliminación.
- **Prueba de borrado en orden descendente (19 al 10):**
  - **Bucle `for (int l=19; l > 9; l--) { ... }`:** Similar al bucle anterior, pero ahora iteramos del 19 al 10 (los últimos números que insertamos) y repetimos el proceso de borrado, actualización de `tree`, recorrido inorden y comparación con `assertFuzzyEquals`.

#### 3. **Notas o advertencias:**

- **Pruebas iterativas:** Este ejemplo usa bucles `for` para realizar una serie de pruebas de forma repetitiva. Esto es útil para probar el borrado de múltiples nodos en diferentes situaciones.
- **Actualización de la salida esperada:** Es crucial **actualizar la string `tree`** después de cada eliminación para que siempre represente la salida inorden **correcta y esperada** del árbol **actual**. Si no actualizáramos `tree`, estaríamos comparando con una salida esperada incorrecta.
- **`replaceFirst()`:** Usar `replaceFirst()` en lugar de `replace()` es importante para evitar problemas si hubiera números repetidos en la string `tree` (aunque en este ejemplo no los hay). `replaceFirst()` solo elimina la primera coincidencia, mientras que `replace()` eliminaría todas.
- **Claridad en la comparación:** Al comparar la salida del `inOrderTraversal()` con la string `tree`, estamos verificando **directamente** que el árbol se está modificando de la manera esperada después de cada operación de borrado.

## E - Probando la Eliminación de Nodos con `testRemove()` - Casos Borde (Edge Cases)

#### 1. **Definición:**

Para asegurar que la función `delete()` es robusta, debemos probar **casos borde** o **casos límite**. Estos son situaciones especiales que pueden ser más propensas a errores. En el caso de la eliminación en un BST, los casos borde típicos son:

- **Eliminar un nodo hoja:** Un nodo que no tiene hijos.
- **Eliminar un nodo interno con un hijo:** Un nodo que tiene solo un hijo (izquierdo o derecho).
- **Eliminar un nodo interno con dos hijos:** Un nodo que tiene dos hijos (izquierdo y derecho).
- **Eliminar la raíz del árbol:** Aunque técnicamente es un caso más específico de los anteriores, a veces se prueba por separado.

El ejemplo se centra en los tres primeros casos.

#### 2. **Ejemplo:**

```java
      // ... (código de las pruebas anteriores) ...

      bst.insert(new Integer(10));// Casos borde de borrado
      bst.insert(new Integer(8));// Borrando una hoja
      bst.insert(new Integer(9));
      bst.insert(new Integer(6));
      bst.insert(new Integer(7));
      bst.delete(new Integer(6)); // Borrando una hoja (6)
      systemOut().clearHistory();
      bst.inOrderTraversal();
      assertFuzzyEquals("7 8 9 10", systemOut().getHistory());

      bst.insert(new Integer(6));// Borrando un nodo interno con un hijo
      bst.delete(new Integer(7)); // Borrando nodo interno (7) con hijo (6)
      systemOut().clearHistory();
      bst.inOrderTraversal();
      assertFuzzyEquals("6 8 9 10", systemOut().getHistory());

      bst = new BST<Integer>(); // Borrando nodo interno y "empujando" el nuevo nodo hacia arriba
      bst.insert(new Integer(10));
      bst.insert(new Integer(8));
      bst.insert(new Integer(9));
      bst.insert(new Integer(7));
      bst.delete(new Integer(8)); // Borrando nodo interno (8) con dos hijos (7 y 9)
      systemOut().clearHistory();
      bst.inOrderTraversal();
      assertFuzzyEquals("7 9 10", systemOut().getHistory());

      bst = new BST<Integer>(); // Borrando nodo interno y progresando al subárbol izquierdo más a la derecha
      bst.insert(new Integer(10));
      bst.insert(new Integer(8));
      bst.insert(new Integer(9));
      bst.insert(new Integer(6));
      bst.insert(new Integer(7));
      bst.delete(new Integer(8)); // Borrando nodo interno (8) con dos hijos (6 y 9)
      systemOut().clearHistory();
      bst.inOrderTraversal();
      assertFuzzyEquals("6 7 9 10", systemOut().getHistory());
   }
```

**Explicación del ejemplo:**

- **Comentarios explicativos:** El código incluye comentarios como `"Borrando una hoja"` o `"Borrando un nodo interno con un hijo"` para indicar qué caso borde se está probando en cada sección. Esto hace que la prueba sea más fácil de entender.
- **Prueba de eliminación de hoja (nodo 6):**
  - Se insertan los nodos 10, 8, 9, 6, 7. En este árbol, el nodo 6 es una hoja.
  - Se elimina el nodo 6 (`bst.delete(new Integer(6))`).
  - Se verifica que el recorrido inorden del árbol resultante sea `"7 8 9 10"`, que es lo esperado después de eliminar la hoja 6.
- **Prueba de eliminación de nodo interno con un hijo (nodo 7):**
  - Se reinserta el nodo 6 (para tener un árbol de partida similar al anterior).
  - Se elimina el nodo 7 (`bst.delete(new Integer(7))`). En este árbol, el nodo 7 es un nodo interno con un solo hijo (el nodo 6).
  - Se verifica que el recorrido inorden sea `"6 8 9 10"`, lo esperado tras eliminar el nodo 7 y "subir" su hijo 6 (o realizar la operación de borrado correspondiente para este caso).
- **Prueba de eliminación de nodo interno con dos hijos (nodo 8) - Caso 1 ("empujando" el nuevo nodo hacia arriba):**
  - Se crea un **nuevo** `BST` (¡importante! `bst = new BST<Integer>();` para empezar con un árbol limpio).
  - Se insertan los nodos 10, 8, 9, 7.
  - Se elimina el nodo 8 (`bst.delete(new Integer(8))`). Aquí, el nodo 8 es un nodo interno con dos hijos (7 y 9). En este caso, la implementación de `delete()` parece que "empuja" el nodo 9 hacia arriba para reemplazar al 8.
  - Se verifica que el recorrido inorden sea `"7 9 10"`.
- **Prueba de eliminación de nodo interno con dos hijos (nodo 8) - Caso 2 (progresando al subárbol izquierdo más a la derecha):**
  - Se crea **otro nuevo** `BST`.
  - Se insertan los nodos 10, 8, 9, 6, 7.
  - Se elimina el nodo 8 (`bst.delete(new Integer(8))`). De nuevo, el nodo 8 es interno con dos hijos (6 y 9). En este caso, la implementación de `delete()` parece que busca el nodo más a la derecha en el subárbol izquierdo del 8 (que sería el 7) y lo usa para reemplazar al 8.
  - Se verifica que el recorrido inorden sea `"6 7 9 10"`.

#### 3. **Notas o advertencias:**

- **Importancia de los casos borde:** Probar los casos borde es crucial para encontrar errores sutiles que podrían no aparecer en pruebas más "normales". Los casos borde suelen ser los puntos donde la lógica del código se vuelve más compleja y donde es más fácil cometer errores.
- **Variedad de casos con nodos internos de dos hijos:** Fíjate que se prueban **dos** escenarios diferentes para la eliminación de un nodo interno con dos hijos. Esto es porque hay **diferentes algoritmos** para manejar este caso en la eliminación de BSTs. Es importante probar diferentes situaciones para asegurar que nuestra implementación funciona correctamente en todos los casos.
- **Reinicio del BST:** En algunas de estas pruebas de casos borde, se crea un **nuevo** `BST` (`bst = new BST<Integer>();`) antes de empezar la prueba. Esto es para asegurar que cada prueba de caso borde comience con un árbol en un estado específico y controlado, sin residuos de pruebas anteriores.

## F - Comparaciones "Fuzzy" con `assertFuzzyEquals()`

#### 1. **Definición:**

`assertFuzzyEquals(esperado, actual)` es un método de afirmación de JUnit que compara dos strings y verifica si son **"fuzzy equals"**. Esto significa que la comparación **ignora**:

- Espacios en blanco al principio y al final de las strings.
- Múltiples espacios en blanco entre palabras (los trata como si fueran un solo espacio).

#### 2. **Ejemplo:**

```java
assertFuzzyEquals("  hola   mundo  ", "hola mundo"); // ¡Esto pasará!
assertFuzzyEquals("hola mundo", "hola  mundo");    // ¡Esto también pasará!
assertFuzzyEquals("hola mundo", "Hola mundo");    // ¡Esto fallará! (diferencia de mayúsculas)
```

**Explicación del ejemplo:**

- En el primer ejemplo, `"  hola   mundo  "` tiene espacios al principio, al final y múltiples espacios entre "hola" y "mundo". `assertFuzzyEquals()` los ignora y lo compara con `"hola mundo"`, por lo que la afirmación **pasa**.
- En el segundo ejemplo, `"hola mundo"` tiene un espacio entre "hola" y "mundo", mientras que `"hola  mundo"` tiene dos. `assertFuzzyEquals()` trata ambos como iguales, por lo que la afirmación **pasa**.
- En el tercer ejemplo, `"hola mundo"` empieza con "h" minúscula, mientras que `"Hola mundo"` empieza con "H" mayúscula. `assertFuzzyEquals()` **sí distingue entre mayúsculas y minúsculas**, por lo que esta afirmación **falla**.

#### 3. **Notas o advertencias:**

- **Útil para salidas de consola:** `assertFuzzyEquals()` es **muy útil para comparar la salida de programas que imprimen en la consola**, como en el caso de los recorridos de árboles (`preOrderTraversal()`, `inOrderTraversal()`). A veces, la salida puede tener pequeños detalles de formato (espacios extra, etc.) que no son relevantes para la prueba en sí. `assertFuzzyEquals()` nos permite ignorar estos detalles y centrarnos en el contenido principal de la salida.
- **No ignora mayúsculas/minúsculas:** Recuerda que `assertFuzzyEquals()` **no ignora las diferencias entre mayúsculas y minúsculas**. Si necesitas una comparación que ignore también las mayúsculas/minúsculas, tendrías que convertir ambas strings a mayúsculas o minúsculas antes de compararlas (por ejemplo, usando `.toUpperCase()` o `.toLowerCase()` en Java).
- **Alternativa a `assertEquals()` para strings con formato flexible:** Si estuvieras comparando strings que deben ser **exactamente iguales**, usarías `assertEquals(esperado, actual)`. `assertFuzzyEquals()` es una alternativa más flexible cuando permites pequeñas variaciones en el formato de las strings.

## G - Comparaciones con Margen de Error (`delta`) en `assertEquals()` para Números Decimales

#### 1. **Definición:**

Cuando trabajamos con números decimales (de punto flotante), como `float` o `double`, las comparaciones de igualdad **exacta** (`assertEquals(valor1, valor2)`) pueden ser problemáticas debido a la forma en que se representan estos números en la computadora. Pequeños errores de redondeo pueden hacer que dos números que "deberían" ser iguales, no lo sean exactamente.

Para solucionar esto, `assertEquals()` nos permite especificar un **margen de error** o **delta**. En lugar de verificar si `valor1` es **exactamente igual** a `valor2`, verifica si la **diferencia absoluta** entre `valor1` y `valor2` es **menor o igual** al `delta`.

#### 2. **Ejemplo:**

```java
public void testsquareroot(){
    // Asumiendo que Calculator.squareroot(2) calcula la raíz cuadrada de 2
    assertEquals(Calculator.squareroot(2), 1.4142, 0.001); // ¡Esto pasará!
    assertEquals(Calculator.squareroot(2), 1.4142, 0.000000000001); // ¡Esto podría fallar!
}
```

**Explicación del ejemplo:**

- **`assertEquals(Calculator.squareroot(2), 1.4142, 0.001);`:** Aquí, estamos comparando el resultado de `Calculator.squareroot(2)` con el valor `1.4142`, y estamos usando un `delta` de `0.001`. Esto significa que la prueba **pasará** si la diferencia absoluta entre el resultado de la raíz cuadrada y `1.4142` es **menor o igual a 0.001**. Como la raíz cuadrada de 2 es aproximadamente 1.41421356..., la diferencia con 1.4142 es muy pequeña (menor que 0.001), por lo que la prueba **pasa**.
- **`assertEquals(Calculator.squareroot(2), 1.4142, 0.000000000001);`:** En este caso, el `delta` es mucho más pequeño (`0.000000000001`). Ahora, la prueba solo pasará si la diferencia es **extremadamente pequeña**. Es **probable** que esta prueba **falle**, porque `1.4142` no es una aproximación lo suficientemente precisa de la raíz cuadrada de 2 para un `delta` tan pequeño. La raíz cuadrada de 2 tiene más decimales (1.4142135623730951...), y la diferencia con `1.4142` podría ser mayor que `0.000000000001`.

#### 3. **Notas o advertencias:**

- **Importancia del `delta` para decimales:** **Siempre usa un `delta` al comparar números `float` o `double` en JUnit.** Si no lo haces, tus pruebas podrían fallar de forma inesperada debido a pequeños errores de redondeo, incluso si la lógica de tu código es correcta.
- **Elegir un `delta` adecuado:** El valor del `delta` debe ser **lo suficientemente pequeño** para detectar errores reales, pero **lo suficientemente grande** para tolerar los errores de redondeo esperados. La elección del `delta` depende de la precisión que necesites en tus cálculos y del contexto de tu aplicación. Un `delta` de `0.001` o `0.0001` suele ser adecuado para muchas situaciones, pero en algunos casos podrías necesitar un `delta` mayor o menor.
- **`assertEquals(esperado, actual, delta)`:** Recuerda que el orden de los argumentos en `assertEquals` con `delta` es: **valor esperado, valor actual, delta**.
