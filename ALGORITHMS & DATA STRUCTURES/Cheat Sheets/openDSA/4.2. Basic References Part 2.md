## A - Compartir (Sharing) y Alias (Aliases)

#### 1. **Definición:**

Cuando dos o más referencias apuntan al **mismo objeto** en memoria, decimos que están **compartiendo** ese objeto. Cada referencia se convierte en un **alias** de las demás, porque puedes usar cualquiera de ellas para acceder y modificar el mismo objeto.

#### 2. **Ejemplo:**

Volvamos al ejemplo anterior:

```java
Empleado empRef = new Empleado("John", 1000);
Empleado second = empRef; // 'second' ahora es un alias de 'empRef'
```

Aquí, tanto `empRef` como `second` son alias. Ambas apuntan al mismo objeto `Empleado`.

#### 3. **Beneficios de compartir:**

- **Comunicación eficiente:** Compartir objetos a través de referencias es una forma muy eficiente de que diferentes partes de tu programa (como diferentes métodos) trabajen con la misma información sin tener que copiarla. Imagina pasarle un documento a un compañero de trabajo dándole una copia (copia profunda) vs. decirle dónde está el documento original para que ambos lo vean (copia superficial/compartir). Compartir es más rápido y usa menos recursos.

#### 4. **Advertencia:**

- **Modificación conjunta:** Si modificas el objeto a través de un alias, ¡el cambio se verá reflejado a través de todos los demás alias! Esto puede ser útil, pero también puede causar errores si no lo tienes en cuenta.

## B - Copia Superficial (Shallow Copy) vs. Copia Profunda (Deep Copy)

#### 1. **¿Qué significa "copiar" en el contexto de referencias?**

Cuando hablamos de "copiar" objetos en Java (y en programación en general), hay dos formas principales de hacerlo, especialmente cuando involucran referencias: **copia superficial** y **copia profunda**.

#### 2. **Copia Superficial (Shallow Copy):**

- **Definición:** Una **copia superficial** significa copiar **solo la referencia**, no el objeto en sí. Es como copiar la dirección de una casa, no la casa entera.
- **Compartir objeto:** Después de una copia superficial, tanto la referencia original como la copia apuntan al **mismo objeto**.
- **Ejemplo:**

```java
Empleado empleadoOriginal = new Empleado("Ana", 60000);
Empleado copiaSuperficial = empleadoOriginal; // Copia superficial
```

En este ejemplo, `copiaSuperficial` es una copia superficial de `empleadoOriginal`. Ambas referencias apuntan al mismo objeto `Empleado`.

#### 3. **Copia Profunda (Deep Copy):**

- **Definición:** Una **copia profunda** significa crear un **nuevo objeto** que sea una copia **independiente** del objeto original, incluyendo todos sus datos. Es como construir una casa nueva exactamente igual a la original.
- **Objetos independientes:** Después de una copia profunda, la referencia original y la copia apuntan a **objetos diferentes** en la memoria, aunque tengan los mismos datos inicialmente.
- **Ejemplo (manual):**

```java
Empleado empleadoOriginal = new Empleado("Carlos", 70000);
Empleado copiaProfunda = new Empleado(empleadoOriginal.getName(), empleadoOriginal.getSalary()); // Copia profunda manual
```

Aquí, `copiaProfunda` es una copia profunda de `empleadoOriginal`. Hemos creado un **nuevo** objeto `Empleado` y le hemos copiado los datos de `empleadoOriginal`. Ahora son objetos separados.

#### 4. **Visualización:**

![image](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_static/Images/green_check.png) Saving... ![Error Saving](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_static/Images/warning.png)
Server Error
[Resubmit](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BasicPointers2.html#)

#### 5. **Ejemplo comparativo en código:**

```java
// Copia Superficial
Empleado firstEmployee = new Empleado("Sam", 50000);
Empleado shallowCopyEmployee = firstEmployee; // Copia superficial
shallowCopyEmployee.setName("John"); // Modificamos a través de la copia superficial
System.out.println(firstEmployee.getName()); // Imprime "John" (¡el original también cambió!)

// Copia Profunda
Empleado secondEmployee = new Empleado("Patrice", 80000);
Empleado deepCopyEmployee = new Empleado(secondEmployee.getName(), secondEmployee.getSalary()); // Copia profunda
deepCopyEmployee.setName("Jane"); // Modificamos la copia profunda
System.out.println(secondEmployee.getName()); // Imprime "Patrice" (¡el original no cambió!)
```

#### 6. **Notas o advertencias:**

- **Cuándo usar cada una:**
  - **Copia Superficial:** Útil cuando quieres que diferentes partes del código trabajen con el **mismo objeto**, compartiendo información y modificaciones. Es más rápida porque no copia el objeto.
  - **Copia Profunda:** Útil cuando quieres crear una **copia independiente** de un objeto, para que las modificaciones en la copia no afecten al original, y viceversa. Es más lenta porque crea un nuevo objeto y copia los datos.
- **Java por defecto:** En Java, cuando asignas objetos o los pasas como argumentos a métodos, por defecto se hace una **copia superficial** de las referencias. Si necesitas una copia profunda, generalmente tienes que implementarla manualmente (como en el ejemplo) o usar métodos específicos de algunas clases que ofrecen copia profunda.

## C - Comparación Superficial (Shallow Comparing) vs. Comparación Profunda (Deep Comparing)

#### 1. **¿Cómo comparamos objetos?**

Al igual que con la copia, al comparar objetos en Java, tenemos dos niveles de comparación: **superficial** y **profunda**.

#### 2. **Comparación Superficial (Shallow Comparing):**

- **Definición:** La **comparación superficial** verifica si dos referencias **apuntan al mismo objeto en memoria**. Compara las "flechas", no lo que señalan.
- **Operador `==`:** En Java, el operador `==` realiza una comparación superficial cuando se usa con referencias a objetos.
- **Ejemplo:**

```java
Empleado emp1 = new Empleado("Luis", 55000);
Empleado emp2 = emp1; // Copia superficial (alias)
Empleado emp3 = new Empleado("Luis", 55000); // Nuevo objeto con los mismos datos

System.out.println(emp1 == emp2); // Imprime "true" (apuntan al mismo objeto)
System.out.println(emp1 == emp3); // Imprime "false" (son objetos diferentes, aunque tengan los mismos datos)
```

#### 3. **Comparación Profunda (Deep Comparing):**

- **Definición:** La **comparación profunda** verifica si dos objetos tienen el **mismo valor**, es decir, si sus contenidos son iguales, incluso si son objetos diferentes en memoria.
- **Método `.equals()`:** En Java, el método `.equals()` (que debes implementar en tus clases si quieres comparación profunda personalizada) se usa para realizar comparación profunda. Para las clases `String`, `Integer`, etc., `.equals()` ya está implementado para comparar el valor.
- **Método `.compareTo()`:** Algunas clases (como `String`) también tienen el método `.compareTo()` que permite comparar el orden de los objetos (útil para ordenar). Devuelve 0 si son iguales en valor.
- **Ejemplo:**

```java
Empleado emp1 = new Empleado("Luis", 55000);
Empleado emp3 = new Empleado("Luis", 55000);

// Comparación profunda (necesitaríamos implementar .equals() en la clase Empleado para esto)
// Asumiendo que hemos implementado .equals() correctamente en Empleado:
// System.out.println(emp1.equals(emp3)); // Debería imprimir "true" si .equals() compara nombre y salario

String nombre1 = "Luis";
String nombre2 = new String("Luis"); // Objeto String diferente pero con el mismo valor

System.out.println(nombre1 == nombre2); // Imprime "false" (objetos String diferentes)
System.out.println(nombre1.equals(nombre2)); // Imprime "true" (mismo valor de cadena)
System.out.println(nombre1.compareTo(nombre2) == 0); // Imprime "true" (mismo valor de cadena)
```

#### 4. **Notas o advertencias:**

- **`==` vs. `.equals()`:** ¡Cuidado! Usar `==` para comparar objetos (no primitivos) casi siempre realiza una comparación superficial. Usa `.equals()` para comparación profunda (cuando esté disponible y correctamente implementada).
- **Implementar `.equals()`:** Si quieres que tus propias clases soporten comparación profunda con `.equals()`, ¡debes implementar el método `.equals()` en esas clases! Java no lo hace automáticamente para clases personalizadas.
- **Strings son especiales:** Para Strings, `.equals()` y `.compareTo()` ya están implementados para comparación profunda de contenido.

## D - Referencias "Malas" (Bad References)

#### 1. **Definición:**

Una **referencia "mala"** es una referencia que **no apunta a ningún objeto válido** en la memoria. Hay dos tipos principales de referencias "malas":

- **Referencias no inicializadas:** Cuando declaras una variable de referencia pero no le asignas un objeto ni `null` inicialmente. En Java, **Java inicializa automáticamente las referencias a `null`**, así que en Java puro, estrictamente hablando, no tendrás referencias "malas" no inicializadas en el sentido de "valor desconocido" como en otros lenguajes.
- **Referencias `null`:** Referencias a las que se les ha asignado explícitamente el valor `null`.

#### 2. **Problema con referencias "malas":**

El gran problema es que si intentas **dereferenciar** una referencia "mala" (ya sea `null` o, en otros lenguajes, no inicializada), ¡tu programa se bloqueará!

#### 3. **`NullPointerException` en Java:**

En Java, intentar dereferenciar una referencia `null` causa un error en tiempo de ejecución llamado **`NullPointerException`**. El programa se detiene inmediatamente y te muestra dónde ocurrió el error.

#### 4. **Ejemplo de código "malo":**

```java
Empleado badPointer; // Declaramos la referencia, pero no la inicializamos explícitamente (Java la inicializa a null)
// badPointer = new Empleado("Sam", 1000); // ¡Olvidamos crear el objeto Empleado!
System.out.println(badPointer.getName());  // ¡Error! NullPointerException aquí
```

#### 5. **Visualización del error:**

![image](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_static/Images/green_check.png) Saving... ![Error Saving](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_static/Images/warning.png)
Server Error
[Resubmit](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/BasicPointers2.html#)

#### 6. **Notas o advertencias:**

- **Java te ayuda:** Java es bastante bueno detectando errores de referencias `null` en tiempo de ejecución y te da un `NullPointerException` claro. Esto facilita la depuración en comparación con lenguajes como C/C++ donde un puntero "malo" podría causar comportamientos más impredecibles.
- **Inicialización es clave:** Asegúrate siempre de que tus referencias apunten a objetos válidos **antes** de intentar usarlas (dereferenciarlas). Crea el objeto con `new` y asigna la referencia para que apunte a él.
- **Comprobaciones de `null`:** Si existe la posibilidad de que una referencia sea `null` en algún punto de tu código, es una buena práctica comprobar si es `null` antes de dereferenciarla para evitar `NullPointerException` (como vimos en el ejemplo anterior con `if (otraReferencia != null) { ... }`).

## E - ¿Por qué son tan comunes los errores de referencias "malas"?

#### 1. **Simplicidad engañosa:**

Las reglas de las referencias en sí no son súper complicadas, pero los errores de referencias `null` (y similares) son **muy comunes** incluso para programadores experimentados. ¿Por qué?

#### 2. **Contraste con tipos primitivos:**

Una razón es la diferencia con los tipos de datos primitivos (como `int`, `float`, `boolean`). Con variables primitivas:

- Las declaras y puedes usarlas casi de inmediato.
- No tienes que preocuparte por "inicializarlas" en el mismo sentido que las referencias a objetos.
- Si les asignas un valor incorrecto, generalmente no causan que el programa se bloquee de repente con un error fatal.

#### 3. **Dos niveles de inicialización para referencias:**

Con las referencias a objetos, tienes que pensar en **dos niveles**:

1.  **La referencia en sí:** Declarar la variable de referencia (ej: `Empleado miEmpleado;`).
2.  **El objeto al que apunta:** Crear el objeto en la memoria y hacer que la referencia apunte a él (ej: `miEmpleado = new Empleado(...);`).

¡Es fácil olvidarse del paso 2! Declaras la referencia, pero te olvidas de crear el objeto y asignárselo. Entonces, la referencia se queda en `null` (o con un valor "malo" en otros lenguajes), y la primera vez que intentas usarla, ¡boom!, `NullPointerException`.

#### 4. **Entrenamiento con herramientas:**

Estamos "entrenados" por la facilidad de uso de las variables primitivas. Estamos acostumbrados a que las variables "simplemente funcionen" después de declararlas. Con las referencias, hay un paso adicional de inicialización del objeto que a veces se nos escapa.

#### 5. **Consejo:**

¡No te sorprendas si te encuentras con errores de referencias `null`! Es una experiencia común. La clave es:

- **Ser consciente** de que las referencias necesitan apuntar a objetos válidos.
- **Visualizar** mentalmente (o con dibujos) las referencias y los objetos en memoria para asegurarte de que todo está conectado correctamente.
- **Depurar** cuidadosamente cuando aparezca un `NullPointerException`. Generalmente, el error está en algún lugar donde olvidaste inicializar una referencia o donde una referencia se volvió `null` inesperadamente.
