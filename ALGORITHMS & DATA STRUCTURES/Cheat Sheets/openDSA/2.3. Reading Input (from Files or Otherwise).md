### **Paso 0: √çndice de Conceptos a Desglosar**

Antes de sumergirnos en el c√≥digo, aqu√≠ tienes el mapa del tesoro. He revisado el texto con lupa y he identificado cada pieza del rompecabezas que vamos a armar. Esta es nuestra lista de tareas, y te prometo que al final, cada uno de estos puntos ser√° tan familiar para ti como tu propio nombre.

1.  **La Clase `Scanner`**: Nuestra herramienta principal para leer texto.
2.  **Lectura por "Tokens" (Palabra por Palabra)**: El primer m√©todo para procesar un archivo, ideal para datos separados por espacios.
3.  **M√©todo `hasNext()`**: C√≥mo preguntar "¬øHay algo m√°s para leer?".
4.  **M√©todo `next()`**: C√≥mo leer la siguiente "palabra" o "token".
5.  **M√©todos Espec√≠ficos de Tipo (`nextDouble()`)**: C√≥mo leer datos que no son solo texto, como n√∫meros.
6.  **Lectura por L√≠neas Completas**: El segundo m√©todo, perfecto cuando los espacios son parte de tus datos.
7.  **M√©todo `hasNextLine()`**: C√≥mo preguntar "¬øQueda alguna l√≠nea por leer?".
8.  **M√©todo `nextLine()`**: C√≥mo leer la l√≠nea completa, con todo y sus espacios.
9.  **El Patr√≥n "Scanner dentro de un Scanner"**: Una t√©cnica ingeniosa para procesar una l√≠nea que acabas de leer.
10. **Cambiando el Separador con `useDelimiter()`**: C√≥mo decirle a `Scanner` que las cosas no se separan por espacios, sino por algo especial como `<SEP>`.
11. **Manejo de Errores con `try-catch`**: Nuestro cintur√≥n de seguridad para evitar que el programa se rompa si el archivo no existe.

---

## A - La Clase `Scanner`: Tu Lector Personal de Texto üî¥

#### 1. **Introducci√≥n:**

Imagina que tienes un libro (un archivo de texto) y necesitas que alguien te lo lea en voz alta, palabra por palabra o l√≠nea por l√≠nea; la clase `Scanner` es ese lector personal y obediente en Java.

#### 2. **Ejemplo:**

```java
import java.io.File;
import java.util.Scanner;
import java.io.FileNotFoundException; // Importante para el try-catch

public class LectorBasico {
    public static void main(String[] args) {
        // args[0] ser√≠a la ruta al archivo, por ejemplo "comandos.txt"
        String nombreArchivo = args[0];

        try {
            // 1. Creamos un objeto File que representa nuestro archivo.
            File archivo = new File(nombreArchivo);

            // 2. Le pasamos ese archivo a nuestro nuevo Scanner.
            // ¬°Ahora el Scanner est√° listo para leer!
            Scanner lector = new Scanner(archivo);

            System.out.println("¬°El Scanner est√° listo para leer el archivo!");

            // Aqu√≠ ir√≠a el c√≥digo para leer, que veremos en los siguientes puntos.

        } catch (FileNotFoundException e) {
            // Esto se ejecuta si el archivo no se encuentra. ¬°Muy importante!
            System.out.println("¬°Oh no! No pude encontrar el archivo: " + nombreArchivo);
            e.printStackTrace();
        }
    }
}
```

**Explicaci√≥n del ejemplo:**
Este c√≥digo es el punto de partida. No lee nada a√∫n, pero hace lo m√°s importante: prepara al `Scanner`. Primero, le decimos d√≥nde est√° el archivo con `new File(nombreArchivo)`. Luego, creamos nuestro `Scanner` y le "entregamos" ese archivo. A partir de ese momento, el objeto `lector` tiene la capacidad de leer el contenido del archivo. Lo envolvemos en un bloque `try-catch` por si acaso el archivo no existe; es una pr√°ctica de programaci√≥n segura que nos evita errores inesperados.

#### 3. **Desarrollo**:

La clase `Scanner` es tu navaja suiza para "parsear" (analizar y descomponer) texto. No solo lee archivos, ¬°tambi√©n puede leer lo que un usuario escribe en la consola o incluso el texto de una variable `String`! Su trabajo es dividir un flujo de texto en pedacitos manejables llamados "tokens". Por defecto, considera que cualquier espacio en blanco (espacios, tabulaciones, saltos de l√≠nea) es un separador, pero como veremos, podemos cambiar esa regla a nuestro antojo.

üî¥ **Fundamental**: Es imposible (o al menos, incre√≠blemente dif√≠cil y poco pr√°ctico) procesar entradas de texto estructurado en Java sin conocer `Scanner`. Es una de las primeras herramientas que aprendes para que tus programas puedan interactuar con el mundo exterior a trav√©s de archivos o la consola. Es la puerta de entrada de los datos a tu programa.

## B - Lectura por "Tokens" (Palabra por Palabra) üü°

#### 1. **Introducci√≥n:**

Este es el modo de lectura m√°s simple del `Scanner`: avanza por el texto y te entrega cada trozo de informaci√≥n que est√© separado por un espacio, como si leyera palabra por palabra.

#### 2. **Ejemplo:**

Imagina un archivo `comandos.txt` con el siguiente contenido:
`add 10.5 25.0 PuntoA`
`delete 5.0 15.0`

```java
// Dentro del m√©todo beginParsing del texto original...
try {
    Scanner sc = new Scanner(new File("comandos.txt"));

    // Leemos el primer comando: "add"
    String cmd1 = sc.next(); // cmd1 ahora es "add"

    // Leemos los par√°metros de "add"
    double x1 = sc.nextDouble(); // x1 ahora es 10.5
    double y1 = sc.nextDouble(); // y1 ahora es 25.0
    String nombre = sc.next();   // nombre ahora es "PuntoA"

    System.out.println("Comando: " + cmd1 + ", X: " + x1 + ", Y: " + y1 + ", Nombre: " + nombre);

    // Ahora leemos el segundo comando: "delete"
    String cmd2 = sc.next(); // cmd2 ahora es "delete"

    // Leemos los par√°metros de "delete"
    double x2 = sc.nextDouble(); // x2 ahora es 5.0
    double y2 = sc.nextDouble(); // y2 ahora es 15.0

    System.out.println("Comando: " + cmd2 + ", X: " + x2 + ", Y: " + y2);

} catch (Exception e) {
    e.printStackTrace();
}
```

**Explicaci√≥n del ejemplo:**
El `Scanner` (`sc`) mira el archivo y ve `add 10.5 25.0 PuntoA ...`. Cada vez que llamamos a `sc.next()`, nos devuelve el siguiente "token" (la siguiente cadena de caracteres hasta un espacio). `sc.nextDouble()` hace lo mismo, pero es m√°s inteligente: convierte ese token a un n√∫mero de tipo `double`. F√≠jate c√≥mo el `Scanner` recuerda d√≥nde se qued√≥. Despu√©s de leer "PuntoA", su "cursor" imaginario est√° justo antes de "delete", listo para la siguiente lectura.

#### 3. **Desarrollo**:

Este m√©todo es perfecto cuando tu archivo de entrada tiene un formato predecible y simple, donde cada pieza de informaci√≥n est√° n√≠tidamente separada por espacios. El `Scanner` usa un "delimitador" (un separador) para saber d√≥nde termina un token y empieza el siguiente. Por defecto, ese delimitador es cualquier espacio en blanco. El c√≥digo del texto original usa un bucle `while(sc.hasNext())` y un `switch` para hacer esto de forma repetitiva y elegante, procesando un archivo entero sin saber de antemano cu√°ntos comandos tiene.

üü° **Importante**: Es una t√©cnica muy com√∫n para archivos de configuraci√≥n o de datos simples. Aunque no es tan flexible como la lectura por l√≠neas para datos complejos (como nombres con espacios), es r√°pida, f√°cil de implementar y muy eficiente para los casos de uso correctos.

## C - `hasNext()` vs. `hasNextLine()`: El Arte de Preguntar Antes de Leer üü°

#### 1. **Introducci√≥n:**

Estos m√©todos son los guardianes de tu `Scanner`; te permiten preguntar de forma segura si hay m√°s contenido para leer antes de intentar tomarlo, evitando as√≠ que tu programa se rompa.

#### 2. **Ejemplo:**

Imagina un archivo `lista.txt`:
`manzana`
`pera`
` `
`naranja`

```java
// ... dentro de un try-catch ...
Scanner sc = new Scanner(new File("lista.txt"));

// hasNext() se usa para leer token por token
System.out.println("--- Leyendo con hasNext() ---");
while (sc.hasNext()) { // ¬øHay un pr√≥ximo token? (S√≠: "manzana") (S√≠: "pera") (S√≠: "naranja")
    String fruta = sc.next();
    System.out.println("Token encontrado: " + fruta);
}
// OJO: hasNext() se salta las l√≠neas vac√≠as porque no contienen "tokens".

// Necesitamos un nuevo Scanner para releer el archivo
sc = new Scanner(new File("lista.txt"));

// hasNextLine() se usa para leer l√≠nea por l√≠nea
System.out.println("\n--- Leyendo con hasNextLine() ---");
while (sc.hasNextLine()) { // ¬øHay una pr√≥xima l√≠nea? (S√≠) (S√≠) (S√≠, la vac√≠a) (S√≠)
    String linea = sc.nextLine();
    System.out.println("L√≠nea encontrada: [" + linea + "]");
}
```

**Explicaci√≥n del ejemplo:**
El primer bucle usa `hasNext()`. Pregunta: "¬øHay otro grupo de caracteres que no sea un espacio?". Por eso encuentra "manzana", "pera" y "naranja", pero ignora por completo la l√≠nea vac√≠a.

El segundo bucle usa `hasNextLine()`. Pregunta: "¬øHay alguna l√≠nea m√°s abajo, incluso si est√° vac√≠a?". Por eso procesa las cuatro l√≠neas, incluyendo la que no tiene nada. Usamos `[` y `]` para que veas claramente la l√≠nea vac√≠a en la salida.

#### 3. **Desarrollo**:

¬°Esta es una de las mayores fuentes de confusi√≥n para los principiantes! Aqu√≠ est√° la diferencia, meridianamente clara:

- `hasNext()`: Te dice `true` si hay al menos un "token" m√°s para leer. Un token es una secuencia de caracteres separada por un delimitador (espacio por defecto). Ignorar√° cualquier cantidad de espacios o l√≠neas vac√≠as hasta encontrar el siguiente token.
- `hasNextLine()`: Te dice `true` si hay una l√≠nea m√°s en el archivo. Una l√≠nea existe hasta que encuentras un car√°cter de "salto de l√≠nea" (`\n`). Una l√≠nea puede estar completamente vac√≠a y `hasNextLine()` aun as√≠ te dir√° `true`.

**¬øCu√°ndo usar cu√°l?**

- Usa `while (sc.hasNext())` cuando est√©s procesando el archivo **token por token** con `sc.next()`, `sc.nextInt()`, etc. (como en el primer ejemplo del texto original).
- Usa `while (sc.hasNextLine())` cuando tu estrategia sea procesar el archivo **l√≠nea por l√≠nea** con `sc.nextLine()` (como en el segundo ejemplo del texto original).

Mezclarlos sin cuidado puede llevar a resultados muy extra√±os. ¬°Mi consejo paranoico es: elige una estrategia (tokens o l√≠neas) y qu√©date con ella!

üü° **Importante**: Usar el m√©todo `has...()` correcto es crucial para que tus bucles de lectura funcionen como esperas. No preguntar antes de leer (`next()` o `nextLine()`) es como saltar a una piscina sin saber si tiene agua: probablemente acabes con un error (`NoSuchElementException`).

## D - `next()` vs. `nextLine()`: La Batalla por los Espacios üü°

#### 1. **Introducci√≥n:**

Ambos m√©todos leen datos, pero `next()` se detiene en el primer espacio que encuentra, mientras que `nextLine()` se lleva la l√≠nea entera, con espacios y todo, hasta el final.

#### 2. **Ejemplo:**

Imagina que el usuario escribe en la consola: `remove artist The Rolling Stones`

```java
Scanner scancmd = new Scanner("remove artist The Rolling Stones");

// --- Intento 1: Usando solo next() ---
String comando = scancmd.next(); // Lee "remove"
String tipo = scancmd.next();    // Lee "artist"
String nombre = scancmd.next();  // ¬°ERROR! Lee solo "The". "Rolling" y "Stones" se quedan atr√°s.

System.out.println("Comando: " + comando);
System.out.println("Tipo: " + tipo);
System.out.println("Nombre (mal le√≠do): " + nombre); // Salida: The

// --- Intento 2: La forma correcta ---
scancmd = new Scanner("remove artist The Rolling Stones"); // Reiniciamos el scanner

String comando2 = scancmd.next(); // Lee "remove"
String tipo2 = scancmd.next();    // Lee "artist"
String nombreCompleto = scancmd.nextLine(); // ¬°CORRECTO! Lee " The Rolling Stones"

// Ojo al espacio inicial. nextLine() lee DESDE donde se qued√≥ next().
// Usamos .trim() para quitarlo.
System.out.println("\nComando: " + comando2);
System.out.println("Tipo: " + tipo2);
System.out.println("Nombre (bien le√≠do): " + nombreCompleto.trim()); // Salida: The Rolling Stones
```

**Explicaci√≥n del ejemplo:**
En el primer intento, `next()` es como un ni√±o que come galletas: toma una ("The") y deja el resto. No sirve para nombres de artistas o canciones que contengan espacios.

En el segundo intento, despu√©s de usar `next()` para obtener las primeras dos palabras, usamos `nextLine()`. Este m√©todo es como una aspiradora: succiona todo lo que queda en la l√≠nea, desde la posici√≥n actual hasta el final. Por eso captura " The Rolling Stones" perfectamente. El m√©todo `.trim()` es un peque√±o truco para eliminar ese espacio molesto que queda al principio.

#### 3. **Desarrollo**:

Esta es LA diferencia clave que debes grabar a fuego en tu mente.

- `next()`: Lee el **pr√≥ximo token**. Se salta los delimitadores (espacios) al principio, lee hasta que encuentra el siguiente delimitador y se detiene, dejando el "cursor" justo despu√©s del token que ley√≥.
- `nextLine()`: Lee **desde la posici√≥n actual del cursor hasta el pr√≥ximo salto de l√≠nea**. No le importan los espacios, se los lleva todos. Despu√©s de leer, mueve el cursor al inicio de la siguiente l√≠nea.

**La trampa mortal:** ¬°Cuidado al mezclar `nextInt()`, `nextDouble()`, etc., con `nextLine()`! Los m√©todos como `nextInt()` leen el n√∫mero, pero dejan el "salto de l√≠nea" (`\n`) en el b√∫fer. Si despu√©s llamas a `nextLine()`, este leer√° ese salto de l√≠nea vac√≠o y te devolver√° una cadena vac√≠a, ¬°causando un caos en tu l√≥gica! El segundo ejemplo del texto original evita esto de forma muy inteligente, como veremos ahora.

üü° **Importante**: Entender esta diferencia es fundamental para no pasar horas depurando tu c√≥digo. Si necesitas leer datos que pueden contener espacios (nombres, frases, etc.), `nextLine()` es tu mejor amigo.

## E - El Patr√≥n "Scanner dentro de un Scanner": Procesando L√≠neas con Precisi√≥n Quir√∫rgica üîµ

#### 1. **Introducci√≥n:**

Esta es una t√©cnica avanzada y s√∫per √∫til: usas un primer `Scanner` para leer un archivo l√≠nea por l√≠nea, y para cada l√≠nea que obtienes, creas un _segundo_ `Scanner` para analizar √∫nicamente el contenido de esa l√≠nea.

#### 2. **Ejemplo:**

```java
// Fragmento del m√©todo beginParsingByLine del texto original
String filename = "comandos_complejos.txt";
try {
   // Scanner 1: Lee el ARCHIVO, l√≠nea por l√≠nea
   Scanner sc = new Scanner(new File(filename));
   Scanner scancmd; // Declaramos el segundo scanner aqu√≠

   while(sc.hasNextLine()) { // Mientras haya l√≠neas en el archivo...
      String line = sc.nextLine(); // Leemos una l√≠nea completa, ej: "remove artist The Beatles"

      // Scanner 2: Nace para leer solo la L√çNEA que acabamos de capturar
      scancmd = new Scanner(line);

      String cmd = scancmd.next(); // El 2do scanner lee "remove" de la variable 'line'

      if (cmd.equals("remove")) {
          String type = scancmd.next(); // El 2do scanner lee "artist"
          String token = scancmd.nextLine().trim(); // El 2do scanner lee el resto: "The Beatles"
          System.out.println("Comando 'remove' para el " + type + ": " + token);
      }
      // Aqu√≠ ir√≠an los otros comandos (insert, print...)
   }
} catch (Exception e) {
   e.printStackTrace();
}
```

**Explicaci√≥n del ejemplo:**
Piensa en `sc` como el bibliotecario que te trae un libro entero (una l√≠nea del archivo). Luego, `scancmd` es una lupa con la que examinas solo esa p√°gina (esa l√≠nea), palabra por palabra.

1.  `sc.nextLine()` nos da la cadena `"remove artist The Beatles"`.
2.  Creamos `scancmd = new Scanner("remove artist The Beatles")`. Este nuevo `Scanner` no sabe nada del archivo, solo conoce esa cadena.
3.  Ahora podemos usar `next()` y `nextLine()` sobre `scancmd` para desmenuzar esa l√≠nea espec√≠fica sin afectar la lectura principal del archivo.

Esto resuelve elegantemente el problema de mezclar `next()` y `nextLine()` que mencionamos antes, porque cada l√≠nea se procesa con un `Scanner` fresco y limpio.

#### 3. **Desarrollo**:

Esta estrategia combina lo mejor de ambos mundos. La lectura l√≠nea por l√≠nea (`sc.nextLine()`) te permite manejar datos que contienen espacios, como t√≠tulos de canciones o nombres de artistas. Una vez que tienes la l√≠nea aislada, usar un segundo `Scanner` sobre ella te da de nuevo la comodidad de la lectura por tokens (`scancmd.next()`) para extraer las partes fijas como el comando (`remove`) o el tipo (`artist`). Es una forma robusta y clara de analizar entradas complejas.

üîµ **Espec√≠fico**: No lo usar√°s todos los d√≠as, pero para analizar archivos de comandos o registros (logs) donde cada l√≠nea es una entidad autocontenida con varias partes, este patr√≥n es oro puro. Es una se√±al de que est√°s empezando a pensar como un programador m√°s experimentado.

## F - `useDelimiter()`: Cambiando las Reglas del Juego üîµ

#### 1. **Introducci√≥n:**

Este m√©todo te da el poder de decirle al `Scanner` que deje de usar los espacios como separadores y utilice cualquier otra cosa que t√∫ definas, como una coma, un punto y coma, o una cadena de texto especial como `<SEP>`.

#### 2. **Ejemplo:**

Imagina un archivo `canciones.txt` con el formato: `Artista<SEP>T√≠tulo de la Canci√≥n`
`Queen<SEP>Bohemian Rhapsody`
`Nirvana<SEP>Smells Like Teen Spirit`

```java
// Dentro del bucle while del patr√≥n "Scanner-dentro-de-Scanner"
String line = "Queen<SEP>Bohemian Rhapsody"; // Simulamos haber le√≠do esta l√≠nea
Scanner scancmd = new Scanner(line);

// ¬°Aqu√≠ est√° la magia!
// Le decimos al scanner: "Olvida los espacios. Tu nuevo separador es '<SEP>'."
scancmd.useDelimiter("<SEP>");

String artist = scancmd.next(); // Lee todo hasta encontrar "<SEP>" -> "Queen"
String song = scancmd.next();   // Lee el resto -> "Bohemian Rhapsody"

System.out.println("Artista: " + artist);
System.out.println("Canci√≥n: " + song);
```

**Explicaci√≥n del ejemplo:**
Normalmente, si hici√©ramos `scancmd.next()` sobre esa l√≠nea, nos devolver√≠a "Queen<SEP>Bohemian". ¬°Un desastre! Pero al llamar a `scancmd.useDelimiter("<SEP>")`, cambiamos las reglas. Ahora el `Scanner` ignora por completo los espacios dentro del t√≠tulo de la canci√≥n. Su √∫nica misi√≥n es buscar la cadena `<SEP>`. Todo lo que est√° antes es el primer token, y todo lo que est√° despu√©s es el segundo. Esto nos permite tener espacios en nuestros datos sin que el `Scanner` se confunda.

#### 3. **Desarrollo**:

Un "delimitador" es simplemente el car√°cter o la cadena de caracteres que marca el l√≠mite entre dos piezas de datos. El delimitador por defecto es `\s+`, una expresi√≥n regular que significa "uno o m√°s caracteres de espacio en blanco".

El m√©todo `useDelimiter()` es la soluci√≥n perfecta cuando los datos que necesitas leer pueden contener espacios, pero tienes un separador √∫nico y fiable. El ejemplo del texto original con `<SEP>` es brillante porque es muy improbable que el nombre de un artista o una canci√≥n contenga esa secuencia exacta de caracteres, lo que lo convierte en un separador robusto y seguro.

üîµ **Espec√≠fico**: Al igual que el patr√≥n anterior, no es para el d√≠a a d√≠a. Pero cuando te enfrentas a formatos de datos no est√°ndar, como archivos CSV (separados por comas) o formatos personalizados como el del ejemplo, saber que puedes cambiar el delimitador te salvar√° de escribir c√≥digo de an√°lisis manual muy complicado.

## G - `try-catch`: Tu Red de Seguridad Anti-Cat√°strofes üî¥

#### 1. **Introducci√≥n:**

Este bloque de c√≥digo es tu plan de contingencia: le dices a Java "intenta (`try`) hacer esta operaci√≥n riesgosa (como abrir un archivo), y si algo sale mal, no rompas el programa, sino que atr√°palo (`catch`) y ejecuta este c√≥digo de emergencia".

#### 2. **Ejemplo:**

```java
public static void beginParsing(String filename) {
    try {
        // --- C√ìDIGO PELIGROSO ---
        // La creaci√≥n del Scanner puede fallar si 'filename' no existe.
        // Las llamadas a sc.next(), sc.nextDouble() pueden fallar si el
        // archivo est√° mal formateado (ej: se espera un n√∫mero y hay texto).
        Scanner sc = new Scanner(new File(filename));

        while(sc.hasNext()) {
            // ... todo el c√≥digo de lectura va aqu√≠ ...
            System.out.println("Leyendo un token...");
            sc.next();
        }
        System.out.println("Lectura finalizada con √©xito.");

    } catch (Exception e) {
        // --- PLAN DE EMERGENCIA ---
        // Si CUALQUIER COSA en el bloque 'try' falla, el programa salta
        // directamente aqu√≠. No se rompe, sino que ejecuta esto.
        System.out.println("¬°ERROR GRAVE! Algo sali√≥ mal durante la lectura del archivo.");
        System.out.println("Puede que el archivo no exista o est√© da√±ado.");

        // e.printStackTrace() es s√∫per √∫til para depurar.
        // Imprime el rastro exacto del error en la consola.
        e.printStackTrace();
    }
}
```

**Explicaci√≥n del ejemplo:**
Todo el c√≥digo que interact√∫a con el archivo est√° dentro del bloque `try`. Si le pasamos un nombre de archivo que no existe, `new Scanner(new File(filename))` lanzar√° una excepci√≥n (`FileNotFoundException`). Sin el `try-catch`, el programa se detendr√≠a con un feo mensaje de error. Con √©l, la ejecuci√≥n salta limpiamente al bloque `catch`, imprime nuestro mensaje amigable y luego contin√∫a (o termina, en este caso) de forma controlada. El texto original advierte que el c√≥digo no es "seguro" porque asume que el formato es correcto; un `try-catch` m√°s robusto podr√≠a tener bloques `catch` espec√≠ficos para diferentes tipos de errores (ej: `InputMismatchException` si `nextDouble()` falla).

#### 3. **Desarrollo**:

Cualquier operaci√≥n que dependa de un recurso externo (un archivo, una conexi√≥n de red, la entrada del usuario) es inherentemente impredecible. El archivo podr√≠a haber sido borrado, la red podr√≠a caerse, el usuario podr√≠a escribir "hola" donde se esperaba un n√∫mero. Las excepciones son el mecanismo de Java para manejar estos "eventos excepcionales". El bloque `try-catch` es la herramienta que usas para gestionar estas excepciones. Ignorarlo es como conducir sin cintur√≥n de seguridad: todo va bien hasta que deja de ir bien, y entonces las consecuencias son graves.

üî¥ **Fundamental**: El manejo de excepciones no es opcional en la programaci√≥n profesional, especialmente en operaciones de entrada/salida (I/O) como la lectura de archivos. Es un concepto absolutamente esencial para crear programas robustos y fiables que no se rompan a la primera de cambio.
