## A - Programación Orientada a Objetos (Object-Oriented Programming - OOP)

#### 1. **Definición:**

La Programación Orientada a Objetos (POO), o en inglés Object-Oriented Programming (OOP), es una forma de programar donde organizamos nuestro código en "objetos". Imagina que cada objeto es como una caja que contiene tanto datos (información) como acciones (cosas que puede hacer). La clave es que las acciones de un objeto están diseñadas para trabajar con sus propios datos.

#### 2. **Ejemplo:**

Piensa en un "coche". Un coche tiene datos como su color, marca, velocidad actual, y acciones como acelerar, frenar, girar. En POO, podríamos crear un "objeto coche" que guarde toda esta información y tenga "métodos" (acciones) para simular estas acciones.

**Explicación del ejemplo:**
En lugar de tener datos del coche por un lado y funciones para manipular el coche por otro (como en la programación tradicional), la POO los junta. Esto hace que el código sea más organizado y fácil de entender, ¡como tener todo lo relacionado con el coche en su propia "caja"!

#### 3. **Notas o advertencias:**

- La POO es una forma de organizar tu código, no un lenguaje de programación en sí mismo. Muchos lenguajes como Java, Python, C++ soportan la POO.
- La idea principal es modelar el mundo real en código, haciendo que los programas sean más intuitivos y manejables, especialmente para proyectos grandes.

## B - Objetos (Objects)

#### 1. **Definición:**

Un objeto es la pieza fundamental de la POO. Piensa en él como una "cosa" que tiene dos partes principales:

- **Datos (atributos o campos):** Son las características o información que describen al objeto. Volviendo al ejemplo del coche, el color, la marca y la velocidad serían atributos.
- **Código (procedimientos o métodos):** Son las acciones que el objeto puede realizar o las cosas que se pueden hacer con él. En el coche, acelerar, frenar y girar serían métodos.

En resumen, un objeto es una estructura de datos que contiene datos y el código que opera sobre esos datos.

#### 2. **Ejemplo:**

Imagina un objeto "Perro".

- **Atributos:** raza, color de pelo, edad, nombre.
- **Métodos:** ladrar(), correr(), comer(), dormir().

**Explicación del ejemplo:**
El objeto "Perro" encapsula (guarda junto) tanto la información sobre un perro (atributos) como las cosas que un perro puede hacer (métodos). Los métodos son la forma en que interactuamos con los datos del objeto.

#### 3. **Notas o advertencias:**

- En muchos lenguajes de POO, los objetos son "instancias" de "clases". Piensa en la clase como un "molde" o "plantilla" para crear objetos. (Ver concepto C - Clases)
- La clave de los objetos es que sus métodos son los que controlan cómo se acceden y modifican sus datos. Esto es importante para la "encapsulación" (Ver concepto D - Encapsulación).

## C - Clases (Classes)

#### 1. **Definición:**

Una clase es como un "plano" o "plantilla" para crear objetos. Define la estructura y el comportamiento que tendrán los objetos de ese tipo. Piensa en una clase como la receta para hacer galletas, y los objetos son las galletas que horneas usando esa receta.

- La clase especifica qué tipo de datos (atributos) tendrá cada objeto.
- La clase también define qué acciones (métodos) podrán realizar los objetos.

#### 2. **Ejemplo:**

Si tenemos una clase llamada `Coche`, esta clase definiría:

- **Atributos** que todo coche tendrá: `color`, `marca`, `modelo`, `velocidadMaxima`.
- **Métodos** que todo coche podrá hacer: `acelerar()`, `frenar()`, `girar()`.

Luego, podemos crear objetos _específicos_ de la clase `Coche`, como `miCoche = new Coche()`, `cocheDeJuan = new Coche()`. Cada uno de estos objetos será un coche individual con sus propios valores para los atributos (color rojo, marca "Toyota", etc.), pero todos seguirán el mismo "plano" definido por la clase `Coche`.

**Explicación del ejemplo:**
La clase `Coche` es la idea general de "coche", mientras que `miCoche` y `cocheDeJuan` son coches _reales_ y concretos, creados a partir de esa idea.

#### 3. **Notas o advertencias:**

- Los objetos son "instancias" de clases. Creas objetos _usando_ clases.
- La clase define el _tipo_ de objeto. Por ejemplo, todos los objetos creados a partir de la clase `Coche` son de tipo "Coche".
- En la mayoría de los lenguajes de POO populares, trabajamos principalmente con clases para definir nuestros objetos.

## D - Encapsulación (Encapsulation)

#### 1. **Definición:**

La encapsulación es como poner una barrera protectora alrededor de los datos de un objeto. Significa que los datos internos de un objeto (sus atributos) están "ocultos" y solo se puede acceder a ellos y modificarlos a través de métodos especiales definidos por la clase.

Piensa en una cápsula medicinal: el medicamento (los datos) está dentro de la cápsula (el objeto) y solo puedes interactuar con él de la manera en que la cápsula lo permite (a través de los métodos).

#### 2. **Ejemplo:**

Imagina una clase `CuentaBancaria`. Queremos proteger el saldo de la cuenta para que no se pueda cambiar directamente desde fuera de la clase, evitando errores como poner saldos negativos sin control.

**Ejemplo MALO (sin encapsulación):**

```java
class CuentaBancariaMala {
  public double saldo; // ¡Público! ¡Cualquiera puede cambiarlo!
}

// ... en otro lugar del código ...
CuentaBancariaMala miCuenta = new CuentaBancariaMala();
miCuenta.saldo = -1000; // ¡Ups! Saldo negativo sin control.
```

**Ejemplo BUENO (con encapsulación):**

```java
class CuentaBancaria {
  private double saldo; // ¡Privado! ¡Solo accesible desde dentro de la clase!

  public double obtenerSaldo() { // Método para ver el saldo (acceso controlado)
    return saldo;
  }

  public void depositar(double cantidad) { // Método para depositar (modificación controlada)
    if (cantidad > 0) {
      saldo += cantidad;
    } else {
      System.out.println("Cantidad inválida para depósito.");
    }
  }

  public void retirar(double cantidad) { // Método para retirar (modificación controlada)
    if (cantidad > 0 && saldo >= cantidad) {
      saldo -= cantidad;
    } else {
      System.out.println("Retiro inválido.");
    }
  }
}

// ... en otro lugar del código ...
CuentaBancaria miCuenta = new CuentaBancaria();
// miCuenta.saldo = -1000; // ¡Error! 'saldo' es privado.
miCuenta.depositar(500); // ¡Bien! Depósito controlado.
System.out.println("Saldo: " + miCuenta.obtenerSaldo()); // ¡Bien! Acceso controlado.
```

**Explicación del ejemplo:**
En el ejemplo bueno, `saldo` es `private`, lo que significa que solo los métodos _dentro_ de la clase `CuentaBancaria` pueden acceder a él directamente. Para interactuar con el saldo desde fuera, debemos usar los métodos `obtenerSaldo()`, `depositar()`, y `retirar()`. Estos métodos pueden incluir lógica para asegurar que las operaciones sean válidas (como no permitir depósitos negativos o retiros que dejen el saldo en negativo).

#### 3. **Notas o advertencias:**

- La encapsulación se logra usando modificadores de acceso como `private`, `public`, `protected` (dependiendo del lenguaje). `private` es el más común para la encapsulación fuerte.
- La encapsulación ayuda a:
  - **Proteger la integridad de los datos:** Evita que los datos se modifiquen de manera incorrecta o inesperada.
  - **Facilitar el mantenimiento y la refactorización:** Puedes cambiar la implementación interna de una clase sin romper el código que la usa, siempre y cuando mantengas la misma interfaz pública (los métodos públicos).
  - **Reducir la complejidad:** Oculta los detalles internos y presenta una interfaz simple y clara para usar el objeto.

## E - Herencia (Inheritance)

#### 1. **Definición:**

La herencia es un mecanismo que permite crear nuevas clases (clases "hijas" o "subclases") basadas en clases ya existentes (clases "padre" o "superclases"). La clase hija "hereda" automáticamente los atributos y métodos de la clase padre, y además puede añadir sus propios atributos y métodos, o modificar los heredados.

Piensa en la herencia biológica: un hijo hereda características de sus padres, pero también tiene sus propias características únicas.

#### 2. **Ejemplo:**

Imaginemos que tenemos una clase general `Vehiculo` con atributos como `marca`, `modelo`, `velocidad` y métodos como `acelerar()`, `frenar()`.

Ahora queremos crear clases más específicas como `Coche`, `Moto`, `Bicicleta`. Todas ellas son _tipos_ de `Vehiculo`. Podemos usar la herencia para que `Coche`, `Moto`, y `Bicicleta` hereden las características comunes de `Vehiculo` y luego añadir sus propias particularidades.

```java
class Vehiculo { // Clase padre
  String marca;
  String modelo;
  int velocidad;

  public void acelerar() {
    velocidad += 10;
    System.out.println("Vehículo acelerando. Velocidad actual: " + velocidad);
  }

  public void frenar() {
    velocidad -= 10;
    System.out.println("Vehículo frenando. Velocidad actual: " + velocidad);
  }
}

class Coche extends Vehiculo { // Clase hija que hereda de Vehiculo
  int numeroPuertas;

  public void abrirPuertas() {
    System.out.println("Abriendo " + numeroPuertas + " puertas del coche.");
  }
}

class Moto extends Vehiculo { // Clase hija que hereda de Vehiculo
  boolean tieneCasco;

  public void ponerCasco() {
    tieneCasco = true;
    System.out.println("Motociclista poniéndose el casco.");
  }
}

public class EjemploHerencia {
  public static void main(String[] args) {
    Coche miCoche = new Coche();
    miCoche.marca = "Toyota"; // Hereda de Vehiculo
    miCoche.modelo = "Corolla"; // Hereda de Vehiculo
    miCoche.numeroPuertas = 4; // Propio de Coche
    miCoche.acelerar(); // Hereda de Vehiculo
    miCoche.abrirPuertas(); // Propio de Coche

    Moto miMoto = new Moto();
    miMoto.marca = "Honda"; // Hereda de Vehiculo
    miMoto.modelo = "CBR"; // Hereda de Vehiculo
    miMoto.tieneCasco = false; // Propio de Moto
    miMoto.frenar(); // Hereda de Vehiculo
    miMoto.ponerCasco(); // Propio de Moto
  }
}
```

**Explicación del ejemplo:**
`Coche` y `Moto` _extienden_ (heredan de) `Vehiculo`. Esto significa que automáticamente tienen los atributos `marca`, `modelo`, `velocidad` y los métodos `acelerar()`, `frenar()` de `Vehiculo`. Además, cada clase hija puede añadir sus propios atributos y métodos específicos (como `numeroPuertas` en `Coche` y `tieneCasco` en `Moto`).

#### 3. **Notas o advertencias:**

- La herencia promueve la **reutilización de código**. Evitas tener que reescribir el mismo código para clases que son similares.
- La herencia crea una jerarquía de clases. Hay clases padre (superclases) y clases hijas (subclases).
- La herencia establece una relación "ES-UN" (IS-A). Un `Coche` _ES-UN_ `Vehiculo`, una `Moto` _ES-UNA_ `Vehiculo`.
- En Java y otros lenguajes, se usa la palabra clave `extends` para indicar la herencia de clases.

## F - Polimorfismo (Polymorphism)

#### 1. **Definición:**

Polimorfismo significa "muchas formas". En POO, se refiere a la capacidad de que un objeto o una acción se comporte de diferentes maneras dependiendo del contexto o del tipo de objeto. Hay dos tipos principales de polimorfismo:

- **Polimorfismo en tiempo de ejecución (Run-time polymorphism) o Polimorfismo de subtipo:** Permite que objetos de diferentes clases que comparten una misma clase padre sean tratados de manera uniforme a través de una interfaz común (la clase padre). La "forma" específica en que se comporta la acción se decide en tiempo de ejecución, dependiendo del tipo real del objeto.
- **Polimorfismo en tiempo de compilación (Compile-time polymorphism) o Sobrecarga de métodos (Method Overloading):** Permite tener varios métodos con el mismo nombre pero con diferentes "firmas" (diferente número o tipo de parámetros) dentro de la misma clase. El compilador decide qué método llamar en función de los argumentos que se le pasan en la llamada.

#### 2. **Ejemplo de Polimorfismo en tiempo de ejecución:**

Volviendo al ejemplo de `Vehiculo`, `Coche`, `Moto`. Imagina que queremos tener una función que "mostrar información" de cualquier tipo de vehículo. Podemos hacer esto usando polimorfismo.

```java
class Vehiculo { // Clase padre (como antes) ... }
class Coche extends Vehiculo { // Clase hija (como antes) ... }
class Moto extends Vehiculo { // Clase hija (como antes) ... }

class Bicicleta extends Vehiculo { // Nueva clase hija
    boolean tieneCanasta;

    @Override // Sobreescritura del método mostrarInformacion de Vehiculo
    public void mostrarInformacion() {
        System.out.println("Soy una Bicicleta marca " + marca + ", modelo " + modelo + (tieneCanasta ? " con canasta." : " sin canasta."));
    }
}


class Vehiculo {
    String marca;
    String modelo;
    int velocidad;

    public void acelerar() {
        velocidad += 10;
        System.out.println("Vehículo acelerando. Velocidad actual: " + velocidad);
    }

    public void frenar() {
        velocidad -= 10;
        System.out.println("Vehículo frenando. Velocidad actual: " + velocidad);
    }

    // Método para mostrar información (será polimórfico)
    public void mostrarInformacion() {
        System.out.println("Vehículo genérico marca " + marca + ", modelo " + modelo);
    }
}

class Coche extends Vehiculo {
    int numeroPuertas;

    public void abrirPuertas() {
        System.out.println("Abriendo " + numeroPuertas + " puertas del coche.");
    }

    @Override // Sobreescritura del método mostrarInformacion de Vehiculo
    public void mostrarInformacion() {
        System.out.println("Coche marca " + marca + ", modelo " + modelo + ", con " + numeroPuertas + " puertas.");
    }
}

class Moto extends Vehiculo {
    boolean tieneCasco;

    public void ponerCasco() {
        tieneCasco = true;
        System.out.println("Motociclista poniéndose el casco.");
    }

    @Override // Sobreescritura del método mostrarInformacion de Vehiculo
    public void mostrarInformacion() {
        System.out.println("Moto marca " + marca + ", modelo " + modelo + (tieneCasco ? ", con casco." : ", sin casco."));
    }
}


public class EjemploPolimorfismoRuntime {
    public static void main(String[] args) {
        Vehiculo[] vehiculos = new Vehiculo[3];
        vehiculos[0] = new Coche();
        vehiculos[0].marca = "Ford";
        vehiculos[0].modelo = "Focus";
        ((Coche) vehiculos[0]).numeroPuertas = 5; // Casting para acceder a atributos específicos de Coche

        vehiculos[1] = new Moto();
        vehiculos[1].marca = "Yamaha";
        vehiculos[1].modelo = "YZF";
        ((Moto) vehiculos[1]).tieneCasco = true; // Casting para acceder a atributos específicos de Moto

        vehiculos[2] = new Bicicleta();
        vehiculos[2].marca = "Giant";
        vehiculos[2].modelo = "Talon";
        ((Bicicleta) vehiculos[2]).tieneCanasta = false; // Casting para acceder a atributos específicos de Bicicleta


        for (Vehiculo vehiculo : vehiculos) {
            vehiculo.mostrarInformacion(); // ¡Polimorfismo en acción!
        }
    }
}
```

**Salida del ejemplo:**

```
Coche marca Ford, modelo Focus, con 5 puertas.
Moto marca Yamaha, modelo YZF, con casco.
Bicicleta marca Giant, modelo Talon sin canasta.
```

**Explicación del ejemplo de Polimorfismo en tiempo de ejecución:**
Tenemos un array de tipo `Vehiculo`, pero en realidad contiene objetos de tipo `Coche` y `Moto` y `Bicicleta` (que son subclases de `Vehiculo`). Cuando llamamos a `vehiculo.mostrarInformacion()`, se ejecuta la versión del método `mostrarInformacion()` _específica_ de la clase del objeto en ese momento (la versión de `Coche` si es un objeto `Coche`, la versión de `Moto` si es un objeto `Moto`, etc.). Esto es polimorfismo en tiempo de ejecución: la "forma" en que se comporta `mostrarInformacion()` cambia dependiendo del tipo de objeto _real_ en tiempo de ejecución. Esto se logra mediante la **sobrescritura de métodos** (`@Override` en Java) en las clases hijas.

#### 3. **Notas sobre Polimorfismo en tiempo de ejecución:**

- Se basa en la herencia y la **sobrescritura de métodos** (overriding).
- Permite escribir código más genérico y flexible que puede trabajar con objetos de diferentes clases de manera uniforme.
- La decisión de qué método ejecutar se toma en tiempo de ejecución, no en tiempo de compilación.

#### 4. **Ejemplo de Polimorfismo en tiempo de compilación (Sobrecarga de métodos):**

Imagina una clase `Calculadora` que tiene un método `sumar()`. Podemos sobrecargar el método `sumar()` para que funcione con diferentes tipos de datos o diferente número de argumentos.

```java
class Calculadora {
  public int sumar(int a, int b) { // Sumar dos enteros
    System.out.println("Sumando dos enteros");
    return a + b;
  }

  public double sumar(double a, double b) { // Sumar dos doubles
    System.out.println("Sumando dos doubles");
    return a + b;
  }

  public int sumar(int a, int b, int c) { // Sumar tres enteros
    System.out.println("Sumando tres enteros");
    return a + b + c;
  }
}

public class EjemploPolimorfismoCompiletime {
  public static void main(String[] args) {
    Calculadora calc = new Calculadora();
    System.out.println("Resultado 1: " + calc.sumar(5, 3)); // Llama a sumar(int, int)
    System.out.println("Resultado 2: " + calc.sumar(2.5, 7.1)); // Llama a sumar(double, double)
    System.out.println("Resultado 3: " + calc.sumar(1, 2, 3)); // Llama a sumar(int, int, int)
  }
}
```

**Salida del ejemplo:**

```
Sumando dos enteros
Resultado 1: 8
Sumando dos doubles
Resultado 2: 9.6
Sumando tres enteros
Resultado 3: 6
```

**Explicación del ejemplo de Polimorfismo en tiempo de compilación:**
Tenemos tres métodos `sumar()` en la clase `Calculadora`, todos con el mismo nombre, pero con diferentes "firmas" (parámetros diferentes). Cuando llamamos a `calc.sumar()`, el _compilador_ decide _en tiempo de compilación_ qué versión de `sumar()` llamar, basándose en los tipos y número de argumentos que le pasamos. Esto es sobrecarga de métodos o polimorfismo en tiempo de compilación.

#### 5. **Notas sobre Polimorfismo en tiempo de compilación:**

- Se logra definiendo múltiples métodos con el mismo nombre pero diferente lista de parámetros dentro de la misma clase.
- El compilador decide qué método llamar en tiempo de compilación, basándose en los argumentos de la llamada.
- Es útil para proporcionar diferentes formas de realizar la misma operación, adaptándose a diferentes tipos de datos o situaciones.

## G - Abstracción (Abstraction)

#### 1. **Definición:**

La abstracción se trata de simplificar la realidad, mostrando solo los detalles esenciales de un objeto y ocultando la complejidad interna. Es como crear un "modelo" simplificado del mundo real en tu código.

Piensa en el control remoto de la televisión. Tiene botones para cambiar de canal, subir el volumen, etc. No necesitas saber cómo funciona internamente el control remoto (los circuitos, la electrónica) para usarlo. El control remoto te proporciona una _abstracción_ de la funcionalidad de la televisión.

En POO, la abstracción se logra a través de clases e interfaces. Las clases encapsulan datos y métodos, y las interfaces definen un "contrato" de comportamiento sin especificar la implementación detallada.

#### 2. **Ejemplo:**

Volvamos al ejemplo del `Vehiculo`. Podemos abstraer la idea de "vehículo" a un nivel más alto, pensando en las acciones _generales_ que cualquier vehículo debe poder hacer, sin entrar en detalles específicos de cómo lo hace cada tipo de vehículo.

Podríamos definir una clase abstracta `VehiculoAbstracto` o una interfaz `InterfazVehiculo` que defina métodos como `arrancar()`, `detener()`, `obtenerCombustibleRestante()`. Luego, las clases concretas como `Coche`, `Moto`, `Bicicleta` _implementarían_ o _extenderían_ esta abstracción, proporcionando su propia implementación específica para cada método.

**Ejemplo con clase abstracta (Java):**

```java
abstract class VehiculoAbstracto { // Clase abstracta
  String marca;
  String modelo;

  public VehiculoAbstracto(String marca, String modelo) {
    this.marca = marca;
    this.modelo = modelo;
  }

  // Métodos abstractos (sin implementación en la clase abstracta)
  public abstract void arrancar();
  public abstract void detener();

  // Método concreto (con implementación en la clase abstracta)
  public void mostrarMarcaModelo() {
    System.out.println("Marca: " + marca + ", Modelo: " + modelo);
  }
}

class CocheConcreto extends VehiculoAbstracto { // Clase concreta que extiende la clase abstracta
  public CocheConcreto(String marca, String modelo) {
    super(marca, modelo); // Llama al constructor de la clase padre
  }

  @Override
  public void arrancar() { // Implementación específica para Coche
    System.out.println("Coche arrancando el motor.");
  }

  @Override
  public void detener() { // Implementación específica para Coche
    System.out.println("Coche deteniendo el motor.");
  }
}

class MotoConcreta extends VehiculoAbstracto { // Clase concreta que extiende la clase abstracta
  public MotoConcreta(String marca, String modelo) {
    super(marca, modelo); // Llama al constructor de la clase padre
  }

  @Override
  public void arrancar() { // Implementación específica para Moto
    System.out.println("Moto encendiendo el motor.");
  }

  @Override
  public void detener() { // Implementación específica para Moto
    System.out.println("Moto apagando el motor.");
  }
}

public class EjemploAbstraccion {
  public static void main(String[] args) {
    VehiculoAbstracto miCocheAbstracto = new CocheConcreto("BMW", "X5");
    miCocheAbstracto.mostrarMarcaModelo(); // Método concreto de la clase abstracta
    miCocheAbstracto.arrancar(); // Método abstracto, implementación de CocheConcreto
    miCocheAbstracto.detener(); // Método abstracto, implementación de CocheConcreto

    VehiculoAbstracto miMotoAbstracta = new MotoConcreta("Ducati", "Monster");
    miMotoAbstracta.mostrarMarcaModelo(); // Método concreto de la clase abstracta
    miMotoAbstracta.arrancar(); // Método abstracto, implementación de MotoConcreta
    miMotoAbstracta.detener(); // Método abstracto, implementación de MotoConcreta
  }
}
```

**Explicación del ejemplo de Abstracción:**
`VehiculoAbstracto` es una clase abstracta. No podemos crear objetos directamente de `VehiculoAbstracto`. Sirve como una "plantilla" o "contrato" para las clases concretas que la extienden (como `CocheConcreto` y `MotoConcreta`). `VehiculoAbstracto` define métodos abstractos (`arrancar()`, `detener()`) que _no tienen implementación_ en la clase abstracta. Las clases concretas _deben_ proporcionar una implementación para estos métodos abstractos. `VehiculoAbstracto` también puede tener métodos concretos (como `mostrarMarcaModelo()`) que las clases hijas heredan y pueden usar directamente.

La abstracción nos permite enfocarnos en el _qué_ (qué hace un vehículo en general: arrancar, detenerse) sin preocuparnos por el _cómo_ (cómo arranca un coche vs. cómo arranca una moto) a nivel de la clase abstracta. Las clases concretas se encargan de los detalles de implementación específicos.

#### 3. **Notas sobre Abstracción:**

- Se logra usando **clases abstractas** e **interfaces**.
- Las clases abstractas pueden tener métodos abstractos (sin implementación) y métodos concretos (con implementación). Las clases hijas deben implementar los métodos abstractos.
- Las interfaces definen un "contrato" de métodos que las clases que implementan la interfaz deben proporcionar.
- La abstracción ayuda a:
  - **Reducir la complejidad:** Oculta los detalles de implementación y presenta una vista simplificada de los objetos.
  - **Mejorar la organización y el diseño:** Define jerarquías de clases y interfaces que facilitan la comprensión y el mantenimiento del código.
  - **Promover la flexibilidad y la extensibilidad:** Permite cambiar la implementación interna sin afectar el código que usa la abstracción (siempre y cuando se mantenga el "contrato" definido por la clase abstracta o interfaz).
