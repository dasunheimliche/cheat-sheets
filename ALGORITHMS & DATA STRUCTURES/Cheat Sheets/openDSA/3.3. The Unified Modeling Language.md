## A - UML (Unified Modeling Language) - Lenguaje de Modelado Unificado

#### 1. **Definición:**

UML, o Lenguaje de Modelado Unificado, es como el lenguaje universal de los arquitectos de software. Es un conjunto de símbolos y diagramas gráficos estándar de la industria que se usan para describir y analizar cómo se construye un programa o sistema. Piensa en UML como un **plano** para construir software.

#### 2. **Ejemplo:**

Imagina que quieres construir una casa. Antes de poner un ladrillo, necesitas un plano, ¿verdad? Ese plano te muestra las habitaciones, las tuberías, la electricidad... ¡todo! UML es como ese plano, pero para el software. Nos ayuda a visualizar las diferentes partes de un programa y cómo encajan entre sí **antes** de escribir código.

#### 3. **Notas o advertencias:**

- **No es un lenguaje de programación:** UML no es para escribir código directamente, sino para **planificar** y **documentar** el diseño de tu software.
- **Estándar de la industria:** Es súper popular en el mundo del desarrollo de software, así que aprender UML te abrirá muchas puertas.
- **Unificación:** UML surgió de la unión de varios métodos de modelado que existían antes. ¡Se juntaron los mejores para crear algo aún mejor! Los capos detrás de esto fueron Grady Booch, Ivar Jacobson y James Rumbaugh, conocidos como "los tres amigos".

## B - Diagramas Estáticos vs. Dinámicos (Static vs Dynamic Diagrams)

#### 1. **Definición:**

En UML, los diagramas se dividen en dos grandes grupos, como si fueran dos vistas diferentes de un edificio:

- **Diagramas Estáticos (Static Diagrams):** Muestran la **estructura** del sistema, las partes que lo componen y cómo se relacionan entre sí, pero sin mostrar el comportamiento en el tiempo. Es como ver los cimientos y las paredes de la casa.
- **Diagramas Dinámicos (Dynamic Diagrams):** Muestran el **comportamiento** del sistema, cómo interactúan las diferentes partes y cómo cambia el sistema con el tiempo. Es como ver cómo la gente se mueve dentro de la casa y cómo se usan las habitaciones.

#### 2. **Ejemplo:**

- **Diagrama Estático:** Un diagrama de clases (Class Diagram) que muestra las diferentes clases de objetos en tu programa (como "Cliente", "Producto", "CarritoDeCompras") y cómo se conectan entre sí.
- **Diagrama Dinámico:** Un diagrama de secuencia (Sequence Diagram) que muestra cómo interactúan los objetos en un escenario específico, por ejemplo, cuando un cliente añade un producto al carrito de compras.

#### 3. **Notas o advertencias:**

- **Vistas complementarias:** Ambos tipos de diagramas son importantes y se complementan entre sí para dar una visión completa del sistema.
- **En este curso:** Nos centraremos principalmente en los **diagramas de clases** (estáticos), que son fundamentales para entender la estructura de un sistema orientado a objetos.

## C - Diagramas de Clases (Class Diagrams)

#### 1. **Definición:**

Un diagrama de clases es el diagrama UML más común y útil. Representa los **tipos de objetos** que hay en un sistema y las **relaciones estáticas** entre ellos. Es como un mapa de las clases y cómo se conectan en tu programa.

#### 2. **Ejemplo:**

Imagina que estás diseñando un sistema para una biblioteca. Un diagrama de clases podría mostrar clases como "Libro", "Autor", "Usuario", "Préstamo", y cómo se relacionan: un "Libro" tiene un "Autor", un "Usuario" puede "Préstamo" un "Libro", etc.

![_images/BackUMLclassMinimal.png](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_images/BackUMLclassMinimal.png)

#### 3. **Notas o advertencias:**

- **Base de la OO:** Los diagramas de clases son esenciales en la programación orientada a objetos (POO) porque visualizan la estructura de clases y objetos.
- **Comunicación:** Son una herramienta excelente para comunicar el diseño de tu software a otros miembros del equipo, clientes, etc.

## D - Clase en UML (Class in UML)

#### 1. **Definición:**

En UML, una clase se representa con un **rectángulo** dividido en compartimentos horizontales. Piensa en este rectángulo como la representación visual de un tipo de objeto en tu programa.

#### 2. **Ejemplo:**

![_images/BackUMLclass.png](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_images/BackUMLclass.png)

- **Compartimento superior:** El nombre de la clase. Por convención, empieza con mayúscula. Si la clase es abstracta (_AbstractClass_), el nombre se escribe en _cursiva_. ¡Este compartimento es obligatorio!
- **Compartimento central:** Lista de **atributos** de la clase. Los atributos son las características o datos que tiene un objeto de esa clase (ej: nombre, edad, color).
- **Compartimento inferior:** Lista de **métodos** de la clase. Los métodos son las acciones que puede realizar un objeto de esa clase (ej: caminar, hablar, comprar).

#### 3. **Notas o advertencias:**

- **Nombre es clave:** El nombre de la clase es lo más importante y siempre debe estar presente.
- **Convenciones:** Seguir las convenciones (mayúsculas, cursiva) hace que los diagramas sean más fáciles de entender para todos.

## E - Atributos y Métodos (Attributes and Methods)

#### 1. **Definición:**

Dentro de cada clase, definimos sus **atributos** (datos) y **métodos** (acciones). Además, indicamos la **visibilidad** de cada uno y si son **estáticos**.

#### 2. **Ejemplo:**

Volviendo al ejemplo de la clase "Persona":

- **Atributos:** `nombre`, `edad`, `direccion`. Podríamos decir que son las "características" de una persona.
- **Métodos:** `caminar()`, `hablar()`, `comer()`. Son las "acciones" que una persona puede realizar.

**Visibilidad:** Controla quién puede acceder a los atributos y métodos desde fuera de la clase. Se indica con un símbolo antes del nombre:

| Símbolo | Visibilidad   | Significado                                                           |
| :------ | :------------ | :-------------------------------------------------------------------- |
| `+`     | **Público**   | Se puede acceder desde cualquier parte.                               |
| `-`     | **Privado**   | Solo se puede acceder desde dentro de la propia clase.                |
| `#`     | **Protegido** | Se puede acceder desde la propia clase y sus subclases (herencia).    |
| `/`     | **Derivado**  | Se calcula a partir de otros atributos (no se almacena directamente). |
| `~`     | **Paquete**   | Visible dentro del mismo paquete (una forma de organizar las clases). |

**Miembros Estáticos (Static Members):** Pertenecen a la clase en sí, no a un objeto específico. Se indican subrayando el nombre. UML los llama "classifier members".

**Sintaxis UML para atributos:** `visibilidad nombre : tipo = valorPorDefecto`

Ejemplo: `+ nombre : String = "Sin nombre"` (atributo público llamado "nombre" de tipo String, con valor por defecto "Sin nombre").

#### 3. **Notas o advertencias:**

- **Encapsulamiento:** La visibilidad es clave para el encapsulamiento, un principio fundamental de la POO que protege los datos y controla cómo se accede a ellos.
- **Estáticos vs. Instancia:** Recuerda la diferencia entre miembros estáticos (de la clase) y miembros de instancia (de cada objeto).

## F - Relaciones de Herencia (Inheritance Relationships) - Generalización (Generalization)

#### 1. **Definición:**

La herencia (en UML se llama **Generalización**) es una relación que indica que una clase (subclase) **es un tipo de** otra clase más general (superclase). Es como decir que un "Perro" **es un tipo de** "Animal". La subclase hereda características (atributos y métodos) de la superclase.

#### 2. **Ejemplo:**

![_images/BackUMLgeneralization.png](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_images/BackUMLgeneralization.png)

En este ejemplo, "Estudiante" (Student) y "Profesor" (Teacher) son subclases de "Persona" (Person). Ambos son tipos de personas y comparten características comunes (como nombre, edad, etc.), pero también tienen características específicas (un estudiante tiene un número de estudiante, un profesor tiene un departamento).

**Representación UML:** Una flecha con **triángulo hueco** que apunta desde la **subclase** hacia la **superclase**. La flecha indica la dirección de la generalización: la subclase **ES UN** tipo de superclase.

#### 3. **Notas o advertencias:**

- **"ES-UN" (IS-A):** La clave para identificar la herencia es la relación "ES-UN". Un estudiante **ES UNA** persona.
- **Reutilización de código:** La herencia es muy útil para reutilizar código y organizar las clases de forma jerárquica.

## G - Relaciones de Realización (Realization Relationships) - Realización (Realization)

#### 1. **Definición:**

La realización (Realization) es una relación entre dos elementos de modelo, donde uno (el cliente) **realiza**, **implementa** o **ejecuta** el comportamiento que otro (el proveedor) **especifica**. Se usa principalmente para representar la **implementación de interfaces**.

#### 2. **Ejemplo:**

![_images/BackUMLrealization.png](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_images/BackUMLrealization.png)

Aquí, la clase "ClaseA" (ClassA) y "ClaseB" (ClassB) **realizan** la interfaz "InterfazC" (InterfaceC). La interfaz define un contrato, un conjunto de métodos que las clases que la implementan deben proporcionar.

**Representación UML:** Una línea **discontinua** con un **triángulo hueco** en el extremo de la **interfaz**. Si la línea va a un usuario de la interfaz (no un implementador), se usa una flecha normal en el extremo de la interfaz.

**Estereotipo <<interface>>:** Se usa `<<interface>>` encima del nombre de la clase para indicar que es una interfaz y no una clase normal. Los estereotipos en UML permiten añadir más información sobre el tipo o propósito de un elemento.

#### 3. **Notas o advertencias:**

- **Interfaces:** Las interfaces definen qué debe hacer algo, pero no cómo lo hace. Las clases que implementan la interfaz se encargan de definir el "cómo".
- **Contratos:** Las realizaciones representan contratos entre clases e interfaces.
- **Similitud con Generalización:** Ojo, se parece a la generalización (herencia) visualmente, pero la **realización** es para **interfaces**, mientras que la **generalización** es para **herencia entre clases**.

## H - Asociación (Association)

#### 1. **Definición:**

Una asociación (Association) representa una **relación general** entre dos clases. Indica que una clase **utiliza** o **conoce** a otra, ya sea a través de atributos o métodos. Es la relación más básica y menos específica.

#### 2. **Ejemplo:**

![_images/BackUMLassociation.png](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_images/BackUMLassociation.png)

Aquí, "ClaseA" (ClassA) está asociada con "ClaseB" (ClassB). Esto podría significar que "ClaseA" tiene un atributo de tipo "ClaseB", o que un método de "ClaseA" recibe un objeto de "ClaseB" como parámetro.

**Representación UML:** Una línea **sólida** que une las dos clases.

- **Bidireccional (Bi-directional):** Si no hay flechas, la asociación es bidireccional, lo que significa que ambas clases se conocen y pueden interactuar entre sí.
- **Unidireccional (Unidirectional):** Si hay una flecha, la asociación es unidireccional, lo que significa que solo la clase de origen de la flecha "conoce" a la clase a la que apunta la flecha.

**Ejemplo de código:**

```java
public class Autor {

  public void escribir(Libro b) {
    // ... hacer algo con el Libro ...
  }
}
```

En este código, la clase `Autor` tiene un método `escribir` que recibe un objeto de tipo `Libro`. Esto representa una asociación entre `Autor` y `Libro`.

#### 3. **Notas o advertencias:**

- **Relación "utiliza":** La asociación indica una relación de "utilización" o "conocimiento" entre clases.
- **Ciclos de vida independientes:** Las clases asociadas suelen tener ciclos de vida independientes, es decir, la existencia de una no depende directamente de la otra.

## I - Multiplicidad (Multiplicity) - Cardinalidad (Cardinality)

#### 1. **Definición:**

La multiplicidad (también llamada cardinalidad) en una asociación indica **cuántos objetos** de cada clase pueden participar en la relación. Es como decir "un coche **tiene un** motor" (multiplicidad 1 para el motor) o "un autor **puede escribir muchos** libros" (multiplicidad \* o 0..\* para los libros).

#### 2. **Ejemplo:**

Se expresa con la notación `n..m` cerca del extremo de la línea de asociación, junto a la clase cuya multiplicidad se está indicando.

- `n`: Número mínimo de instancias de la clase que pueden participar en la relación.
- `m`: Número máximo de instancias.
- Si `n = m`, solo se escribe `n`.
- `0`: Relación opcional (puede no haber ninguna instancia).
- `*`: Cero o más (muchos).

**Valores de Multiplicidad Comunes:**

| Valor  | Significado                                  | Ejemplo                                     |
| :----- | :------------------------------------------- | :------------------------------------------ |
| `1`    | Uno y solo uno (obligatorio)                 | Un coche **tiene un** motor.                |
| `0..1` | Cero o uno (opcional)                        | Una persona **puede tener** o no coche.     |
| `1..*` | Uno o más (obligatorio al menos uno)         | Un pedido **tiene uno o más** productos.    |
| `*`    | Cero o más (opcional, puede haber muchos)    | Un autor **puede escribir** o no libros.    |
| `l..u` | Entre `l` y `u` (límite inferior y superior) | Un equipo **tiene entre 2 y 11** jugadores. |
| `l..*` | `l` o más (límite inferior, sin superior)    | Un curso **tiene 10 o más** estudiantes.    |

#### 3. **Notas o advertencias:**

- **Restricciones:** La multiplicidad define restricciones sobre cuántos objetos pueden relacionarse.
- **Claridad:** Usar la multiplicidad hace que los diagramas de clases sean mucho más precisos y fáciles de entender.

## J - Agregación (Aggregation)

#### 1. **Definición:**

La agregación (Aggregation) es un tipo especial de asociación que indica que un objeto **es parte de** otro objeto, pero sus **ciclos de vida son independientes**. Es una relación "TIENE-UN" (HAS-A) más débil que la composición. Si el "contenedor" desaparece, las "partes" pueden seguir existiendo.

#### 2. **Ejemplo:**

![_images/BackUMLaggregation.png](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_images/BackUMLaggregation.png)

Una "Universidad" (University) **tiene** "Departamentos" (Department), y un "Departamento" **tiene** "Profesores" (Professor). Si la universidad cierra, los departamentos dejan de existir **dentro de esa universidad**, pero los profesores **siguen existiendo** y podrían trabajar en otra universidad.

**Representación UML:** Una línea sólida con un **rombo hueco (blanco)** en el extremo de la clase "contenedor" (la que "tiene" las partes).

**Ejemplo de código:**

```java
public class Departamento {

  private Profesor profesor;

  public void setProfesor(Profesor profesor) {
    this.profesor = profesor;
  }
}
```

En este código, un `Departamento` **tiene** un `Profesor` (relación de agregación).

#### 3. **Notas o advertencias:**

- **"TIENE-UN" (HAS-A) débil:** La agregación es una forma de "TIENE-UN" donde las partes pueden existir sin el todo.
- **Uso con precaución:** Como dice Martin Fowler, la agregación puede ser confusa y a veces no añade mucho valor semántico en comparación con una asociación simple. ¡Úsala con criterio!

## K - Composición (Composition)

#### 1. **Definición:**

La composición (Composition) es una forma aún más fuerte de agregación. También indica una relación "TIENE-UN" (HAS-A), pero aquí el ciclo de vida de la "parte" **depende del ciclo de vida del "todo"**. Si el "contenedor" desaparece, las "partes" **también desaparecen**. Además, una "parte" solo puede pertenecer a **un** "todo".

#### 2. **Ejemplo:**

![_images/BackUMLcomposition.png](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_images/BackUMLcomposition.png)

Un "Coche" (Car) **tiene** un "Motor" (Engine). Cuando se crea un coche, se crea también un motor **específicamente para ese coche**. Si el coche se destruye, el motor **también se destruye** y no puede usarse en otro coche. El motor **pertenece exclusivamente** a ese coche.

**Representación UML:** Una línea sólida con un **rombo relleno (negro)** en el extremo de la clase "contenedor".

**Ejemplo de código:**

```java
public class Coche {

  private Motor motor = new Motor(); // El motor se crea al crear el coche
}
```

#### 3. **Notas o advertencias:**

- **"TIENE-UN" (HAS-A) fuerte:** La composición es una relación "TIENE-UN" donde las partes son dependientes del todo y exclusivas de él.
- **Ciclo de vida dependiente:** La clave de la composición es la dependencia del ciclo de vida.
- **Exclusividad:** Una parte en una composición solo puede pertenecer a un todo.

## L - Relaciones de Dependencia (Dependency Relationships) - Dependencia (Dependency)

#### 1. **Definición:**

La dependencia (Dependency) es una relación que indica que una clase **depende de otra** para funcionar, pero **no la "tiene"** como parte de sí misma. Generalmente, se da cuando una clase usa otra **como parámetro** en uno de sus métodos.

#### 2. **Ejemplo:**

![_images/BackUMLdependency.png](https://opendsa-server.cs.vt.edu/ODSA/Books/Everything/html/_images/BackUMLdependency.png)

La clase "Cliente" (Customer) **depende** de la clase "Libro" (Book) para su método `comprar(Libro b)`. El `Cliente` necesita un `Libro` para realizar la compra, pero no "tiene" un `Libro` como atributo propio. La dependencia surge porque el método `comprar` **recibe un `Libro` como parámetro**.

**Representación UML:** Una línea **discontinua con flecha** que apunta desde la clase **dependiente** (la que necesita la otra) hacia la clase de la que **depende**.

**Ejemplo de código:**

```java
public class Cliente {

  public void comprar(Libro b) {} // Dependencia de Libro como parámetro
}
```

#### 3. **Notas o advertencias:**

- **"Usa-A" (USES-A):** La dependencia se puede pensar como una relación "USA-A" o "NECESITA-A".
- **Parámetros:** La dependencia es común cuando una clase recibe objetos de otra clase como parámetros en sus métodos.
- **Menos fuerte que Asociación:** La dependencia es una relación más débil que la asociación. No implica una conexión estructural tan fuerte entre las clases.
