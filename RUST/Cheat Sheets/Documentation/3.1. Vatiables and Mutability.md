## A - Variables: Inmutables por Defecto (`let`) üî¥

#### 1. **Introducci√≥n:**

En Rust, cuando creas una variable con `let`, su valor queda "sellado" y no puedes cambiarlo despu√©s; piensa en ello como poner un dato en una caja de cristal cerrada para siempre.

#### 2. **Ejemplo:**

```rust
fn main() {
    // Creamos una "caja de cristal" llamada 'puntuacion' y metemos un 100.
    let puntuacion = 100;
    println!("Tu puntuaci√≥n es: {}", puntuacion);

    // La siguiente l√≠nea, si la descomentas, har√° que el programa FALLE.
    // ¬°No puedes cambiar lo que hay en una caja sellada!
    // puntuacion = 110;
}
```

![Este c√≥digo no compila](https://doc.rust-lang.org/stable/book/img/ferris/does_not_compile.svg)

**Explicaci√≥n del ejemplo:**
Creamos la variable `puntuacion` y le asignamos el valor `100`. Como no hemos dicho lo contrario, esta variable es **inmutable**. Si luego intentamos asignarle un nuevo valor (`110`), el compilador de Rust, que es nuestro guardi√°n protector, nos detendr√° con un error. ¬°No te frustres si te pasa! Es Rust cuid√°ndote.

#### 3. **Desarrollo:**

Esta es una de las caracter√≠sticas de seguridad m√°s importantes y definitorias de Rust. Al hacer que las variables sean inmutables por defecto, Rust te "empuja" a ser muy deliberado sobre qu√© partes de tu c√≥digo pueden cambiar y cu√°les no.

¬øPor qu√© esta "paranoia"? Porque una de las fuentes de errores m√°s dif√≠ciles de rastrear en otros lenguajes es cuando un valor cambia inesperadamente en una parte lejana del c√≥digo, causando un efecto domin√≥ de caos. Rust previene esto de ra√≠z. Si un valor no _necesita_ cambiar, Rust se asegura de que _no pueda_ cambiar. Es una red de seguridad que te permite razonar sobre tu c√≥digo con mucha m√°s confianza.

üî¥ **Fundamental**: Esta es la regla n√∫mero uno de las variables en Rust. Entender la inmutabilidad por defecto es el primer y m√°s crucial paso para empezar a pensar "a lo Rust".

---

## B - Mutabilidad (`mut`): D√°ndole Permiso a tus Variables para Cambiar üî¥

#### 1. **Introducci√≥n:**

Si necesitas que una variable pueda cambiar su valor a lo largo del programa, debes darle permiso expl√≠citamente usando la palabra clave `mut`.

#### 2. **Ejemplo:**

```rust
fn main() {
    // Usamos 'let mut' para crear una caja que S√ç podemos abrir y cambiar.
    let mut puntos_de_vida = 100;
    println!("Puntos de vida iniciales: {}", puntos_de_vida);

    // ¬°Recibes da√±o! Como es mutable, podemos cambiar el valor.
    puntos_de_vida = 80;
    println!("Puntos de vida restantes: {}", puntos_de_vida);
}
```

**Explicaci√≥n del ejemplo:**
Al declarar `puntos_de_vida` con `let mut`, le estamos diciendo a Rust: "Conf√≠a en m√≠, s√© que esta variable necesita cambiar, y me har√© responsable". Por eso, podemos reasignarle el valor de `100` a `80` sin que el compilador se queje.

#### 3. **Desarrollo:**

Usar `mut` no es solo sintaxis, es una forma de comunicaci√≥n. Le est√°s diciendo al compilador y, m√°s importante a√∫n, a cualquier persona (¬°incluido tu "yo" del futuro!) que lea el c√≥digo: "¬°Atenci√≥n! El valor de esta variable est√° dise√±ado para cambiar".

Aunque la inmutabilidad es la opci√≥n segura por defecto, la mutabilidad es absolutamente esencial para casi cualquier programa real. ¬øC√≥mo llevar√≠as la cuenta de un puntaje en un juego, el total de un carrito de compras o la posici√≥n de un personaje en la pantalla sin poder cambiar valores? La genialidad de Rust es que te obliga a ser consciente y expl√≠cito sobre estos cambios, haciendo tu c√≥digo m√°s predecible.

üî¥ **Fundamental**: Es la otra cara de la moneda de la inmutabilidad. Necesitas dominar tanto `let` como `let mut` para escribir cualquier programa √∫til en Rust.

---

## C - Constantes (`const`): Valores Fijos Grabados en Piedra üü°

#### 1. **Introducci√≥n:**

Una constante es un valor que no solo es inmutable, sino que est√° fijado _antes_ de que el programa se ejecute y nunca, bajo ninguna circunstancia, puede cambiar.

#### 2. **Ejemplo:**

```rust
// Se declara fuera de 'main', en el scope global. ¬°Accesible desde todas partes!
const SEGUNDOS_EN_UNA_HORA: u32 = 3600;

fn main() {
    println!("Una hora tiene {} segundos.", SEGUNDOS_EN_UNA_HORA);
}
```

**Explicaci√≥n del ejemplo:**
`SEGUNDOS_EN_UNA_HORA` es una constante. F√≠jate en los detalles, que son muy importantes:

1.  Usamos la palabra clave `const` en lugar de `let`.
2.  El nombre est√° en `MAYUSCULAS_CON_GUIONES_BAJOS`. Esta es la convenci√≥n de estilo en Rust y te ayuda a identificarlas de un vistazo.
3.  Es **obligatorio** especificar el tipo del valor (en este caso, `u32`, que es un n√∫mero entero de 32 bits sin signo).

#### 3. **Desarrollo:**

Aqu√≠ es donde muchos principiantes se confunden. "Espera un momento... ¬øno es esto lo mismo que una variable inmutable con `let`?". ¬°Excelente pregunta! La respuesta es un rotundo **NO**, y entender la diferencia te har√° un mejor programador de Rust.

- **Variable inmutable (`let`):** Su valor se puede asignar a partir de un c√°lculo que ocurre **mientras el programa se ejecuta** (en tiempo de ejecuci√≥n). Por ejemplo, `let resultado = una_funcion_compleja();`. El valor de `resultado` no se conoce hasta que se llama a la funci√≥n. Una vez asignado, no puede cambiar.
- **Constante (`const`):** Su valor **DEBE** ser conocido **antes de que el programa se compile**. No puedes asignarle el resultado de una funci√≥n que se ejecuta en tiempo de ejecuci√≥n. El valor de la constante se inserta directamente en el c√≥digo del programa, como si hubieras escrito `3600` en todas partes.

**En resumen:** Usa `const` para valores universales en tu aplicaci√≥n que nunca cambiar√°n, como valores matem√°ticos (PI), l√≠mites (INTENTOS_MAXIMOS), o configuraciones fijas. Esto hace que tu c√≥digo sea m√°s f√°cil de leer y de mantener, porque si ese valor necesita cambiar alguna vez, solo lo cambias en un lugar.

üü° **Importante**: No las usar√°s en cada l√≠nea de c√≥digo como `let`, pero son la herramienta perfecta para valores fijos y globales. Conocerlas y usarlas correctamente es una se√±al de un c√≥digo bien estructurado.

---

## D - Shadowing: "Eclipsando" una Variable con una Nueva üü°

#### 1. **Introducci√≥n:**

El "shadowing" (sombreado o eclipsamiento) es una t√©cnica que te permite declarar una **nueva** variable con el mismo nombre que una variable anterior, "ocultando" o "eclipsando" la original de forma efectiva.

#### 2. **Ejemplo:**

```rust
fn main() {
    let x = 5;

    // 1. Primer 'shadowing': creamos una NUEVA variable 'x' que oculta a la anterior.
    //    Esta nueva variable toma el valor de la 'x' anterior (5) y le suma 1.
    let x = x + 1;

    {
        // 2. Segundo 'shadowing': creamos OTRA variable 'x' que solo existe
        //    dentro de estas llaves {}. Oculta a la 'x' que val√≠a 6.
        let x = x * 2;
        println!("El valor de x en el scope interno es: {}", x); // Imprime 12
    }

    // 3. Al salir de las llaves, la 'x' que val√≠a 12 desaparece.
    //    La 'x' que val√≠a 6 vuelve a ser visible.
    println!("El valor de x fuera del scope es: {}", x); // Imprime 6
}
```

**Explicaci√≥n del ejemplo:**
La clave aqu√≠ es la palabra `let`. Cada vez que usas `let x = ...`, no est√°s _modificando_ la `x` anterior. ¬°Est√°s creando una variable completamente nueva que casualmente se llama igual! La `x` original sigue existiendo en memoria, pero est√° en la "sombra", inaccesible, mientras la nueva est√© visible.

#### 3. **Desarrollo: La Batalla Final - `mut` vs. Shadowing**

Esta es la duda del mill√≥n de d√≥lares. "¬øPor qu√© diablos usar√≠a `shadowing` si simplemente puedo hacer la variable mutable con `mut`?". ¬°Ah, mi joven aprendiz, prep√°rate para la iluminaci√≥n! Esta es una de las ideas m√°s elegantes de Rust.

| Caracter√≠stica    | `let mut` (Mutabilidad)                                          | `let` (Shadowing)                                                                           |
| :---------------- | :--------------------------------------------------------------- | :------------------------------------------------------------------------------------------ |
| **¬øQu√© hace?**    | Cambia el **valor** dentro de la misma variable.                 | Crea una **variable completamente nueva** con el mismo nombre.                              |
| **Tipo de dato**  | **NO PUEDE CAMBIAR**. La variable est√° atada a su tipo original. | **S√ç PUEDE CAMBIAR**. Como es una variable nueva, puede tener un tipo totalmente diferente. |
| **Inmutabilidad** | La variable es mutable durante toda su vida.                     | La nueva variable es inmutable por defecto (a menos que uses `let mut`).                    |

**¬°El superpoder del Shadowing es cambiar el tipo!**

Imagina que pides al usuario que escriba cu√°ntos espacios quiere. Lo recibes como texto, pero para usarlo necesitas que sea un n√∫mero.

**Intento con `mut` (¬°FALLAR√Å!):**

```rust
let mut spaces = "   "; // 'spaces' es un texto (&str)
// La siguiente l√≠nea da un ERROR porque .len() devuelve un n√∫mero (usize),
// y no puedes meter un n√∫mero en una caja etiquetada para "texto".
// spaces = spaces.len();
```

![Este c√≥digo no compila](https://doc.rust-lang.org/stable/book/img/ferris/does_not_compile.svg)

**La soluci√≥n elegante con Shadowing (¬°FUNCIONA!):**

```rust
// 1. La primera variable 'spaces' es de tipo texto (&str).
let spaces = "   ";

// 2. Hacemos 'shadowing'. Creamos una NUEVA variable 'spaces'
//    que es de tipo n√∫mero (usize), conteniendo la longitud de la anterior.
let spaces = spaces.len();

// Ahora podemos trabajar con 'spaces' como un n√∫mero, y adem√°s, ¬°es inmutable!
println!("N√∫mero de espacios: {}", spaces);
```

**Conclusi√≥n y Consejo del Pedagogo:**

- Usa `mut` cuando necesites cambiar el estado de algo a lo largo del tiempo, pero su naturaleza no cambia (un contador, puntos de vida, una suma total).
- Usa **shadowing** cuando quieras realizar una **transformaci√≥n** a un valor, especialmente si esa transformaci√≥n cambia su tipo. Te ahorra tener que inventar nombres nuevos como `texto_input` y `numero_input`, haciendo tu c√≥digo m√°s limpio, conciso y seguro, porque despu√©s de la transformaci√≥n, el valor vuelve a ser inmutable.

üü° **Importante**: El shadowing es un patr√≥n extremadamente com√∫n y "idiom√°tico" en Rust. Al principio puede parecer raro, pero una vez que haces "clic" con su utilidad para transformar datos, lo ver√°s como una herramienta poderosa y elegante.
