## A - Dockerfile de Desarrollo para JavaScript

#### 1. **Definición:**

Un `Dockerfile` es un archivo de texto que contiene instrucciones para Docker sobre cómo construir una imagen de contenedor. En este caso, crearemos un `Dockerfile.dev` específico para el entorno de desarrollo de una aplicación JavaScript.

#### 2. **Ejemplo:**

```dockerfile
FROM node:lts-alpine

EXPOSE 3000

USER node

RUN mkdir -p /home/node/app

WORKDIR /home/node/app

COPY ./package.json .
RUN npm install

COPY . .

CMD [ "npm", "run", "dev" ]
```

**Explicación del ejemplo:**

- **`FROM node:lts-alpine`**: Imagina que eliges una base sólida para construir tu casa. Aquí, elegimos la imagen oficial de Node.js (`node`) en su versión LTS (soporte a largo plazo) y variante Alpine (ligera). Es como tener un sistema operativo pequeño y listo para ejecutar JavaScript.
- **`EXPOSE 3000`**: Le decimos a Docker que nuestra aplicación dentro del contenedor usará el puerto 3000. Es como abrir una ventana en tu casa para que la gente pueda asomarse.
- **`USER node`**: Por seguridad, cambiamos el usuario por defecto a `node`. Normalmente, Docker usa el usuario `root` (administrador), pero es más seguro usar un usuario menos poderoso como `node`.
- **`RUN mkdir -p /home/node/app`**: Creamos una carpeta llamada `app` dentro del directorio `/home/node/`. Piensa en esto como crear una habitación dentro de tu casa para tu aplicación.
- **`WORKDIR /home/node/app`**: Nos movemos a la carpeta `/home/node/app` que acabamos de crear. Es como entrar en esa habitación para empezar a trabajar allí.
- **`COPY ./package.json .`**: Copiamos el archivo `package.json` desde tu ordenador (`./`) a la carpeta de trabajo dentro del contenedor (`.`). Este archivo le dice a Node.js qué dependencias (librerías) necesita tu proyecto.
- **`RUN npm install`**: Ejecutamos el comando `npm install` dentro del contenedor. Esto instala todas las dependencias listadas en `package.json`. Es como instalar todos los muebles y herramientas que necesitas en tu habitación.
- **`COPY . .`**: Copiamos todo el resto de los archivos de tu proyecto desde tu ordenador (`.`) a la carpeta de trabajo dentro del contenedor (`.`). Es como traer todos los planos, materiales y decoraciones a tu habitación.
- **`CMD [ "npm", "run", "dev" ]`**: Finalmente, le decimos a Docker que cuando inicie el contenedor, ejecute el comando `npm run dev`. Este comando, generalmente, inicia el servidor de desarrollo de tu aplicación JavaScript. Es como encender las luces y abrir las puertas de tu casa para que la aplicación empiece a funcionar.

#### 3. **Notas o advertencias:**

- Este `Dockerfile.dev` está pensado para el desarrollo, no para producción.
- La instrucción `USER node` mejora la seguridad al evitar ejecutar el contenedor como usuario `root`.
- `EXPOSE` solo documenta el puerto, no lo publica automáticamente. La publicación se hace al ejecutar el contenedor con `-p`.

## B - Construyendo la Imagen de Desarrollo

#### 1. **Definición:**

Una vez que tienes tu `Dockerfile.dev`, necesitas construir una imagen Docker a partir de él. La imagen es como una plantilla que contiene todo lo necesario para ejecutar tu aplicación.

#### 2. **Ejemplo:**

```bash
docker image build --file Dockerfile.dev --tag hello-dock:dev .
```

**Explicación del ejemplo:**

- **`docker image build`**: Este es el comando para construir una imagen Docker.
- **`--file Dockerfile.dev`**: Le indicamos a Docker que use el archivo llamado `Dockerfile.dev` para las instrucciones de construcción. Si el archivo se llamara simplemente `Dockerfile`, no necesitaríamos esta opción.
- **`--tag hello-dock:dev`**: Le damos un nombre y una etiqueta a la imagen que vamos a construir. `hello-dock` es el nombre y `dev` es la etiqueta. Es como ponerle un nombre y una versión a tu plantilla.
- **`.`**: El punto al final indica el "contexto de construcción". En este caso, es el directorio actual. Docker usará los archivos en este directorio para construir la imagen.

#### 3. **Notas o advertencias:**

- Si no especificas `--file`, Docker buscará un archivo llamado `Dockerfile` en el contexto de construcción.
- Las etiquetas (`tags`) son útiles para versionar tus imágenes (ej: `hello-dock:1.0`, `hello-dock:latest`).

## C - Ejecutando el Contenedor de Desarrollo

#### 1. **Definición:**

Después de construir la imagen, puedes ejecutar un contenedor basado en esa imagen. Un contenedor es una instancia en ejecución de una imagen.

#### 2. **Ejemplo:**

```bash
docker container run \
    --rm \
    --detach \
    --publish 3000:3000 \
    --name hello-dock-dev \
    hello-dock:dev
```

**Explicación del ejemplo:**

- **`docker container run`**: Este es el comando para ejecutar un contenedor.
- **`--rm`**: Indica que el contenedor se eliminará automáticamente cuando se detenga. Es útil para contenedores de desarrollo que no necesitas mantener.
- **`--detach` o `-d`**: Ejecuta el contenedor en segundo plano (detached mode). Así, la terminal queda libre para otros comandos.
- **`--publish 3000:3000` o `-p 3000:3000`**: Publica el puerto 3000 de tu ordenador al puerto 3000 del contenedor. Esto permite acceder a la aplicación dentro del contenedor desde tu navegador en `http://127.0.0.1:3000`.
- **`--name hello-dock-dev`**: Le da un nombre al contenedor, `hello-dock-dev`. Esto facilita la gestión del contenedor (detenerlo, reiniciarlo, etc.).
- **`hello-dock:dev`**: Especifica la imagen que se usará para crear el contenedor, en este caso, `hello-dock:dev` que construimos antes.

#### 3. **Notas o advertencias:**

- Sin `--detach`, el contenedor se ejecuta en primer plano y verás los logs en tu terminal. Para detenerlo, generalmente usas `Ctrl+C`.
- Si el puerto del host (primer `3000` en `--publish 3000:3000`) es diferente al puerto del contenedor (segundo `3000`), accederías a la aplicación usando el puerto del host. Por ejemplo, con `--publish 8080:3000`, accederías en `http://127.0.0.1:8080`.

## D - Problema con la Recarga en Vivo (Hot Reload)

#### 1. **Definición:**

La "recarga en vivo" o "hot reload" es una característica común en los servidores de desarrollo de frameworks JavaScript. Permite que la página web se actualice automáticamente en el navegador cuando haces cambios en el código.

#### 2. **Problema:**

Si modificas el código de tu proyecto en tu ordenador, no verás los cambios reflejados automáticamente en la aplicación que se ejecuta dentro del contenedor. Esto se debe a que el contenedor tiene su propio sistema de archivos, separado del de tu ordenador.

![image](https://docker-handbook.farhan.dev/containerizing-a-javascript-application/local-vs-container-file-system.svg)

**Explicación del problema:**

Imagina que tienes dos copias de tu casa: una física (tu ordenador) y una virtual (el contenedor). Cuando cambias algo en tu casa física, ¡no se cambia automáticamente en la virtual! El contenedor tiene una copia del código que hiciste al construir la imagen, pero no sabe de los cambios que haces después en tu ordenador.

#### 3. **Notas o advertencias:**

- Este problema es común al desarrollar con contenedores y se soluciona con "volúmenes".

## E - Volúmenes Bind Mounts para Recarga en Vivo

#### 1. **Definición:**

Un "bind mount" es una forma de compartir una carpeta de tu ordenador directamente con un contenedor. En lugar de copiar archivos, el contenedor accede a los archivos directamente desde tu ordenador.

#### 2. **Solución con Bind Mounts:**

Usando un bind mount, puedes "montar" la carpeta de tu proyecto local dentro del contenedor. Así, cualquier cambio que hagas en tu código local se reflejará inmediatamente dentro del contenedor, activando la recarga en vivo del servidor de desarrollo.

![image](https://docker-handbook.farhan.dev/containerizing-a-javascript-application/bind-mounts.svg)

#### 3. **Ejemplo de Bind Mount:**

```bash
docker container run \
    --rm \
    --publish 3000:3000 \
    --name hello-dock-dev \
    --volume $(pwd):/home/node/app \
    hello-dock:dev
```

**Explicación del ejemplo:**

- **`--volume $(pwd):/home/node/app` o `-v $(pwd):/home/node/app`**: Esta es la clave. Crea un bind mount.
  - **`$(pwd)`**: Esto en la terminal se expande a la ruta absoluta del directorio actual de tu ordenador (donde está tu proyecto).
  - **`:/home/node/app`**: Esta es la ruta dentro del contenedor donde se "montará" la carpeta de tu ordenador. Coincide con el `WORKDIR` que definimos en el `Dockerfile.dev`.

#### 4. **Notas o advertencias:**

- La sintaxis general de `--volume` para bind mounts es: `--volume <ruta absoluta en tu ordenador>:<ruta absoluta en el contenedor>:<permisos (opcional)>`.
- Los cambios en los archivos dentro del contenedor (en la carpeta montada) también se reflejarán en tu sistema de archivos local.

## F - Problema con `node_modules` y Bind Mounts

#### 1. **Definición:**

Al usar bind mounts para la recarga en vivo, surge un nuevo problema relacionado con la carpeta `node_modules`.

#### 2. **Problema:**

En proyectos Node.js, las dependencias (librerías) se instalan en la carpeta `node_modules` dentro del directorio del proyecto. Cuando montas la carpeta de tu proyecto local en el contenedor con un bind mount, ¡reemplazas el contenido de la carpeta dentro del contenedor con el contenido de tu carpeta local! Si no has instalado las dependencias en tu ordenador (o si son diferentes a las del contenedor), la carpeta `node_modules` dentro del contenedor puede quedar incompleta o incorrecta.

#### 3. **Ejemplo del Problema:**

Al ejecutar el contenedor con el bind mount anterior, podrías ver errores como `"vite: not found"` o `"npm WARN Local package.json exists, but node_modules missing, did you mean to install?"`. Esto indica que el comando `npm run dev` (que usa `vite`) no encuentra las dependencias necesarias porque `node_modules` está faltando o es incorrecta dentro del contenedor.

## G - Volúmenes Anónimos para `node_modules`

#### 1. **Definición:**

Un "volumen anónimo" es similar a un bind mount, pero Docker gestiona la ubicación real de los datos en tu sistema de archivos. No necesitas especificar una carpeta local.

#### 2. **Solución con Volúmenes Anónimos:**

Para solucionar el problema con `node_modules`, puedes crear un volumen anónimo específicamente para esta carpeta dentro del contenedor. Docker creará un volumen gestionado y lo montará en `/home/node/app/node_modules` dentro del contenedor. Esto asegura que `node_modules` dentro del contenedor sea persistente y no se vea afectado por el bind mount de la carpeta del proyecto.

#### 3. **Ejemplo de Volumen Anónimo:**

```bash
docker container run \
    --rm \
    --detach \
    --publish 3000:3000 \
    --name hello-dock-dev \
    --volume $(pwd):/home/node/app \
    --volume /home/node/app/node_modules \
    hello-dock:dev
```

**Explicación del ejemplo:**

- **`--volume /home/node/app/node_modules` o `-v /home/node/app/node_modules`**: Crea un volumen anónimo. Solo especificamos la ruta dentro del contenedor (`/home/node/app/node_modules`). Docker se encarga de crear y gestionar el volumen en el sistema de archivos del host.

#### 4. **Notas o advertencias:**

- La sintaxis general de `--volume` para volúmenes anónimos es: `--volume <ruta absoluta en el contenedor>:<permisos (opcional)>`.
- Ahora tenemos dos volúmenes: un bind mount para el código del proyecto (recarga en vivo) y un volumen anónimo para `node_modules` (dependencias correctas).

## H - Builds Multi-Etapa (Multi-Staged Builds)

#### 1. **Definición:**

Los "builds multi-etapa" permiten optimizar las imágenes Docker, especialmente para aplicaciones en producción. La idea es usar múltiples etapas de construcción dentro de un mismo `Dockerfile`.

#### 2. **Problema en Producción:**

Para producción, no necesitas el servidor de desarrollo de Node.js ni todas las dependencias de desarrollo. Solo necesitas los archivos estáticos (HTML, CSS, JavaScript) que genera el proceso de "build" de tu aplicación. Incluir todo el entorno de Node.js en la imagen final de producción la haría innecesariamente grande.

#### 3. **Solución con Builds Multi-Etapa:**

Con builds multi-etapa, puedes:

1.  **Etapa 1 (Builder):** Usar una imagen de Node.js para construir la aplicación (ejecutar `npm run build`).
2.  **Etapa 2 (Final):** Usar una imagen más ligera (como `nginx`) y copiar solo los archivos construidos desde la etapa 1 a esta imagen final.

Así, la imagen final de producción solo contiene lo esencial para ejecutar la aplicación, siendo mucho más pequeña y segura.

## I - Dockerfile de Producción Multi-Etapa

#### 1. **Definición:**

Un `Dockerfile` para producción que utiliza builds multi-etapa para optimizar la imagen final.

#### 2. **Ejemplo:**

```dockerfile
FROM node:lts-alpine as builder

WORKDIR /app

COPY ./package.json ./
RUN npm install

COPY . .
RUN npm run build

FROM nginx:stable-alpine

EXPOSE 80

COPY --from=builder /app/dist /usr/share/nginx/html
```

**Explicación del ejemplo:**

- **`FROM node:lts-alpine as builder`**: Inicia la primera etapa, llamada "builder", usando la imagen de Node.js. `as builder` le da un nombre a esta etapa para referenciarla después.
- **`WORKDIR /app`**, **`COPY ./package.json ./`**, **`RUN npm install`**, **`COPY . .`**, **`RUN npm run build`**: Estas instrucciones son similares al `Dockerfile.dev`, pero aquí ejecutamos `npm run build` para generar los archivos estáticos de producción. Estos archivos se guardan en la carpeta `/app/dist` (por defecto en proyectos Vite).
- **`FROM nginx:stable-alpine`**: Inicia la segunda etapa, la etapa final, usando la imagen de Nginx (un servidor web ligero) en su versión Alpine.
- **`EXPOSE 80`**: Nginx usa el puerto 80 por defecto.
- **`COPY --from=builder /app/dist /usr/share/nginx/html`**: Aquí está la magia del multi-etapa.
  - **`--from=builder`**: Indica que vamos a copiar archivos desde la etapa llamada "builder".
  - **`/app/dist`**: Es la carpeta de origen dentro de la etapa "builder" (donde se guardaron los archivos construidos).
  - **`/usr/share/nginx/html`**: Es la carpeta de destino dentro de la etapa actual (Nginx). Esta es la carpeta donde Nginx busca los archivos web para servir.

#### 3. **Notas o advertencias:**

- La imagen final se basa en `nginx:stable-alpine`, que es mucho más pequeña que `node:lts-alpine`.
- La imagen final solo contiene los archivos necesarios para servir la aplicación estática, sin Node.js ni dependencias de desarrollo.

## J - Construyendo la Imagen de Producción

#### 1. **Definición:**

Construir la imagen Docker de producción a partir del `Dockerfile` multi-etapa.

#### 2. **Ejemplo:**

```bash
docker image build --tag hello-dock:prod .
```

**Explicación del ejemplo:**

- **`docker image build`**: Comando para construir la imagen.
- **`--tag hello-dock:prod`**: Nombre y etiqueta para la imagen de producción.
- **.**: Contexto de construcción (directorio actual). Docker usará el `Dockerfile` (sin extensión, por defecto) en este directorio.

#### 3. **Notas o advertencias:**

- Asegúrate de estar en el directorio correcto donde se encuentra el `Dockerfile` (sin extensión) de producción.

## K - Ejecutando el Contenedor de Producción

#### 1. **Definición:**

Ejecutar un contenedor basado en la imagen de producción que construimos.

#### 2. **Ejemplo:**

```bash
docker container run \
    --rm \
    --detach \
    --name hello-dock-prod \
    --publish 8080:80 \
    hello-dock:prod
```

**Explicación del ejemplo:**

- **`docker container run`**: Comando para ejecutar el contenedor.
- **`--rm`**: Eliminar el contenedor al detenerse.
- **`--detach`**: Ejecutar en segundo plano.
- **`--name hello-dock-prod`**: Nombre del contenedor.
- **`--publish 8080:80`**: Publica el puerto 8080 de tu ordenador al puerto 80 del contenedor (donde Nginx sirve la aplicación). Accederás a la aplicación en `http://127.0.0.1:8080`.
- **`hello-dock:prod`**: Imagen de producción a usar.

#### 3. **Notas o advertencias:**

- En producción real, probablemente no usarías `--rm` y quizás no `--detach` dependiendo de tu orquestador de contenedores.
- El puerto del host (`8080`) puede ser diferente al puerto del contenedor (`80`).

## L - Archivo `.dockerignore`

#### 1. **Definición:**

El archivo `.dockerignore` es similar a `.gitignore` para Git. Define una lista de archivos y carpetas que Docker debe **ignorar** al construir una imagen.

#### 2. **Ejemplo de `.dockerignore`:**

```
.git
*Dockerfile*
*docker-compose*
node_modules
```

**Explicación del ejemplo:**

- **.git**: Ignora la carpeta `.git` (historial de Git). No es necesario incluirla en la imagen.
- `*Dockerfile*`: Ignora cualquier archivo que contenga "Dockerfile" en su nombre. Útil para evitar incluir Dockerfiles de desarrollo en la imagen de producción.
- `*docker-compose*`: Ignora archivos de Docker Compose.
- **`node_modules`**: Ignora la carpeta `node_modules`. En un build multi-etapa, las dependencias se gestionan en la etapa "builder" y no son necesarias en la imagen final (o se instalan solo las necesarias). En otros casos, puede que no quieras copiar `node_modules` local si prefieres que se instale dentro del contenedor.

#### 3. **Notas o advertencias:**

- El archivo `.dockerignore` debe estar en el **contexto de construcción** (normalmente, el mismo directorio que el `Dockerfile`).
- Las reglas en `.dockerignore` usan la sintaxis de `gitignore`.
- `.dockerignore` **no afecta a los bind mounts**. Si montas una carpeta con un bind mount, Docker usará directamente esa carpeta, ignorando `.dockerignore`.
