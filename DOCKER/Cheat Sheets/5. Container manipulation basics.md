## A - Ejecutando Contenedores

#### 1. **Definición:**

El comando `docker container run` se usa para crear y ejecutar un contenedor a partir de una imagen. Es como darle vida a una plantilla de software.

#### 2. **Ejemplo:**

```bash
docker container run fhsinchy/hello-dock
```

**Explicación del ejemplo:**
Este comando le dice a Docker: "¡Oye, crea y ejecuta un contenedor usando la imagen `fhsinchy/hello-dock`!". Docker buscará esta imagen (primero localmente y luego en Docker Hub si no la encuentra) y la usará para iniciar tu contenedor.

#### 3. **Notas o advertencias:**

- Esta forma básica es válida, pero la sintaxis recomendada es `docker <tipo-de-objeto> <comando> <opciones>`. En este caso, `tipo-de-objeto` es `container` y `comando` es `run`.
- Si la imagen no está en tu sistema, Docker la descargará automáticamente de Docker Hub.

## B - Sintaxis General de Comandos Docker

#### 1. **Definición:**

La estructura general de los comandos de Docker es como una receta: primero dices **qué tipo de cosa** vas a manejar (objeto), luego **qué quieres hacer** con ella (comando), y finalmente, **cómo quieres hacerlo** (opciones).

#### 2. **Ejemplo:**

```bash
docker container run --publish 8080:80 fhsinchy/hello-dock
```

**Explicación del ejemplo:**

- `docker`: El comando base para interactuar con Docker.
- `container`: El tipo de objeto que estamos manejando (contenedores).
- `run`: El comando específico que queremos ejecutar (iniciar un contenedor).
- `--publish 8080:80`: Una opción que le dice a Docker que conecte el puerto 8080 de tu computadora al puerto 80 dentro del contenedor.
- `fhsinchy/hello-dock`: El nombre de la imagen que vamos a usar.

#### 3. **Notas o advertencias:**

- `object-type` puede ser `container`, `image`, `network`, `volume`, etc.
- `command` puede ser `run`, `start`, `stop`, `ls`, `rm`, etc. (¡veremos muchos de estos!).
- `options` modifican el comportamiento del comando. Por ejemplo, `--detach` para ejecutar en segundo plano.

## C - Publicando Puertos

#### 1. **Definición:**

Publicar puertos es como abrir una ventana en tu contenedor para que el mundo exterior pueda comunicarse con las aplicaciones que corren dentro. Por defecto, los contenedores están aislados.

#### 2. **Ejemplo:**

```bash
docker container run --publish 8080:80 fhsinchy/hello-dock
```

**Explicación del ejemplo:**
`--publish 8080:80` (o `-p 8080:80` que es lo mismo) significa: "Conecta el puerto 8080 de mi computadora (host port) con el puerto 80 dentro del contenedor (container port)". Así, cuando accedes a `http://127.0.0.1:8080` en tu navegador, ¡estás hablando con la aplicación dentro del contenedor!

![image](https://docker-handbook.farhan.dev/container-manipulation-basics/hello-dock.png)

#### 3. **Notas o advertencias:**

- Sintaxis: `--publish <puerto-de-la-máquina-local>:<puerto-del-contenedor>`.
- Puedes usar `-p` en lugar de `--publish`, es más corto.
- Si no publicas puertos, no podrás acceder a las aplicaciones dentro del contenedor desde fuera.

## D - Modo Detached (Segundo Plano)

#### 1. **Definición:**

El modo "detached" es como poner una aplicación a correr en segundo plano. El contenedor se ejecuta sin ocupar tu terminal, dejándote libre para seguir trabajando.

#### 2. **Ejemplo:**

```bash
docker container run --detach --publish 8080:80 fhsinchy/hello-dock
```

**Explicación del ejemplo:**
`--detach` (o `-d`) le dice a Docker que ejecute el contenedor en segundo plano. Después de ejecutar este comando, verás solo el ID del contenedor, y el contenedor seguirá funcionando aunque cierres la terminal.

```bash
# 9f21cb77705810797c4b847dbd330d9c732ffddba14fb435470567a7a3f46cdc
```

#### 3. **Notas o advertencias:**

- Sin `--detach`, el contenedor se ejecuta en primer plano y se detiene si cierras la terminal.
- El orden de las opciones como `--detach` y `--publish` no importa, pero el nombre de la imagen siempre va al final.

## E - Listando Contenedores

#### 1. **Definición:**

El comando `docker container ls` es tu "lista de chequeo" de contenedores. Te muestra qué contenedores están corriendo actualmente.

#### 2. **Ejemplo:**

```bash
docker container ls
```

**Output:**

```bash
# CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                  NAMES
# 9f21cb777058        fhsinchy/hello-dock   "/docker-entrypoint.…"   5 seconds ago       Up 5 seconds        0.0.0.0:8080->80/tcp   gifted_sammet
```

**Explicación del ejemplo:**
Este output te muestra información clave sobre los contenedores en ejecución:

- `CONTAINER ID`: Un identificador único y corto del contenedor.
- `IMAGE`: La imagen que se usó para crear el contenedor.
- `COMMAND`: El comando que se está ejecutando dentro del contenedor.
- `CREATED`: Hace cuánto tiempo se creó el contenedor.
- `STATUS`: El estado actual del contenedor (Up significa que está corriendo).
- `PORTS`: Muestra la publicación de puertos (puerto local -> puerto del contenedor).
- `NAMES`: Un nombre generado automáticamente por Docker (o uno que tú le hayas dado).

#### 3. **Notas o advertencias:**

- `docker container ls` solo muestra contenedores **en ejecución**.
- Para ver **todos** los contenedores (corriendo y detenidos), usa `docker container ls --all` o `docker container ls -a`.

```bash
docker container ls --all
```

**Output:**

```bash
# CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS                     PORTS                  NAMES
# 9f21cb777058        fhsinchy/hello-dock   "/docker-entrypoint.…"   2 minutes ago       Up 2 minutes               0.0.0.0:8080->80/tcp   gifted_sammet
# 6cf52771dde1        fhsinchy/hello-dock   "/docker-entrypoint.…"   3 minutes ago       Exited (0) 3 minutes ago                          reverent_torvalds
# 128ec8ceab71        hello-world           "/hello"                 4 minutes ago       Exited (0) 4 minutes ago                          exciting_chebyshev
```

- `Exited (0)` significa que el contenedor terminó de ejecutarse sin errores. Otros códigos indican problemas.

## F - Nombrando y Renombrando Contenedores

#### 1. **Definición:**

Darle nombres a tus contenedores hace que sea mucho más fácil identificarlos y manejarlos, en lugar de usar IDs largos y aleatorios.

#### 2. **Ejemplo:**

**Nombrando al crear:**

```bash
docker container run --detach --publish 8888:80 --name hello-dock-container fhsinchy/hello-dock
```

**Explicación del ejemplo:**
`--name hello-dock-container` le asigna el nombre "hello-dock-container" a este nuevo contenedor.

**Renombrando un contenedor existente:**

```bash
docker container rename gifted_sammet hello-dock-container-2
```

**Explicación del ejemplo:**
`docker container rename <nombre-actual> <nombre-nuevo>` cambia el nombre de un contenedor. Aquí, renombramos "gifted_sammet" a "hello-dock-container-2".

#### 3. **Notas o advertencias:**

- Usa `--name` con `docker container run` para nombrar un contenedor al crearlo.
- Usa `docker container rename` para cambiar el nombre de contenedores ya existentes, estén corriendo o no.
- Los nombres de contenedor deben ser únicos.

## G - Deteniendo y Matando Contenedores

#### 1. **Definición:**

A veces necesitas parar un contenedor. Docker ofrece dos maneras: `stop` y `kill`.

#### 2. **Ejemplo:**

**Deteniendo (stop):**

```bash
docker container stop hello-dock-container
```

**Explicación del ejemplo:**
`docker container stop <nombre-o-ID>` detiene un contenedor de forma "suave". Envía una señal `SIGTERM` al contenedor, dándole tiempo para cerrarse correctamente. Si no se detiene rápido, Docker envía `SIGKILL` para forzar el cierre.

**Matando (kill):**

```bash
docker container kill hello-dock-container-2
```

**Explicación del ejemplo:**
`docker container kill <nombre-o-ID>` detiene un contenedor de forma "dura" e inmediata. Envía directamente una señal `SIGKILL`, lo que fuerza el cierre del contenedor sin darle tiempo a "limpiar" o guardar nada.

#### 3. **Notas o advertencias:**

- Usa `stop` para un cierre normal y limpio.
- Usa `kill` solo si `stop` no funciona o necesitas detener el contenedor inmediatamente.
- Ambos comandos aceptan el nombre o el ID del contenedor.

## H - Reiniciando Contenedores

#### 1. **Definición:**

Reiniciar un contenedor puede significar dos cosas: volver a arrancar un contenedor detenido, o reiniciar un contenedor que ya está corriendo.

#### 2. **Ejemplo:**

**Iniciando un contenedor detenido (start):**

```bash
docker container start hello-dock-container
```

**Explicación del ejemplo:**
`docker container start <nombre-o-ID>` inicia un contenedor que estaba detenido. El contenedor vuelve a correr con la misma configuración de puertos y en modo detached (segundo plano) por defecto.

**Reiniciando un contenedor en ejecución (restart):**

```bash
docker container restart hello-dock-container-2
```

**Explicación del ejemplo:**
`docker container restart <nombre-o-ID>` reinicia un contenedor que ya está corriendo. Docker primero intenta detenerlo y luego lo vuelve a iniciar.

#### 3. **Notas o advertencias:**

- `start` se usa para contenedores que están en estado `Exited`.
- `restart` se usa para reiniciar contenedores que ya están `Up` (corriendo). Si usas `restart` en un contenedor detenido, funcionará igual que `start`.

## I - Creando Contenedores Sin Ejecutar

#### 1. **Definición:**

A veces quieres crear un contenedor pero no iniciarlo inmediatamente. `docker container create` te permite hacer justo eso: prepara el contenedor, pero lo deja en estado "creado" (Created), listo para ser iniciado después.

#### 2. **Ejemplo:**

**Creando:**

```bash
docker container create --publish 8080:80 fhsinchy/hello-dock
```

**Output:**

```bash
# 2e7ef5098bab92f4536eb9a372d9b99ed852a9a816c341127399f51a6d053856
```

**Listando todos los contenedores:**

```bash
docker container ls --all
```

**Output:**

```bash
# CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS               NAMES
# 2e7ef5098bab        fhsinchy/hello-dock   "/docker-entrypoint.…"   30 seconds ago      Created                                 hello-dock
```

**Iniciando un contenedor creado:**

```bash
docker container start hello-dock
```

**Output:**

```bash
# hello-dock
```

**Verificando que está corriendo:**

```bash
docker container ls
```

**Output:**

```bash
# CONTAINER ID        IMAGE                 COMMAND                  CREATED              STATUS              PORTS                  NAMES
# 2e7ef5098bab        fhsinchy/hello-dock   "/docker-entrypoint.…"   About a minute ago   Up 29 seconds       0.0.0.0:8080->80/tcp   hello-dock
```

**Explicación del ejemplo:**
Primero, `docker container create` crea el contenedor "hello-dock" en estado `Created`. Luego, `docker container start hello-dock` lo inicia, cambiando su estado a `Up`.

#### 3. **Notas o advertencias:**

- `docker container run` es en realidad una combinación de `docker container create` y `docker container start`.
- En la mayoría de los casos, `run` es suficiente, pero `create` es útil en escenarios más avanzados donde necesitas configurar el contenedor antes de iniciarlo.

## J - Eliminando Contenedores Detenidos

#### 1. **Definición:**

Los contenedores detenidos siguen ocupando espacio en tu sistema. `docker container rm` (remove) te permite limpiar estos contenedores "colgando" (dangling).

#### 2. **Ejemplo:**

**Listando todos los contenedores (para ver los detenidos):**

```bash
docker container ls --all
```

**Output:**

```bash
# CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS                      PORTS                  NAMES
# b1db06e400c4        fhsinchy/hello-dock   "/docker-entrypoint.…"   6 minutes ago       Up About a minute           0.0.0.0:8888->80/tcp   hello-dock-container
# 9f21cb777058        fhsinchy/hello-dock   "/docker-entrypoint.…"   10 minutes ago      Up About a minute           0.0.0.0:8080->80/tcp   hello-dock-container-2
# 6cf52771dde1        fhsinchy/hello-dock   "/docker-entrypoint.…"   10 minutes ago      Exited (0) 10 minutes ago                          reverent_torvalds
# 128ec8ceab71        hello-world           "/hello"                 12 minutes ago      Exited (0) 12 minutes ago                          exciting_chebyshev
```

**Eliminando un contenedor específico:**

```bash
docker container rm 6cf52771dde1
```

**Output:**

```bash
# 6cf52771dde1
```

**Eliminando varios contenedores a la vez:**

```bash
docker container rm <ID_contenedor_1> <ID_contenedor_2> <ID_contenedor_3>
```

**Eliminando todos los contenedores detenidos (prune):**

```bash
docker container prune
```

Docker te pedirá confirmación:

```
# WARNING! This will remove all stopped containers.
# Are you sure you want to continue? [y/N]
```

Puedes usar `--force` o `-f` para evitar la confirmación:

```bash
docker container prune --force
```

#### 3. **Notas o advertencias:**

- `docker container rm <ID_o_nombre>` elimina contenedores específicos.
- `docker container prune` elimina **todos** los contenedores detenidos. ¡Úsalo con cuidado!
- No puedes eliminar contenedores que estén corriendo. Primero debes detenerlos.

## K - Eliminación Automática de Contenedores

#### 1. **Definición:**

Si quieres que un contenedor se elimine automáticamente justo después de que se detiene, puedes usar la opción `--rm` con `docker container run` o `docker container start`. ¡Ideal para contenedores temporales!

#### 2. **Ejemplo:**

**Ejecutando un contenedor con eliminación automática:**

```bash
docker container run --rm --detach --publish 8888:80 --name hello-dock-volatile fhsinchy/hello-dock
```

**Verificando que está corriendo:**

```bash
docker container ls
```

**Output:**

```bash
# CONTAINER ID   IMAGE                 COMMAND                  CREATED              STATUS              PORTS                  NAMES
# 0d74e14091dc   fhsinchy/hello-dock   "/docker-entrypoint.…"   About a minute ago   Up About a minute   0.0.0.0:8888->80/tcp   hello-dock-volatile
```

**Deteniendo el contenedor:**

```bash
docker container stop hello-dock-volatile
```

**Output:**

```bash
# hello-dock-volatile
```

**Verificando la lista de contenedores (todos):**

```bash
docker container ls --all
```

**Output:**

```bash
# CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
```

¡La lista está vacía! El contenedor `hello-dock-volatile` se eliminó automáticamente al detenerse.

#### 3. **Notas o advertencias:**

- Usa `--rm` con `docker container run` o `docker container start` para habilitar la eliminación automática.
- Es muy útil para contenedores que solo necesitas ejecutar una vez o que son temporales.
- Una vez que un contenedor con `--rm` se detiene, ¡desaparece! No podrás reiniciarlo ni inspeccionarlo después.

## L - Modo Interactivo

#### 1. **Definición:**

El modo interactivo te permite "entrar" dentro de un contenedor que está corriendo y usar la terminal como si estuvieras directamente en ese sistema operativo. Es como abrir una puerta a la consola del contenedor.

#### 2. **Ejemplo:**

**Entrando a un contenedor Ubuntu:**

```bash
docker container run --rm -it ubuntu
```

**Output (dentro del contenedor Ubuntu):**

```bash
# root@dbb1f56b9563:/# cat /etc/os-release
# NAME="Ubuntu"
# VERSION="20.04.1 LTS (Focal Fossa)"
# ... (más información de Ubuntu) ...
```

**Explicación del ejemplo:**
`--rm -it ubuntu` crea y ejecuta un contenedor Ubuntu en modo interactivo. `-it` es una combinación de dos opciones:

- `-i` o `--interactive`: Mantiene la entrada estándar (teclado) abierta para que puedas enviar comandos al contenedor.
- `-t` o `--tty`: Asigna una pseudo-TTY, lo que te da una experiencia de terminal "bonita" y funcional dentro del contenedor.

Ahora estás dentro del contenedor Ubuntu, ¡puedes ejecutar comandos Linux como `cat /etc/os-release`!

**Saliendo del modo interactivo:**

Escribe `exit` y presiona Enter. Volverás a tu terminal normal.

#### 3. **Notas o advertencias:**

- Siempre usa `-it` (o `--interactive --tty`) cuando quieras interactuar con la terminal dentro de un contenedor.
- Funciona genial con imágenes de sistemas operativos (como `ubuntu`, `fedora`, `alpine`) o imágenes de lenguajes de programación que ofrecen shells interactivas (como `node`, `python`, `bash`).

## M - Ejecutando Comandos Dentro de Contenedores (No Interactivos)

#### 1. **Definición:**

A veces solo necesitas ejecutar un comando específico dentro de un contenedor que ya existe o al crear uno nuevo, sin entrar en modo interactivo. Es como pedirle al contenedor que haga una tarea rápida y te dé el resultado.

#### 2. **Ejemplo:**

**Ejecutando `uname -a` en un contenedor Alpine:**

```bash
docker container run alpine uname -a
```

**Output:**

```bash
# Linux f08dbbe9199b 5.8.0-22-generic #23-Ubuntu SMP Fri Oct 9 00:34:40 UTC 2020 x86_64 Linux
```

**Explicación del ejemplo:**
`docker container run alpine uname -a` crea un contenedor Alpine, ejecuta el comando `uname -a` dentro de él, muestra el resultado en tu terminal, y luego detiene y (en este caso con `--rm` implícito o si no se especifica) elimina el contenedor.

**Ejecutando un comando complejo con `sh -c` en Busybox:**

```bash
docker container run --rm busybox sh -c "echo -n my-secret | base64"
```

**Output:**

```bash
# bXktc2VjcmV0
```

**Explicación del ejemplo:**
Aquí usamos `sh -c "<comando>"` para ejecutar un comando más complejo (pipeline con `echo` y `base64`) dentro de un contenedor Busybox. `sh` es la shell (intérprete de comandos) dentro del contenedor Busybox, y `-c` le dice a `sh` que ejecute el comando que viene a continuación como una cadena.

#### 3. **Notas o advertencias:**

- Todo lo que escribas después del nombre de la imagen en `docker container run` se pasa como argumentos al "entrypoint" (punto de entrada) de la imagen.
- La mayoría de las imágenes usan `sh` o `bash` como entrypoint por defecto, así que puedes pasar comandos shell directamente.
- Es útil para tareas rápidas, scripts, o cuando solo necesitas el resultado de un comando dentro de un entorno específico (el contenedor).

## N - Trabajando con Imágenes Ejecutables y Bind Mounts

#### 1. **Definición:**

Las "imágenes ejecutables" están diseñadas para comportarse como programas. Junto con los "bind mounts", puedes darles acceso a directorios de tu sistema local, ¡haciendo que los contenedores interactúen directamente con tus archivos!

#### 2. **Ejemplo:**

**Ejecutando `rmbyext` (programa para borrar archivos por extensión) en un contenedor con bind mount:**

```bash
docker container run --rm -v $(pwd):/zone fhsinchy/rmbyext pdf
```

**Explicación del ejemplo:**

- `fhsinchy/rmbyext`: Una imagen ejecutable que contiene el script `rmbyext`.
- `pdf`: El argumento que se pasa al script `rmbyext` dentro del contenedor (la extensión de los archivos a borrar).
- `-v $(pwd):/zone` (o `--volume $(pwd):/zone`): Esto es un "bind mount". Conecta el directorio actual de tu sistema local (`$(pwd)` que se expande al path absoluto del directorio actual) al directorio `/zone` dentro del contenedor. ¡Cualquier cambio en `/zone` dentro del contenedor afectará directamente a tu directorio local!

![image](https://docker-handbook.farhan.dev/container-manipulation-basics/bind-mount.png)

En este ejemplo, el comando `rmbyext pdf` se ejecuta dentro del contenedor, pero gracias al bind mount, ¡está operando directamente sobre los archivos en tu directorio local! Borrará todos los archivos `.pdf` en el directorio donde ejecutas el comando.

#### 3. **Notas o advertencias:**

- **Imágenes Ejecutables:** Tienen un "entrypoint" configurado para ejecutar un programa específico (no una shell). Los argumentos que les pasas en `docker run` se envían directamente a ese programa.
- **Bind Mounts (`-v` o `--volume`):** Sintaxis: `-v <directorio-local>:<directorio-contenedor>:<opciones-acceso>`. El tercer campo (opciones de acceso) es opcional. Crea una conexión directa entre un directorio de tu máquina y un directorio dentro del contenedor.
- **¡Cuidado con los Bind Mounts!** Los contenedores pueden modificar archivos en tu sistema local si les das acceso con bind mounts. Asegúrate de entender lo que estás haciendo, especialmente con imágenes de terceros.
