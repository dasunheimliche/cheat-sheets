## A - Aislamiento de Contenedores y el Reto de la Comunicación

#### 1. **Definición:**

Los contenedores Docker son entornos aislados. Por defecto, no pueden comunicarse entre sí directamente. Imagina que tienes dos contenedores, uno con una aplicación web y otro con una base de datos. Necesitas una forma de "conectar el cable" entre ellos para que puedan trabajar juntos.

#### 2. **Ejemplo:**

Piensa en dos habitaciones separadas (contenedores). En una habitación tienes una aplicación que necesita datos (aplicación web), y en la otra habitación tienes los datos (base de datos). Necesitas crear una puerta o un túnel para que la aplicación pueda acceder a los datos.

#### 3. **Notas o advertencias:**

- Este aislamiento es una característica de seguridad importante de Docker.
- Para aplicaciones sencillas de un solo contenedor, este aislamiento no es un problema. Pero para proyectos más complejos con múltiples partes, la comunicación entre contenedores es esencial.

## B - Intentos Incorrectos de Conexión entre Contenedores

#### 1. **Definición:**

Existen formas intuitivas pero **incorrectas** de intentar conectar contenedores, que no funcionan debido al aislamiento. Dos de estas ideas erróneas son:

- **Usar puertos expuestos:** Pensar que conectar a `127.0.0.1:puerto_expuesto` desde un contenedor funcionará para otro contenedor.
- **Usar la IP del contenedor:** Intentar encontrar la IP de un contenedor y usarla para conectar desde otro contenedor.

#### 2. **Ejemplo - Puerto Expuesto:**

Imagina que expones el puerto 5432 de un contenedor de base de datos PostgreSQL. Si desde otro contenedor intentas conectar a `127.0.0.1:5432`, **no funcionará**. `127.0.0.1` siempre se refiere a "este mismo contenedor", no a tu máquina host ni a otros contenedores.

#### 3. **Ejemplo - IP del Contenedor:**

Puedes encontrar la IP de un contenedor con `docker container inspect`. Pero usar esta IP directamente para conectar **no es recomendable** por dos razones:

- **No es estable:** La IP puede cambiar si el contenedor se reinicia o se recrea.
- **No es la forma correcta:** Docker ofrece mejores soluciones para la comunicación entre contenedores.

#### 4. **Notas o advertencias:**

- Aunque estas ideas parecen lógicas al principio, el aislamiento de contenedores las hace inviables.
- Usar estas técnicas puede funcionar en algunos casos simples, pero no es una solución robusta ni escalable para proyectos reales.

## C - Redes Bridge Definidas por el Usuario: La Solución

#### 1. **Definición:**

La forma **correcta** de conectar contenedores en Docker es usando **redes bridge definidas por el usuario**. Piensa en esto como crear una "red local privada" para tus contenedores. Al poner contenedores en la misma red, les permites comunicarse de forma segura y estable.

#### 2. **Analogía:**

Imagina que tienes varias casas (contenedores) y quieres que se comuniquen entre sí. En lugar de usar la red pública de internet (puertos expuestos o IPs directas), creas una calle privada (red bridge definida por el usuario) donde todas las casas pueden "hablar" entre ellas fácilmente.

#### 3. **Beneficios Clave:**

- **Resolución DNS Automática:** Los contenedores se encuentran por su **nombre** en lugar de IPs. ¡Mucho más fácil!
- **Mejor Aislamiento:** Separa tus contenedores en redes lógicas, evitando conflictos y mejorando la seguridad.
- **Flexibilidad:** Puedes conectar y desconectar contenedores de estas redes "en caliente", sin tener que recrearlos.

#### 4. **Notas o advertencias:**

- Docker proporciona redes por defecto, pero las redes **definidas por el usuario** son mucho más potentes y recomendables para la mayoría de los casos.
- Usar redes bridge definidas por el usuario es una **buena práctica** en Docker.

## D - Básicos de Redes en Docker

#### 1. **Definición:**

En Docker, una **red** es un objeto lógico, como un contenedor o una imagen. Puedes crear, gestionar y eliminar redes usando comandos de Docker.

#### 2. **Listar Redes:**

Para ver las redes que tienes en tu sistema, usa el comando:

```bash
docker network ls
```

#### 3. **Ejemplo de Salida:**

```
NETWORK ID     NAME      DRIVER    SCOPE
c2e59f2b96bd   bridge    bridge    local
124dccee067f   host      host      local
506e3822bf1f   none      null      local
```

**Explicación del ejemplo:**
Esta salida muestra una tabla con información sobre las redes:

- **NETWORK ID:** Un identificador único para cada red.
- **NAME:** El nombre de la red. `bridge` es la red bridge por defecto.
- **DRIVER:** El tipo de red. `bridge`, `host`, `none` son drivers comunes.
- **SCOPE:** Indica el alcance de la red (`local` en este caso).

#### 4. **Drivers de Red:**

Los **drivers de red** definen el tipo de red y cómo funciona. Docker tiene varios drivers, pero los más importantes son:

- **`bridge`:** El driver por defecto. Ideal para conectar contenedores que necesitan comunicarse entre sí en la misma máquina Docker.
- **`host`:** Elimina el aislamiento de red. El contenedor comparte la red de la máquina host. ¡Cuidado con la seguridad!
- **`none`:** Desactiva completamente la red para el contenedor. Útil en casos muy específicos donde no se necesita red.
- **`overlay` y `macvlan`:** Drivers más avanzados para escenarios específicos (fuera del alcance de esta guía básica).

#### 5. **Notas o advertencias:**

- Para la mayoría de las aplicaciones multi-contenedor, el driver `bridge` (especialmente las redes bridge definidas por el usuario) es el más útil.
- Entender los drivers de red te permite elegir la mejor opción para tus necesidades.

## E - La Red Bridge por Defecto

#### 1. **Definición:**

Docker viene con una red bridge **por defecto** llamada `bridge`. Si no especificas una red al crear un contenedor, se conecta automáticamente a esta red `bridge`.

#### 2. **Ejemplo - Contenedor en la Red Bridge por Defecto:**

```bash
docker container run --rm --detach --name hello-dock --publish 8080:80 fhsinchy/hello-dock
```

Este comando crea un contenedor `hello-dock`. Si ahora inspeccionas la red `bridge`, verás que `hello-dock` está conectado a ella:

```bash
docker network inspect --format='{{range .Containers}}{{.Name}}{{end}}' bridge
```

**Salida:**

```
hello-dock
```

**Explicación del ejemplo:**
El contenedor `hello-dock` se ha unido automáticamente a la red `bridge` por defecto.

#### 3. **Comunicación en la Red Bridge por Defecto:**

Los contenedores en la red `bridge` por defecto **pueden comunicarse usando IPs**, pero como vimos antes, esto no es ideal.

#### 4. **Limitaciones de la Red Bridge por Defecto:**

- **Sin Resolución DNS Automática por Nombre:** No puedes usar el nombre del contenedor para comunicarte con él fácilmente.
- **Menos Aislamiento:** Todos los contenedores por defecto están en la misma red, lo que puede ser menos seguro y más propenso a conflictos en proyectos grandes.
- **Menos Flexible:** Para desconectar un contenedor de la red `bridge` por defecto, necesitas recrearlo.

#### 5. **Notas o advertencias:**

- Aunque la red `bridge` por defecto es útil para empezar, para proyectos más serios, las **redes bridge definidas por el usuario** son muy superiores.
- Evita depender de la red `bridge` por defecto para la comunicación entre contenedores en entornos de producción.

## F - Creando una Red Bridge Definida por el Usuario

#### 1. **Definición:**

Crear tu propia red bridge definida por el usuario es muy sencillo. Usa el comando `docker network create`.

#### 2. **Comando para Crear una Red:**

```bash
docker network create <nombre_de_red>
```

#### 3. **Ejemplo - Crear la Red 'skynet':**

```bash
docker network create skynet
```

**Salida:**

```
7bd5f351aa892ac6ec15fed8619fc3bbb95a7dcdd58980c28304627c8f7eb070
```

#### 4. **Verificar la Creación:**

Puedes verificar que la red se ha creado con `docker network ls`:

```bash
docker network ls
```

**Ejemplo de Salida (con la nueva red 'skynet'):**

```
NETWORK ID     NAME     DRIVER    SCOPE
be0cab667c4b   bridge   bridge    local
124dccee067f   host     host      local
506e3822bf1f   none     null      local
7bd5f351aa89   skynet   bridge    local
```

**Explicación del ejemplo:**
La red `skynet` aparece ahora en la lista de redes, con el driver `bridge`.

#### 5. **Notas o advertencias:**

- Elige nombres descriptivos para tus redes (ej: `backend-net`, `frontend-net`).
- Por defecto, `docker network create` crea redes de tipo `bridge`.

## G - Conectando Contenedores a una Red

#### 1. **Dos Formas de Conectar:**

Hay dos maneras principales de conectar un contenedor a una red definida por el usuario:

- **`docker network connect` (para contenedores existentes):** Conecta un contenedor que ya está en marcha a una red.
- **`--network` en `docker container run` o `create` (al crear el contenedor):** Especifica la red al crear el contenedor.

#### 2. **`docker network connect`:**

**Sintaxis:**

```bash
docker network connect <identificador_red> <identificador_contenedor>
```

**Ejemplo - Conectar `hello-dock` a `skynet`:**

```bash
docker network connect skynet hello-dock
```

**Verificar la Conexión:**

```bash
docker network inspect --format='{{range .Containers}} {{.Name}} {{end}}' skynet
```

**Salida:**

```
hello-dock
```

**Explicación del ejemplo:**
El contenedor `hello-dock` ahora está conectado a la red `skynet`.

#### 3. **`--network` en `docker container run`:**

**Sintaxis:**

```bash
docker container run --network <identificador_red> ...
```

**Ejemplo - Crear `alpine-box` en `skynet`:**

```bash
docker container run --network skynet --rm --name alpine-box -it alpine sh
```

#### 4. **Resolución DNS Automática en Acción:**

Dentro del contenedor `alpine-box` (conectado a `skynet`), puedes hacer ping a `hello-dock` ¡usando su nombre!

```bash
/ # ping hello-dock
```

**Ejemplo de Salida (ping exitoso):**

```
PING hello-dock (172.18.0.2): 56 data bytes
64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.191 ms
...
```

**Explicación del ejemplo:**
¡Funciona! Docker resuelve automáticamente el nombre `hello-dock` a su IP dentro de la red `skynet`.

#### 5. **Notas o advertencias:**

- Para que la resolución DNS por nombre funcione, ¡asegúrate de dar **nombres personalizados** a tus contenedores con `--name`! Los nombres generados aleatoriamente no funcionarán para esto.
- Un contenedor puede estar conectado a **múltiples redes** a la vez.

## H - Desconectando Contenedores de una Red

#### 1. **Comando para Desconectar:**

Usa el comando `docker network disconnect`.

#### 2. **Sintaxis:**

```bash
docker network disconnect <identificador_red> <identificador_contenedor>
```

#### 3. **Ejemplo - Desconectar `hello-dock` de `skynet`:**

```bash
docker network disconnect skynet hello-dock
```

#### 4. **Notas o advertencias:**

- Al igual que `docker network connect`, `docker network disconnect` no muestra salida en la consola si tiene éxito.
- Puedes verificar la desconexión inspeccionando la red con `docker network inspect`.

## I - Eliminando Redes

#### 1. **Comando para Eliminar Redes:**

Usa el comando `docker network rm`.

#### 2. **Sintaxis:**

```bash
docker network rm <identificador_red>
```

#### 3. **Ejemplo - Eliminar la Red `skynet`:**

```bash
docker network rm skynet
```

#### 4. **Eliminar Redes No Utilizadas (Prune):**

Para eliminar redes que no están siendo usadas por ningún contenedor, usa `docker network prune`.

```bash
docker network prune
```

**Opciones de `docker network prune`:**

- `-f` o `--force`: Fuerza la eliminación sin confirmación.
- `-a` o `--all`: (Según el texto, esta opción no se menciona como parte de `prune`, verificar documentación oficial si es necesario).

#### 5. **Notas o advertencias:**

- Asegúrate de que ningún contenedor esté usando la red que intentas eliminar. Si hay contenedores conectados, Docker te dará un error.
- `docker network prune` es útil para limpiar redes que ya no necesitas y liberar recursos.
