## A - ¿Qué es Docker Compose?

#### 1. **Definición:**

Docker Compose es como un **director de orquesta** para tus aplicaciones Docker que tienen múltiples contenedores. En lugar de dar un montón de comandos complicados para levantar cada contenedor por separado, con Compose usas un único archivo (`docker-compose.yaml`) para definir todos los servicios (contenedores) de tu aplicación y cómo se relacionan entre sí. ¡Con un solo comando, levantas toda la orquesta!

#### 2. **Ejemplo:**

Imagina que tienes una aplicación web con una base de datos (PostgreSQL) y un servidor web (Node.js). Con Docker Compose, en lugar de arrancar PostgreSQL y Node.js por separado, defines ambos en un archivo `docker-compose.yaml` y los levantas juntos con un comando.

#### 3. **Notas o advertencias:**

- Docker Compose es **ideal para desarrollo y pruebas**, pero **no se recomienda para producción**. Para entornos de producción, existen otras herramientas más robustas.
- Piensa en `docker-compose.yaml` como la **partitura** de tu aplicación multi-contenedor.

## B - Archivo `docker-compose.yaml`

#### 1. **Definición:**

Es el **corazón de Docker Compose**. Un archivo en formato YAML donde defines todos los **servicios** (contenedores), **volúmenes** y **redes** que componen tu aplicación multi-contenedor. Es como la receta de tu plato Docker.

#### 2. **Ejemplo:**

```yaml
version: "3.8" # Versión del formato de Docker Compose

services: # Aquí defines tus contenedores (servicios)
  db: # Servicio de base de datos (PostgreSQL)
    image: postgres:12 # Imagen de Docker que usará
    container_name: notes-db-dev # Nombre del contenedor
    volumes: # Volúmenes para persistencia de datos
      - db-data:/var/lib/postgresql/data
    environment: # Variables de entorno para configurar PostgreSQL
      POSTGRES_DB: notesdb
      POSTGRES_PASSWORD: secret
  api: # Servicio de API (Node.js)
    build: # Instrucciones para construir la imagen desde un Dockerfile
      context: ./api # Directorio donde está el Dockerfile
      dockerfile: Dockerfile.dev # Nombre del Dockerfile
    image: notes-api:dev # Nombre de la imagen que se construirá
    container_name: notes-api-dev # Nombre del contenedor
    environment: # Variables de entorno para la API
      DB_HOST: db # Nombre del servicio 'db' (PostgreSQL)
      DB_DATABASE: notesdb
      DB_PASSWORD: secret
    volumes: # Volúmenes para desarrollo (hot-reload)
      - /home/node/app/node_modules
      - ./api:/home/node/app
    ports: # Mapeo de puertos para acceder a la API desde el host
      - 3000:3000

volumes: # Volúmenes nombrados definidos fuera de los servicios
  db-data:
    name: notes-db-dev-data
```

**Explicación del ejemplo:**

Este `docker-compose.yaml` define dos servicios: `db` (PostgreSQL) y `api` (Node.js).

- **`version: "3.8"`**: Indica la versión del formato del archivo Compose. Siempre debe ir al principio.
- **`services:`**: Aquí se listan todos los servicios (contenedores) de tu aplicación.
- **`db:` y `api:`**: Son los nombres de nuestros servicios. Tú eliges los nombres.
- Dentro de cada servicio (`db`, `api`), se definen propiedades como `image`, `build`, `container_name`, `volumes`, `environment`, `ports`, etc. ¡Veremos estas propiedades en detalle más adelante!
- **`volumes:`** al final define volúmenes nombrados que pueden ser usados por los servicios.

#### 3. **Notas o advertencias:**

- La **indentación** en YAML es **crucial**. ¡Asegúrate de que tu archivo esté bien indentado (usando espacios, no tabs)!
- El archivo se llama por convención `docker-compose.yaml` (o `docker-compose.yml`).
- Docker Compose busca este archivo por defecto en el directorio donde ejecutas los comandos.

## C - Bloque `services` en `docker-compose.yaml`

#### 1. **Definición:**

Es la sección principal de `docker-compose.yaml` donde defines cada uno de los **servicios** (contenedores) que componen tu aplicación. Cada servicio es como un componente de tu aplicación, por ejemplo, la base de datos, la API, el frontend, etc.

#### 2. **Ejemplo:**

```yaml
services:
  db: # Servicio 'db' (base de datos)
    image: postgres:12
    # ... más configuraciones para 'db'
  api: # Servicio 'api' (servidor web)
    build:
      context: ./api
      dockerfile: Dockerfile.dev
    # ... más configuraciones para 'api'
```

**Explicación del ejemplo:**

En este ejemplo, dentro de `services`, definimos dos servicios: `db` y `api`. Cada uno de estos bloques (`db:` y `api:`) contendrá la configuración específica para ese servicio, como la imagen que usarán, cómo construirla, variables de entorno, etc.

#### 3. **Notas o advertencias:**

- Cada servicio dentro de `services` se convierte en un contenedor cuando levantas tu aplicación con `docker-compose up`.
- El nombre que le das al servicio (ej: `db`, `api`) es importante porque se usa para la **comunicación entre contenedores** dentro de Docker Compose. (Veremos esto en 'environment').

## D - Definición de un Servicio: `image`

#### 1. **Definición:**

La propiedad `image` dentro de la definición de un servicio especifica la **imagen de Docker pre-construida** que se usará para crear el contenedor de ese servicio. Es como decirle a Docker Compose: "Para este servicio, usa esta imagen que ya existe en Docker Hub o localmente".

#### 2. **Ejemplo:**

```yaml
services:
  db:
    image: postgres:12 # Usa la imagen oficial de PostgreSQL versión 12
    container_name: notes-db-dev
    # ...
```

**Explicación del ejemplo:**

Aquí, para el servicio `db`, estamos usando la imagen `postgres:12`. Docker Compose descargará esta imagen de Docker Hub (si no la tienes localmente) y la usará para crear el contenedor `notes-db-dev`.

#### 3. **Notas o advertencias:**

- Puedes usar **cualquier imagen de Docker Hub** o imágenes que hayas construido y tengas localmente.
- La sintaxis es `image: nombre_de_la_imagen:tag`. Si no pones el tag (ej: `postgres`), por defecto usa el tag `latest`.
- Si usas `image`, **no necesitas usar `build`** para este servicio, ya que estás usando una imagen pre-construida.

## E - Definición de un Servicio: `build`

#### 1. **Definición:**

La propiedad `build` se usa cuando **no tienes una imagen pre-construida** para tu servicio y necesitas **construirla desde un Dockerfile**. Le dices a Docker Compose: "Para este servicio, construye una imagen usando el Dockerfile que te indico".

#### 2. **Ejemplo:**

```yaml
services:
  api:
    build:
      context: ./api # Directorio donde está el Dockerfile (contexto de construcción)
      dockerfile: Dockerfile.dev # Nombre del Dockerfile (si no es 'Dockerfile')
    image: notes-api:dev # Nombre que le daremos a la imagen construida
    container_name: notes-api-dev
    # ...
```

**Explicación del ejemplo:**

Para el servicio `api`, usamos `build`.

- **`context: ./api`**: Indica que el **contexto de construcción** es el directorio `./api`. El contexto es el directorio donde Docker buscará el Dockerfile y otros archivos necesarios para construir la imagen.
- **`dockerfile: Dockerfile.dev`**: Especifica que el **Dockerfile** que se usará para construir la imagen se llama `Dockerfile.dev` y está dentro del contexto (en este caso, dentro de `./api`). Si tu Dockerfile se llama simplemente `Dockerfile`, no necesitas esta línea.
- **`image: notes-api:dev`**: Define el **nombre que le daremos a la imagen** que se construirá. En este caso, `notes-api:dev`.

#### 3. **Notas o advertencias:**

- Si usas `build`, Docker Compose **construirá la imagen la primera vez** que ejecutes `docker-compose up` o cuando la imagen no exista. En ejecuciones posteriores, si no hay cambios en el Dockerfile o el contexto, Docker usará la imagen en caché (para acelerar el proceso).
- Puedes usar `docker-compose up --build` para **forzar la reconstrucción de la imagen** incluso si no hay cambios.
- Si usas `build`, **no necesitas usar `image`** para _obtener_ la imagen, pero sí es buena práctica usar `image` para **nombrar la imagen que se construirá**.

## F - Definición de un Servicio: `container_name`

#### 1. **Definición:**

`container_name` te permite **especificar un nombre personalizado** para el contenedor de un servicio. Si no lo defines, Docker Compose generará un nombre automáticamente basado en el nombre del directorio del proyecto y el nombre del servicio.

#### 2. **Ejemplo:**

```yaml
services:
  db:
    image: postgres:12
    container_name: notes-db-dev # Nombre personalizado para el contenedor de la base de datos
    # ...
  api:
    build:
      context: ./api
      dockerfile: Dockerfile.dev
    container_name: notes-api-dev # Nombre personalizado para el contenedor de la API
    # ...
```

**Explicación del ejemplo:**

Aquí, hemos nombrado explícitamente los contenedores como `notes-db-dev` y `notes-api-dev`. Esto facilita identificarlos cuando usas comandos de Docker como `docker ps` o `docker-compose ps`.

#### 3. **Notas o advertencias:**

- Usar `container_name` es **opcional**, pero **recomendable** para tener nombres de contenedores más descriptivos y fáciles de recordar.
- Los nombres de contenedor deben ser **únicos** dentro de tu entorno Docker.

## G - Definición de un Servicio: `volumes`

#### 1. **Definición:**

`volumes` define los **volúmenes** que se montarán en el contenedor de un servicio. Los volúmenes se usan para **persistir datos** (que no se pierdan al eliminar el contenedor) o para **compartir código** entre tu máquina host y el contenedor (útil para desarrollo).

#### 2. **Ejemplo:**

```yaml
services:
  db:
    image: postgres:12
    volumes:
      - db-data:/var/lib/postgresql/data # Volumen nombrado 'db-data' mapeado al directorio de datos de PostgreSQL
    # ...
  api:
    build:
      context: ./api
      dockerfile: Dockerfile.dev
    volumes:
      - /home/node/app/node_modules # Volumen anónimo para no persistir 'node_modules'
      - ./api:/home/node/app # Bind mount: directorio './api' de tu host mapeado al directorio '/home/node/app' del contenedor
    # ...

volumes: # Definición del volumen nombrado 'db-data' fuera de los servicios
  db-data:
    name: notes-db-dev-data # Nombre explícito para el volumen nombrado
```

**Explicación del ejemplo:**

- **Servicio `db`:**
  - `- db-data:/var/lib/postgresql/data`: Esto crea un **volumen nombrado** llamado `db-data` (definido en la sección `volumes` al final del archivo) y lo monta en el directorio `/var/lib/postgresql/data` dentro del contenedor `db`. Esto asegura que los datos de la base de datos PostgreSQL se guarden en este volumen y persistan incluso si eliminas el contenedor.
- **Servicio `api`:**
  - `- /home/node/app/node_modules`: Esto crea un **volumen anónimo** y lo monta en `/home/node/app/node_modules` dentro del contenedor `api`. Los volúmenes anónimos son útiles para directorios que no quieres persistir (como `node_modules` en desarrollo, que se pueden reinstalar fácilmente).
  - `- ./api:/home/node/app`: Esto crea un **bind mount**. Monta el directorio `./api` de tu máquina host en el directorio `/home/node/app` dentro del contenedor `api`. Esto es **muy útil para desarrollo**, ya que cualquier cambio que hagas en los archivos de tu proyecto en tu máquina host se reflejará inmediatamente dentro del contenedor (hot-reload).

#### 3. **Notas o advertencias:**

- Hay tres tipos principales de volúmenes en Docker Compose:
  - **Volúmenes nombrados:** Se definen en la sección `volumes` y se referencian por nombre en los servicios. Son la forma recomendada para persistir datos.
  - **Volúmenes anónimos:** Se definen solo en la sección `volumes` de un servicio (ej: `- /ruta/en/contenedor`). Docker les da un nombre aleatorio y son útiles para datos temporales.
  - **Bind mounts:** Montan un directorio o archivo específico de tu máquina host dentro del contenedor (ej: `- ./local:/remoto`). Útiles para desarrollo y compartir configuración.
- La sintaxis general es `- <origen>:<destino>`. `<origen>` depende del tipo de volumen (nombre de volumen, ruta local, etc.) y `<destino>` es siempre una ruta dentro del contenedor.

## H - Definición de un Servicio: `environment`

#### 1. **Definición:**

`environment` te permite definir **variables de entorno** que estarán disponibles dentro del contenedor de un servicio. Las variables de entorno son una forma común de configurar aplicaciones sin tener que modificar el código directamente.

#### 2. **Ejemplo:**

```yaml
services:
  db:
    image: postgres:12
    environment:
      POSTGRES_DB: notesdb # Variable de entorno para el nombre de la base de datos
      POSTGRES_PASSWORD: secret # Variable de entorno para la contraseña de PostgreSQL
    # ...
  api:
    build:
      context: ./api
      dockerfile: Dockerfile.dev
    environment:
      DB_HOST: db # Variable de entorno para el host de la base de datos (¡mira la nota!)
      DB_DATABASE: notesdb
      DB_PASSWORD: secret
    # ...
```

**Explicación del ejemplo:**

- **Servicio `db`:** Definimos las variables de entorno `POSTGRES_DB` y `POSTGRES_PASSWORD` para configurar el nombre de la base de datos y la contraseña de PostgreSQL. La imagen `postgres` usa estas variables para la configuración inicial.
- **Servicio `api`:** Definimos variables como `DB_HOST`, `DB_DATABASE`, `DB_PASSWORD` que nuestra aplicación API (Node.js) usará para conectarse a la base de datos.
  - **`DB_HOST: db`**: ¡Aquí está la magia de Docker Compose! En lugar de poner `localhost` o una IP, usamos el **nombre del servicio `db`**. Docker Compose automáticamente resuelve `db` al **nombre de host interno** del contenedor `db` dentro de la red de Docker Compose. ¡Así, la API puede encontrar la base de datos usando simplemente el nombre del servicio!

#### 3. **Notas o advertencias:**

- Las variables de entorno son muy útiles para **configurar diferentes entornos** (desarrollo, pruebas, producción) sin cambiar el código.
- Puedes definir variables de entorno directamente en el `docker-compose.yaml` o **cargarlas desde un archivo `.env`**.
- La **comunicación entre servicios por nombre** (como `DB_HOST: db`) es una de las grandes ventajas de Docker Compose.

## I - Definición de un Servicio: `ports`

#### 1. **Definición:**

`ports` define el **mapeo de puertos** entre tu máquina host y el contenedor de un servicio. Esto te permite acceder a los servicios que se ejecutan dentro de los contenedores desde tu navegador o desde otras aplicaciones en tu máquina host.

#### 2. **Ejemplo:**

```yaml
services:
  api:
    build:
      context: ./api
      dockerfile: Dockerfile.dev
    ports:
      - 3000:3000 # Mapea el puerto 3000 de tu host al puerto 3000 del contenedor
    # ...
```

**Explicación del ejemplo:**

- **`- 3000:3000`**: Esto mapea el **puerto 3000 de tu máquina host** al **puerto 3000 del contenedor `api`**. Ahora, puedes acceder a tu API desde tu navegador o cliente HTTP en `http://localhost:3000`.

#### 3. **Notas o advertencias:**

- La sintaxis es `- <puerto_host>:<puerto_contenedor>`.
- Si solo quieres exponer el puerto del contenedor en un puerto aleatorio del host, puedes usar solo el puerto del contenedor: `- "3000"`. Docker elegirá un puerto libre en tu host.
- Si quieres que el servicio solo sea accesible **internamente** dentro de la red de Docker Compose (y no desde tu host), **no definas `ports`**.

## J - Definición de un Servicio: `networks`

#### 1. **Definición:**

`networks` te permite **conectar un servicio a una o más redes de Docker**. Por defecto, Docker Compose crea una red bridge para tu proyecto y conecta todos los servicios a ella. Pero puedes definir redes personalizadas para un mayor control y aislamiento.

#### 2. **Ejemplo:**

```yaml
version: "3.8"

services:
  db:
    image: postgres:12
    networks:
      - backend # Conecta el servicio 'db' a la red 'backend'
    # ...
  api:
    build:
      context: ./api
      dockerfile: Dockerfile.dev
    networks:
      - backend # Conecta el servicio 'api' a la red 'backend'
    # ...
  client:
    build:
      context: ./client
      dockerfile: Dockerfile.dev
    networks:
      - frontend # Conecta el servicio 'client' a la red 'frontend'
    # ...
  nginx:
    build:
      context: ./nginx
      dockerfile: Dockerfile.dev
    ports:
      - 8080:80
    networks:
      - frontend # Conecta 'nginx' a la red 'frontend'
      - backend # Conecta 'nginx' también a la red 'backend' (¡para que pueda hablar con la API!)

networks: # Definición de redes personalizadas fuera de los servicios
  frontend:
    name: fullstack-notes-application-network-frontend # Nombre explícito para la red 'frontend'
    driver: bridge # Tipo de red (bridge es el más común)
  backend:
    name: fullstack-notes-application-network-backend # Nombre explícito para la red 'backend'
    driver: bridge # Tipo de red 'bridge'
```

**Explicación del ejemplo:**

- **`networks:`** al final del archivo define dos redes personalizadas: `frontend` y `backend`, ambas de tipo `bridge`.
- **Servicios `db` y `api`:** Se conectan a la red `backend`. Esto significa que solo pueden comunicarse entre sí (y con otros servicios que también estén en la red `backend`).
- **Servicio `client`:** Se conecta a la red `frontend`.
- **Servicio `nginx`:** Se conecta a **ambas redes**, `frontend` y `backend`. Esto es crucial porque Nginx actúa como un **router**. Recibe las peticiones del frontend (red `frontend`) y las puede redirigir a la API (red `backend`).

#### 3. **Notas o advertencias:**

- Usar redes personalizadas te permite **aislar servicios** y controlar mejor el flujo de tráfico entre ellos.
- Si no defines redes personalizadas, Docker Compose crea una red por defecto y conecta todos los servicios a ella. Esto suele ser suficiente para aplicaciones sencillas.
- El tipo de red `bridge` es el más común para aplicaciones Docker Compose.

## K - Comandos de Docker Compose: `up`

#### 1. **Definición:**

`docker-compose up` es el comando **mágico** para **levantar toda tu aplicación multi-contenedor** definida en `docker-compose.yaml`. Hace varias cosas:

1.  **Construye las imágenes** (si usas `build` en algún servicio y la imagen no existe o ha cambiado).
2.  **Crea los contenedores** para cada servicio.
3.  **Arranca los contenedores**.
4.  **Configura las redes y volúmenes**.

#### 2. **Ejemplo:**

```bash
docker-compose --file docker-compose.yaml up --detach
```

**Explicación del ejemplo:**

- **`docker-compose up`**: Comando principal para levantar la aplicación.
- **`--file docker-compose.yaml` o `-f docker-compose.yaml`**: Especifica el archivo `docker-compose.yaml` que se usará. Solo es necesario si tu archivo no se llama `docker-compose.yaml` o si está en otro directorio. En la mayoría de los casos, puedes omitir `--file`.
- **`--detach` o `-d`**: Arranca los contenedores **en segundo plano** (detached mode). Tu terminal quedará libre para seguir usando. Si no usas `--detach`, los logs de los contenedores se mostrarán en tu terminal (útil para desarrollo).

#### 3. **Notas o advertencias:**

- Ejecuta `docker-compose up` **en el mismo directorio donde está tu archivo `docker-compose.yaml`**.
- La primera vez que ejecutas `docker-compose up`, puede tardar un poco más porque tiene que construir las imágenes y descargar las imágenes base. Las siguientes veces será más rápido porque usará las imágenes en caché.
- Usa `--detach` para desarrollo y pruebas, para que tu terminal no se quede bloqueada con los logs.

## L - Comandos de Docker Compose: `start`

#### 1. **Definición:**

`docker-compose start` **arranca contenedores que ya existen pero están detenidos**. A diferencia de `up`, **no construye imágenes ni crea contenedores nuevos**. Es como el comando `docker container start` pero para todos los servicios definidos en tu `docker-compose.yaml`.

#### 2. **Ejemplo:**

```bash
docker-compose start
```

**Explicación del ejemplo:**

Este comando simplemente arranca los contenedores que ya fueron creados previamente con `docker-compose up` y que están en estado detenido.

#### 3. **Notas o advertencias:**

- `docker-compose start` es **más rápido que `docker-compose up`** porque no tiene que construir imágenes ni crear contenedores.
- Úsalo cuando ya has levantado tu aplicación con `up` y luego la has detenido con `stop` o `down`, y quieres volver a arrancarla rápidamente.

## M - Comandos de Docker Compose: `ps`

#### 1. **Definición:**

`docker-compose ps` te muestra el **estado de los contenedores** definidos en tu `docker-compose.yaml`. Es similar a `docker container ls`, pero **solo muestra los contenedores gestionados por Docker Compose** para tu proyecto actual.

#### 2. **Ejemplo:**

```bash
docker-compose ps
```

**Output de ejemplo:**

```
     Name                   Command               State           Ports
-------------------------------------------------------------------------------
 notes-api-dev   docker-entrypoint.sh ./nod ...   Up      0.0.0.0:3000->3000/tcp
 notes-db-dev    docker-entrypoint.sh postgres    Up      5432/tcp
```

**Explicación del ejemplo:**

El output muestra una tabla con información sobre los contenedores:

- **`Name`**: Nombre del contenedor (definido con `container_name` o generado por Docker Compose).
- **`Command`**: Comando que se está ejecutando dentro del contenedor.
- **`State`**: Estado del contenedor (`Up` = corriendo, `Exited` = detenido, etc.).
- **`Ports`**: Mapeo de puertos (si lo hay).

#### 3. **Notas o advertencias:**

- `docker-compose ps` es útil para **ver rápidamente si tus servicios están corriendo** y en qué estado se encuentran.
- Es menos detallado que `docker container ls -a`, pero más enfocado en los servicios de tu proyecto Docker Compose.

## N - Comandos de Docker Compose: `exec`

#### 1. **Definición:**

`docker-compose exec <nombre_servicio> <comando>` te permite **ejecutar un comando dentro de un contenedor en ejecución** de un servicio específico. Es como `docker container exec`, pero más fácil de usar con Docker Compose.

#### 2. **Ejemplo:**

```bash
docker-compose exec api npm run db:migrate
```

**Explicación del ejemplo:**

- **`docker-compose exec api`**: Indica que queremos ejecutar un comando dentro del contenedor del servicio `api`.
- **`npm run db:migrate`**: Es el comando que queremos ejecutar dentro del contenedor `api`. En este caso, ejecuta un script de migración de base de datos usando `npm`.

**Output de ejemplo:**

```
> notes-api@ db:migrate /home/node/app
> knex migrate:latest

Using environment: development
Batch 1 run: 1 migrations
```

#### 3. **Notas o advertencias:**

- **No necesitas usar `-it`** para sesiones interactivas como con `docker container exec`. `docker-compose exec` ya te da una terminal interactiva por defecto.
- `docker-compose exec` es muy útil para **depurar, ejecutar scripts, o entrar a la shell** de un contenedor en ejecución.

## O - Comandos de Docker Compose: `logs`

#### 1. **Definición:**

`docker-compose logs <nombre_servicio>` te muestra los **logs (registros) de un servicio en ejecución**. Es útil para ver la salida de tu aplicación, errores, etc.

#### 2. **Ejemplo:**

```bash
docker-compose logs api
```

**Output de ejemplo (parcial):**

```
Attaching to notes-api-dev
notes-api-dev | [nodemon] 2.0.7
notes-api-dev | [nodemon] reading config ./nodemon.json
notes-api-dev | [nodemon] to restart at any time, enter `rs`
notes-api-dev | [nodemon] or send SIGHUP to 1 to restart
notes-api-dev | [nodemon] ignoring: *.test.js
notes-api-dev | [nodemon] watching path(s): *.*
notes-api-dev | [nodemon] watching extensions: js,mjs,json
notes-api-dev | [nodemon] starting `node bin/www`
notes-api-dev | [nodemon] forking
notes-api-dev | [nodemon] child pid: 19
notes-api-dev | [nodemon] watching 18 files
notes-api-dev | app running -> http://127.0.0.1:3000
```

**Explicación del ejemplo:**

Este comando muestra los logs del servicio `api`. En este ejemplo, vemos logs de `nodemon` (una herramienta para desarrollo Node.js) indicando que la API se ha iniciado correctamente.

#### 3. **Notas o advertencias:**

- **`docker-compose logs -f <nombre_servicio>` o `docker-compose logs --follow <nombre_servicio>`**: Sigue los logs **en tiempo real**. Los nuevos logs se mostrarán en tu terminal a medida que se generen. Útil para ver la salida de tu aplicación mientras la usas. Presiona `Ctrl+C` para salir del modo `-f`.
- `docker-compose logs` es una herramienta esencial para **depurar y monitorizar** tus aplicaciones Docker Compose.

## P - Comandos de Docker Compose: `down`

#### 1. **Definición:**

`docker-compose down` es el comando para **detener y eliminar toda tu aplicación Docker Compose**. Hace lo siguiente:

1.  **Detiene los contenedores** de todos los servicios.
2.  **Elimina los contenedores**.
3.  **Elimina las redes** creadas por Docker Compose para tu proyecto.
4.  **Opcionalmente, elimina los volúmenes nombrados** (si usas la opción `--volumes`).

#### 2. **Ejemplo:**

```bash
docker-compose down --volumes
```

**Explicación del ejemplo:**

- **`docker-compose down`**: Comando principal para detener y eliminar la aplicación.
- **`--volumes`**: **Opcional**. Indica que también quieres **eliminar los volúmenes nombrados** definidos en la sección `volumes` de tu `docker-compose.yaml`. Si no usas `--volumes`, los volúmenes nombrados **se conservarán** (útil si quieres mantener los datos entre ejecuciones de `down` y `up`).

#### 3. **Notas o advertencias:**

- `docker-compose down` es el comando para **limpiar completamente** tu entorno Docker Compose.
- **¡Cuidado con `--volumes`!** Si lo usas, **perderás los datos** almacenados en los volúmenes nombrados. Úsalo solo si realmente quieres eliminar los datos. Si solo quieres detener la aplicación y conservarlos datos, usa `docker-compose stop` en su lugar.

## Q - Comandos de Docker Compose: `stop`

#### 1. **Definición:**

`docker-compose stop` **detiene los contenedores de todos los servicios**, pero **no los elimina**. Los contenedores y las redes se mantienen, y puedes volver a arrancarlos rápidamente con `docker-compose start` o `docker-compose up`. Es como `docker container stop` pero para todos los servicios de tu proyecto.

#### 2. **Ejemplo:**

```bash
docker-compose stop
```

**Explicación del ejemplo:**

Este comando detiene todos los contenedores definidos en tu `docker-compose.yaml`. Los contenedores quedarán en estado `Exited`.

#### 3. **Notas o advertencias:**

- `docker-compose stop` es **más rápido que `docker-compose down`** porque solo detiene los contenedores, no los elimina ni elimina las redes.
- Úsalo cuando quieres **detener temporalmente tu aplicación** pero quieres poder volver a arrancarla rápidamente sin tener que reconstruir imágenes o recrear contenedores. Es útil para **ahorrar recursos** cuando no estás usando la aplicación.
