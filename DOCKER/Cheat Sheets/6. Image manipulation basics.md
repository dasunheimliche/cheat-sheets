## A - Creación Básica de Imágenes

#### 1. **Definición:**

Las imágenes Docker son como plantillas congeladas y de solo lectura que se usan para crear contenedores. Piensa en ellas como el plano de construcción de tu contenedor. Un **Dockerfile** es un archivo de texto que contiene todas las instrucciones para construir una imagen.

#### 2. **Ejemplo:**

**Dockerfile:**

```dockerfile
FROM ubuntu:latest

EXPOSE 80

RUN apt-get update && \
    apt-get install nginx -y && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

CMD ["nginx", "-g", "daemon off;"]
```

**Explicación del ejemplo:**

Este Dockerfile crea una imagen basada en Ubuntu (`FROM ubuntu:latest`), expone el puerto 80 (`EXPOSE 80`), instala NGINX (`RUN apt-get ...`), y configura NGINX para que se ejecute cuando inicie el contenedor (`CMD ["nginx", "-g", "daemon off;"]`).

#### 3. **Notas o advertencias:**

- Cada `Dockerfile` debe empezar con `FROM` para definir la imagen base.
- `EXPOSE` documenta los puertos, pero aún necesitas usar `--publish` al ejecutar el contenedor.
- `RUN` ejecuta comandos _dentro_ de la imagen durante la construcción.
- `CMD` define el comando _por defecto_ que se ejecuta cuando _inicias_ un contenedor desde la imagen.

## B - Construyendo una Imagen

#### 1. **Definición:**

Para crear una imagen a partir de un Dockerfile, usas el comando `docker image build`. Necesitas especificar la ubicación del Dockerfile (el "contexto de construcción").

#### 2. **Ejemplo:**

**Comando para construir la imagen (desde el directorio con el Dockerfile):**

```bash
docker image build .
```

**Output:**

```
# Sending build context to Docker daemon  3.584kB
# Step 1/4 : FROM ubuntu:latest
#  ---> d70eaf7277ea
# Step 2/4 : EXPOSE 80
#  ---> Running in 9eae86582ec7
# Removing intermediate container 9eae86582ec7
#  ---> 8235bd799a56
# Step 3/4 : RUN apt-get update &&     apt-get install nginx -y &&     apt-get clean && rm -rf /var/lib/apt/lists/*
#  ---> Running in a44725cbb3fa
### LONG INSTALLATION STUFF GOES HERE ###
# Removing intermediate container a44725cbb3fa
#  ---> 3066bd20292d
# Step 4/4 : CMD ["nginx", "-g", "daemon off;"]
#  ---> Running in 4792e4691660
# Removing intermediate container 4792e4691660
#  ---> 3199372aa3fc
# Successfully built 3199372aa3fc
```

**Explicación del ejemplo:**

`docker image build .` le dice a Docker que construya una imagen usando el `Dockerfile` en el directorio actual (`.`). El output muestra cada "paso" definido en el Dockerfile. Al final, te da el ID de la imagen construida (`Successfully built 3199372aa3fc`).

#### 3. **Notas o advertencias:**

- El `.` al final del comando es crucial: define el **contexto de construcción**, el directorio que Docker puede usar para construir la imagen.
- Docker busca un archivo llamado `Dockerfile` por defecto en el contexto.

## C - Ejecutando un Contenedor con tu Imagen

#### 1. **Definición:**

Una vez que tienes tu imagen, puedes crear y ejecutar contenedores basados en ella usando `docker container run`.

#### 2. **Ejemplo:**

**Comando para ejecutar un contenedor usando el ID de la imagen del ejemplo anterior:**

```bash
docker container run --rm --detach --name custom-nginx-packaged --publish 8080:80 3199372aa3fc
```

**Output:**

```
# ec09d4e1f70c903c3b954c8d7958421cdd1ae3d079b57f929e44131fbf8069a0

docker container ls
```

**Output de `docker container ls`:**

```
# CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES
# ec09d4e1f70c        3199372aa3fc        "nginx -g 'daemon of…"   23 seconds ago      Up 22 seconds       0.0.0.0:8080->80/tcp   custom-nginx-packaged
```

**Explicación del ejemplo:**

Este comando ejecuta un contenedor en segundo plano (`--detach`), le da un nombre (`--name custom-nginx-packaged`), mapea el puerto 8080 de tu máquina al puerto 80 del contenedor (`--publish 8080:80`), y usa la imagen con ID `3199372aa3fc`.

#### 3. **Notas o advertencias:**

- Asegúrate de usar el ID de imagen correcto que obtuviste al construirla.
- Visita `http://127.0.0.1:8080` en tu navegador para ver la página de NGINX.

## D - Etiquetando Imágenes (Tagging)

#### 1. **Definición:**

Las etiquetas (tags) son nombres amigables que le das a tus imágenes en lugar de usar IDs largos y aleatorios. Es como ponerle un nombre a tu imagen. Usas el formato `<repositorio>:<etiqueta>`. El repositorio es como el nombre de la imagen y la etiqueta indica una versión o build específica.

#### 2. **Ejemplo:**

**Comando para construir y etiquetar una imagen:**

```bash
docker image build --tag custom-nginx:packaged .
```

**Output:**

```
# Sending build context to Docker daemon  1.055MB
# Step 1/4 : FROM ubuntu:latest
#  ---> f63181f19b2f
# Step 2/4 : EXPOSE 80
#  ---> Running in 53ab370b9efc
# Removing intermediate container 53ab370b9efc
#  ---> 6d6460a74447
# Step 3/4 : RUN apt-get update &&     apt-get install nginx -y &&     apt-get clean && rm -rf /var/lib/apt/lists/*
#  ---> Running in b4951b6b48bb
### LONG INSTALLATION STUFF GOES HERE ###
# Removing intermediate container b4951b6b48bb
#  ---> fdc6cdd8925a
# Step 4/4 : CMD ["nginx", "-g", "daemon off;"]
#  ---> Running in 3bdbd2af4f0e
# Removing intermediate container 3bdbd2af4f0e
#  ---> f8837621b99d
# Successfully built f8837621b99d
# Successfully tagged custom-nginx:packaged
```

**Explicación del ejemplo:**

`--tag custom-nginx:packaged` le dice a Docker que etiquete la imagen construida como `custom-nginx` con la etiqueta `packaged`. Ahora puedes referirte a tu imagen como `custom-nginx:packaged`.

#### 3. **Notas o advertencias:**

- Usa `--tag` o `-t` para etiquetar durante la construcción.
- Si olvidas etiquetar, puedes usar `docker image tag <image id> <repositorio>:<etiqueta>` para etiquetar una imagen existente.

## E - Listando y Eliminando Imágenes

#### 1. **Definición:**

Para ver las imágenes que tienes localmente, usa `docker image ls`. Para eliminar imágenes, usa `docker image rm`. También puedes usar `docker image prune` para limpiar imágenes no utilizadas.

#### 2. **Ejemplo:**

**Listar imágenes:**

```bash
docker image ls
```

**Output:**

```
# REPOSITORY     TAG        IMAGE ID       CREATED         SIZE
# <none>         <none>     3199372aa3fc   7 seconds ago   132MB
# custom-nginx   packaged   f8837621b99d   4 minutes ago   132MB
```

**Eliminar una imagen por etiqueta:**

```bash
docker image rm custom-nginx:packaged
```

**Output:**

```
# Untagged: custom-nginx:packaged
# Deleted: sha256:f8837621b99d3388a9e78d9ce49fbb773017f770eea80470fb85e0052beae242
# Deleted: sha256:fdc6cdd8925ac25b9e0ed1c8539f96ad89ba1b21793d061e2349b62dd517dadf
# Deleted: sha256:c20e4aa46615fe512a4133089a5cd66f9b7da76366c96548790d5bf865bd49c4
# Deleted: sha256:6d6460a744475a357a2b631a4098aa1862d04510f3625feb316358536fcd8641
```

**Limpiar imágenes no etiquetadas (dangling):**

```bash
docker image prune --force
```

**Output (ejemplo):**

```
# Deleted Images:
# deleted: sha256:ba9558bdf2beda81b9acc652ce4931a85f0fc7f69dbc91b4efc4561ef7378aff
# deleted: sha256:ad9cc3ff27f0d192f8fa5fadebf813537e02e6ad472f6536847c4de183c02c81
# deleted: sha256:f1e9b82068d43c1bb04ff3e4f0085b9f8903a12b27196df7f1145aa9296c85e7
# deleted: sha256:ec16024aa036172544908ec4e5f842627d04ef99ee9b8d9aaa26b9c2a4b52baa

# Total reclaimed space: 59.19MB
```

#### 3. **Notas o advertencias:**

- `docker image rm` elimina imágenes por ID o etiqueta.
- `docker image prune --force` elimina imágenes _dangling_ sin preguntar confirmación.
- Usa `--all` o `-a` con `prune` para eliminar _todas_ las imágenes en caché. ¡Ten cuidado con esto!

## F - Capas de una Imagen

#### 1. **Definición:**

Las imágenes Docker están construidas en **capas**. Cada instrucción en tu Dockerfile crea una nueva capa. Esto hace que las imágenes sean eficientes porque las capas comunes se pueden compartir entre imágenes y se pueden reutilizar en builds posteriores (caché).

#### 2. **Ejemplo:**

**Ver las capas de una imagen:**

```bash
docker image history custom-nginx:packaged
```

**Output (ejemplo):**

```
# IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
# 7f16387f7307        5 minutes ago       /bin/sh -c #(nop)  CMD ["nginx" "-g" "daemon…   0B
# 587c805fe8df        5 minutes ago       /bin/sh -c apt-get update &&     apt-get ins…   60MB
# 6fe4e51e35c1        6 minutes ago       /bin/sh -c #(nop)  EXPOSE 80                    0B
# d70eaf7277ea        17 hours ago        /bin/sh -c #(nop)  CMD ["/bin/bash"]            0B
# <missing>           17 hours ago        /bin/sh -c mkdir -p /run/systemd && echo 'do…   7B
# <missing>           17 hours ago        /bin/sh -c [ -z "$(apt-get indextargets)" ]     0B
# <missing>           17 hours ago        /bin/sh -c set -xe   && echo '#!/bin/sh' > /…   811B
# <missing>           17 hours ago        /bin/sh -c #(nop) ADD file:435d9776fdd3a1834…   72.9MB
```

**Explicación del ejemplo:**

`docker image history` muestra las capas de la imagen `custom-nginx:packaged`. Cada línea representa una capa, creada por una instrucción en el Dockerfile. Las capas superiores son las más recientes.

#### 3. **Notas o advertencias:**

- Cada instrucción `RUN`, `COPY`, `ADD`, etc., generalmente crea una capa.
- Docker usa un **sistema de archivos de unión (union file system)** para gestionar estas capas de forma eficiente, evitando la duplicación de datos.

## G - Construyendo NGINX desde el Código Fuente

#### 1. **Definición:**

En lugar de instalar NGINX con un gestor de paquetes, puedes construirlo directamente desde su código fuente dentro de tu imagen Docker. Esto te da más control sobre la configuración.

#### 2. **Ejemplo:**

**Dockerfile para construir NGINX desde el código fuente:**

```dockerfile
FROM ubuntu:focal

RUN apt-get update && \
    apt-get install build-essential\
                    libpcre3 \
                    libpcre3-dev \
                    zlib1g \
                    zlib1g-dev \
                    libssl1.1 \
                    libssl-dev \
                    -y && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

COPY nginx-1.19.2.tar.gz .

RUN tar -xvf nginx-1.19.2.tar.gz && rm nginx-1.19.2.tar.gz

RUN cd nginx-1.19.2 && \
    ./configure \
        --sbin-path=/usr/bin/nginx \
        --conf-path=/etc/nginx/nginx.conf \
        --error-log-path=/var/log/nginx/error.log \
        --http-log-path=/var/log/nginx/access.log \
        --with-pcre \
        --pid-path=/var/run/nginx.pid \
        --with-http_ssl_module && \
    make && make install

RUN rm -rf /nginx-1.19.2

CMD ["nginx", "-g", "daemon off;"]
```

**Explicación del ejemplo:**

Este Dockerfile:

1.  Instala dependencias de compilación (`build-essential`, etc.) con `RUN apt-get ...`.
2.  Copia el código fuente de NGINX (`nginx-1.19.2.tar.gz`) a la imagen con `COPY`.
3.  Descomprime el código fuente y lo elimina con `RUN tar ...`.
4.  Configura, compila e instala NGINX con `RUN cd nginx-1.19.2 && ./configure ... && make && make install`.
5.  Elimina el directorio del código fuente con `RUN rm -rf /nginx-1.19.2`.

#### 3. **Notas o advertencias:**

- `COPY <origen> <destino>` copia archivos desde tu máquina al sistema de archivos de la imagen.
- Asegúrate de tener el archivo `nginx-1.19.2.tar.gz` en el mismo directorio que el Dockerfile (o ajusta la ruta en `COPY`).

## H - Usando `ARG` y `ADD` para Flexibilidad

#### 1. **Definición:**

`ARG` define variables que puedes usar en tu Dockerfile. `ADD` es similar a `COPY`, pero también puede descargar archivos desde URLs y extraer archivos automáticamente.

#### 2. **Ejemplo:**

**Dockerfile usando `ARG` y `ADD`:**

```dockerfile
FROM ubuntu:focal

RUN apt-get update && \
    apt-get install build-essential\
                    libpcre3 \
                    libpcre3-dev \
                    zlib1g \
                    zlib1g-dev \
                    libssl1.1 \
                    libssl-dev \
                    -y && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

ARG FILENAME="nginx-1.19.2"
ARG EXTENSION="tar.gz"

ADD https://nginx.org/download/${FILENAME}.${EXTENSION} .

RUN tar -xvf ${FILENAME}.${EXTENSION} && rm ${FILENAME}.${EXTENSION}

RUN cd ${FILENAME} && \
    ./configure \
        --sbin-path=/usr/bin/nginx \
        --conf-path=/etc/nginx/nginx.conf \
        --error-log-path=/var/log/nginx/error.log \
        --http-log-path=/var/log/nginx/access.log \
        --with-pcre \
        --pid-path=/var/run/nginx.pid \
        --with-http_ssl_module && \
    make && make install

RUN rm -rf /${FILENAME}

CMD ["nginx", "-g", "daemon off;"]
```

**Explicación del ejemplo:**

- `ARG FILENAME="nginx-1.19.2"` y `ARG EXTENSION="tar.gz"` definen variables para el nombre del archivo y la extensión.
- `ADD https://nginx.org/download/${FILENAME}.${EXTENSION} .` descarga el archivo de NGINX directamente desde la URL, usando las variables `ARG`.

#### 3. **Notas o advertencias:**

- `ARG` hace que tu Dockerfile sea más configurable. Puedes cambiar la versión de NGINX fácilmente cambiando el valor de `FILENAME`.
- `ADD` puede simplificar la descarga de archivos desde internet durante la construcción de la imagen.

## I - Optimizando Imágenes: Reduciendo el Tamaño

#### 1. **Definición:**

Imágenes más pequeñas se descargan y se inician más rápido. Para optimizar el tamaño, elimina dependencias innecesarias y realiza operaciones de limpieza en la misma capa.

#### 2. **Ejemplo:**

**Dockerfile optimizado para tamaño:**

```dockerfile
FROM ubuntu:focal

EXPOSE 80

ARG FILENAME="nginx-1.19.2"
ARG EXTENSION="tar.gz"

ADD https://nginx.org/download/${FILENAME}.${EXTENSION} .

RUN apt-get update && \
    apt-get install build-essential \
                    libpcre3 \
                    libpcre3-dev \
                    zlib1g \
                    zlib1g-dev \
                    libssl1.1 \
                    libssl-dev \
                    -y && \
    tar -xvf ${FILENAME}.${EXTENSION} && rm ${FILENAME}.${EXTENSION} && \
    cd ${FILENAME} && \
    ./configure \
        --sbin-path=/usr/bin/nginx \
        --conf-path=/etc/nginx/nginx.conf \
        --error-log-path=/var/log/nginx/error.log \
        --http-log-path=/var/log/nginx/access.log \
        --with-pcre \
        --pid-path=/var/run/nginx.pid \
        --with-http_ssl_module && \
    make && make install && \
    cd / && rm -rfv /${FILENAME} && \
    apt-get remove build-essential \
                    libpcre3-dev \
                    zlib1g-dev \
                    libssl-dev \
                    -y && \
    apt-get autoremove -y && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

CMD ["nginx", "-g", "daemon off;"]
```

**Explicación del ejemplo:**

Todo el trabajo pesado (instalación de dependencias, compilación, instalación, limpieza) se hace en un solo comando `RUN`. Esto asegura que las dependencias de compilación se eliminen en la misma capa, reduciendo el tamaño final de la imagen.

#### 3. **Notas o advertencias:**

- Realizar instalaciones y limpiezas en la misma instrucción `RUN` es clave para la optimización del tamaño.
- Dependencias de compilación (`build-essential`, `-dev` packages) no son necesarias para _ejecutar_ NGINX, así que se eliminan después de la compilación.

## J - Usando Alpine Linux para Imágenes Aún Más Pequeñas

#### 1. **Definición:**

[Alpine Linux](https://alpinelinux.org/) es una distribución de Linux muy ligera, ideal para contenedores pequeños. Usa `apk` como gestor de paquetes.

#### 2. **Ejemplo:**

**Dockerfile usando Alpine Linux:**

```dockerfile
FROM alpine:latest

EXPOSE 80

ARG FILENAME="nginx-1.19.2"
ARG EXTENSION="tar.gz"

ADD https://nginx.org/download/${FILENAME}.${EXTENSION} .

RUN apk add --no-cache pcre zlib && \
    apk add --no-cache \
            --virtual .build-deps \
            build-base \
            pcre-dev \
            zlib-dev \
            openssl-dev && \
    tar -xvf ${FILENAME}.${EXTENSION} && rm ${FILENAME}.${EXTENSION} && \
    cd ${FILENAME} && \
    ./configure \
        --sbin-path=/usr/bin/nginx \
        --conf-path=/etc/nginx/nginx.conf \
        --error-log-path=/var/log/nginx/error.log \
        --http-log-path=/var/log/nginx/access.log \
        --with-pcre \
        --pid-path=/var/run/nginx.pid \
        --with-http_ssl_module && \
    make && make install && \
    cd / && rm -rfv /${FILENAME} && \
    apk del .build-deps

CMD ["nginx", "-g", "daemon off;"]
```

**Explicación del ejemplo:**

- `FROM alpine:latest` usa Alpine Linux como imagen base.
- `apk add` se usa en lugar de `apt-get install`.
- `--no-cache` en `apk add` evita guardar la caché de paquetes, reduciendo el tamaño.
- `--virtual .build-deps` crea un "paquete virtual" para las dependencias de compilación, que luego se elimina con `apk del .build-deps`.

#### 3. **Notas o advertencias:**

- Alpine Linux es mucho más pequeño que Ubuntu, resultando en imágenes significativamente más pequeñas.
- `apk` es el gestor de paquetes de Alpine, diferente a `apt-get` de Ubuntu.
- Los nombres de los paquetes en Alpine pueden ser diferentes a los de Ubuntu.

## K - Creando Imágenes Ejecutables

#### 1. **Definición:**

Puedes crear imágenes que se comporten como ejecutables, donde al ejecutar el contenedor, se ejecuta directamente un script o programa. Esto se logra con la instrucción `ENTRYPOINT`.

#### 2. **Ejemplo:**

**Dockerfile para una imagen "ejecutable" de Python:**

```dockerfile
FROM python:3-alpine

WORKDIR /zone

RUN apk add --no-cache git && \
    pip install git+https://github.com/fhsinchy/rmbyext.git#egg=rmbyext && \
    apk del git

ENTRYPOINT [ "rmbyext" ]
```

**Explicación del ejemplo:**

- `WORKDIR /zone` establece el directorio de trabajo dentro del contenedor.
- `RUN ... pip install ...` instala un script de Python llamado `rmbyext` desde GitHub.
- `ENTRYPOINT [ "rmbyext" ]` define que al ejecutar la imagen, se ejecutará el comando `rmbyext`.

#### 3. **Notas o advertencias:**

- `ENTRYPOINT` define el comando principal que se ejecuta cuando se inicia un contenedor desde la imagen.
- Puedes pasar argumentos al script `rmbyext` directamente al ejecutar el contenedor, como si fuera un ejecutable normal.

## L - Compartiendo tus Imágenes Online

#### 1. **Definición:**

Para compartir tus imágenes con el mundo, necesitas subirlas a un registro de imágenes online como [Docker Hub](https://hub.docker.com/).

#### 2. **Ejemplo:**

**Pasos para compartir una imagen en Docker Hub:**

1.  **Crea una cuenta en Docker Hub.**
2.  **Inicia sesión en Docker Hub desde la línea de comandos:**

    ```bash
    docker login
    ```

    Introduce tu usuario y contraseña de Docker Hub cuando se te pida.

3.  **Etiqueta tu imagen con tu nombre de usuario de Docker Hub:**

    ```bash
    docker image build --tag <tu_usuario_dockerhub>/custom-nginx:latest -f Dockerfile.built .
    ```

    Reemplaza `<tu_usuario_dockerhub>` con tu nombre de usuario real.

4.  **Sube la imagen a Docker Hub:**

    ```bash
    docker image push <tu_usuario_dockerhub>/custom-nginx:latest
    ```

**Output de `docker image push` (ejemplo):**

```
# The push refers to repository [docker.io/fhsinchy/custom-nginx]
# 4352b1b1d9f5: Pushed
# a4518dd720bd: Pushed
# 1d756dc4e694: Pushed
# d7a7e2b6321a: Pushed
# f6253634dc78: Mounted from library/ubuntu
# 9069f84dbbe9: Mounted from library/ubuntu
# bacd3af13903: Mounted from library/ubuntu
# latest: digest: sha256:ffe93440256c9edb2ed67bf3bba3c204fec3a46a36ac53358899ce1a9eee497a size: 1788
```

**Explicación del ejemplo:**

Estos pasos te guían para etiquetar correctamente tu imagen y subirla a tu repositorio en Docker Hub, para que otros puedan usarla.

#### 3. **Notas o advertencias:**

- El formato para compartir imágenes en Docker Hub es `<usuario_dockerhub>/<nombre_imagen>:<etiqueta>`.
- Una cuenta gratuita en Docker Hub te permite tener repositorios públicos ilimitados y un repositorio privado.
- Una vez subida, tu imagen estará disponible para que cualquiera la descargue y la use con `docker pull <usuario_dockerhub>/<nombre_imagen>:<etiqueta>`.
