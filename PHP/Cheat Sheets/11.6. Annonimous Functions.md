## A - Funciones anónimas

**Definición:** Las funciones anónimas, también conocidas como cierres (closures), permiten la creación de funciones que no tienen un nombre especificado. Son útiles como valores de parámetros llamables y tienen muchos otros usos.

**Ejemplo:**

```php
echo preg_replace_callback('~-([a-z])~', function ($match) {
    return strtoupper($match[1]);
}, 'hello-world'); // outputs helloWorld
```

## B - Asignación de funciones anónimas a variables

**Definición:** Las funciones anónimas pueden ser asignadas a variables, y PHP convierte automáticamente estas expresiones en instancias de la clase interna Closure.

**Ejemplo:**

```php
$greet = function($name) {
    printf("Hello %s\r\n", $name);
};
$greet('World'); // outputs Hello World
$greet('PHP'); // outputs Hello PHP
```

## C - Herencia de variables del ámbito padre

**Definición:** Las funciones anónimas pueden heredar variables del ámbito padre utilizando la construcción use. Estas variables deben ser pasadas explícitamente.

**Ejemplo:**

```php
$message = 'hello';
$example = function() use ($message) {
    var_dump($message);
};
$example(); // outputs string(5) "hello"
```

## D - Funciones anónimas estáticas

**Definición:** Las funciones anónimas pueden ser declaradas como estáticas, lo que evita que tengan la clase actual automáticamente vinculada a ellas.

**Ejemplo:**

```php
class Foo {
    function __construct() {
        $func = static function() {
            var_dump($this);
        };
        $func();
    }
}
new Foo(); // outputs NULL
```

## E - Uso de funciones anónimas en clases

**Definición:** Cuando se declaran en el contexto de una clase, la clase actual se vincula automáticamente a la función, haciendo que $this esté disponible dentro del ámbito de la función.

**Ejemplo:**

```php
class Test {
    public function testing() {
        return function() {
            var_dump($this);
        };
    }
}
$object = new Test;
$function = $object->testing();
$function(); // outputs object(Test)#1 (0) { }
```
