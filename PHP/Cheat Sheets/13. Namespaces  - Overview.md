## A - Namespaces

**Definición:** Un mecanismo para encapsular elementos de código (como clases, funciones y constantes) para evitar colisiones de nombres y mejorar la organización del código. Similar a cómo los directorios organizan archivos en un sistema operativo.

**Ejemplo:**

```PHP

<?php
namespace my\project;

class User {
    public function getName() {
        return "Usuario del proyecto";
    }
}

function greet() {
    return "Hola desde el proyecto!";
}

const VERSION = "1.0";

$user = new User();
echo $user->getName() . "\n"; // Salida: Usuario del proyecto
echo greet() . "\n"; // Salida: Hola desde el proyecto!
echo VERSION . "\n"; // Salida: 1.0
?>
```

(Este ejemplo define un namespace my\project que contiene una clase User, una función greet y una constante VERSION. Esto evita conflictos con otras clases, funciones o constantes con el mismo nombre en otros namespaces o en el espacio global.)

## B - Colisiones de Nombres

**Definición:** Un problema que ocurre cuando dos o más elementos de código (clases, funciones, constantes) tienen el mismo nombre, lo que genera errores y ambigüedad. Los namespaces resuelven este problema al proporcionar un contexto único para cada elemento.

**Ejemplo:**

```PHP

<?php
// Sin namespaces (potencial colisión)
class Logger {
    public function log($message) {
        echo "Logger 1: " . $message . "\n";
    }
}

class Logger { // Error: Redefinición de la clase Logger
    public function log($message, $level) {
        echo "Logger 2 (nivel " . $level . "): " . $message . "\n";
    }
}

// Con namespaces (sin colisión)
namespace app1;
class Logger {
    public function log($message) {
        echo "Logger app1: " . $message . "\n";
    }
}

namespace app2;
class Logger {
    public function log($message, $level) {
        echo "Logger app2 (nivel " . $level . "): " . $message . "\n";
    }
}

$logger1 = new \app1\Logger();
$logger2 = new \app2\Logger();

$logger1->log("Mensaje de app1"); // Salida: Logger app1: Mensaje de app1
$logger2->log("Mensaje de app2", "INFO"); // Salida: Logger app2 (nivel INFO): Mensaje de app2

?>
```

(Este ejemplo demuestra cómo los namespaces app1 y app2 permiten la existencia de dos clases Logger sin generar un error de redefinición.)

## C - Alias (o Nombres Cortos)

**Definición:** La capacidad de asignar un nombre más corto a un namespace o clase para simplificar el código y mejorar la legibilidad, especialmente cuando se utilizan nombres de namespaces largos.

**Ejemplo:**

```PHP

<?php
namespace very\long\namespace\for\my\project;
class MyClass {}

// Usando un alias:
use very\long\namespace\for\my\project\MyClass as My;

$obj = new My(); // Equivalente a: $obj = new \very\long\namespace\for\my\project\MyClass();

//Otro ejemplo
use very\long\namespace\for\my\project as vlnfmp;
$obj2 = new vlnfmp\MyClass();

?>
```

(En este ejemplo, My es un alias para very\long\namespace\for\my\project\MyClass. Esto hace que el código sea más conciso y fácil de leer.)

## D - Espacio Global

**Definición:** El espacio de nombres predeterminado donde existen las funciones y clases integradas de PHP, así como cualquier código que no esté dentro de un namespace definido explícitamente. Se accede a él con el prefijo `\`.

**Ejemplo:**

```PHP

<?php
namespace my\space;

class MyClass {}

$obj = new MyClass(); // Instancia MyClass dentro de my\space
$str = new \stdClass(); // Instancia stdClass desde el espacio global

$len = \strlen("hola"); //Llama a la funcion strlen del espacio global
?>
```

(Aquí, \stdClass y \strlen se refieren a la clase stdClass y a la función strlen que existen en el espacio global.)

## E - Operador namespace y Constante **NAMESPACE**

**Definición:** El operador namespace se utiliza para acceder a elementos dentro del namespace actual. La constante **NAMESPACE** contiene el nombre del namespace actual como una cadena.

**Ejemplo:**

```PHP

<?php
namespace my\space;

const MYCONST = 123;

function myFunction() {
    echo namespace\MYCONST . "\n"; // Accede a MYCONST dentro de my\space
    echo __NAMESPACE__ . '\MYCONST' . "\n"; //Otra forma de acceder a MYCONST dentro de my\space
    echo constant(__NAMESPACE__ . '\MYCONST'). "\n"; //otra forma mas
}

myFunction(); // Salida: 123
?>
```

(En este ejemplo, namespace\MYCONST y **NAMESPACE** . '\MYCONST' son equivalentes y acceden a la constante MYCONST dentro del namespace my\space.)
