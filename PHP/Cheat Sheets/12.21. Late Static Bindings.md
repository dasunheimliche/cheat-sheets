## A - Late Static Bindings

**Definición:** Late Static Bindings es una característica de PHP que permite referenciar la clase llamada en un contexto de herencia estática, utilizando información en tiempo de ejecución.

**Ejemplo:**

```php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        static::who(); // Aquí se usa Late Static Bindings
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test(); // Salida: B
```

**Descripción del ejemplo:** En este ejemplo, static::who() en la clase A se resuelve en tiempo de ejecución para referenciar la clase B, resultando en la salida B.

## B - Limitaciones de self::

**Definición:** Las referencias estáticas a la clase actual como self:: o **CLASS** se resuelven usando la clase en la que la función pertenece, es decir, donde fue definida.

**Ejemplo:**

```php
class A {
    public static function who() {
        echo __CLASS__;
    }
    public static function test() {
        self::who();
    }
}

class B extends A {
    public static function who() {
        echo __CLASS__;
    }
}

B::test(); // Salida: A
```

**Descripción del ejemplo:** En este ejemplo, self::who() en la clase A se resuelve en la clase A, resultando en la salida A.

## C - Uso de static:: en Contextos No Estáticos

**Definición:** En contextos no estáticos, la clase llamada será la clase de la instancia del objeto. static:: solo puede referirse a propiedades estáticas.

**Ejemplo:**

```php
class A {
    private function foo() {
        echo "success!\n";
    }
    public function test() {
        $this->foo();
        static::foo();
    }
}

class B extends A {}

$b = new B();
$b->test(); // Salida: success! success!
```

**Descripción del ejemplo:** En este ejemplo, static::foo() se resuelve en la clase A, resultando en la salida success! success!.

## D - Llamadas de Reenvío y No Reenvío

**Definición:** Las llamadas estáticas usando palabras clave como parent:: o self:: reenviarán la información de la llamada, mientras que las llamadas completamente resueltas con static:: no tendrán fallback.

**Ejemplo:**

```php
class A {
    public static function foo() {
        static::who();
    }
    public static function who() {
        echo __CLASS__ . "\n";
    }
}

class B extends A {
    public static function test() {
        A::foo();
        parent::foo();
        self::foo();
    }
    public static function who() {
        echo __CLASS__ . "\n";
    }
}

class C extends B {
    public static function who() {
        echo __CLASS__ . "\n";
    }
}

C::test(); // Salida: A C C
```

**Descripción del ejemplo:** En este ejemplo, A::foo() se resuelve en la clase A, parent::foo() y self::foo() se resuelven en la clase C, resultando en la salida A C C.
