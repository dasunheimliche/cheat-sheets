## A - Herencia de Objetos

**Definición:** La herencia es un principio de programación que permite que una clase (subclase) herede métodos, propiedades y constantes públicas y protegidas de otra clase (clase padre). Las subclases pueden sobrescribir estos métodos para implementar funcionalidad adicional sin reimplementar toda la funcionalidad compartida.

**Ejemplo:**

```php
class Foo {
    public function printItem($string) {
        echo 'Foo: ' . $string . PHP_EOL;
    }
    public function printPHP() {
        echo 'PHP is great.' . PHP_EOL;
    }
}

class Bar extends Foo {
    public function printItem($string) {
        echo 'Bar: ' . $string . PHP_EOL;
    }
}

$foo = new Foo();
$bar = new Bar();
$foo->printItem('baz'); // Output: 'Foo: baz'
$foo->printPHP(); // Output: 'PHP is great'
$bar->printItem('baz'); // Output: 'Bar: baz'
$bar->printPHP(); // Output: 'PHP is great'
```

## B - Compatibilidad de Tipos de Retorno

**Definición:** A partir de PHP 8.1, los métodos internos comenzaron a declarar tentativamente sus tipos de retorno. Los métodos sobrescritos deben ser compatibles con el tipo de retorno del método padre; de lo contrario, se emite un aviso de deprecación.

**Ejemplo:**

```php
class MyDateTime extends DateTime {
    public function modify(string $modifier) {
        return false;
    }
}
// "Deprecated: Return type of MyDateTime::modify(string $modifier) should either be compatible with DateTime::modify(string $modifier): DateTime|false, or the #[\ReturnTypeWillChange] attribute should be used to temporarily suppress the notice" as of PHP 8.1.0
```

## C - Sobrescritura de Métodos

**Definición:** Los métodos de una clase pueden ser sobrescritos en una subclase para cambiar su comportamiento. Sin embargo, los métodos privados de una clase padre no son accesibles para una subclase y pueden ser reimplementados sin seguir las reglas de herencia normales.

**Ejemplo:**

```php
class Foo {
    public function printItem($string) {
        echo 'Foo: ' . $string . PHP_EOL;
    }
    public function printPHP() {
        echo 'PHP is great.' . PHP_EOL;
    }
}

class Bar extends Foo {
    public function printItem($string) {
        echo 'Bar: ' . $string . PHP_EOL;
    }
}

$foo = new Foo();
$bar = new Bar();
$foo->printItem('baz'); // Output: 'Foo: baz'
$foo->printPHP(); // Output: 'PHP is great'
$bar->printItem('baz'); // Output: 'Bar: baz'
$bar->printPHP(); // Output: 'PHP is great'
```

## D - Restricciones de Métodos Privados

**Definición:** A partir de PHP 8.0.0, las únicas restricciones aplicadas a los métodos privados son los constructores privados finales, que se utilizan comúnmente para "deshabilitar" el constructor cuando se utilizan métodos de fábrica estáticos.

**Ejemplo:**

```php
class ParentClass {
    private function privateMethod() {
        echo 'This is a private method.';
    }
}

class ChildClass extends ParentClass {
    // Puede reimplementar el método privado sin restricciones
    private function privateMethod() {
        echo 'This is a reimplemented private method.';
    }
}
```

## E - Visibilidad de Métodos y Propiedades

**Definición:** La visibilidad de los métodos y propiedades puede relajarse, por ejemplo, un método protegido puede marcarse como público, pero no pueden restringirse, por ejemplo, marcar una propiedad pública como privada. Una excepción son los constructores, cuya visibilidad puede restringirse.

**Ejemplo:**

```php
class A {
    public int $prop;
}

class B extends A {
    // Ilegal: read-write -> readonly
    public readonly int $prop;
}
```
