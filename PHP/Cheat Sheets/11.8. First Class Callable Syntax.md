## A - Sintaxis de callable de primera clase

**Definición:** La sintaxis de callable de primera clase se introdujo en PHP 8.1.0 como una forma de crear funciones anónimas a partir de callable. Esta sintaxis es accesible para el análisis estático y utiliza el ámbito en el punto donde se adquiere el callable.

**Ejemplo:**

```php
class Foo {
    public function method() {}
    public static function staticmethod() {}
    public function __invoke() {}
}
$obj = new Foo();
$classStr = 'Foo';
$methodStr = 'method';

$f1 = strlen(...);
$f2 = $obj(...); // objeto invocable
$f3 = $obj->method(...);
$f4 = $obj->$methodStr(...);
$f5 = Foo::staticmethod(...);
$f6 = $classStr::$staticmethodStr(...);
```

## B - Comparación de ámbito

**Definición:** CallableExpr(...) respeta el ámbito en el punto donde se crea, a diferencia de los callable tradicionales que usan cadenas y arrays.

**Ejemplo:**

```php
class Foo {
    public function getPrivateMethod() {
        return [$this, 'privateMethod'];
    }
    private function privateMethod() {
        echo __METHOD__, "\n";
    }
}
$foo = new Foo;
$privateMethod = $foo->getPrivateMethod();
$privateMethod(); // Error fatal: Llamada a método privado Foo::privateMethod() desde el ámbito global

class Foo1 {
    public function getPrivateMethod() {
        return $this->privateMethod(...); // idéntico a Closure::fromCallable([$this, 'privateMethod'])
    }
    private function privateMethod() {
        echo __METHOD__, "\n";
    }
}
$foo1 = new Foo1;
$privateMethod = $foo1->getPrivateMethod();
$privateMethod(); // Foo1::privateMethod
```

## C - Limitaciones de la sintaxis de callable de primera clase

**Definición:** La creación de objetos con esta sintaxis (por ejemplo, new Foo(...)) no está soportada, ya que new Foo() no se considera una llamada. Además, no se puede combinar con el operador nullsafe.

**Ejemplo:**

```php
$obj?->method(...); // Error de compilación
$obj?->prop->method(...); // Error de compilación
```
