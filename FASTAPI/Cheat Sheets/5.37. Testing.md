## A - Testing en FastAPI

**Definición:**  
FastAPI facilita la prueba de aplicaciones gracias a su integración con **Starlette** y **HTTPX**. Puedes usar `pytest` para escribir pruebas de manera sencilla y familiar, ya que HTTPX está diseñado de manera similar a la popular librería **Requests**.

**Ejemplo básico:**

```python
from fastapi import FastAPI
from fastapi.testclient import TestClient

app = FastAPI()

@app.get("/")
async def read_main():
    return {"msg": "Hello World"}

client = TestClient(app)

def test_read_main():
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"msg": "Hello World"}
```

**Descripción del ejemplo:**

- `TestClient(app)`: Crea un cliente de prueba para tu aplicación FastAPI.
- `client.get("/")`: Realiza una solicitud GET a la ruta principal (`/`).
- `assert response.status_code == 200`: Verifica que el código de estado de la respuesta sea 200 (éxito).
- `assert response.json() == {"msg": "Hello World"}`: Verifica que el cuerpo de la respuesta sea el JSON esperado.

---

## B - Estructura de archivos para pruebas

**Definición:**  
En una aplicación real, es común separar las pruebas en un archivo diferente. La estructura de archivos podría verse así:

```
├── app
│   ├── __init__.py
│   ├── main.py
│   └── test_main.py
```

**Ejemplo:**

- `main.py` contiene la aplicación FastAPI.
- `test_main.py` contiene las pruebas.

**Código en `main.py`:**

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
async def read_main():
    return {"msg": "Hello World"}
```

**Código en `test_main.py`:**

```python
from fastapi.testclient import TestClient
from .main import app

client = TestClient(app)

def test_read_main():
    response = client.get("/")
    assert response.status_code == 200
    assert response.json() == {"msg": "Hello World"}
```

**Descripción del ejemplo:**

- `from .main import app`: Importa la aplicación FastAPI desde `main.py`.
- Las pruebas se escriben en funciones que comienzan con `test_` (convención de `pytest`).

---

## C - Pruebas con autenticación y manejo de errores

**Definición:**  
Puedes probar endpoints que requieren autenticación (como headers) y manejan errores (como códigos 400 o 404).

**Ejemplo extendido en `main.py`:**

```python
from fastapi import FastAPI, Header, HTTPException
from pydantic import BaseModel

app = FastAPI()

fake_secret_token = "coneofsilence"
fake_db = {
    "foo": {"id": "foo", "title": "Foo", "description": "There goes my hero"},
    "bar": {"id": "bar", "title": "Bar", "description": "The bartenders"},
}

class Item(BaseModel):
    id: str
    title: str
    description: str | None = None

@app.get("/items/{item_id}")
async def read_item(item_id: str, x_token: str = Header()):
    if x_token != fake_secret_token:
        raise HTTPException(status_code=400, detail="Invalid X-Token header")
    if item_id not in fake_db:
        raise HTTPException(status_code=404, detail="Item not found")
    return fake_db[item_id]

@app.post("/items/")
async def create_item(item: Item, x_token: str = Header()):
    if x_token != fake_secret_token:
        raise HTTPException(status_code=400, detail="Invalid X-Token header")
    if item.id in fake_db:
        raise HTTPException(status_code=409, detail="Item already exists")
    fake_db[item.id] = item
    return item
```

**Ejemplo de pruebas en `test_main.py`:**

```python
from fastapi.testclient import TestClient
from .main import app

client = TestClient(app)

def test_read_item():
    response = client.get("/items/foo", headers={"X-Token": "coneofsilence"})
    assert response.status_code == 200
    assert response.json() == {
        "id": "foo",
        "title": "Foo",
        "description": "There goes my hero",
    }

def test_read_item_bad_token():
    response = client.get("/items/foo", headers={"X-Token": "hailhydra"})
    assert response.status_code == 400
    assert response.json() == {"detail": "Invalid X-Token header"}

def test_create_item():
    response = client.post(
        "/items/",
        headers={"X-Token": "coneofsilence"},
        json={"id": "foobar", "title": "Foo Bar", "description": "The Foo Barters"},
    )
    assert response.status_code == 200
    assert response.json() == {
        "id": "foobar",
        "title": "Foo Bar",
        "description": "The Foo Barters",
    }
```

**Descripción del ejemplo:**

- Se prueban casos exitosos y fallidos, como tokens inválidos o ítems inexistentes.
- Se usan `headers` para enviar el token de autenticación.
- Se verifica el código de estado y el cuerpo de la respuesta.

---

## D - Ejecución de pruebas con `pytest`

**Definición:**  
Para ejecutar las pruebas, instala `pytest` y ejecuta el comando `pytest` en la terminal. `pytest` detectará automáticamente los archivos de prueba y ejecutará las funciones que comienzan con `test_`.

**Instalación de `pytest`:**

```bash
pip install pytest
```

**Ejecución de pruebas:**

```bash
pytest
```

**Salida esperada:**
================ test session starts ================
collected 6 items

test_main.py ...... [100%]

================ 6 passed in 0.12s ================

---

## E - Parámetros comunes en `TestClient`

**Definición:**  
El `TestClient` permite enviar diferentes tipos de datos en las solicitudes, como parámetros de ruta, cuerpos JSON, headers y cookies.

**Ejemplos de uso:**

- **JSON body:**

  ```python
  response = client.post("/items/", json={"id": "foo", "title": "Foo"})
  ```

- **Headers:**

  ```python
  response = client.get("/items/foo", headers={"X-Token": "coneofsilence"})
  ```

- **Query parameters:**

  ```python
  response = client.get("/items/?skip=0&limit=10")
  ```

- **Cookies:**

  ```python
  response = client.get("/items/", cookies={"session": "abc123"})
  ```
