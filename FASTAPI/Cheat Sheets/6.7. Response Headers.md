## A - Headers usando Response Parameter

**Definición:** Permite establecer headers HTTP en una respuesta mientras se mantiene la capacidad de retornar objetos normales y usar response_model. Los headers se establecen a través de un parámetro de tipo Response inyectado en la función.

**Ejemplo:**

```python

from fastapi import FastAPI, Response
from pydantic import BaseModel
from typing import Optional
import time

class APIResponse(BaseModel):
    data: dict
    message: str
    status: str

app = FastAPI()

@app.get("/api/v1/data", response_model=APIResponse)
async def get_data(response: Response, request_id: Optional[str] = None):
    # Registrar tiempo de inicio
    start_time = time.time()

    # Establecer headers comunes
    response.headers["X-Request-ID"] = request_id or "gen_" + str(int(time.time()))
    response.headers["X-API-Version"] = "1.0"
    response.headers["Cache-Control"] = "max-age=3600"

    # Simular procesamiento
    data = {"key": "value"}

    # Añadir headers de rendimiento
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    response.headers["X-Rate-Limit-Remaining"] = "98"
    response.headers["X-Rate-Limit-Reset"] = str(int(time.time()) + 3600)

    return APIResponse(
        data=data,
        message="Data retrieved successfully",
        status="success"
    )
```

(Este ejemplo muestra cómo establecer headers informativos y de control mientras se mantiene el tipado fuerte y la validación del modelo de respuesta.)

## B - Headers usando Response Directa

**Definición:** Permite crear y retornar una respuesta HTTP directamente con headers personalizados, útil cuando necesitas control total sobre la respuesta.

**Ejemplo:**

```python

from fastapi import FastAPI, HTTPException
from fastapi.responses import JSONResponse, RedirectResponse, StreamingResponse
from typing import Generator
import time
import json

app = FastAPI()

def generate_large_data() -> Generator[str, None, None]:
    """Generador de datos para streaming"""
    for i in range(100):
        yield json.dumps({"chunk": i}) + "\n"
        time.sleep(0.1)

@app.get("/download/data")
async def download_data():
    # Headers para descarga de archivo
    headers = {
        "Content-Disposition": "attachment; filename=data.json",
        "Content-Type": "application/json",
        "X-Download-Start": str(int(time.time())),
        "Access-Control-Expose-Headers": "Content-Disposition"
    }

    return JSONResponse(
        content={"data": "content"},
        headers=headers
    )

@app.get("/stream/data")
async def stream_data():
    # Headers para streaming
    headers = {
        "Content-Type": "application/x-ndjson",
        "X-Stream-Type": "json-stream",
        "Cache-Control": "no-cache",
        "Connection": "keep-alive",
        "Transfer-Encoding": "chunked"
    }

    return StreamingResponse(
        generate_large_data(),
        headers=headers,
        media_type="application/x-ndjson"
    )

@app.get("/redirect/secure")
async def secure_redirect():
    # Headers para redirección segura
    headers = {
        "X-Redirect-Reason": "security_upgrade",
        "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
        "X-Frame-Options": "DENY",
        "X-Content-Type-Options": "nosniff"
    }

    return RedirectResponse(
        url="https://secure.example.com",
        headers=headers,
        status_code=307
    )
```

(Este ejemplo muestra diferentes tipos de respuestas con headers específicos para cada caso de uso.)

## C - Headers en Dependencias

**Definición:** Permite establecer headers desde funciones de dependencia, útil para operaciones comunes como autenticación, rate limiting, o tracking que deben aplicarse a múltiples endpoints.

**Ejemplo:**

```python

from fastapi import FastAPI, Depends, Response, Request, Header
from typing import Optional
import time

app = FastAPI()

async def add_security_headers(response: Response):
    """Dependency para headers de seguridad"""
    security_headers = {
        "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
        "X-Frame-Options": "DENY",
        "X-Content-Type-Options": "nosniff",
        "X-XSS-Protection": "1; mode=block",
        "Content-Security-Policy": "default-src 'self'",
        "Referrer-Policy": "strict-origin-when-cross-origin"
    }

    for header_key, header_value in security_headers.items():
        response.headers[header_key] = header_value

async def add_tracking_headers(
    request: Request,
    response: Response,
    user_agent: Optional[str] = Header(None)
):
    """Dependency para headers de tracking"""
    response.headers["X-Request-ID"] = f"{int(time.time())}-{id(request)}"
    response.headers["X-User-Agent"] = user_agent or "Unknown"
    response.headers["X-Client-IP"] = request.client.host

    return {"request_id": response.headers["X-Request-ID"]}

@app.get("/secure-endpoint")
async def secure_endpoint(
    security: None = Depends(add_security_headers),
    tracking: dict = Depends(add_tracking_headers)
):
    return {
        "message": "Secure content",
        "request_id": tracking["request_id"]
    }
```

(Este ejemplo muestra cómo usar dependencies para añadir headers de seguridad y tracking automáticamente.)

## D - Headers Personalizados y CORS

**Definición:** Muestra cómo trabajar con headers personalizados, especialmente en el contexto de CORS (Cross-Origin Resource Sharing) y navegadores web.

**Ejemplo:**

```python

from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from typing import Optional

app = FastAPI()

# Configuración CORS con headers personalizados
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://frontend.example.com"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
    expose_headers=[
        "X-Custom-Header",
        "X-Request-ID",
        "Content-Disposition",
        "X-RateLimit-Remaining"
    ],
    max_age=3600
)

@app.get("/api/data")
async def get_data(request: Request):
    # Headers personalizados que serán visibles para el cliente
    custom_headers = {
        "X-Custom-Header": "custom-value",
        "X-Request-ID": f"req_{int(time.time())}",
        "X-RateLimit-Remaining": "98",
        # Headers internos (con prefijo X-)
        "X-Internal-Server": "api-node-1",
        "X-Processing-Time": "0.123s",
    }

    return JSONResponse(
        content={"data": "example"},
        headers=custom_headers
    )

# Middleware para procesar headers personalizados
@app.middleware("http")
async def process_headers(request: Request, call_next):
    # Capturar tiempo de inicio
    start_time = time.time()

    # Procesar la solicitud
    response = await call_next(request)

    # Añadir headers de diagnóstico
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    response.headers["X-Server-Node"] = "node-1"

    # Conservar headers originales
    original_headers = response.headers.items()

    # Crear nueva respuesta con headers combinados
    return Response(
        content=response.body,
        status_code=response.status_code,
        headers=dict(original_headers),
        media_type=response.media_type
    )
```

(Este ejemplo muestra cómo trabajar con headers personalizados en el contexto de CORS y cómo procesarlos a través de middleware.)
