## A - OpenAPI `operationId`

**Definición:**  
El `operationId` es un identificador único que se puede asignar a una operación de ruta en OpenAPI. Es útil para herramientas que generan clientes de API, ya que les permite referirse a operaciones específicas de manera única. Si no eres un experto en OpenAPI, probablemente no necesites usar esto.

**Ejemplo:**

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/items/", operation_id="some_specific_id_you_define")
async def read_items():
    return [{"item_id": "Foo"}]
```

**Descripción del ejemplo:**  
Aquí, se define un `operation_id` personalizado para la operación de ruta `read_items`. Esto asegura que este identificador sea único en el esquema OpenAPI generado.

---

## B - Usar el nombre de la función como `operationId`

**Definición:**  
Puedes usar el nombre de la función de la operación de ruta como `operationId`. Esto simplifica los nombres de las funciones en los clientes generados automáticamente. Sin embargo, debes asegurarte de que los nombres de las funciones sean únicos, incluso si están en diferentes módulos.

**Ejemplo:**

```python
from fastapi import FastAPI
from fastapi.routing import APIRoute

app = FastAPI()

@app.get("/items/")
async def read_items():
    return [{"item_id": "Foo"}]

def use_route_names_as_operation_ids(app: FastAPI) -> None:
    for route in app.routes:
        if isinstance(route, APIRoute):
            route.operation_id = route.name  # 'read_items' en este caso

use_route_names_as_operation_ids(app)
```

**Descripción del ejemplo:**  
Este código recorre todas las rutas de la aplicación y asigna el nombre de la función como `operationId`. En este caso, `read_items` se convierte en el `operationId`.

---

## C - Excluir una operación de ruta del esquema OpenAPI

**Definición:**  
Puedes excluir una operación de ruta del esquema OpenAPI generado y, por lo tanto, de la documentación automática, usando el parámetro `include_in_schema` y estableciéndolo en `False`.

**Ejemplo:**

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/items/", include_in_schema=False)
async def read_items():
    return [{"item_id": "Foo"}]
```

**Descripción del ejemplo:**  
La operación de ruta `read_items` no aparecerá en la documentación OpenAPI generada.

---

## D - Descripción avanzada desde el docstring

**Definición:**  
Puedes limitar las líneas del docstring de una función que se utilizan para la descripción en OpenAPI. Usando el carácter `f` (form feed), FastAPI truncará la descripción en ese punto. Esto es útil si quieres que parte del docstring sea visible en la documentación y otra parte sea utilizada por otras herramientas como Sphinx.

**Ejemplo:**

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None

@app.post("/items/", response_model=Item, summary="Create an item")
async def create_item(item: Item):
    """
    Create an item with all the information:
    - **name**: each item must have a name
    - **description**: a long description
    - **price**: required
    - **tax**: if the item doesn't have tax, you can omit this
    f
    :param item: User input.
    """
    return item
```

**Descripción del ejemplo:**  
El docstring se usa para la descripción en OpenAPI, pero todo lo que sigue después de `f` no se muestra en la documentación de FastAPI.

---

## E - Respuestas adicionales en OpenAPI

**Definición:**  
Además de la respuesta principal, puedes declarar respuestas adicionales con sus modelos, códigos de estado, etc. Esto es útil para documentar respuestas de error o respuestas alternativas.

**Ejemplo:**  
(No se proporciona un ejemplo en el texto, pero puedes consultar la documentación de FastAPI sobre "Respuestas adicionales en OpenAPI").

---

## F - Extensión del esquema OpenAPI con `openapi_extra`

**Definición:**  
Puedes extender el esquema OpenAPI generado automáticamente para una operación de ruta usando el parámetro `openapi_extra`. Esto es útil para agregar metadatos personalizados o extensiones OpenAPI.

**Ejemplo:**

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/items/", openapi_extra={"x-aperture-labs-portal": "blue"})
async def read_items():
    return [{"item_id": "portal-gun"}]
```

**Descripción del ejemplo:**  
Aquí se agrega una extensión personalizada `x-aperture-labs-portal` al esquema OpenAPI de la operación de ruta.

---

## G - Esquema OpenAPI personalizado para el cuerpo de la solicitud

**Definición:**  
Puedes definir manualmente el esquema OpenAPI para el cuerpo de una solicitud, incluso si no estás utilizando las funciones automáticas de FastAPI con Pydantic. Esto es útil si estás manejando la validación manualmente pero aún quieres documentar el esquema esperado.

**Ejemplo:**

```python
from fastapi import FastAPI, Request

app = FastAPI()

@app.post("/items/", openapi_extra={
    "requestBody": {
        "content": {
            "application/json": {
                "schema": {
                    "required": ["name", "price"],
                    "type": "object",
                    "properties": {
                        "name": {"type": "string"},
                        "price": {"type": "number"},
                        "description": {"type": "string"},
                    },
                }
            }
        },
        "required": True,
    },
})
async def create_item(request: Request):
    raw_body = await request.body()
    return {"size": len(raw_body)}
```

**Descripción del ejemplo:**  
Aquí se define manualmente el esquema del cuerpo de la solicitud en OpenAPI, aunque la validación real se maneja manualmente en el código.

---

## H - Tipo de contenido personalizado en OpenAPI

**Definición:**  
Puedes definir un tipo de contenido personalizado (como YAML) en el esquema OpenAPI, incluso si no estás utilizando las funciones automáticas de FastAPI para validar ese tipo de contenido.

**Ejemplo:**

```python
from fastapi import FastAPI, HTTPException, Request
from pydantic import BaseModel, ValidationError
import yaml

app = FastAPI()

class Item(BaseModel):
    name: str
    tags: list[str]

@app.post("/items/", openapi_extra={
    "requestBody": {
        "content": {"application/x-yaml": {"schema": Item.model_json_schema()}},
        "required": True,
    },
})
async def create_item(request: Request):
    raw_body = await request.body()
    try:
        data = yaml.safe_load(raw_body)
    except yaml.YAMLError:
        raise HTTPException(status_code=422, detail="Invalid YAML")
    try:
        item = Item.model_validate(data)
    except ValidationError as e:
        raise HTTPException(status_code=422, detail=e.errors(include_url=False))
    return item
```

**Descripción del ejemplo:**  
Aquí se define un esquema OpenAPI para un cuerpo de solicitud YAML, aunque la validación real se maneja manualmente en el código.
