## A - Actualización reemplazando con PUT

**Definición:** Para actualizar un elemento, puedes usar la operación HTTP PUT. Utiliza jsonable_encoder para convertir los datos de entrada a datos que se puedan almacenar como JSON.

**Ejemplo:**

```python
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str | None = None
    description: str | None = None
    price: float | None = None
    tax: float = 10.5
    tags: list[str] = []

items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}

@app.get("/items/{item_id}", response_model=Item)
async def read_item(item_id: str):
    return items[item_id]

@app.put("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    update_item_encoded = jsonable_encoder(item)
    items[item_id] = update_item_encoded
    return update_item_encoded
```

## B - Advertencia sobre reemplazo

**Definición:** Al usar PUT, si no incluyes un atributo ya almacenado, el modelo de entrada tomará el valor predeterminado de ese atributo.

**Ejemplo:**

```python
# Si actualizas el elemento "bar" con:
{
    "name": "Barz",
    "price": 3,
    "description": None
}
# El atributo "tax" tomará el valor predeterminado de 10.5 en lugar de 20.2.
```

## C - Actualizaciones parciales con PATCH

**Definición:** Puedes usar la operación HTTP PATCH para actualizar parcialmente los datos, enviando solo los datos que deseas actualizar.

**Ejemplo:**

```python
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str | None = None
    description: str | None = None
    price: float | None = None
    tax: float = 10.5
    tags: list[str] = []

items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}

@app.get("/items/{item_id}", response_model=Item)
async def read_item(item_id: str):
    return items[item_id]

@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    stored_item_data = items[item_id]
    stored_item_model = Item(**stored_item_data)
    update_data = item.dict(exclude_unset=True)
    updated_item = stored_item_model.copy(update=update_data)
    items[item_id] = jsonable_encoder(updated_item)
    return updated_item
```

## D - Uso del parámetro exclude_unset de Pydantic

**Definición:** Para recibir actualizaciones parciales, es útil usar el parámetro exclude_unset en el método model_dump() de Pydantic.

**Ejemplo:**

```python
update_data = item.model_dump(exclude_unset=True)
```

## E - Uso del parámetro update de Pydantic

**Definición:** Puedes crear una copia del modelo existente usando .model_copy(), y pasar el parámetro update con un dict que contenga los datos a actualizar.

**Ejemplo:**

```python
updated_item = stored_item_model.model_copy(update=update_data)
```

## F - Resumen de actualizaciones parciales

**Definición:** Para aplicar actualizaciones parciales, puedes usar PATCH en lugar de PUT, recuperar los datos almacenados, poner esos datos en un modelo Pydantic, generar un dict sin valores predeterminados del modelo de entrada, crear una copia del modelo almacenado actualizando sus atributos con las actualizaciones parciales recibidas, convertir el modelo copiado a algo que se pueda almacenar en tu base de datos y guardar los datos.

**Ejemplo:**

```python
from fastapi import FastAPI
from fastapi.encoders import jsonable_encoder
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str | None = None
    description: str | None = None
    price: float | None = None
    tax: float = 10.5
    tags: list[str] = []

items = {
    "foo": {"name": "Foo", "price": 50.2},
    "bar": {"name": "Bar", "description": "The bartenders", "price": 62, "tax": 20.2},
    "baz": {"name": "Baz", "description": None, "price": 50.2, "tax": 10.5, "tags": []},
}

@app.get("/items/{item_id}", response_model=Item)
async def read_item(item_id: str):
    return items[item_id]

@app.patch("/items/{item_id}", response_model=Item)
async def update_item(item_id: str, item: Item):
    stored_item_data = items[item_id]
    stored_item_model = Item(**stored_item_data)
    update_data = item.dict(exclude_unset=True)
    updated_item = stored_item_model.copy(update=update_data)
    items[item_id] = jsonable_encoder(updated_item)
    return updated_item
```
