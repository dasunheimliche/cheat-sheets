¡Hola! ¡Qué alegría tenerte aquí! Soy tu pedagogo y programador de confianza, y mi única misión en este universo es que entiendas esto a la perfección. ¡A un nivel casi obsesivo! No te preocupes por nada, he preparado todo para que no te quede ni la más mínima duda. Vamos a desmenuzar este tema de FastAPI juntos, paso a pasito, como si estuviéramos montando un LEGO. ¡Empecemos!

### **Paso 0: Lista de Conceptos a Explicar**

Antes de sumergirnos en el código, aquí tienes el mapa del tesoro. He identificado cada concepto clave del texto que vamos a explorar. Así sabrás exactamente qué vamos a aprender y podrás verificar que no nos dejamos nada en el tintero. ¡Mi paranoia por la claridad me obliga a hacerlo!

1.  **Parámetros de Consulta (Query Parameters) Opcionales**: Cómo declarar parámetros que no son obligatorios en la URL, usando `str | None = None`.
2.  **`Annotated` y `Query`: La Forma Moderna de Validar**: Introducción al uso de `Annotated` junto con `Query` para añadir validaciones a los parámetros.
3.  **Validación de Longitud (`max_length` y `min_length`)**: Cómo restringir el número de caracteres de un parámetro de consulta.
4.  **Validación con Expresiones Regulares (`pattern`)**: Cómo asegurar que un parámetro de consulta siga un formato específico usando regex.
5.  **Valores por Defecto (No `None`)**: Cómo asignar un valor predeterminado a un parámetro de consulta si el cliente no envía uno.
6.  **El Método Antiguo: `Query` como Valor por Defecto**: Explicación de la sintaxis `q: str | None = Query(default=None, ...)` para entender código más antiguo.
7.  **`Annotated` vs. `Query` como Valor por Defecto: La Batalla Final**: Una comparación directa y clara, destacando por qué `Annotated` es la opción superior y recomendada.
8.  **Parámetro Obsoleto `regex`**: Una breve mención sobre el antiguo parámetro `regex` para que no te tome por sorpresa si lo ves.
9.  **Parámetros Requeridos con `Query`**: Cómo hacer que un parámetro sea obligatorio, incluso cuando le estás añadiendo validaciones con `Query`.
10. **Parámetros Requeridos que pueden ser `None`**: El caso especial y un poco confuso de un parámetro que debe ser enviado obligatoriamente, pero cuyo valor puede ser nulo.
11. **Parámetros de Consulta de tipo Lista (Múltiples Valores)**: Cómo aceptar múltiples valores para un mismo parámetro en la URL (ej: `?tag=a&tag=b`).
12. **Añadiendo Metadatos para la Documentación (`title` y `description`)**: Cómo hacer que tu documentación automática sea más clara y útil para otros desarrolladores.
13. **Usando Alias para Parámetros (`alias`)**: Cómo nombrar un parámetro en la URL de una forma que no es válida en Python (ej: `item-query`).
14. **Marcando Parámetros como Obsoletos (`deprecated`)**: Cómo indicar en la documentación que un parámetro ya no debería usarse.
15. **Excluyendo Parámetros de la Documentación (`include_in_schema`)**: Cómo ocultar parámetros internos o secretos de la documentación pública.
16. **Validación Personalizada con `AfterValidator`**: El superpoder para crear tus propias reglas de validación cuando las predefinidas no son suficientes.

---

## A - Parámetros de Consulta Opcionales: El "Quizás" de tu API 🔴

#### 1. **Introducción:**

Esto te permite definir parámetros en la URL (los que van después del `?`) que el usuario puede incluir o no, sin que tu aplicación se rompa.

#### 2. **Ejemplo:**

Imagina que tienes una tienda online y quieres permitir buscar productos. A veces buscarán algo específico, a veces querrán ver todo.

```python
from fastapi import FastAPI

app = FastAPI()

# Lista de productos de nuestra tienda imaginaria
fake_products_db = [{"product_name": "Laptop Gamer"}, {"product_name": "Teclado Mecánico"}]

@app.get("/search-products/")
async def search_products(query: str | None = None):
    # Si el usuario nos da una 'query' para buscar...
    if query:
        # ...devolvemos un saludo con su búsqueda y los productos.
        return {"message": f"Buscando productos que contengan: '{query}'", "products": fake_products_db}

    # Si no nos da nada, simplemente devolvemos todos los productos.
    return {"products": fake_products_db}
```

**Explicación del ejemplo:**

- **URL sin parámetro:** Si vas a `http://127.0.0.1:8000/search-products/`, la función recibe `query` como `None` y devuelve todos los productos.
- **URL con parámetro:** Si vas a `http://127.0.0.1:8000/search-products/?query=teclado`, la función recibe `query` con el valor `"teclado"` y te devuelve un mensaje personalizado.

#### 3. **Desarrollo**:

La magia aquí está en la declaración del tipo y el valor por defecto: `query: str | None = None`.

- `str | None`: Esto le dice a Python (y a tu editor de código) que la variable `query` puede ser una cadena de texto (`str`) o puede ser `None`. Es como decir "espero texto, pero acepto que no me des nada".
- `= None`: Este es el valor por defecto. Al asignarle `None` como valor predeterminado, FastAPI entiende automáticamente que este parámetro es **opcional**. Si el usuario no lo envía en la URL, FastAPI le pasará `None` a tu función. ¡Cero errores, pura flexibilidad!

🔴 **Fundamental**: Es absolutamente esencial. Casi todas las APIs que construyas tendrán parámetros opcionales para filtros, búsquedas, paginación, etc. Entender esto es como aprender a caminar antes de correr.

## B - `Annotated` y `Query`: La Forma Moderna de Validar 🟡

#### 1. **Introducción:**

`Annotated` es como una "etiqueta" que le pones a tus tipos de datos para añadirles información extra, y `Query` es la información específica que le dice a FastAPI "¡Oye, esto es un parámetro de consulta y quiero que le apliques estas reglas!".

#### 2. **Ejemplo:**

Sigamos con nuestra tienda. Queremos que la búsqueda (`query`) sea opcional, pero si la proporcionan, no puede tener más de 20 caracteres para no sobrecargar la base de datos.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/search-products/")
async def search_products(
    # Aquí está la magia: "etiquetamos" nuestro tipo con Query
    query: Annotated[str | None, Query(max_length=20)] = None
):
    if query:
        return {"message": f"Buscando productos que contengan: '{query}'"}

    return {"message": "Mostrando todos los productos."}
```

**Explicación del ejemplo:**

- `Annotated[str | None, ... ]`: Le decimos a Python: "El tipo base es `str | None`, pero espera, tengo más información para ti".
- `Query(max_length=20)`: Esta es la información extra para FastAPI. Le estamos diciendo: "Este parámetro es de la URL (`Query`), y su longitud máxima es de 20 caracteres".
- Si un usuario intenta ir a `.../?query=un_texto_demasiado_largo_para_buscar`, FastAPI automáticamente le devolverá un error claro y descriptivo. ¡Tú no tienes que escribir ni una línea de código para esa validación!

#### 3. **Desarrollo**:

Piensa en `Annotated` como un sobre. El tipo de dato (`str | None`) es la carta que va dentro, y `Query(...)` es una nota adhesiva que le pegas al sobre con instrucciones especiales para el cartero (FastAPI).

Esta es la forma **recomendada y moderna** de hacerlo desde la versión 0.95.0 de FastAPI. Es más limpio, más intuitivo y compatible con otras herramientas del ecosistema de Python.

🟡 **Importante**: Aunque podrías vivir sin ello usando métodos antiguos (que veremos), esta es la forma correcta y recomendada de escribir código FastAPI hoy en día. Adoptarla te hará un mejor programador y tu código será más fácil de mantener.

## C - Validación de Longitud (`max_length` y `min_length`) 🟡

#### 1. **Introducción:**

Son reglas que puedes añadir con `Query` para controlar el tamaño mínimo y máximo del texto que un usuario puede enviar en un parámetro.

#### 2. **Ejemplo:**

En nuestra tienda, queremos que la búsqueda tenga al menos 3 caracteres (para evitar búsquedas inútiles como "a") y como máximo 20.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/search-products/")
async def search_products(
    query: Annotated[
        str | None,
        Query(min_length=3, max_length=20)
    ] = None
):
    if query:
        return {"message": f"Buscando: '{query}'"}

    return {"message": "Mostrando todos los productos."}
```

**Explicación del ejemplo:**

- `min_length=3`: Si un usuario busca con `/?query=pc`, ¡perfecto! Pero si intenta con `/?query=a`, FastAPI le dirá amablemente que el texto es demasiado corto.
- `max_length=20`: Si busca `/?query=teclado_mecanico_rgb`, ¡genial! Pero si intenta con `/?query=este_texto_es_absurdamente_largo`, FastAPI lo detendrá.

#### 3. **Desarrollo**:

Estas validaciones son increíblemente útiles para proteger tu aplicación. Evitan que los usuarios envíen datos basura, demasiado cortos para ser útiles o demasiado largos que podrían causar problemas de rendimiento o seguridad. FastAPI se encarga de todo el trabajo sucio de validar y devolver errores claros, para que tú te concentres en la lógica de tu aplicación.

🟡 **Importante**: Usarás validaciones de longitud constantemente. Son una de las herramientas más comunes y poderosas para asegurar la calidad de los datos que entran a tu API.

## D - Validación con Expresiones Regulares (`pattern`) 🔵

#### 1. **Introducción:**

Una expresión regular (o "regex") es una secuencia de caracteres que define un patrón de búsqueda, permitiéndote validar formatos muy específicos, como un código postal, un email o un formato de factura.

#### 2. **Ejemplo:**

Imagina que en nuestra tienda, además de buscar, se pueden buscar productos por un código de inventario que siempre sigue el formato `PROD-` seguido de 3 números (ej: `PROD-123`).

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/products-by-code/")
async def find_product_by_code(
    code: Annotated[
        str,
        Query(pattern="^PROD-[0-9]{3}$")
    ]
):
    return {"message": f"Buscando producto con código: {code}"}
```

**Explicación del ejemplo:**

- `pattern="^PROD-[0-9]{3}$"`: ¡No te asustes! Desglosemos este jeroglífico:
  - `^`: El texto debe empezar aquí.
  - `PROD-`: Debe contener literalmente "PROD-".
  - `[0-9]{3}`: Debe tener exactamente 3 caracteres que sean números del 0 al 9.
  - `$`: El texto debe terminar aquí.
- **Válido:** `/?code=PROD-456`
- **Inválido:** `/?code=PROD-12` (faltan números), `/?code=XYZ-123` (no empieza con PROD), `/?code=PROD-1234` (demasiados números). FastAPI rechazará todos los inválidos.

#### 3. **Desarrollo**:

Las expresiones regulares son una herramienta extremadamente potente, pero también pueden ser complejas. No necesitas ser un experto para empezar, pero saber que existen y que FastAPI te permite usarlas con el parámetro `pattern` es un as bajo la manga. Son perfectas para cuando una simple validación de longitud no es suficiente y necesitas que los datos tengan una estructura muy concreta.

🔵 **Específico**: No las usarás todos los días, pero para situaciones donde el formato de los datos es estricto (códigos de producto, números de serie, identificadores fiscales), son la herramienta perfecta. Es bueno saber que están ahí para cuando las necesites.

## E - Valores por Defecto (No `None`) 🟡

#### 1. **Introducción:**

Puedes hacer que un parámetro opcional tenga un valor predeterminado útil en lugar de `None`, para que tu función siempre trabaje con un dato concreto.

#### 2. **Ejemplo:**

En nuestra tienda, queremos paginar los resultados. Vamos a tener un parámetro `page` (página) que, si no se especifica, por defecto será `1`.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/products/")
async def list_products(
    # Si no me dicen la página, asumo que es la primera.
    page: Annotated[int, Query(ge=1)] = 1
):
    return {"message": f"Mostrando productos de la página {page}"}
```

**Explicación del ejemplo:**

- `page: Annotated[int, Query(ge=1)] = 1`:
  - El tipo es `int` (un número entero).
  - `Query(ge=1)`: Añadimos una validación para que la página sea "greater than or equal to 1" (mayor o igual a 1). ¡No queremos páginas negativas!
  - `= 1`: Este es el valor por defecto. Si la URL es `/products/`, `page` valdrá `1`. Si es `/products/?page=3`, `page` valdrá `3`.

#### 3. **Desarrollo**:

Establecer valores por defecto sensatos simplifica enormemente tu código. En lugar de tener que comprobar `if page is None: page = 1` dentro de tu función, lo declaras directamente en la firma. Esto hace que tu lógica sea más limpia y tus intenciones más claras. Es una práctica muy común para la paginación (`page=1`, `limit=10`), filtros (`status="active"`), etc.

🟡 **Importante**: Es una técnica muy común y útil. Simplifica tu código y mejora la experiencia del usuario de tu API al proporcionar comportamientos predecibles y sensatos.

## F - El Método Antiguo: `Query` como Valor por Defecto 🟡

#### 1. **Introducción:**

Antes de que `Annotated` fuera la norma, la forma de añadir validaciones era asignando `Query(...)` directamente como valor por defecto del parámetro.

#### 2. **Ejemplo:**

Así se vería nuestro ejemplo de validación de longitud con el método antiguo. ¡Quiero que lo veas para que lo reconozcas, no para que lo copies!

```python
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/search-products-old-way/")
async def search_products_old_way(
    # Fíjate: Query(...) está en el lugar del valor por defecto.
    query: str | None = Query(default=None, min_length=3, max_length=20)
):
    if query:
        return {"message": f"Buscando (estilo antiguo): '{query}'"}

    return {"message": "Mostrando todos los productos (estilo antiguo)."}
```

**Explicación del ejemplo:**

- `query: str | None = Query(...)`: En lugar de `... = None`, ahora el valor por defecto es una llamada a `Query()`.
- `Query(default=None, ...)`: Como `Query()` ha "robado" el sitio del valor por defecto, ahora tenemos que decirle a `Query` cuál era el valor por defecto original usando el argumento `default=None`. Es un poco redundante, ¿verdad?

#### 3. **Desarrollo**:

Este método funciona perfectamente y hace lo mismo que `Annotated`. Sin embargo, es menos intuitivo. El valor por defecto de un parámetro de función en Python debería ser el valor real (`None`, `1`, `"hola"`), no un objeto de configuración como `Query()`. Verás mucho código escrito así en proyectos más antiguos o en tutoriales de hace unos años. Es crucial que lo entiendas para no confundirte.

🟡 **Importante**: No lo uses para código nuevo. Pero es muy importante que sepas leerlo y entenderlo, porque te lo encontrarás. Piénsalo como aprender a leer latín: no lo vas a hablar, pero te ayuda a entender de dónde vienen muchas cosas.

## G - `Annotated` vs. `Query` como Valor por Defecto: La Batalla Final 🔴

#### 1. **Introducción:**

Esta es la comparación definitiva para que entiendas por qué `Annotated` no es solo una opción, sino **la mejor opción**. ¡Quiero que esto quede grabado a fuego en tu mente!

#### 2. **Ejemplo Comparativo:**

Veamos la misma función escrita de las dos maneras. Ambas hacen lo mismo en FastAPI, pero una es mucho más "pura" en términos de Python.

```python
from typing import Annotated
from fastapi import FastAPI, Query

# --- MÉTODO MODERNO Y RECOMENDADO (con Annotated) ---
def get_user_modern(user_id: Annotated[int, Query(ge=1)]):
    return f"Obteniendo usuario {user_id}"

# --- MÉTODO ANTIGUO (con Query como default) ---
def get_user_old(user_id: int = Query(ge=1)):
    # ¡OJO! Aquí user_id no es un int, es un objeto Query!
    return f"Obteniendo usuario {user_id}"
```

**Explicación del ejemplo:**
Ahora, el momento de la verdad. ¿Qué pasa si intentamos llamar a estas funciones fuera de FastAPI, en un script normal de Python?

```python
# Llamando a la función moderna:
# get_user_modern()
# ERROR! Tu editor y Python te gritan: "¡Falta el argumento 'user_id'!"
# ¡Esto es BUENO! Te avisa de un error antes de que ocurra.

# Llamando a la función antigua:
result = get_user_old()
print(result)
# SALIDA: "Obteniendo usuario QueryInfo(ge=1)"
# ¡Esto es MALO! No da error, pero el resultado es basura.
# El valor por defecto no es un número, es el objeto Query.
```

#### 3. **Desarrollo**:

La diferencia es abismal y esta es la razón por la que mi paranoia pedagógica me obliga a insistir:

1.  **Claridad y Pureza (Ventaja de `Annotated`)**: Con `Annotated`, el valor por defecto (`= "valor"`) es el valor real. La firma de la función es estándar en Python. `Annotated` solo añade "metadatos" que FastAPI lee, pero no interfiere con cómo funciona la función por sí sola.
2.  **Reutilización y Seguridad (Ventaja de `Annotated`)**: Como vimos, la función moderna es segura para ser llamada desde cualquier parte de tu código. La antigua es una trampa: parece que funciona, pero te dará valores inesperados si la usas fuera del contexto de FastAPI. Tu editor de código te ayudará con la versión `Annotated`, pero te dejará caer en la trampa con la versión antigua.
3.  **Composición (Ventaja de `Annotated`)**: `Annotated` te permite añadir múltiples "etiquetas" de metadatos, no solo para FastAPI, sino también para otras herramientas como Typer (para crear CLIs). Es más extensible.

🔴 **Fundamental**: Entender esta diferencia es crucial para escribir código robusto, mantenible y moderno en FastAPI. **Usa siempre `Annotated` para código nuevo**. La claridad que ganas y los errores que evitas valen oro.

## H - Parámetro Obsoleto `regex` ⚪

#### 1. **Introducción:**

En versiones antiguas de FastAPI (y Pydantic v1), el parámetro para expresiones regulares se llamaba `regex` en lugar de `pattern`.

#### 2. **Ejemplo:**

Así se vería el ejemplo de validación de código de producto con el parámetro obsoleto.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/products-by-code-deprecated/")
async def find_product_by_code_deprecated(
    # Fíjate en `regex` en lugar de `pattern`
    code: Annotated[str, Query(regex="^PROD-[0-9]{3}$")]
):
    return {"message": f"Buscando con regex (obsoleto) el código: {code}"}
```

**Explicación del ejemplo:**
El código hace exactamente lo mismo que el que usa `pattern`. La única diferencia es el nombre del argumento.

#### 3. **Desarrollo**:

FastAPI y Pydantic se actualizaron para alinearse con los estándares de JSON Schema, que utiliza `pattern` para las expresiones regulares. Por eso `regex` fue marcado como obsoleto (deprecated). No deberías usarlo nunca en código nuevo, pero si te encuentras con un proyecto antiguo y ves `regex`, ya sabes que simplemente es el abuelo de `pattern`. Solo tienes que renombrarlo y todo seguirá funcionando.

⚪ **Raramente usado**: Este concepto es puramente histórico. Solo necesitas saber que existe para no asustarte si lo ves en código ajeno. Siempre, siempre, siempre usa `pattern` en su lugar.

---

## I - Parámetros Requeridos con `Query`: El "Sí o Sí" de tu API 🔴

#### 1. **Introducción:**

Para hacer que un parámetro con validaciones de `Query` sea obligatorio, simplemente no le asignes ningún valor por defecto.

#### 2. **Ejemplo:**

Imagina que necesitas buscar un usuario por su ID, y ese ID es absolutamente obligatorio. No hay búsqueda sin ID.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/users/")
async def get_user_by_id(
    # Fíjate bien: NO hay un "= None" al final.
    # Esto lo convierte en un parámetro requerido.
    user_id: Annotated[str, Query(min_length=5)]
):
    return {"message": f"Buscando al usuario con ID: {user_id}"}
```

**Explicación del ejemplo:**

- La clave está en la ausencia del `= algo`. Al no tener un valor por defecto, Python y FastAPI entienden que este parámetro **debe** ser proporcionado.
- Si un usuario intenta ir a `/users/` sin un `?user_id=...`, FastAPI automáticamente devolverá un error 422 (Unprocessable Entity) diciendo que falta el parámetro `user_id`. ¡Protección automática!

#### 3. **Desarrollo**:

La regla de oro es simple: **sin valor por defecto, el parámetro es requerido**. Esto es un principio fundamental de las funciones de Python que FastAPI respeta y aprovecha. Incluso cuando usamos toda la parafernalia de `Annotated` y `Query`, esta regla básica sigue aplicando. Es la forma más limpia y directa de exigir un dato.

🔴 **Fundamental**: Tan esencial como saber hacer parámetros opcionales. Necesitas controlar qué datos son indispensables para que tus endpoints funcionen.

## J - Parámetros Requeridos que pueden ser `None`: La Paradoja Obligatoria 🔵

#### 1. **Introducción:**

Este es un caso especial: obligas al cliente a enviar el parámetro, pero le permites que su valor sea explícitamente `None`.

#### 2. **Ejemplo:**

Supongamos que actualizamos un perfil de usuario. Queremos que el cliente nos diga explícitamente qué hacer con el campo "apodo" (`nickname`). Puede darnos un nuevo apodo, o puede decirnos "quiero que no tenga apodo" enviando `None`. Pero no puede simplemente ignorar el campo.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.put("/users/profile")
async def update_profile(
    # Acepta str o None, pero NO tiene valor por defecto.
    nickname: Annotated[str | None, Query(max_length=20)]
):
    if nickname is None:
        return {"message": "Apodo eliminado explícitamente."}
    return {"message": f"Apodo actualizado a: {nickname}"}
```

**Explicación del ejemplo:**

- `str | None`: Le decimos que el tipo puede ser texto o `None`.
- **Sin `= ...`**: Al no tener valor por defecto, es requerido.
- **URL válida 1:** `/users/profile?nickname=ElPro` -> `nickname` es `"ElPro"`.
- **URL válida 2:** `/users/profile?nickname=` -> `nickname` es `None`. El cliente lo envió vacío, lo que se interpreta como nulo.
- **URL inválida:** `/users/profile` -> FastAPI dará error porque el parámetro `nickname` no fue enviado.

#### 3. **Desarrollo**:

¿Por qué querrías hacer esto? Para ser explícito. Forzar al cliente a tomar una decisión sobre un campo evita ambigüedades. En una operación de actualización (PUT/PATCH), esto distingue entre "no quiero cambiar este campo" (no se envía el parámetro) y "quiero vaciar este campo" (se envía el parámetro con valor nulo).

🔵 **Específico**: Es una técnica avanzada para diseños de API muy rigurosos. No la usarás todos los días, pero es una herramienta muy potente para evitar malentendidos entre el cliente y el servidor en operaciones de modificación de datos.

## K - Parámetros de Consulta de tipo Lista: Recibiendo Múltiples Valores 🟡

#### 1. **Introducción:**

Permite que un parámetro de consulta se repita en la URL para recibir una lista de valores, ideal para filtros múltiples.

#### 2. **Ejemplo:**

En nuestra tienda, queremos buscar productos que coincidan con varias etiquetas a la vez. Por ejemplo, productos que sean "gamer" Y "en-oferta".

```python
from typing import Annotated, list
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/products/filter-by-tags/")
async def filter_by_tags(
    # El tipo es una lista de strings: list[str]
    tags: Annotated[list[str] | None, Query()] = None
):
    if tags:
        return {"filtering_by_tags": tags}
    return {"message": "No se especificaron tags."}
```

**Explicación del ejemplo:**

- Si un usuario va a la URL: `.../?tags=gamer&tags=en-oferta`
- FastAPI mágicamente recogerá ambos valores y se los entregará a tu función dentro de la variable `tags` como una lista de Python: `["gamer", "en-oferta"]`.
- **¡CUIDADO! ¡TRAMPA A EVITAR!** Debes usar `Query()` explícitamente (incluso si está vacío como en `Query()`). Si solo pones `tags: list[str] | None = None`, FastAPI pensará que esperas una lista en el _cuerpo_ de la petición (request body), no en la URL, y no funcionará como esperas.

La documentación se verá así, permitiendo añadir varios campos:
![Documentación para listas](https://fastapi.tiangolo.com/img/tutorial/query-params-str-validations/image02.png)

#### 3. **Desarrollo**:

Esta funcionalidad es increíblemente útil. Permite crear sistemas de filtrado complejos de una manera muy intuitiva para el usuario de la API. Puedes, por supuesto, combinarlo con valores por defecto:

`tags: Annotated[list[str], Query()] = ["electronica"]`

Si el usuario no envía ninguna etiqueta, por defecto buscará "electronica".

También puedes usar `list` en lugar de `list[str]`, pero ¡ten cuidado! Si usas `list` a secas, FastAPI no validará que los elementos dentro de la lista sean strings. Siempre es mejor ser específico (`list[str]`, `list[int]`, etc.) para mayor seguridad.

🟡 **Importante**: Una herramienta muy común y poderosa para cualquier API que necesite filtros complejos. Es muy probable que la necesites tarde o temprano.

## L - Añadiendo Metadatos para la Documentación (`title` y `description`) 🟡

#### 1. **Introducción:**

Puedes añadir un título y una descripción a tus parámetros para que la documentación automática de tu API sea mucho más fácil de entender para otros programadores (¡o para tu yo del futuro!).

#### 2. **Ejemplo:**

Vamos a mejorar la documentación de nuestro parámetro de búsqueda `q`.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/items/search")
async def search_items(
    q: Annotated[
        str | None,
        Query(
            title="Término de Búsqueda",
            description="El texto que quieres buscar en la base de datos de productos. La búsqueda no distingue mayúsculas de minúsculas.",
            min_length=3,
        ),
    ] = None,
):
    if q:
        return {"searching_for": q}
    return {"message": "Mostrando todos los items."}
```

**Explicación del ejemplo:**

- `title="Término de Búsqueda"`: Este será el "nombre" principal del parámetro en la interfaz de la documentación. Es más legible que el nombre de la variable `q`.
- `description="..."`: Este texto más largo aparecerá como una ayuda, explicando exactamente qué hace el parámetro, qué valores espera y cualquier otra cosa que sea útil saber.

#### 3. **Desarrollo**:

Documentar tu código es un acto de bondad. FastAPI hace que sea tan fácil que no hay excusa para no hacerlo. Estos metadatos no cambian cómo funciona tu código, pero transforman tu API de una caja negra a una herramienta bien explicada y fácil de usar. El `title` y la `description` se incorporan al esquema OpenAPI, que es el estándar que usan las herramientas de documentación como Swagger UI y ReDoc.

🟡 **Importante**: Es una muy buena práctica. Unos minutos añadiendo estos metadatos pueden ahorrar horas de confusión a quien consuma tu API. ¡Hazlo por ellos y por ti!

## M - Usando Alias para Parámetros (`alias`) 🔵

#### 1. **Introducción:**

Te permite usar un nombre para el parámetro en la URL que sería inválido como nombre de variable en Python, como uno que contiene un guion (`-`).

#### 2. **Ejemplo:**

Supongamos que por una convención externa, el parámetro de búsqueda debe llamarse `item-query` en la URL. Pero `item-query` no es un nombre de variable válido en Python.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/items/aliased-search")
async def aliased_search(
    # En la URL es "item-query", pero en nuestro código es "item_query".
    item_query: Annotated[str | None, Query(alias="item-query")] = None
):
    if item_query:
        return {"searching_with_alias": item_query}
    return {"message": "No query provided."}
```

**Explicación del ejemplo:**

- `alias="item-query"`: Esta es la instrucción clave. Le dice a FastAPI: "Cuando veas `item-query` en la URL, por favor, pon su valor en la variable `item_query` de mi función".
- El usuario final usará la URL: `.../?item-query=mi-busqueda`
- Tu código recibirá `"mi-busqueda"` en la variable `item_query`, que sí es un nombre válido en Python.

#### 3. **Desarrollo**:

El `alias` actúa como un traductor entre el "mundo exterior" (la URL) y tu "mundo interior" (tu código Python). Es la solución perfecta cuando necesitas integrarte con sistemas existentes que tienen convenciones de nombrado diferentes o cuando simplemente prefieres que tus URLs sigan un estilo (como `kebab-case`) que no es compatible con Python (`snake_case`).

🔵 **Específico**: No lo necesitarás siempre, pero es un salvavidas cuando te enfrentas a requisitos de nombrado específicos. Es una de esas herramientas que te alegrará mucho saber que existe cuando llegue el momento.

## N - Marcando Parámetros como Obsoletos (`deprecated`) 🔵

#### 1. **Introducción:**

Permite marcar un parámetro como "obsoleto" en la documentación, indicando a los usuarios que ya no deberían usarlo y que podría ser eliminado en el futuro.

#### 2. **Ejemplo:**

Decidimos que nuestro parámetro `q` es muy genérico y queremos reemplazarlo por uno más específico llamado `search_term`. Pero no podemos eliminar `q` de golpe porque hay clientes que ya lo están usando.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/items/deprecate-search")
async def deprecate_search(
    q: Annotated[
        str | None,
        Query(
            alias="item-query",
            title="Query string",
            deprecated=True, # ¡Aquí está la magia!
        ),
    ] = None,
):
    if q:
        return {"message": f"Buscando con el parámetro obsoleto: {q}"}
    return {"message": "No query."}
```

**Explicación del ejemplo:**

- `deprecated=True`: Al añadir esto, el parámetro seguirá funcionando exactamente igual, pero en la documentación automática aparecerá tachado y con una advertencia de que está obsoleto.

Así se verá en la documentación, ¡un aviso claro y directo!
![Parámetro obsoleto](https://fastapi.tiangolo.com/img/tutorial/query-params-str-validations/image01.png)

#### 3. **Desarrollo**:

"Deprecar" es una parte fundamental del ciclo de vida de una API. Te permite evolucionar y mejorar tu API sin romper la compatibilidad con los usuarios existentes de forma abrupta. Les da tiempo para migrar a los nuevos parámetros mientras la versión antigua sigue funcionando. Es una forma profesional y considerada de gestionar los cambios.

🔵 **Específico**: Lo usarás cuando necesites refactorizar o cambiar el diseño de un endpoint que ya está en producción. Es una herramienta clave para la mantenibilidad a largo plazo de tu API.

## O - Excluyendo Parámetros de la Documentación (`include_in_schema`) 🔵

#### 1. **Introducción:**

Te permite tener un parámetro de consulta que funciona perfectamente pero que está completamente oculto de la documentación de la API.

#### 2. **Ejemplo:**

Imagina que tienes un parámetro secreto, `secret_key`, que solo debe ser conocido por algunos servicios internos para activar un modo de depuración, y no quieres que aparezca en la documentación pública.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/internal/data")
async def get_internal_data(
    # Este parámetro no aparecerá en /docs
    secret_key: Annotated[str | None, Query(include_in_schema=False)] = None
):
    if secret_key == "supersecret":
        return {"message": "Acceso concedido a los datos secretos."}
    return {"message": "Acceso denegado."}
```

**Explicación del ejemplo:**

- `include_in_schema=False`: Esta instrucción le dice a FastAPI: "Oye, este parámetro existe y funciona, pero por favor, no lo incluyas en el esquema OpenAPI".
- Como resultado, cuando vayas a `/docs` o `/redoc`, el endpoint `/internal/data` aparecerá, pero el parámetro `secret_key` será invisible. Solo quien conozca su existencia podrá usarlo.

#### 3. **Desarrollo**:

Esta es una herramienta útil para parámetros de depuración, claves de acceso temporales, o cualquier otro parámetro que no forme parte de la interfaz pública y estable de tu API. Te da control total sobre lo que se documenta y lo que permanece como un detalle de implementación interno.

🔵 **Específico**: Para casos de uso muy particulares, como parámetros internos, de depuración o de seguridad por oscuridad. Es bueno saber que tienes esta opción para controlar la visibilidad de tu API.

## P - Validación Personalizada con `AfterValidator` 🔵

#### 1. **Introducción:**

Es tu navaja suiza para validaciones. Cuando `min_length`, `pattern`, etc., no son suficientes, puedes usar tu propia función de Python para crear cualquier regla de validación que se te ocurra.

#### 2. **Ejemplo:**

Necesitamos validar un identificador de producto que debe empezar obligatoriamente con `PROD-` o `TEST-`. Ninguna de las validaciones estándar nos sirve para chequear "uno u otro prefijo".

```python
from typing import Annotated
from fastapi import FastAPI
from pydantic import AfterValidator

app = FastAPI()

# 1. Creamos nuestra función de validación personalizada
def check_product_id_prefix(value: str):
    if not value.startswith(("PROD-", "TEST-")):
        # Si no es válido, lanzamos un ValueError. FastAPI lo atrapará.
        raise ValueError('El ID debe empezar con "PROD-" o "TEST-"')
    # Si es válido, devolvemos el valor sin cambios.
    return value

@app.get("/products/validate-id/")
async def get_product_by_valid_id(
    # 2. Usamos AfterValidator para "enganchar" nuestra función.
    product_id: Annotated[str, AfterValidator(check_product_id_prefix)]
):
    return {"valid_product_id": product_id}
```

**Explicación del ejemplo:**

1.  **La Función Validadora (`check_product_id_prefix`)**:
    - Recibe el valor del parámetro (`value`).
    - Comprueba si cumple nuestra lógica personalizada.
    - Si la validación falla, lanza un `ValueError` con un mensaje descriptivo. FastAPI convertirá esto en un error 422 claro para el cliente.
    - Si todo está bien, debe devolver el valor.
2.  **La Conexión con `Annotated`**:
    - `AfterValidator(check_product_id_prefix)`: Le decimos a Pydantic (el motor de validación de FastAPI) que, _después_ de validar que el valor es un `str`, ejecute nuestra función `check_product_id_prefix` sobre él.

#### 3. **Desarrollo**:

`AfterValidator` te da un poder casi ilimitado. La única regla es que tu validación debe basarse únicamente en el valor del parámetro en sí. Si necesitas consultar una base de datos o llamar a otra API para validar algo, deberías usar el sistema de **Dependencias** de FastAPI, que es un tema más avanzado.

**Pequeños trucos del ejemplo que no quiero que se te escapen:**

- `value.startswith(("PROD-", "TEST-"))`: El método `startswith` de los strings en Python es genial, ¡puede aceptar una tupla de prefijos y comprobará si el string empieza con alguno de ellos!
- El ejemplo del texto original usa `random.choice` para dar una sugerencia si no se provee un ID. Es un detalle simpático que muestra cómo puedes combinar la lógica de tu API con las validaciones.

🔵 **Específico**: Es una herramienta avanzada. La mayoría de las veces te bastará con las validaciones estándar. Pero cuando te enfrentes a una regla de negocio compleja y muy específica, `AfterValidator` será tu mejor amigo.
