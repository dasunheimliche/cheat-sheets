¬°Hola! ¬°Qu√© alegr√≠a tenerte aqu√≠! Soy tu pedagogo y programador de confianza, y mi √∫nica misi√≥n en este universo es que entiendas esto a la perfecci√≥n. ¬°A un nivel casi obsesivo! No te preocupes por nada, he preparado todo para que no te quede ni la m√°s m√≠nima duda. Vamos a desmenuzar este tema de FastAPI juntos, paso a pasito, como si estuvi√©ramos montando un LEGO. ¬°Empecemos!

### **Paso 0: Lista de Conceptos a Explicar**

Antes de sumergirnos en el c√≥digo, aqu√≠ tienes el mapa del tesoro. He identificado cada concepto clave del texto que vamos a explorar. As√≠ sabr√°s exactamente qu√© vamos a aprender y podr√°s verificar que no nos dejamos nada en el tintero. ¬°Mi paranoia por la claridad me obliga a hacerlo!

1.  **Par√°metros de Consulta (Query Parameters) Opcionales**: C√≥mo declarar par√°metros que no son obligatorios en la URL, usando `str | None = None`.
2.  **`Annotated` y `Query`: La Forma Moderna de Validar**: Introducci√≥n al uso de `Annotated` junto con `Query` para a√±adir validaciones a los par√°metros.
3.  **Validaci√≥n de Longitud (`max_length` y `min_length`)**: C√≥mo restringir el n√∫mero de caracteres de un par√°metro de consulta.
4.  **Validaci√≥n con Expresiones Regulares (`pattern`)**: C√≥mo asegurar que un par√°metro de consulta siga un formato espec√≠fico usando regex.
5.  **Valores por Defecto (No `None`)**: C√≥mo asignar un valor predeterminado a un par√°metro de consulta si el cliente no env√≠a uno.
6.  **El M√©todo Antiguo: `Query` como Valor por Defecto**: Explicaci√≥n de la sintaxis `q: str | None = Query(default=None, ...)` para entender c√≥digo m√°s antiguo.
7.  **`Annotated` vs. `Query` como Valor por Defecto: La Batalla Final**: Una comparaci√≥n directa y clara, destacando por qu√© `Annotated` es la opci√≥n superior y recomendada.
8.  **Par√°metro Obsoleto `regex`**: Una breve menci√≥n sobre el antiguo par√°metro `regex` para que no te tome por sorpresa si lo ves.
9.  **Par√°metros Requeridos con `Query`**: C√≥mo hacer que un par√°metro sea obligatorio, incluso cuando le est√°s a√±adiendo validaciones con `Query`.
10. **Par√°metros Requeridos que pueden ser `None`**: El caso especial y un poco confuso de un par√°metro que debe ser enviado obligatoriamente, pero cuyo valor puede ser nulo.
11. **Par√°metros de Consulta de tipo Lista (M√∫ltiples Valores)**: C√≥mo aceptar m√∫ltiples valores para un mismo par√°metro en la URL (ej: `?tag=a&tag=b`).
12. **A√±adiendo Metadatos para la Documentaci√≥n (`title` y `description`)**: C√≥mo hacer que tu documentaci√≥n autom√°tica sea m√°s clara y √∫til para otros desarrolladores.
13. **Usando Alias para Par√°metros (`alias`)**: C√≥mo nombrar un par√°metro en la URL de una forma que no es v√°lida en Python (ej: `item-query`).
14. **Marcando Par√°metros como Obsoletos (`deprecated`)**: C√≥mo indicar en la documentaci√≥n que un par√°metro ya no deber√≠a usarse.
15. **Excluyendo Par√°metros de la Documentaci√≥n (`include_in_schema`)**: C√≥mo ocultar par√°metros internos o secretos de la documentaci√≥n p√∫blica.
16. **Validaci√≥n Personalizada con `AfterValidator`**: El superpoder para crear tus propias reglas de validaci√≥n cuando las predefinidas no son suficientes.

---

## A - Par√°metros de Consulta Opcionales: El "Quiz√°s" de tu API üî¥

#### 1. **Introducci√≥n:**

Esto te permite definir par√°metros en la URL (los que van despu√©s del `?`) que el usuario puede incluir o no, sin que tu aplicaci√≥n se rompa.

#### 2. **Ejemplo:**

Imagina que tienes una tienda online y quieres permitir buscar productos. A veces buscar√°n algo espec√≠fico, a veces querr√°n ver todo.

```python
from fastapi import FastAPI

app = FastAPI()

# Lista de productos de nuestra tienda imaginaria
fake_products_db = [{"product_name": "Laptop Gamer"}, {"product_name": "Teclado Mec√°nico"}]

@app.get("/search-products/")
async def search_products(query: str | None = None):
    # Si el usuario nos da una 'query' para buscar...
    if query:
        # ...devolvemos un saludo con su b√∫squeda y los productos.
        return {"message": f"Buscando productos que contengan: '{query}'", "products": fake_products_db}

    # Si no nos da nada, simplemente devolvemos todos los productos.
    return {"products": fake_products_db}
```

**Explicaci√≥n del ejemplo:**

- **URL sin par√°metro:** Si vas a `http://127.0.0.1:8000/search-products/`, la funci√≥n recibe `query` como `None` y devuelve todos los productos.
- **URL con par√°metro:** Si vas a `http://127.0.0.1:8000/search-products/?query=teclado`, la funci√≥n recibe `query` con el valor `"teclado"` y te devuelve un mensaje personalizado.

#### 3. **Desarrollo**:

La magia aqu√≠ est√° en la declaraci√≥n del tipo y el valor por defecto: `query: str | None = None`.

- `str | None`: Esto le dice a Python (y a tu editor de c√≥digo) que la variable `query` puede ser una cadena de texto (`str`) o puede ser `None`. Es como decir "espero texto, pero acepto que no me des nada".
- `= None`: Este es el valor por defecto. Al asignarle `None` como valor predeterminado, FastAPI entiende autom√°ticamente que este par√°metro es **opcional**. Si el usuario no lo env√≠a en la URL, FastAPI le pasar√° `None` a tu funci√≥n. ¬°Cero errores, pura flexibilidad!

üî¥ **Fundamental**: Es absolutamente esencial. Casi todas las APIs que construyas tendr√°n par√°metros opcionales para filtros, b√∫squedas, paginaci√≥n, etc. Entender esto es como aprender a caminar antes de correr.

## B - `Annotated` y `Query`: La Forma Moderna de Validar üü°

#### 1. **Introducci√≥n:**

`Annotated` es como una "etiqueta" que le pones a tus tipos de datos para a√±adirles informaci√≥n extra, y `Query` es la informaci√≥n espec√≠fica que le dice a FastAPI "¬°Oye, esto es un par√°metro de consulta y quiero que le apliques estas reglas!".

#### 2. **Ejemplo:**

Sigamos con nuestra tienda. Queremos que la b√∫squeda (`query`) sea opcional, pero si la proporcionan, no puede tener m√°s de 20 caracteres para no sobrecargar la base de datos.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/search-products/")
async def search_products(
    # Aqu√≠ est√° la magia: "etiquetamos" nuestro tipo con Query
    query: Annotated[str | None, Query(max_length=20)] = None
):
    if query:
        return {"message": f"Buscando productos que contengan: '{query}'"}

    return {"message": "Mostrando todos los productos."}
```

**Explicaci√≥n del ejemplo:**

- `Annotated[str | None, ... ]`: Le decimos a Python: "El tipo base es `str | None`, pero espera, tengo m√°s informaci√≥n para ti".
- `Query(max_length=20)`: Esta es la informaci√≥n extra para FastAPI. Le estamos diciendo: "Este par√°metro es de la URL (`Query`), y su longitud m√°xima es de 20 caracteres".
- Si un usuario intenta ir a `.../?query=un_texto_demasiado_largo_para_buscar`, FastAPI autom√°ticamente le devolver√° un error claro y descriptivo. ¬°T√∫ no tienes que escribir ni una l√≠nea de c√≥digo para esa validaci√≥n!

#### 3. **Desarrollo**:

Piensa en `Annotated` como un sobre. El tipo de dato (`str | None`) es la carta que va dentro, y `Query(...)` es una nota adhesiva que le pegas al sobre con instrucciones especiales para el cartero (FastAPI).

Esta es la forma **recomendada y moderna** de hacerlo desde la versi√≥n 0.95.0 de FastAPI. Es m√°s limpio, m√°s intuitivo y compatible con otras herramientas del ecosistema de Python.

üü° **Importante**: Aunque podr√≠as vivir sin ello usando m√©todos antiguos (que veremos), esta es la forma correcta y recomendada de escribir c√≥digo FastAPI hoy en d√≠a. Adoptarla te har√° un mejor programador y tu c√≥digo ser√° m√°s f√°cil de mantener.

## C - Validaci√≥n de Longitud (`max_length` y `min_length`) üü°

#### 1. **Introducci√≥n:**

Son reglas que puedes a√±adir con `Query` para controlar el tama√±o m√≠nimo y m√°ximo del texto que un usuario puede enviar en un par√°metro.

#### 2. **Ejemplo:**

En nuestra tienda, queremos que la b√∫squeda tenga al menos 3 caracteres (para evitar b√∫squedas in√∫tiles como "a") y como m√°ximo 20.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/search-products/")
async def search_products(
    query: Annotated[
        str | None,
        Query(min_length=3, max_length=20)
    ] = None
):
    if query:
        return {"message": f"Buscando: '{query}'"}

    return {"message": "Mostrando todos los productos."}
```

**Explicaci√≥n del ejemplo:**

- `min_length=3`: Si un usuario busca con `/?query=pc`, ¬°perfecto! Pero si intenta con `/?query=a`, FastAPI le dir√° amablemente que el texto es demasiado corto.
- `max_length=20`: Si busca `/?query=teclado_mecanico_rgb`, ¬°genial! Pero si intenta con `/?query=este_texto_es_absurdamente_largo`, FastAPI lo detendr√°.

#### 3. **Desarrollo**:

Estas validaciones son incre√≠blemente √∫tiles para proteger tu aplicaci√≥n. Evitan que los usuarios env√≠en datos basura, demasiado cortos para ser √∫tiles o demasiado largos que podr√≠an causar problemas de rendimiento o seguridad. FastAPI se encarga de todo el trabajo sucio de validar y devolver errores claros, para que t√∫ te concentres en la l√≥gica de tu aplicaci√≥n.

üü° **Importante**: Usar√°s validaciones de longitud constantemente. Son una de las herramientas m√°s comunes y poderosas para asegurar la calidad de los datos que entran a tu API.

## D - Validaci√≥n con Expresiones Regulares (`pattern`) üîµ

#### 1. **Introducci√≥n:**

Una expresi√≥n regular (o "regex") es una secuencia de caracteres que define un patr√≥n de b√∫squeda, permiti√©ndote validar formatos muy espec√≠ficos, como un c√≥digo postal, un email o un formato de factura.

#### 2. **Ejemplo:**

Imagina que en nuestra tienda, adem√°s de buscar, se pueden buscar productos por un c√≥digo de inventario que siempre sigue el formato `PROD-` seguido de 3 n√∫meros (ej: `PROD-123`).

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/products-by-code/")
async def find_product_by_code(
    code: Annotated[
        str,
        Query(pattern="^PROD-[0-9]{3}$")
    ]
):
    return {"message": f"Buscando producto con c√≥digo: {code}"}
```

**Explicaci√≥n del ejemplo:**

- `pattern="^PROD-[0-9]{3}$"`: ¬°No te asustes! Desglosemos este jerogl√≠fico:
  - `^`: El texto debe empezar aqu√≠.
  - `PROD-`: Debe contener literalmente "PROD-".
  - `[0-9]{3}`: Debe tener exactamente 3 caracteres que sean n√∫meros del 0 al 9.
  - `$`: El texto debe terminar aqu√≠.
- **V√°lido:** `/?code=PROD-456`
- **Inv√°lido:** `/?code=PROD-12` (faltan n√∫meros), `/?code=XYZ-123` (no empieza con PROD), `/?code=PROD-1234` (demasiados n√∫meros). FastAPI rechazar√° todos los inv√°lidos.

#### 3. **Desarrollo**:

Las expresiones regulares son una herramienta extremadamente potente, pero tambi√©n pueden ser complejas. No necesitas ser un experto para empezar, pero saber que existen y que FastAPI te permite usarlas con el par√°metro `pattern` es un as bajo la manga. Son perfectas para cuando una simple validaci√≥n de longitud no es suficiente y necesitas que los datos tengan una estructura muy concreta.

üîµ **Espec√≠fico**: No las usar√°s todos los d√≠as, pero para situaciones donde el formato de los datos es estricto (c√≥digos de producto, n√∫meros de serie, identificadores fiscales), son la herramienta perfecta. Es bueno saber que est√°n ah√≠ para cuando las necesites.

## E - Valores por Defecto (No `None`) üü°

#### 1. **Introducci√≥n:**

Puedes hacer que un par√°metro opcional tenga un valor predeterminado √∫til en lugar de `None`, para que tu funci√≥n siempre trabaje con un dato concreto.

#### 2. **Ejemplo:**

En nuestra tienda, queremos paginar los resultados. Vamos a tener un par√°metro `page` (p√°gina) que, si no se especifica, por defecto ser√° `1`.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/products/")
async def list_products(
    # Si no me dicen la p√°gina, asumo que es la primera.
    page: Annotated[int, Query(ge=1)] = 1
):
    return {"message": f"Mostrando productos de la p√°gina {page}"}
```

**Explicaci√≥n del ejemplo:**

- `page: Annotated[int, Query(ge=1)] = 1`:
  - El tipo es `int` (un n√∫mero entero).
  - `Query(ge=1)`: A√±adimos una validaci√≥n para que la p√°gina sea "greater than or equal to 1" (mayor o igual a 1). ¬°No queremos p√°ginas negativas!
  - `= 1`: Este es el valor por defecto. Si la URL es `/products/`, `page` valdr√° `1`. Si es `/products/?page=3`, `page` valdr√° `3`.

#### 3. **Desarrollo**:

Establecer valores por defecto sensatos simplifica enormemente tu c√≥digo. En lugar de tener que comprobar `if page is None: page = 1` dentro de tu funci√≥n, lo declaras directamente en la firma. Esto hace que tu l√≥gica sea m√°s limpia y tus intenciones m√°s claras. Es una pr√°ctica muy com√∫n para la paginaci√≥n (`page=1`, `limit=10`), filtros (`status="active"`), etc.

üü° **Importante**: Es una t√©cnica muy com√∫n y √∫til. Simplifica tu c√≥digo y mejora la experiencia del usuario de tu API al proporcionar comportamientos predecibles y sensatos.

## F - El M√©todo Antiguo: `Query` como Valor por Defecto üü°

#### 1. **Introducci√≥n:**

Antes de que `Annotated` fuera la norma, la forma de a√±adir validaciones era asignando `Query(...)` directamente como valor por defecto del par√°metro.

#### 2. **Ejemplo:**

As√≠ se ver√≠a nuestro ejemplo de validaci√≥n de longitud con el m√©todo antiguo. ¬°Quiero que lo veas para que lo reconozcas, no para que lo copies!

```python
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/search-products-old-way/")
async def search_products_old_way(
    # F√≠jate: Query(...) est√° en el lugar del valor por defecto.
    query: str | None = Query(default=None, min_length=3, max_length=20)
):
    if query:
        return {"message": f"Buscando (estilo antiguo): '{query}'"}

    return {"message": "Mostrando todos los productos (estilo antiguo)."}
```

**Explicaci√≥n del ejemplo:**

- `query: str | None = Query(...)`: En lugar de `... = None`, ahora el valor por defecto es una llamada a `Query()`.
- `Query(default=None, ...)`: Como `Query()` ha "robado" el sitio del valor por defecto, ahora tenemos que decirle a `Query` cu√°l era el valor por defecto original usando el argumento `default=None`. Es un poco redundante, ¬øverdad?

#### 3. **Desarrollo**:

Este m√©todo funciona perfectamente y hace lo mismo que `Annotated`. Sin embargo, es menos intuitivo. El valor por defecto de un par√°metro de funci√≥n en Python deber√≠a ser el valor real (`None`, `1`, `"hola"`), no un objeto de configuraci√≥n como `Query()`. Ver√°s mucho c√≥digo escrito as√≠ en proyectos m√°s antiguos o en tutoriales de hace unos a√±os. Es crucial que lo entiendas para no confundirte.

üü° **Importante**: No lo uses para c√≥digo nuevo. Pero es muy importante que sepas leerlo y entenderlo, porque te lo encontrar√°s. Pi√©nsalo como aprender a leer lat√≠n: no lo vas a hablar, pero te ayuda a entender de d√≥nde vienen muchas cosas.

## G - `Annotated` vs. `Query` como Valor por Defecto: La Batalla Final üî¥

#### 1. **Introducci√≥n:**

Esta es la comparaci√≥n definitiva para que entiendas por qu√© `Annotated` no es solo una opci√≥n, sino **la mejor opci√≥n**. ¬°Quiero que esto quede grabado a fuego en tu mente!

#### 2. **Ejemplo Comparativo:**

Veamos la misma funci√≥n escrita de las dos maneras. Ambas hacen lo mismo en FastAPI, pero una es mucho m√°s "pura" en t√©rminos de Python.

```python
from typing import Annotated
from fastapi import FastAPI, Query

# --- M√âTODO MODERNO Y RECOMENDADO (con Annotated) ---
def get_user_modern(user_id: Annotated[int, Query(ge=1)]):
    return f"Obteniendo usuario {user_id}"

# --- M√âTODO ANTIGUO (con Query como default) ---
def get_user_old(user_id: int = Query(ge=1)):
    # ¬°OJO! Aqu√≠ user_id no es un int, es un objeto Query!
    return f"Obteniendo usuario {user_id}"
```

**Explicaci√≥n del ejemplo:**
Ahora, el momento de la verdad. ¬øQu√© pasa si intentamos llamar a estas funciones fuera de FastAPI, en un script normal de Python?

```python
# Llamando a la funci√≥n moderna:
# get_user_modern()
# ERROR! Tu editor y Python te gritan: "¬°Falta el argumento 'user_id'!"
# ¬°Esto es BUENO! Te avisa de un error antes de que ocurra.

# Llamando a la funci√≥n antigua:
result = get_user_old()
print(result)
# SALIDA: "Obteniendo usuario QueryInfo(ge=1)"
# ¬°Esto es MALO! No da error, pero el resultado es basura.
# El valor por defecto no es un n√∫mero, es el objeto Query.
```

#### 3. **Desarrollo**:

La diferencia es abismal y esta es la raz√≥n por la que mi paranoia pedag√≥gica me obliga a insistir:

1.  **Claridad y Pureza (Ventaja de `Annotated`)**: Con `Annotated`, el valor por defecto (`= "valor"`) es el valor real. La firma de la funci√≥n es est√°ndar en Python. `Annotated` solo a√±ade "metadatos" que FastAPI lee, pero no interfiere con c√≥mo funciona la funci√≥n por s√≠ sola.
2.  **Reutilizaci√≥n y Seguridad (Ventaja de `Annotated`)**: Como vimos, la funci√≥n moderna es segura para ser llamada desde cualquier parte de tu c√≥digo. La antigua es una trampa: parece que funciona, pero te dar√° valores inesperados si la usas fuera del contexto de FastAPI. Tu editor de c√≥digo te ayudar√° con la versi√≥n `Annotated`, pero te dejar√° caer en la trampa con la versi√≥n antigua.
3.  **Composici√≥n (Ventaja de `Annotated`)**: `Annotated` te permite a√±adir m√∫ltiples "etiquetas" de metadatos, no solo para FastAPI, sino tambi√©n para otras herramientas como Typer (para crear CLIs). Es m√°s extensible.

üî¥ **Fundamental**: Entender esta diferencia es crucial para escribir c√≥digo robusto, mantenible y moderno en FastAPI. **Usa siempre `Annotated` para c√≥digo nuevo**. La claridad que ganas y los errores que evitas valen oro.

## H - Par√°metro Obsoleto `regex` ‚ö™

#### 1. **Introducci√≥n:**

En versiones antiguas de FastAPI (y Pydantic v1), el par√°metro para expresiones regulares se llamaba `regex` en lugar de `pattern`.

#### 2. **Ejemplo:**

As√≠ se ver√≠a el ejemplo de validaci√≥n de c√≥digo de producto con el par√°metro obsoleto.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/products-by-code-deprecated/")
async def find_product_by_code_deprecated(
    # F√≠jate en `regex` en lugar de `pattern`
    code: Annotated[str, Query(regex="^PROD-[0-9]{3}$")]
):
    return {"message": f"Buscando con regex (obsoleto) el c√≥digo: {code}"}
```

**Explicaci√≥n del ejemplo:**
El c√≥digo hace exactamente lo mismo que el que usa `pattern`. La √∫nica diferencia es el nombre del argumento.

#### 3. **Desarrollo**:

FastAPI y Pydantic se actualizaron para alinearse con los est√°ndares de JSON Schema, que utiliza `pattern` para las expresiones regulares. Por eso `regex` fue marcado como obsoleto (deprecated). No deber√≠as usarlo nunca en c√≥digo nuevo, pero si te encuentras con un proyecto antiguo y ves `regex`, ya sabes que simplemente es el abuelo de `pattern`. Solo tienes que renombrarlo y todo seguir√° funcionando.

‚ö™ **Raramente usado**: Este concepto es puramente hist√≥rico. Solo necesitas saber que existe para no asustarte si lo ves en c√≥digo ajeno. Siempre, siempre, siempre usa `pattern` en su lugar.

---

## I - Par√°metros Requeridos con `Query`: El "S√≠ o S√≠" de tu API üî¥

#### 1. **Introducci√≥n:**

Para hacer que un par√°metro con validaciones de `Query` sea obligatorio, simplemente no le asignes ning√∫n valor por defecto.

#### 2. **Ejemplo:**

Imagina que necesitas buscar un usuario por su ID, y ese ID es absolutamente obligatorio. No hay b√∫squeda sin ID.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/users/")
async def get_user_by_id(
    # F√≠jate bien: NO hay un "= None" al final.
    # Esto lo convierte en un par√°metro requerido.
    user_id: Annotated[str, Query(min_length=5)]
):
    return {"message": f"Buscando al usuario con ID: {user_id}"}
```

**Explicaci√≥n del ejemplo:**

- La clave est√° en la ausencia del `= algo`. Al no tener un valor por defecto, Python y FastAPI entienden que este par√°metro **debe** ser proporcionado.
- Si un usuario intenta ir a `/users/` sin un `?user_id=...`, FastAPI autom√°ticamente devolver√° un error 422 (Unprocessable Entity) diciendo que falta el par√°metro `user_id`. ¬°Protecci√≥n autom√°tica!

#### 3. **Desarrollo**:

La regla de oro es simple: **sin valor por defecto, el par√°metro es requerido**. Esto es un principio fundamental de las funciones de Python que FastAPI respeta y aprovecha. Incluso cuando usamos toda la parafernalia de `Annotated` y `Query`, esta regla b√°sica sigue aplicando. Es la forma m√°s limpia y directa de exigir un dato.

üî¥ **Fundamental**: Tan esencial como saber hacer par√°metros opcionales. Necesitas controlar qu√© datos son indispensables para que tus endpoints funcionen.

## J - Par√°metros Requeridos que pueden ser `None`: La Paradoja Obligatoria üîµ

#### 1. **Introducci√≥n:**

Este es un caso especial: obligas al cliente a enviar el par√°metro, pero le permites que su valor sea expl√≠citamente `None`.

#### 2. **Ejemplo:**

Supongamos que actualizamos un perfil de usuario. Queremos que el cliente nos diga expl√≠citamente qu√© hacer con el campo "apodo" (`nickname`). Puede darnos un nuevo apodo, o puede decirnos "quiero que no tenga apodo" enviando `None`. Pero no puede simplemente ignorar el campo.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.put("/users/profile")
async def update_profile(
    # Acepta str o None, pero NO tiene valor por defecto.
    nickname: Annotated[str | None, Query(max_length=20)]
):
    if nickname is None:
        return {"message": "Apodo eliminado expl√≠citamente."}
    return {"message": f"Apodo actualizado a: {nickname}"}
```

**Explicaci√≥n del ejemplo:**

- `str | None`: Le decimos que el tipo puede ser texto o `None`.
- **Sin `= ...`**: Al no tener valor por defecto, es requerido.
- **URL v√°lida 1:** `/users/profile?nickname=ElPro` -> `nickname` es `"ElPro"`.
- **URL v√°lida 2:** `/users/profile?nickname=` -> `nickname` es `None`. El cliente lo envi√≥ vac√≠o, lo que se interpreta como nulo.
- **URL inv√°lida:** `/users/profile` -> FastAPI dar√° error porque el par√°metro `nickname` no fue enviado.

#### 3. **Desarrollo**:

¬øPor qu√© querr√≠as hacer esto? Para ser expl√≠cito. Forzar al cliente a tomar una decisi√≥n sobre un campo evita ambig√ºedades. En una operaci√≥n de actualizaci√≥n (PUT/PATCH), esto distingue entre "no quiero cambiar este campo" (no se env√≠a el par√°metro) y "quiero vaciar este campo" (se env√≠a el par√°metro con valor nulo).

üîµ **Espec√≠fico**: Es una t√©cnica avanzada para dise√±os de API muy rigurosos. No la usar√°s todos los d√≠as, pero es una herramienta muy potente para evitar malentendidos entre el cliente y el servidor en operaciones de modificaci√≥n de datos.

## K - Par√°metros de Consulta de tipo Lista: Recibiendo M√∫ltiples Valores üü°

#### 1. **Introducci√≥n:**

Permite que un par√°metro de consulta se repita en la URL para recibir una lista de valores, ideal para filtros m√∫ltiples.

#### 2. **Ejemplo:**

En nuestra tienda, queremos buscar productos que coincidan con varias etiquetas a la vez. Por ejemplo, productos que sean "gamer" Y "en-oferta".

```python
from typing import Annotated, list
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/products/filter-by-tags/")
async def filter_by_tags(
    # El tipo es una lista de strings: list[str]
    tags: Annotated[list[str] | None, Query()] = None
):
    if tags:
        return {"filtering_by_tags": tags}
    return {"message": "No se especificaron tags."}
```

**Explicaci√≥n del ejemplo:**

- Si un usuario va a la URL: `.../?tags=gamer&tags=en-oferta`
- FastAPI m√°gicamente recoger√° ambos valores y se los entregar√° a tu funci√≥n dentro de la variable `tags` como una lista de Python: `["gamer", "en-oferta"]`.
- **¬°CUIDADO! ¬°TRAMPA A EVITAR!** Debes usar `Query()` expl√≠citamente (incluso si est√° vac√≠o como en `Query()`). Si solo pones `tags: list[str] | None = None`, FastAPI pensar√° que esperas una lista en el _cuerpo_ de la petici√≥n (request body), no en la URL, y no funcionar√° como esperas.

La documentaci√≥n se ver√° as√≠, permitiendo a√±adir varios campos:
![Documentaci√≥n para listas](https://fastapi.tiangolo.com/img/tutorial/query-params-str-validations/image02.png)

#### 3. **Desarrollo**:

Esta funcionalidad es incre√≠blemente √∫til. Permite crear sistemas de filtrado complejos de una manera muy intuitiva para el usuario de la API. Puedes, por supuesto, combinarlo con valores por defecto:

`tags: Annotated[list[str], Query()] = ["electronica"]`

Si el usuario no env√≠a ninguna etiqueta, por defecto buscar√° "electronica".

Tambi√©n puedes usar `list` en lugar de `list[str]`, pero ¬°ten cuidado! Si usas `list` a secas, FastAPI no validar√° que los elementos dentro de la lista sean strings. Siempre es mejor ser espec√≠fico (`list[str]`, `list[int]`, etc.) para mayor seguridad.

üü° **Importante**: Una herramienta muy com√∫n y poderosa para cualquier API que necesite filtros complejos. Es muy probable que la necesites tarde o temprano.

## L - A√±adiendo Metadatos para la Documentaci√≥n (`title` y `description`) üü°

#### 1. **Introducci√≥n:**

Puedes a√±adir un t√≠tulo y una descripci√≥n a tus par√°metros para que la documentaci√≥n autom√°tica de tu API sea mucho m√°s f√°cil de entender para otros programadores (¬°o para tu yo del futuro!).

#### 2. **Ejemplo:**

Vamos a mejorar la documentaci√≥n de nuestro par√°metro de b√∫squeda `q`.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/items/search")
async def search_items(
    q: Annotated[
        str | None,
        Query(
            title="T√©rmino de B√∫squeda",
            description="El texto que quieres buscar en la base de datos de productos. La b√∫squeda no distingue may√∫sculas de min√∫sculas.",
            min_length=3,
        ),
    ] = None,
):
    if q:
        return {"searching_for": q}
    return {"message": "Mostrando todos los items."}
```

**Explicaci√≥n del ejemplo:**

- `title="T√©rmino de B√∫squeda"`: Este ser√° el "nombre" principal del par√°metro en la interfaz de la documentaci√≥n. Es m√°s legible que el nombre de la variable `q`.
- `description="..."`: Este texto m√°s largo aparecer√° como una ayuda, explicando exactamente qu√© hace el par√°metro, qu√© valores espera y cualquier otra cosa que sea √∫til saber.

#### 3. **Desarrollo**:

Documentar tu c√≥digo es un acto de bondad. FastAPI hace que sea tan f√°cil que no hay excusa para no hacerlo. Estos metadatos no cambian c√≥mo funciona tu c√≥digo, pero transforman tu API de una caja negra a una herramienta bien explicada y f√°cil de usar. El `title` y la `description` se incorporan al esquema OpenAPI, que es el est√°ndar que usan las herramientas de documentaci√≥n como Swagger UI y ReDoc.

üü° **Importante**: Es una muy buena pr√°ctica. Unos minutos a√±adiendo estos metadatos pueden ahorrar horas de confusi√≥n a quien consuma tu API. ¬°Hazlo por ellos y por ti!

## M - Usando Alias para Par√°metros (`alias`) üîµ

#### 1. **Introducci√≥n:**

Te permite usar un nombre para el par√°metro en la URL que ser√≠a inv√°lido como nombre de variable en Python, como uno que contiene un guion (`-`).

#### 2. **Ejemplo:**

Supongamos que por una convenci√≥n externa, el par√°metro de b√∫squeda debe llamarse `item-query` en la URL. Pero `item-query` no es un nombre de variable v√°lido en Python.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/items/aliased-search")
async def aliased_search(
    # En la URL es "item-query", pero en nuestro c√≥digo es "item_query".
    item_query: Annotated[str | None, Query(alias="item-query")] = None
):
    if item_query:
        return {"searching_with_alias": item_query}
    return {"message": "No query provided."}
```

**Explicaci√≥n del ejemplo:**

- `alias="item-query"`: Esta es la instrucci√≥n clave. Le dice a FastAPI: "Cuando veas `item-query` en la URL, por favor, pon su valor en la variable `item_query` de mi funci√≥n".
- El usuario final usar√° la URL: `.../?item-query=mi-busqueda`
- Tu c√≥digo recibir√° `"mi-busqueda"` en la variable `item_query`, que s√≠ es un nombre v√°lido en Python.

#### 3. **Desarrollo**:

El `alias` act√∫a como un traductor entre el "mundo exterior" (la URL) y tu "mundo interior" (tu c√≥digo Python). Es la soluci√≥n perfecta cuando necesitas integrarte con sistemas existentes que tienen convenciones de nombrado diferentes o cuando simplemente prefieres que tus URLs sigan un estilo (como `kebab-case`) que no es compatible con Python (`snake_case`).

üîµ **Espec√≠fico**: No lo necesitar√°s siempre, pero es un salvavidas cuando te enfrentas a requisitos de nombrado espec√≠ficos. Es una de esas herramientas que te alegrar√° mucho saber que existe cuando llegue el momento.

## N - Marcando Par√°metros como Obsoletos (`deprecated`) üîµ

#### 1. **Introducci√≥n:**

Permite marcar un par√°metro como "obsoleto" en la documentaci√≥n, indicando a los usuarios que ya no deber√≠an usarlo y que podr√≠a ser eliminado en el futuro.

#### 2. **Ejemplo:**

Decidimos que nuestro par√°metro `q` es muy gen√©rico y queremos reemplazarlo por uno m√°s espec√≠fico llamado `search_term`. Pero no podemos eliminar `q` de golpe porque hay clientes que ya lo est√°n usando.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/items/deprecate-search")
async def deprecate_search(
    q: Annotated[
        str | None,
        Query(
            alias="item-query",
            title="Query string",
            deprecated=True, # ¬°Aqu√≠ est√° la magia!
        ),
    ] = None,
):
    if q:
        return {"message": f"Buscando con el par√°metro obsoleto: {q}"}
    return {"message": "No query."}
```

**Explicaci√≥n del ejemplo:**

- `deprecated=True`: Al a√±adir esto, el par√°metro seguir√° funcionando exactamente igual, pero en la documentaci√≥n autom√°tica aparecer√° tachado y con una advertencia de que est√° obsoleto.

As√≠ se ver√° en la documentaci√≥n, ¬°un aviso claro y directo!
![Par√°metro obsoleto](https://fastapi.tiangolo.com/img/tutorial/query-params-str-validations/image01.png)

#### 3. **Desarrollo**:

"Deprecar" es una parte fundamental del ciclo de vida de una API. Te permite evolucionar y mejorar tu API sin romper la compatibilidad con los usuarios existentes de forma abrupta. Les da tiempo para migrar a los nuevos par√°metros mientras la versi√≥n antigua sigue funcionando. Es una forma profesional y considerada de gestionar los cambios.

üîµ **Espec√≠fico**: Lo usar√°s cuando necesites refactorizar o cambiar el dise√±o de un endpoint que ya est√° en producci√≥n. Es una herramienta clave para la mantenibilidad a largo plazo de tu API.

## O - Excluyendo Par√°metros de la Documentaci√≥n (`include_in_schema`) üîµ

#### 1. **Introducci√≥n:**

Te permite tener un par√°metro de consulta que funciona perfectamente pero que est√° completamente oculto de la documentaci√≥n de la API.

#### 2. **Ejemplo:**

Imagina que tienes un par√°metro secreto, `secret_key`, que solo debe ser conocido por algunos servicios internos para activar un modo de depuraci√≥n, y no quieres que aparezca en la documentaci√≥n p√∫blica.

```python
from typing import Annotated
from fastapi import FastAPI, Query

app = FastAPI()

@app.get("/internal/data")
async def get_internal_data(
    # Este par√°metro no aparecer√° en /docs
    secret_key: Annotated[str | None, Query(include_in_schema=False)] = None
):
    if secret_key == "supersecret":
        return {"message": "Acceso concedido a los datos secretos."}
    return {"message": "Acceso denegado."}
```

**Explicaci√≥n del ejemplo:**

- `include_in_schema=False`: Esta instrucci√≥n le dice a FastAPI: "Oye, este par√°metro existe y funciona, pero por favor, no lo incluyas en el esquema OpenAPI".
- Como resultado, cuando vayas a `/docs` o `/redoc`, el endpoint `/internal/data` aparecer√°, pero el par√°metro `secret_key` ser√° invisible. Solo quien conozca su existencia podr√° usarlo.

#### 3. **Desarrollo**:

Esta es una herramienta √∫til para par√°metros de depuraci√≥n, claves de acceso temporales, o cualquier otro par√°metro que no forme parte de la interfaz p√∫blica y estable de tu API. Te da control total sobre lo que se documenta y lo que permanece como un detalle de implementaci√≥n interno.

üîµ **Espec√≠fico**: Para casos de uso muy particulares, como par√°metros internos, de depuraci√≥n o de seguridad por oscuridad. Es bueno saber que tienes esta opci√≥n para controlar la visibilidad de tu API.

## P - Validaci√≥n Personalizada con `AfterValidator` üîµ

#### 1. **Introducci√≥n:**

Es tu navaja suiza para validaciones. Cuando `min_length`, `pattern`, etc., no son suficientes, puedes usar tu propia funci√≥n de Python para crear cualquier regla de validaci√≥n que se te ocurra.

#### 2. **Ejemplo:**

Necesitamos validar un identificador de producto que debe empezar obligatoriamente con `PROD-` o `TEST-`. Ninguna de las validaciones est√°ndar nos sirve para chequear "uno u otro prefijo".

```python
from typing import Annotated
from fastapi import FastAPI
from pydantic import AfterValidator

app = FastAPI()

# 1. Creamos nuestra funci√≥n de validaci√≥n personalizada
def check_product_id_prefix(value: str):
    if not value.startswith(("PROD-", "TEST-")):
        # Si no es v√°lido, lanzamos un ValueError. FastAPI lo atrapar√°.
        raise ValueError('El ID debe empezar con "PROD-" o "TEST-"')
    # Si es v√°lido, devolvemos el valor sin cambios.
    return value

@app.get("/products/validate-id/")
async def get_product_by_valid_id(
    # 2. Usamos AfterValidator para "enganchar" nuestra funci√≥n.
    product_id: Annotated[str, AfterValidator(check_product_id_prefix)]
):
    return {"valid_product_id": product_id}
```

**Explicaci√≥n del ejemplo:**

1.  **La Funci√≥n Validadora (`check_product_id_prefix`)**:
    - Recibe el valor del par√°metro (`value`).
    - Comprueba si cumple nuestra l√≥gica personalizada.
    - Si la validaci√≥n falla, lanza un `ValueError` con un mensaje descriptivo. FastAPI convertir√° esto en un error 422 claro para el cliente.
    - Si todo est√° bien, debe devolver el valor.
2.  **La Conexi√≥n con `Annotated`**:
    - `AfterValidator(check_product_id_prefix)`: Le decimos a Pydantic (el motor de validaci√≥n de FastAPI) que, _despu√©s_ de validar que el valor es un `str`, ejecute nuestra funci√≥n `check_product_id_prefix` sobre √©l.

#### 3. **Desarrollo**:

`AfterValidator` te da un poder casi ilimitado. La √∫nica regla es que tu validaci√≥n debe basarse √∫nicamente en el valor del par√°metro en s√≠. Si necesitas consultar una base de datos o llamar a otra API para validar algo, deber√≠as usar el sistema de **Dependencias** de FastAPI, que es un tema m√°s avanzado.

**Peque√±os trucos del ejemplo que no quiero que se te escapen:**

- `value.startswith(("PROD-", "TEST-"))`: El m√©todo `startswith` de los strings en Python es genial, ¬°puede aceptar una tupla de prefijos y comprobar√° si el string empieza con alguno de ellos!
- El ejemplo del texto original usa `random.choice` para dar una sugerencia si no se provee un ID. Es un detalle simp√°tico que muestra c√≥mo puedes combinar la l√≥gica de tu API con las validaciones.

üîµ **Espec√≠fico**: Es una herramienta avanzada. La mayor√≠a de las veces te bastar√° con las validaciones est√°ndar. Pero cuando te enfrentes a una regla de negocio compleja y muy espec√≠fica, `AfterValidator` ser√° tu mejor amigo.
