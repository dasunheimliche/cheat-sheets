## A - Configuración y Variables de Entorno

**Definición:** Valores externos a la aplicación (como claves secretas, URLs de bases de datos, etc.) que se utilizan para configurar el comportamiento de la misma. Las variables de entorno son una forma común de proporcionar estas configuraciones.

**Ejemplo:** Variables de entorno como DATABASE_URL, SECRET_KEY, ADMIN_EMAIL, etc. que configuran la aplicación.

(Estas variables pueden cambiar según el entorno y usualmente son sensibles.)

## B - Tipos y Validación

**Definición:** Las variables de entorno solo almacenan texto (str). Cualquier conversión a otros tipos de datos y validación deben realizarse en el código de la aplicación.

**Ejemplo:** Una variable de entorno ITEMS_PER_USER se leerá como string pero se debe convertir en entero.

(La validación es una parte fundamental de la lectura de settings para asegurar la integridad de los datos)

## C - pydantic-settings

**Definición:** Una librería de Pydantic para gestionar la configuración proveniente de variables de entorno. Facilita la lectura, conversión y validación de settings.

**Ejemplo:** Utilizar la clase BaseSettings para definir los atributos de la configuración.

(Anteriormente estaba incluida en la librería principal de Pydantic, pero se separó a una librería aparte.)

## D - Clase BaseSettings

**Definición:** Clase base de pydantic_settings que se utiliza para crear una clase de settings, similar a un modelo Pydantic. Los atributos se definen con type annotations y opcionalmente valores por defecto.

**Ejemplo:**

```Python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    app_name: str = "Mi App"
    admin_email: str
    items_per_user: int = 50
```

(Esta clase de settings tendrá 3 atributos y solo el admin_email es obligatorio.)

## E - Lectura de Variables de Entorno

**Definición:** Al crear una instancia de la clase Settings, Pydantic lee las variables de entorno correspondientes (sin importar mayúsculas y minúsculas) y las asigna a los atributos. Convierte y valida los datos.

**Ejemplo:** Una variable de entorno APP_NAME se asignará al atributo app_name del objeto settings.

(Se utilizan las mismas reglas de validación que los modelos Pydantic.)

## F - Usar el objeto settings

**Definición:** Se puede acceder a los valores de settings a través de la instancia del objeto Settings, después de haberlos leído y validado.

**Ejemplo:**

```Python
from fastapi import FastAPI
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    app_name: str = "Mi App"
    admin_email: str
    items_per_user: int = 50

settings = Settings()

app = FastAPI()

@app.get("/info")
async def info():
    return {
        "app_name": settings.app_name,
        "admin_email": settings.admin_email,
        "items_per_user": settings.items_per_user
    }
```

(El atributo settings contiene la información configurada desde las variables de entorno)

## G - Settings en Otro Módulo

**Definición:** Se puede definir la clase Settings en un módulo separado para mantener la organización del proyecto.

**Ejemplo:** Un archivo config.py que contiene la definición de la clase Settings, y que se importa en main.py.

(De esta forma se organiza mejor la app, similar al patrón visto en "Bigger Applications".)

## H - Settings como Dependencia

**Definición:** Es posible definir una función que devuelve un objeto Settings y usarla como dependencia, lo cual facilita el testeo.

**Ejemplo:**

```Python
from functools import lru_cache
from fastapi import Depends
from typing import Annotated

from .config import Settings

@lru_cache
def get_settings():
    return Settings()

async def my_endpoint(settings: Annotated[Settings, Depends(get_settings)]):
  # ...
  pass
```

(La función get_settings puede ser sobreescrita para el testeo, y lru_cache es usada para evitar que se cree una instancia por cada petición).

## I - Sobreescritura de Dependencias para Settings

**Definición:** Se puede sobreescribir la dependencia que retorna el objeto Settings durante las pruebas para proporcionar valores diferentes y simular diferentes configuraciones.

**Ejemplo:**

```Python
from fastapi.testclient import TestClient
from .main import app, get_settings
from .config import Settings

client = TestClient(app)

def override_settings():
  return Settings(admin_email="test@example.com")

app.dependency_overrides[get_settings] = override_settings
```

(Durante la ejecución de tests, get_settings retornara la configuración de override_settings).

## J - Archivos .env

**Definición:** Un archivo donde se guardan variables de entorno. Cada linea del archivo tiene el formato: CLAVE=VALOR. La libreria python-dotenv (junto con pydantic_settings) permite leer settings desde este tipo de archivos.

**Ejemplo:** Un archivo .env con contenido como ADMIN_EMAIL="deadpool@example.com"\nAPP_NAME="ChimichangApp"

(Estos archivos facilitan la configuración del proyecto para diferentes entornos.)

## K - Lectura de .env

**Definición:** Se configura la clase Settings para que lea los settings desde el archivo .env, al momento de crear una instancia de la clase.

**Ejemplo:**

```Python
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    app_name: str = "Mi App"
    admin_email: str
    items_per_user: int = 50
    model_config = SettingsConfigDict(env_file=".env")
```

(Este código le indica a pydantic que debe leer los settings desde el archivo .env.)

## L - lru_cache para Settings

**Definición:** Decorador de functools que permite que la función decorada solo sea ejecutada la primera vez, y que después retorne la misma instancia en las subsiguientes llamadas. Se usa para evitar leer los archivos .env o crear la instancia Settings múltiples veces, pero aún permite el testeo.

**Ejemplo:**

```Python
from functools import lru_cache
from .config import Settings

@lru_cache
def get_settings():
    return Settings()
```

(La funcion solo se ejecutara una vez, para obtener los settings, las siguientes veces se retornara la misma instancia ya obtenida.)
