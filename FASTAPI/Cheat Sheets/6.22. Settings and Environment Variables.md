## A - Variables de entorno

**Definición:**  
Las variables de entorno son valores externos a tu aplicación que se utilizan para configurar su comportamiento. Son útiles para manejar datos sensibles (como claves secretas) o valores que pueden cambiar entre entornos (como URLs de bases de datos). Estas variables son cadenas de texto y deben ser convertidas y validadas en tu código.

**Ejemplo:**

```bash
# En la terminal
export DATABASE_URL="postgres://user:password@localhost:5432/mydatabase"
```

Descripción: Aquí se define una variable de entorno `DATABASE_URL` que contiene la URL de una base de datos. Esta variable puede ser leída por tu aplicación para conectarse a la base de datos.

---

## B - Pydantic `BaseSettings`

**Definición:**  
Pydantic ofrece una clase llamada `BaseSettings` para manejar configuraciones y variables de entorno de manera eficiente. Permite definir atributos con tipos específicos, valores predeterminados y validaciones, similar a los modelos de Pydantic.

**Ejemplo:**

```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    app_name: str = "Awesome API"
    admin_email: str
    items_per_user: int = 50

settings = Settings()
```

Descripción: Aquí se define una clase `Settings` que hereda de `BaseSettings`. Los atributos `app_name`, `admin_email` e `items_per_user` pueden ser configurados mediante variables de entorno. Si no se proporcionan, `app_name` e `items_per_user` tendrán valores predeterminados.

---

## C - Validación y tipos de datos

**Definición:**  
Pydantic convierte automáticamente las variables de entorno (que son cadenas de texto) a los tipos de datos especificados en la clase `Settings`. Si la conversión no es posible, lanza un error de validación.

**Ejemplo:**

```python
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    port: int = 8000

settings = Settings()
```

Descripción: Si la variable de entorno `PORT` se define como `"8000"`, Pydantic la convertirá a un entero. Si se define como `"ochocientos"`, lanzará un error porque no puede convertir esa cadena a un entero.

---

## D - Uso de `Settings` en una aplicación FastAPI

**Definición:**  
Puedes usar una instancia de `Settings` en tu aplicación FastAPI para acceder a las configuraciones definidas. Esto es útil para centralizar la gestión de configuraciones.

**Ejemplo:**

```python
from fastapi import FastAPI
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    app_name: str = "Awesome API"
    admin_email: str

settings = Settings()
app = FastAPI()

@app.get("/info")
async def info():
    return {
        "app_name": settings.app_name,
        "admin_email": settings.admin_email,
    }
```

Descripción: Aquí se usa la instancia `settings` para devolver información de la aplicación en un endpoint. Los valores se obtienen de las variables de entorno o de los valores predeterminados.

---

## E - Configuración en un módulo separado

**Definición:**  
Es una buena práctica separar la configuración en un archivo independiente (por ejemplo, `config.py`) para mantener el código organizado y reutilizable.

**Ejemplo:**

```python
# config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    app_name: str = "Awesome API"
    admin_email: str

settings = Settings()
```

```python
# main.py
from fastapi import FastAPI
from .config import settings

app = FastAPI()

@app.get("/info")
async def info():
    return {
        "app_name": settings.app_name,
        "admin_email": settings.admin_email,
    }
```

Descripción: La configuración se define en `config.py` y se importa en `main.py` para su uso en la aplicación.

---

## F - Configuración como dependencia

**Definición:**  
Puedes proporcionar la configuración como una dependencia en FastAPI. Esto facilita la sobreescritura de configuraciones durante las pruebas.

**Ejemplo:**

```python
from functools import lru_cache
from fastapi import Depends, FastAPI
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    app_name: str = "Awesome API"
    admin_email: str

app = FastAPI()

@lru_cache
def get_settings():
    return Settings()

@app.get("/info")
async def info(settings: Settings = Depends(get_settings)):
    return {
        "app_name": settings.app_name,
        "admin_email": settings.admin_email,
    }
```

Descripción: La función `get_settings` se usa como dependencia para proporcionar la configuración. El decorador `@lru_cache` asegura que la configuración se cargue solo una vez.

---

## G - Uso de archivos `.env`

**Definición:**  
Los archivos `.env` permiten definir variables de entorno en un archivo de texto. Pydantic puede leer estos archivos automáticamente.

**Ejemplo:**

```bash
# .env
ADMIN_EMAIL="admin@example.com"
APP_NAME="MyApp"

python
# config.py
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    app_name: str = "Awesome API"
    admin_email: str

    model_config = SettingsConfigDict(env_file=".env")
```

Descripción: Pydantic leerá las variables de entorno del archivo `.env` y las usará para configurar la instancia de `Settings`.

---

## H - `@lru_cache` para optimización

**Definición:**  
El decorador `@lru_cache` evita que la configuración se cargue múltiples veces. Almacena en caché el resultado de la función, lo que mejora el rendimiento.

**Ejemplo:**

```python
from functools import lru_cache
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    app_name: str = "Awesome API"

@lru_cache
def get_settings():
    return Settings()
```

Descripción: La función `get_settings` se ejecutará solo una vez, y su resultado se almacenará en caché para llamadas posteriores.

---

## I - Pruebas con configuraciones personalizadas

**Definición:**  
Durante las pruebas, puedes sobreescribir las dependencias de configuración para usar valores personalizados.

**Ejemplo:**

```python
from fastapi.testclient import TestClient
from .main import app, get_settings

def get_settings_override():
    return Settings(admin_email="test@example.com")

app.dependency_overrides[get_settings] = get_settings_override

client = TestClient(app)

def test_info():
    response = client.get("/info")
    assert response.json()["admin_email"] == "test@example.com"
```

Descripción: Aquí se sobreescribe la dependencia `get_settings` para usar un correo electrónico de prueba durante la ejecución de la prueba.

---

## J - Recapitulación

**Definición:**

- Usa `BaseSettings` de Pydantic para gestionar configuraciones.
- Separa la configuración en un archivo independiente.
- Usa dependencias para facilitar las pruebas.
- Lee variables de entorno desde archivos `.env`.
- Optimiza el rendimiento con `@lru_cache`.
