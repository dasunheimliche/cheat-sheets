## A - Query Parameter Models

**Definición:**  
Si tienes un grupo de **query parameters** relacionados, puedes crear un **modelo Pydantic** para declararlos. Esto te permite reutilizar el modelo en múltiples lugares y declarar validaciones y metadatos para todos los parámetros a la vez.

**Ejemplo:**

```python
from typing import Annotated, Literal
from fastapi import FastAPI, Query
from pydantic import BaseModel, Field

app = FastAPI()

class FilterParams(BaseModel):
    limit: int = Field(100, gt=0, le=100)
    offset: int = Field(0, ge=0)
    order_by: Literal["created_at", "updated_at"] = "created_at"
    tags: list[str] = []

@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    return filter_query
```

**Descripción del ejemplo:**

- `FilterParams` es un modelo Pydantic que define varios query parameters.
- `limit` debe ser un número entre 1 y 100.
- `offset` debe ser un número mayor o igual a 0.
- `order_by` solo puede ser `"created_at"` o `"updated_at"`.
- `tags` es una lista opcional de cadenas.

---

## B - Forbid Extra Query Parameters (Prohibir Parámetros Extra)

**Definición:**  
Puedes configurar el modelo Pydantic para prohibir parámetros adicionales que no estén definidos en el modelo.

**Ejemplo:**

```python
from typing import Annotated, Literal
from fastapi import FastAPI, Query
from pydantic import BaseModel, Field

app = FastAPI()

class FilterParams(BaseModel):
    model_config = {"extra": "forbid"}
    limit: int = Field(100, gt=0, le=100)
    offset: int = Field(0, ge=0)
    order_by: Literal["created_at", "updated_at"] = "created_at"
    tags: list[str] = []

@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    return filter_query
```

**Descripción del ejemplo:**

- Si un cliente intenta enviar un parámetro adicional (por ejemplo, `tool=plumbus`), FastAPI devolverá un error indicando que el parámetro no está permitido.

---

## C - Check the Docs (Verificar la Documentación)

**Definición:**  
FastAPI genera automáticamente documentación interactiva para los query parameters definidos en el modelo Pydantic.

**Ejemplo:**

```python
from typing import Annotated, Literal
from fastapi import FastAPI, Query
from pydantic import BaseModel, Field

app = FastAPI()

class FilterParams(BaseModel):
    limit: int = Field(100, gt=0, le=100)
    offset: int = Field(0, ge=0)
    order_by: Literal["created_at", "updated_at"] = "created_at"
    tags: list[str] = []

@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    return filter_query
```

**Descripción del ejemplo:**

- La documentación en `/docs` mostrará los query parameters definidos en `FilterParams` con sus respectivas validaciones y descripciones.

---

## D - Summary (Resumen)

**Definición:**  
Puedes usar **modelos Pydantic** para declarar **query parameters** en FastAPI. Esto te permite:

1.  **Reutilizar** el modelo en múltiples endpoints.
2.  **Agrupar** parámetros relacionados.
3.  **Validar** y documentar los parámetros de manera centralizada.

**Ejemplo:**

```python
from typing import Annotated, Literal
from fastapi import FastAPI, Query
from pydantic import BaseModel, Field

app = FastAPI()

class FilterParams(BaseModel):
    limit: int = Field(100, gt=0, le=100)
    offset: int = Field(0, ge=0)
    order_by: Literal["created_at", "updated_at"] = "created_at"
    tags: list[str] = []

@app.get("/items/")
async def read_items(filter_query: Annotated[FilterParams, Query()]):
    return filter_query
```

**Descripción del ejemplo:**

- `FilterParams` define un grupo de query parameters con validaciones específicas.
- FastAPI extrae automáticamente los valores de los query parameters y los valida según el modelo.
