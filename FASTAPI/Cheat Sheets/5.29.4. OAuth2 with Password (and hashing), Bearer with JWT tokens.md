## A - JWT (JSON Web Tokens)

**Definición:**  
Un JWT (JSON Web Token) es un estándar para codificar un objeto JSON en una cadena larga y densa sin espacios. Se utiliza para transmitir información entre partes de manera segura. Aunque no está encriptado, está firmado, lo que permite verificar que el token fue emitido por una fuente confiable y no ha sido alterado.

**Ejemplo:**

```python
import jwt

# Crear un token JWT
token = jwt.encode({"sub": "user123", "exp": 1633032800}, "secret_key", algorithm="HS256")
print(token)

# Decodificar un token JWT
decoded = jwt.decode(token, "secret_key", algorithms=["HS256"])
print(decoded)
```

**Descripción del ejemplo:**  
En este ejemplo, se crea un token JWT con un payload que contiene el sujeto (`sub`) y la fecha de expiración (`exp`). Luego, se decodifica el token para verificar su contenido.

---

## B - Password Hashing (Hash de contraseñas)

**Definición:**  
El "hashing" de contraseñas es el proceso de convertir una contraseña en una secuencia de bytes (una cadena de texto que parece aleatoria). Esto se hace para almacenar contraseñas de manera segura, ya que no se puede revertir el proceso para obtener la contraseña original.

**Ejemplo:**

```python
from passlib.context import CryptContext

# Crear un contexto de hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# Hashear una contraseña
hashed_password = pwd_context.hash("mi_contraseña")
print(hashed_password)

# Verificar una contraseña
is_valid = pwd_context.verify("mi_contraseña", hashed_password)
print(is_valid)  # True si coincide, False si no
```

**Descripción del ejemplo:**  
Aquí se utiliza `passlib` para hashear una contraseña y luego verificar si una contraseña dada coincide con el hash almacenado.

---

## C - OAuth2 con Password y Bearer JWT

**Definición:**  
OAuth2 es un protocolo de autorización que permite a los usuarios autenticarse y obtener tokens de acceso (JWT) para interactuar con una API. En este caso, se utiliza el flujo "password" donde el usuario proporciona su nombre de usuario y contraseña para obtener un token JWT.

**Ejemplo:**

```python
from fastapi import Depends, FastAPI, HTTPException
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm

app = FastAPI()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

@app.post("/token")
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    # Verificar usuario y contraseña
    if form_data.username != "johndoe" or form_data.password != "secret":
        raise HTTPException(status_code=400, detail="Usuario o contraseña incorrectos")

    # Crear y devolver un token JWT
    access_token = jwt.encode({"sub": form_data.username}, "secret_key", algorithm="HS256")
    return {"access_token": access_token, "token_type": "bearer"}
```

**Descripción del ejemplo:**  
Este código muestra cómo implementar un endpoint `/token` que recibe las credenciales del usuario y devuelve un token JWT si las credenciales son válidas.

---

## D - Verificación de Token JWT

**Definición:**  
Una vez que un usuario tiene un token JWT, este token se puede utilizar para autenticar solicitudes posteriores. El servidor verifica la firma del token y extrae la información del usuario (como el `sub` o sujeto).

**Ejemplo:**

```python
from fastapi import Depends, HTTPException

async def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, "secret_key", algorithms=["HS256"])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Token inválido")
        return {"username": username}
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Token inválido")

@app.get("/users/me")
async def read_users_me(current_user: dict = Depends(get_current_user)):
    return current_user
```

**Descripción del ejemplo:**  
Este código muestra cómo verificar un token JWT en cada solicitud y extraer el nombre de usuario para autorizar el acceso a un endpoint protegido.

---

## E - Expiración de Tokens

**Definición:**  
Los tokens JWT pueden tener una fecha de expiración (`exp`), lo que limita su validez. Después de la expiración, el token ya no es válido y el usuario debe autenticarse nuevamente para obtener un nuevo token.

**Ejemplo:**

```python
from datetime import datetime, timedelta

def create_access_token(data: dict, expires_delta: timedelta = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, "secret_key", algorithm="HS256")
```

**Descripción del ejemplo:**  
Este código muestra cómo agregar una fecha de expiración a un token JWT. Si no se proporciona un `expires_delta`, el token expirará en 15 minutos.

---

## F - Scopes en OAuth2

**Definición:**  
Los "scopes" (alcances) en OAuth2 son permisos específicos que se pueden asignar a un token JWT. Estos permiten restringir lo que un usuario o aplicación puede hacer con la API.

**Ejemplo:**

```python
from fastapi.security import OAuth2PasswordBearer, SecurityScopes

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token", scopes={"read": "Leer datos", "write": "Escribir datos"})

async def get_current_user(security_scopes: SecurityScopes, token: str = Depends(oauth2_scheme)):
    if security_scopes.scopes:
        authenticate_value = f'Bearer scope="{security_scopes.scope_str}"'
    else:
        authenticate_value = "Bearer"
    # Verificar scopes y devolver usuario
```

**Descripción del ejemplo:**  
Este código muestra cómo definir y verificar scopes en un token JWT para controlar el acceso a diferentes partes de la API.

---

## G - Instalación de Dependencias

**Definición:**  
Para trabajar con JWT y hashing de contraseñas en Python, es necesario instalar las bibliotecas `PyJWT` y `passlib`.

**Ejemplo:**

```bash
pip install pyjwt passlib[bcrypt]
```

**Descripción del ejemplo:**  
Este comando instala las bibliotecas necesarias para generar y verificar tokens JWT, así como para hashear y verificar contraseñas.

---

## H - Uso de `Annotated` en FastAPI

**Definición:**  
`Annotated` es una forma moderna de definir dependencias en FastAPI, permitiendo una sintaxis más clara y flexible.

**Ejemplo:**

```python
from typing import Annotated
from fastapi import Depends

async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    # Lógica para obtener el usuario
    return {"username": "johndoe"}
```

**Descripción del ejemplo:**  
Este código muestra cómo usar `Annotated` para definir dependencias en FastAPI de manera más legible.

---

## I - Manejo de Errores en Autenticación

**Definición:**  
Es importante manejar errores como tokens inválidos o expirados, y devolver respuestas HTTP adecuadas (como 401 Unauthorized).

**Ejemplo:**

```python
from fastapi import HTTPException

async def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        payload = jwt.decode(token, "secret_key", algorithms=["HS256"])
        username: str = payload.get("sub")
        if username is None:
            raise HTTPException(status_code=401, detail="Token inválido")
        return {"username": username}
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expirado")
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Token inválido")
```

**Descripción del ejemplo:**  
Este código muestra cómo manejar errores comunes relacionados con la autenticación JWT.

---

## J - Integración con Bases de Datos

**Definición:**  
En una aplicación real, los usuarios y sus contraseñas hasheadas se almacenan en una base de datos. FastAPI no impone ninguna base de datos específica, por lo que puedes usar cualquier sistema de base de datos.

**Ejemplo:**

```python
from sqlalchemy.orm import Session

def get_user(db: Session, username: str):
    return db.query(User).filter(User.username == username).first()

def authenticate_user(db: Session, username: str, password: str):
    user = get_user(db, username)
    if not user or not pwd_context.verify(password, user.hashed_password):
        return False
    return user
```

**Descripción del ejemplo:**  
Este código muestra cómo integrar la autenticación con una base de datos utilizando SQLAlchemy.
