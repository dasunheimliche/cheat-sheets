## A - Additional Responses con Modelo Pydantic

**Definición:** Es una característica de FastAPI que permite declarar múltiples tipos de respuestas posibles para un endpoint, cada una con su propio código de estado HTTP, modelo de datos y descripción. Esto se hace mediante el parámetro responses en el decorador de la ruta.

**Ejemplo:**

```python

from fastapi import FastAPI, HTTPException
from fastapi.responses import JSONResponse
from pydantic import BaseModel
from typing import Optional

# Modelos de datos para diferentes respuestas
class Item(BaseModel):
    id: str
    name: str
    description: Optional[str] = None
    price: float

class ErrorMessage(BaseModel):
    message: str
    error_code: str
    details: Optional[dict] = None

class SuccessMessage(BaseModel):
    message: str
    item_id: str

app = FastAPI()

@app.get(
    "/items/{item_id}",
    response_model=Item,  # Respuesta principal
    responses={
        404: {"model": ErrorMessage, "description": "Item no encontrado"},
        400: {"model": ErrorMessage, "description": "Solicitud inválida"},
        201: {"model": SuccessMessage, "description": "Item creado exitosamente"}
    }
)
async def get_item(item_id: str):
    # Simulamos búsqueda en base de datos
    if item_id == "not_found":
        return JSONResponse(
            status_code=404,
            content={
                "message": "Item no encontrado",
                "error_code": "ITEM_NOT_FOUND",
                "details": {"searched_id": item_id}
            }
        )

    if item_id == "invalid":
        return JSONResponse(
            status_code=400,
            content={
                "message": "ID de item inválido",
                "error_code": "INVALID_ID",
                "details": {"reason": "El ID debe ser alfanumérico"}
            }
        )

    # Caso exitoso
    return {
        "id": item_id,
        "name": "Ejemplo Item",
        "description": "Este es un item de ejemplo",
        "price": 29.99
    }
```

(Este ejemplo muestra cómo definir múltiples respuestas posibles con diferentes modelos Pydantic. La documentación OpenAPI generada incluirá todos estos modelos y sus esquemas JSON correspondientes. Cada respuesta está tipada y validada.)

## B - Additional Media Types Response

**Definición:** Permite que un mismo endpoint pueda responder con diferentes tipos de contenido (Content-Type), como JSON, imágenes, archivos PDF, etc. Esto se logra especificando los diferentes tipos de medios en el parámetro responses y utilizando las clases de respuesta apropiadas.
**Ejemplo:**

```python

from fastapi import FastAPI, Header
from fastapi.responses import JSONResponse, FileResponse, HTMLResponse
from pydantic import BaseModel
from typing import Union, Optional

class ProductData(BaseModel):
    id: str
    name: str
    price: float
    image_url: str

app = FastAPI()

@app.get(
    "/products/{product_id}",
    response_model=ProductData,
    responses={
        200: {
            "content": {
                "application/json": {
                    "example": {
                        "id": "123",
                        "name": "Laptop",
                        "price": 999.99,
                        "image_url": "/images/laptop.png"
                    }
                },
                "image/png": {},
                "text/html": {},
            },
            "description": "Retorna la información del producto en el formato solicitado"
        }
    }
)
async def get_product(
    product_id: str,
    accept: Optional[str] = Header(None),
    format: Optional[str] = None
):
    # Datos base del producto
    product = {
        "id": product_id,
        "name": "Laptop Pro",
        "price": 999.99,
        "image_url": "/images/laptop.png"
    }

    # Determinar formato de respuesta
    if format == "image" or accept == "image/png":
        return FileResponse(
            "product_image.png",
            media_type="image/png",
            filename=f"product_{product_id}.png"
        )

    if format == "html" or accept == "text/html":
        html_content = f"""
        <html>
            <head><title>Producto {product_id}</title></head>
            <body>
                <h1>{product['name']}</h1>
                <p>Precio: ${product['price']}</p>
                <img src="{product['image_url']}" alt="{product['name']}">
            </body>
        </html>
        """
        return HTMLResponse(content=html_content)

    # Por defecto, retorna JSON
    return JSONResponse(content=product)
```

(Este ejemplo muestra cómo un mismo endpoint puede devolver diferentes tipos de contenido basado en el encabezado Accept o un parámetro de consulta. La documentación OpenAPI generada mostrará todos los tipos de contenido posibles.)

## C - Combining Response Information

**Definición:** Permite combinar diferentes aspectos de la respuesta como el modelo principal, códigos de estado, ejemplos, descripciones y esquemas adicionales en una única definición de ruta. Esto crea una documentación más rica y precisa de las posibles respuestas del endpoint.

**Ejemplo:**

```python

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime

class OrderItem(BaseModel):
    product_id: str
    quantity: int
    unit_price: float

class Order(BaseModel):
    id: str
    items: List[OrderItem]
    total: float
    status: str
    created_at: datetime

class OrderError(BaseModel):
    error_code: str
    message: str
    details: Optional[dict] = None

app = FastAPI()

@app.get(
    "/orders/{order_id}",
    response_model=Order,  # Modelo principal para respuesta exitosa
    responses={
        200: {
            "description": "Orden recuperada exitosamente",
            "content": {
                "application/json": {
                    "example": {
                        "id": "ord_123",
                        "items": [
                            {
                                "product_id": "prod_1",
                                "quantity": 2,
                                "unit_price": 29.99
                            }
                        ],
                        "total": 59.98,
                        "status": "completed",
                        "created_at": "2024-01-01T12:00:00Z"
                    }
                }
            }
        },
        404: {
            "model": OrderError,
            "description": "Orden no encontrada",
            "content": {
                "application/json": {
                    "example": {
                        "error_code": "ORDER_NOT_FOUND",
                        "message": "La orden especificada no existe",
                        "details": {"order_id": "ord_123"}
                    }
                }
            }
        },
        400: {
            "model": OrderError,
            "description": "Solicitud inválida",
            "headers": {
                "X-Error-Code": {
                    "description": "Código de error específico",
                    "schema": {"type": "string"}
                }
            }
        }
    }
)
async def get_order(order_id: str):
    if not order_id.startswith("ord_"):
        raise HTTPException(
            status_code=400,
            detail={
                "error_code": "INVALID_ORDER_ID",
                "message": "ID de orden inválido",
                "details": {"format_expected": "ord_XXXXX"}
            }
        )

    # Simular búsqueda de orden
    if order_id == "ord_404":
        raise HTTPException(
            status_code=404,
            detail={
                "error_code": "ORDER_NOT_FOUND",
                "message": "Orden no encontrada",
                "details": {"order_id": order_id}
            }
        )

    # Retornar orden de ejemplo
    return {
        "id": order_id,
        "items": [
            {
                "product_id": "prod_1",
                "quantity": 2,
                "unit_price": 29.99
            }
        ],
        "total": 59.98,
        "status": "completed",
        "created_at": datetime.now()
    }
```

(Este ejemplo muestra cómo combinar múltiples aspectos de las respuestas, incluyendo modelos, ejemplos, encabezados personalizados y descripciones detalladas.)

## D - Reusable Responses

**Definición:** Permite definir respuestas comunes que pueden ser reutilizadas en múltiples endpoints, manteniendo la capacidad de agregar respuestas específicas para cada ruta. Esto se logra mediante el uso del operador de desempaquetado (**) de Python y la definición de diccionarios de respuestas reutilizables.
**Ejemplo:\*\*

```python

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import Dict, Any
from fastapi.responses import JSONResponse, FileResponse

# Modelos base
class BaseError(BaseModel):
    error_code: str
    message: str
    details: Dict[str, Any] = {}

# Respuestas comunes reutilizables
common_responses = {
    400: {
        "model": BaseError,
        "description": "Error de validación o solicitud inválida",
        "content": {
            "application/json": {
                "example": {
                    "error_code": "VALIDATION_ERROR",
                    "message": "Error en los datos proporcionados",
                    "details": {"field": "username", "error": "required"}
                }
            }
        }
    },
    401: {
        "model": BaseError,
        "description": "No autenticado",
        "content": {
            "application/json": {
                "example": {
                    "error_code": "UNAUTHORIZED",
                    "message": "Autenticación requerida",
                    "details": {"missing": "Bearer token"}
                }
            }
        }
    },
    403: {
        "model": BaseError,
        "description": "No autorizado",
        "content": {
            "application/json": {
                "example": {
                    "error_code": "FORBIDDEN",
                    "message": "No tiene permisos suficientes",
                    "details": {"required_role": "admin"}
                }
            }
        }
    }
}

# Respuestas específicas para operaciones con archivos
file_responses = {
    **common_responses,  # Incluye todas las respuestas comunes
    415: {
        "model": BaseError,
        "description": "Tipo de archivo no soportado",
        "content": {
            "application/json": {
                "example": {
                    "error_code": "UNSUPPORTED_MEDIA_TYPE",
                    "message": "Formato de archivo no soportado",
                    "details": {
                        "supported_types": ["image/jpeg", "image/png"],
                        "provided_type": "image/gif"
                    }
                }
            }
        }
    }
}

app = FastAPI()

@app.post(
    "/users/{user_id}/avatar",
    responses={
        **file_responses,  # Incluye respuestas comunes y de archivos
        200: {
            "content": {
                "application/json": {
                    "example": {
                        "message": "Avatar actualizado",
                        "avatar_url": "/avatars/123.png"
                    }
                }
            },
            "description": "Avatar actualizado exitosamente"
        }
    }
)
async def update_avatar(user_id: str):
    # Simulación de diferentes escenarios de error
    if user_id == "unauthorized":
        return JSONResponse(
            status_code=401,
            content={
                "error_code": "UNAUTHORIZED",
                "message": "Token no proporcionado",
                "details": {"required": "Bearer token"}
            }
        )

    if user_id == "forbidden":
        return JSONResponse(
            status_code=403,
            content={
                "error_code": "FORBIDDEN",
                "message": "No tiene permisos para este usuario",
                "details": {"required_role": "admin"}
            }
        )

    # Caso exitoso
    return {
        "message": "Avatar actualizado",
        "avatar_url": f"/avatars/{user_id}.png"
    }

# Otro endpoint que reutiliza las respuestas comunes
@app.post(
    "/users/{user_id}/documents",
    responses={
        **file_responses,  # Reutiliza las mismas respuestas
        201: {
            "description": "Documento subido exitosamente",
            "content": {
                "application/json": {
                    "example": {
                        "document_id": "doc_123",
                        "url": "/documents/123.pdf"
                    }
                }
            }
        }
    }
)
async def upload_document(user_id: str):
    # Lógica similar al endpoint anterior
    pass
```

(Este ejemplo muestra cómo crear y reutilizar respuestas comunes en múltiples endpoints, mientras se mantiene la flexibilidad para agregar respuestas específicas. También demuestra cómo organizar y estructurar las respuestas para mantener el código DRY (Don't Repeat Yourself).)
