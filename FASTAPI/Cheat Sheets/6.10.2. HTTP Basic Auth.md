## A - Configuración Básica de HTTP Basic Auth

**Definición:** Es un sistema de autenticación simple que requiere un username y password enviados en el header HTTP, retornando un error 401 si no son proporcionados.

**Ejemplo:**

```python

from fastapi import Depends, FastAPI
from fastapi.security import HTTPBasic, HTTPBasicCredentials

app = FastAPI()
security = HTTPBasic()

@app.get("/users/me")
def read_user(credentials: Annotated[HTTPBasicCredentials, Depends(security)]):
    return {
        "username": credentials.username,
        "password": credentials.password
    }
```

(Muestra la configuración básica para autenticación HTTP Basic)

## B - Validación Segura de Credenciales

**Definición:** La validación de credenciales debe realizarse usando secrets.compare_digest() para prevenir ataques de temporización (timing attacks).

**Ejemplo:**

```python

import secrets
from fastapi import HTTPException, status

def validate_credentials(
    credentials: HTTPBasicCredentials,
    correct_username: str,
    correct_password: str
):
    current_username_bytes = credentials.username.encode("utf8")
    correct_username_bytes = correct_username.encode("utf8")

    current_password_bytes = credentials.password.encode("utf8")
    correct_password_bytes = correct_password.encode("utf8")

    is_correct_username = secrets.compare_digest(
        current_username_bytes, correct_username_bytes
    )
    is_correct_password = secrets.compare_digest(
        current_password_bytes, correct_password_bytes
    )

    if not (is_correct_username and is_correct_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Credenciales incorrectas",
            headers={"WWW-Authenticate": "Basic"},
        )
    return True
```

(Demuestra la validación segura de credenciales contra timing attacks)

## C - Manejo de Errores HTTP Basic

**Definición:** Se debe devolver un error 401 con el header WWW-Authenticate para que el navegador muestre el prompt de login.

**Ejemplo:**

```python

def handle_auth_error(realm: str = "Acceso restringido"):
    return HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Autenticación requerida",
        headers={
            "WWW-Authenticate": f'Basic realm="{realm}"'
        }
    )

@app.get("/protected")
async def protected_route(
    credentials: Annotated[HTTPBasicCredentials, Depends(security)]
):
    try:
        # Intenta validar credenciales
        if not credentials:
            raise handle_auth_error()
        return {"message": "Acceso permitido"}
    except:
        raise handle_auth_error()
```

(Ilustra el manejo correcto de errores en autenticación básica)

## D - Dependencia de Autenticación Completa

**Definición:** Una implementación completa combina la validación segura con el manejo de errores en una dependencia reutilizable.

**Ejemplo:**

```python

def get_current_user(
    credentials: Annotated[HTTPBasicCredentials, Depends(security)]
):
    # Simula base de datos de usuarios
    users_db = {
        "admin": {
            "username": "admin",
            "password": "secreto",
            "role": "admin"
        }
    }

    try:
        user = users_db[credentials.username]
        is_valid = validate_credentials(
            credentials,
            user["username"],
            user["password"]
        )
        if is_valid:
            return user
    except KeyError:
        raise handle_auth_error()

@app.get("/admin")
async def admin_route(
    user: Annotated[dict, Depends(get_current_user)]
):
    if user["role"] != "admin":
        raise HTTPException(status_code=403, detail="Acceso denegado")
    return {"message": "Panel de administración"}
```

(Muestra una implementación completa con validación y roles)
