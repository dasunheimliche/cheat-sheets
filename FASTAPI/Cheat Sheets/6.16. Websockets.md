## A - WebSockets en FastAPI

**Definición:**  
WebSockets es un protocolo de comunicación que permite una conexión bidireccional y persistente entre un cliente (como un navegador) y un servidor. A diferencia de HTTP, que es unidireccional, WebSockets permite enviar y recibir datos en tiempo real sin necesidad de recargar la página. FastAPI soporta WebSockets de manera nativa.

**Ejemplo básico:**

```python
from fastapi import FastAPI, WebSocket
from fastapi.responses import HTMLResponse

app = FastAPI()

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Message text was: {data}")
```

**Descripción del ejemplo:**

1.  Se define una ruta WebSocket en `/ws`.
2.  El servidor acepta la conexión con `await websocket.accept()`.
3.  En un bucle infinito, el servidor recibe mensajes del cliente con `await websocket.receive_text()` y responde con `await websocket.send_text()`.

---

## B - Instalación de dependencias

**Definición:**  
Para usar WebSockets en FastAPI, necesitas instalar la librería `websockets`. Esto se hace con `pip`. Es recomendable trabajar en un entorno virtual para evitar conflictos de dependencias.

**Ejemplo:**

```bash
pip install websockets
```

**Descripción del ejemplo:**  
Este comando instala la librería `websockets`, que es necesaria para manejar conexiones WebSocket en FastAPI.

---

## C - Cliente WebSocket

**Definición:**  
Un cliente WebSocket es cualquier aplicación que se conecta a un servidor WebSocket. En producción, esto podría ser un frontend hecho con React, Vue.js, Angular, o incluso una aplicación móvil. Para propósitos de prueba, puedes usar un simple HTML con JavaScript.

**Ejemplo de cliente HTML:**

```html
<!DOCTYPE html>
<html>
  <head>
    <title>WebSocket Chat</title>
  </head>
  <body>
    <h1>WebSocket Chat</h1>
    <form onsubmit="sendMessage(event)">
      <input type="text" id="messageText" autocomplete="off" />
      <button>Send</button>
    </form>
    <ul id="messages"></ul>
    <script>
      var ws = new WebSocket("ws://localhost:8000/ws");
      ws.onmessage = function (event) {
        var messages = document.getElementById("messages");
        var message = document.createElement("li");
        message.textContent = event.data;
        messages.appendChild(message);
      };
      function sendMessage(event) {
        var input = document.getElementById("messageText");
        ws.send(input.value);
        input.value = "";
        event.preventDefault();
      }
    </script>
  </body>
</html>
```

**Descripción del ejemplo:**

1.  Se crea una conexión WebSocket con `new WebSocket("ws://localhost:8000/ws")`.
2.  Cuando se recibe un mensaje (`onmessage`), se muestra en una lista (`<ul>`).
3.  El formulario envía mensajes al servidor con `ws.send()`.

---

## D - Manejo de mensajes y respuestas

**Definición:**  
En una ruta WebSocket, puedes recibir y enviar mensajes de forma asíncrona. FastAPI permite manejar texto, binario y JSON.

**Ejemplo:**

```python
@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Message text was: {data}")
```

**Descripción del ejemplo:**

1.  El servidor acepta la conexión con `await websocket.accept()`.
2.  En un bucle, recibe mensajes de texto con `await websocket.receive_text()`.
3.  Responde al cliente con `await websocket.send_text()`.

---

## E - Uso de dependencias en WebSockets

**Definición:**  
Puedes usar dependencias como `Depends`, `Cookie`, `Header`, `Query`, etc., en rutas WebSocket, de la misma manera que en rutas HTTP. Esto es útil para validar tokens, cookies, o parámetros de consulta.

**Ejemplo con dependencias:**

```python
from fastapi import WebSocket, Cookie, Query, WebSocketException, status

async def get_cookie_or_token(
    websocket: WebSocket,
    session: str | None = Cookie(default=None),
    token: str | None = Query(default=None),
):
    if session is None and token is None:
        raise WebSocketException(code=status.WS_1008_POLICY_VIOLATION)
    return session or token

@app.websocket("/items/{item_id}/ws")
async def websocket_endpoint(
    websocket: WebSocket,
    item_id: str,
    cookie_or_token: str = Depends(get_cookie_or_token),
):
    await websocket.accept()
    while True:
        data = await websocket.receive_text()
        await websocket.send_text(f"Session or token: {cookie_or_token}")
```

**Descripción del ejemplo:**

1.  Se define una dependencia `get_cookie_or_token` que valida si hay una cookie o un token.
2.  Si no hay ninguno, se lanza una excepción `WebSocketException`.
3.  La dependencia se usa en la ruta WebSocket para validar la conexión.

---

## F - Manejo de desconexiones

**Definición:**  
Cuando un cliente se desconecta, se lanza una excepción `WebSocketDisconnect`. Puedes capturar esta excepción para manejar la desconexión de manera adecuada, como notificar a otros clientes.

**Ejemplo:**

```python
from fastapi import WebSocketDisconnect

@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: int):
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            await manager.send_personal_message(f"You wrote: {data}", websocket)
            await manager.broadcast(f"Client #{client_id} says: {data}")
    except WebSocketDisconnect:
        manager.disconnect(websocket)
        await manager.broadcast(f"Client #{client_id} left the chat")
```

**Descripción del ejemplo:**

1.  Se captura la excepción `WebSocketDisconnect` cuando un cliente se desconecta.
2.  Se notifica a los demás clientes que un usuario ha abandonado el chat.

---

## G - Conexiones múltiples y broadcasting

**Definición:**  
Puedes manejar múltiples conexiones WebSocket y enviar mensajes a todos los clientes conectados (broadcasting). Esto es útil para aplicaciones como chats en tiempo real.

**Ejemplo:**

```python
class ConnectionManager:
    def __init__(self):
        self.active_connections: list[WebSocket] = []

    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)

    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)

    async def broadcast(self, message: str):
        for connection in self.active_connections:
            await connection.send_text(message)

manager = ConnectionManager()

@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: int):
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            await manager.broadcast(f"Client #{client_id} says: {data}")
    except WebSocketDisconnect:
        manager.disconnect(websocket)
        await manager.broadcast(f"Client #{client_id} left the chat")
```

**Descripción del ejemplo:**

1.  Se crea una clase `ConnectionManager` para manejar conexiones activas.
2.  Se usa `broadcast` para enviar mensajes a todos los clientes conectados.
3.  Cuando un cliente se desconecta, se notifica a los demás.
