## A - Uso de `dataclasses` en FastAPI

**Definición:**  
FastAPI permite el uso de `dataclasses` de Python para definir modelos de datos, además de los modelos Pydantic. Estas `dataclasses` son compatibles con FastAPI gracias a la integración interna de Pydantic, lo que permite validación, serialización y documentación automática, similar a los modelos Pydantic.

**Ejemplo:**

```python
from dataclasses import dataclass
from typing import Union
from fastapi import FastAPI

@dataclass
class Item:
    name: str
    price: float
    description: Union[str, None] = None
    tax: Union[float, None] = None

app = FastAPI()

@app.post("/items/")
async def create_item(item: Item):
    return item
```

**Descripción del ejemplo:**  
Este código define una `dataclass` llamada `Item` con campos como `name`, `price`, `description` y `tax`. Luego, se usa esta `dataclass` como parámetro en una ruta POST `/items/`. FastAPI valida y convierte automáticamente los datos de la solicitud en una instancia de `Item`.

---

## B - `dataclasses` en `response_model`

**Definición:**  
Puedes usar `dataclasses` en el parámetro `response_model` de las rutas de FastAPI. Esto permite que FastAPI genere automáticamente la documentación de la API y valide las respuestas.

**Ejemplo:**

```python
from dataclasses import dataclass, field
from typing import List, Union
from fastapi import FastAPI

@dataclass
class Item:
    name: str
    price: float
    tags: List[str] = field(default_factory=list)
    description: Union[str, None] = None
    tax: Union[float, None] = None

app = FastAPI()

@app.get("/items/next", response_model=Item)
async def read_next_item():
    return {
        "name": "Island In The Moon",
        "price": 12.99,
        "description": "A place to be playin' and havin' fun",
        "tags": ["breater"],
    }
```

**Descripción del ejemplo:**  
Este código define una ruta GET `/items/next` que devuelve un objeto `Item`. El esquema de la `dataclass` se muestra en la documentación de la API generada automáticamente.

---

## C - `dataclasses` en estructuras de datos anidadas

**Definición:**  
Puedes combinar `dataclasses` con otras anotaciones de tipo para crear estructuras de datos anidadas. En algunos casos, es posible que necesites usar `pydantic.dataclasses` en lugar de las `dataclasses` estándar para evitar problemas con la documentación automática.

**Ejemplo:**

```python
from dataclasses import field
from typing import List, Union
from fastapi import FastAPI
from pydantic.dataclasses import dataclass

@dataclass
class Item:
    name: str
    description: Union[str, None] = None

@dataclass
class Author:
    name: str
    items: List[Item] = field(default_factory=list)

app = FastAPI()

@app.post("/authors/{author_id}/items/", response_model=Author)
async def create_author_items(author_id: str, items: List[Item]):
    return {"name": author_id, "items": items}

@app.get("/authors/", response_model=List[Author])
def get_authors():
    return [
        {
            "name": "Breaters",
            "items": [
                {
                    "name": "Island In The Moon",
                    "description": "A place to be playin' and havin' fun",
                },
                {"name": "Holy Buddies"},
            ],
        },
        {
            "name": "System of an Up",
            "items": [
                {
                    "name": "Salt",
                    "description": "The kombucha mushroom people's favorite",
                },
                {"name": "Pad Thai"},
                {
                    "name": "Lonely Night",
                    "description": "The mostests lonliest nightiest of allest",
                },
            ],
        },
    ]
```

**Descripción del ejemplo:**  
Este código define dos `dataclasses`: `Item` y `Author`. La clase `Author` contiene una lista de objetos `Item`. Se usan en rutas POST y GET para manejar datos anidados. FastAPI convierte automáticamente las respuestas a JSON y genera la documentación correspondiente.

---

## D - Limitaciones de `dataclasses`

**Definición:**  
Aunque las `dataclasses` son útiles, no tienen todas las funcionalidades de los modelos Pydantic. Por ejemplo, no admiten validaciones personalizadas avanzadas. Si necesitas más control, es recomendable usar modelos Pydantic.

**Ejemplo:**

```python
from pydantic import BaseModel, validator

class Item(BaseModel):
    name: str
    price: float

    @validator("price")
    def price_must_be_positive(cls, value):
        if value <= 0:
            raise ValueError("Price must be positive")
        return value
```

**Descripción del ejemplo:**  
Este código define un modelo Pydantic `Item` con una validación personalizada para asegurarse de que el precio sea positivo. Esto no es posible con `dataclasses` estándar.

---

## E - Combinación de `dataclasses` y modelos Pydantic

**Definición:**  
Puedes combinar `dataclasses` con modelos Pydantic para aprovechar lo mejor de ambos. Por ejemplo, puedes usar `dataclasses` para estructuras simples y modelos Pydantic para validaciones complejas.

**Ejemplo:**

```python
from dataclasses import dataclass
from pydantic import BaseModel

@dataclass
class Item:
    name: str
    price: float

class DetailedItem(BaseModel):
    item: Item
    description: str
```

**Descripción del ejemplo:**  
Este código combina una `dataclass` `Item` con un modelo Pydantic `DetailedItem`. Esto permite estructuras de datos flexibles y validaciones avanzadas.
