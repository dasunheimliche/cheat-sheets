## A - Obtener el usuario actual

**Definición:**  
En aplicaciones con autenticación, es común necesitar obtener la información del usuario actual en los endpoints. FastAPI permite hacer esto utilizando dependencias y el sistema de inyección de dependencias. Se puede crear una dependencia que decodifique un token y devuelva un modelo de usuario.

**Ejemplo:**

```python
from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer
from pydantic import BaseModel

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None

def fake_decode_token(token: str):
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

async def get_current_user(token: str = Depends(oauth2_scheme)):
    user = fake_decode_token(token)
    return user

@app.get("/users/me")
async def read_users_me(current_user: User = Depends(get_current_user)):
    return current_user
```

**Descripción del ejemplo:**  
Este código define un modelo `User` y una función `fake_decode_token` que simula la decodificación de un token. La dependencia `get_current_user` obtiene el token y devuelve un objeto `User`. Finalmente, el endpoint `/users/me` utiliza esta dependencia para devolver el usuario actual.

---

## B - Dependencias anidadas

**Definición:**  
Las dependencias en FastAPI pueden tener subdependencias. En este caso, `get_current_user` depende de `oauth2_scheme`, que obtiene el token del encabezado `Authorization`. Esto permite modularizar y reutilizar la lógica de autenticación.

**Ejemplo:**

```python
async def get_current_user(token: str = Depends(oauth2_scheme)):
    user = fake_decode_token(token)
    return user
```

**Descripción del ejemplo:**  
La función `get_current_user` depende de `oauth2_scheme`, que es responsable de extraer el token del encabezado de la solicitud. Esto permite separar la lógica de obtención del token de la lógica de decodificación.

---

## C - Uso de `Annotated` (Python 3.9+)

**Definición:**  
`Annotated` es una forma moderna de definir dependencias en FastAPI. Proporciona una sintaxis más clara y es preferible en Python 3.9 y versiones posteriores.

**Ejemplo:**

```python
from typing import Annotated
from fastapi import Depends, FastAPI
from fastapi.security import OAuth2PasswordBearer
from pydantic import BaseModel

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None

def fake_decode_token(token: str):
    return User(
        username=token + "fakedecoded", email="john@example.com", full_name="John Doe"
    )

async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]):
    user = fake_decode_token(token)
    return user

@app.get("/users/me")
async def read_users_me(current_user: Annotated[User, Depends(get_current_user)]):
    return current_user
```

**Descripción del ejemplo:**  
Este código es equivalente al anterior, pero usa `Annotated` para definir las dependencias de manera más explícita.

---

## D - Flexibilidad en los modelos de usuario

**Definición:**  
FastAPI no restringe el tipo de modelo que puedes usar para representar al usuario. Puedes usar un modelo Pydantic, un diccionario, una cadena, o incluso una instancia de un modelo de base de datos. Esto permite adaptar la autenticación a las necesidades específicas de tu aplicación.

**Ejemplo:**

```python
class User(BaseModel):
    id: int
    email: str
    is_active: bool

async def get_current_user(token: str = Depends(oauth2_scheme)):
    # Lógica para obtener el usuario desde una base de datos
    user = get_user_from_db(token)
    return user
```

**Descripción del ejemplo:**  
En este ejemplo, el modelo `User` incluye un `id` y `email`, y la función `get_current_user` obtiene el usuario desde una base de datos.

---

## E - Reutilización de dependencias

**Definición:**  
Una de las ventajas de FastAPI es que las dependencias se pueden escribir una vez y reutilizar en múltiples endpoints. Esto reduce la duplicación de código y facilita el mantenimiento.

**Ejemplo:**

```python
@app.get("/users/me")
async def read_users_me(current_user: User = Depends(get_current_user)):
    return current_user

@app.get("/items/")
async def read_items(current_user: User = Depends(get_current_user)):
    return {"user": current_user, "items": ["item1", "item2"]}
```

**Descripción del ejemplo:**  
Aquí, la dependencia `get_current_user` se reutiliza en dos endpoints diferentes, lo que demuestra la potencia del sistema de dependencias de FastAPI.

---

## F - Manejo de errores automático

**Definición:**  
Si el token no es válido o no está presente, FastAPI automáticamente devuelve un error HTTP 401 (`UNAUTHORIZED`). No es necesario verificar manualmente la validez del token en cada endpoint.

**Ejemplo de error:**

```json
{
  "detail": "Not authenticated"
}
```

---

## G - Resumen

**Definición:**  
FastAPI facilita la obtención del usuario actual mediante el uso de dependencias y el sistema de inyección de dependencias. Esto permite separar la lógica de autenticación de la lógica de los endpoints, haciendo el código más modular y fácil de mantener.
