## A - Dependencias Parametrizadas Básicas

**Definición:** Permite crear dependencias que pueden ser configuradas mediante parámetros al momento de su instanciación, usando clases con el método **call**.

**Ejemplo:**

```python

from fastapi import FastAPI, Depends
from typing import Optional

class QueryValidator:
    def __init__(self, min_length: int, required_prefix: str):
        self.min_length = min_length
        self.required_prefix = required_prefix

    def __call__(self, q: Optional[str] = None):
        if not q:
            return False

        return (
            len(q) >= self.min_length and
            q.startswith(self.required_prefix)
        )

app = FastAPI()

# Crear instancias con diferentes configuraciones
search_validator = QueryValidator(min_length=3, required_prefix="search:")
filter_validator = QueryValidator(min_length=5, required_prefix="filter:")

@app.get("/search")
async def search_endpoint(
    is_valid: bool = Depends(search_validator)
):
    return {"is_valid_search": is_valid}

@app.get("/filter")
async def filter_endpoint(
    is_valid: bool = Depends(filter_validator)
):
    return {"is_valid_filter": is_valid}
```

(Este ejemplo muestra cómo crear una dependencia parametrizable para validar queries con diferentes criterios.)

## B - Dependencias Parametrizadas con Estado

**Definición:** Permite crear dependencias que mantienen estado y pueden ser configuradas, útil para manejo de cache, rate limiting, o tracking.

**Ejemplo:**

```python

from fastapi import FastAPI, Depends, HTTPException, Request
from typing import Dict, Optional
import time

class RateLimiter:
    def __init__(
        self,
        requests_per_minute: int,
        burst_size: Optional[int] = None
    ):
        self.requests_per_minute = requests_per_minute
        self.burst_size = burst_size or requests_per_minute
        self.requests: Dict[str, list] = {}

    def _clean_old_requests(self, client_id: str):
        """Limpia requests antiguos"""
        current_time = time.time()
        self.requests[client_id] = [
            req_time for req_time in self.requests[client_id]
            if current_time - req_time < 60
        ]

    async def __call__(self, request: Request):
        client_id = request.client.host
        current_time = time.time()

        # Inicializar registro para nuevo cliente
        if client_id not in self.requests:
            self.requests[client_id] = []

        # Limpiar requests antiguos
        self._clean_old_requests(client_id)

        # Verificar límites
        if len(self.requests[client_id]) >= self.burst_size:
            raise HTTPException(
                status_code=429,
                detail="Too many requests"
            )

        # Registrar nuevo request
        self.requests[client_id].append(current_time)

        # Retornar información útil
        return {
            "requests_remaining": self.burst_size - len(self.requests[client_id]),
            "client_id": client_id
        }

app = FastAPI()

# Crear diferentes limitadores
api_limiter = RateLimiter(requests_per_minute=60)  # 60 rpm
admin_limiter = RateLimiter(
    requests_per_minute=1000,  # 1000 rpm
    burst_size=100  # Pero máximo 100 simultáneos
)

@app.get("/api/public")
async def public_api(
    rate_info: dict = Depends(api_limiter)
):
    return {
        "message": "Public API",
        "rate_info": rate_info
    }

@app.get("/api/admin")
async def admin_api(
    rate_info: dict = Depends(admin_limiter)
):
    return {
        "message": "Admin API",
        "rate_info": rate_info
    }
```

(Este ejemplo muestra una implementación de rate limiting usando dependencias parametrizadas con estado.)

## C - Dependencias Parametrizadas Anidadas

**Definición:** Permite crear dependencias que dependen de otras dependencias y pueden ser configuradas.

**Ejemplo:**

```python

from fastapi import FastAPI, Depends, Header, HTTPException
from typing import Optional, List
import jwt

class SecurityValidator:
    def __init__(
        self,
        required_scopes: List[str],
        secret_key: str
    ):
        self.required_scopes = required_scopes
        self.secret_key = secret_key

    async def verify_token(
        self,
        authorization: Optional[str] = Header(None)
    ) -> dict:
        """Sub-dependencia para verificar token"""
        if not authorization:
            raise HTTPException(
                status_code=401,
                detail="No authorization token provided"
            )

        try:
            payload = jwt.decode(
                authorization,
                self.secret_key,
                algorithms=["HS256"]
            )
            return payload
        except jwt.InvalidTokenError:
            raise HTTPException(
                status_code=401,
                detail="Invalid token"
            )

    async def __call__(
        self,
        token_data: dict = Depends(verify_token)
    ):
        # Verificar scopes
        token_scopes = token_data.get("scopes", [])

        for required_scope in self.required_scopes:
            if required_scope not in token_scopes:
                raise HTTPException(
                    status_code=403,
                    detail=f"Missing required scope: {required_scope}"
                )

        return token_data

app = FastAPI()

# Crear validadores con diferentes configuraciones
read_validator = SecurityValidator(
    required_scopes=["read"],
    secret_key="secret1"
)

admin_validator = SecurityValidator(
    required_scopes=["admin", "write"],
    secret_key="secret2"
)

@app.get("/items/")
async def read_items(
    user: dict = Depends(read_validator)
):
    return {
        "message": "Read items",
        "user": user
    }

@app.post("/items/")
async def create_item(
    user: dict = Depends(admin_validator)
):
    return {
        "message": "Create item",
        "user": user
    }
```

(Este ejemplo muestra cómo crear dependencias anidadas para manejo de autenticación y autorización.)

## D - Dependencias Parametrizadas con Factorías

**Definición:** Utiliza el patrón factoría para crear dependencias parametrizadas más flexibles y reutilizables.

**Ejemplo:**

```python

from fastapi import FastAPI, Depends, HTTPException
from typing import Optional, Callable, TypeVar, Generic
from pydantic import BaseModel

T = TypeVar('T')

class CacheConfig(BaseModel):
    ttl: int
    max_size: int
    namespace: str

class CacheFactory(Generic[T]):
    def __init__(
        self,
        config: CacheConfig,
        loader: Callable[..., T]
    ):
        self.config = config
        self.loader = loader
        self.cache = {}

    def create_dependency(self) -> Callable[..., T]:
        """Crea una nueva dependencia con la configuración actual"""
        async def dependency(key: str) -> T:
            cache_key = f"{self.config.namespace}:{key}"

            # Verificar cache
            if cache_key in self.cache:
                return self.cache[cache_key]

            # Cargar dato
            try:
                data = await self.loader(key)

                # Almacenar en cache
                if len(self.cache) < self.config.max_size:
                    self.cache[cache_key] = data

                return data
            except Exception as e:
                raise HTTPException(
                    status_code=500,
                    detail=f"Error loading data: {str(e)}"
                )

        return dependency

app = FastAPI()

# Simulación de loaders
async def load_user(user_id: str) -> dict:
    return {"id": user_id, "name": f"User {user_id}"}

async def load_product(product_id: str) -> dict:
    return {"id": product_id, "name": f"Product {product_id}"}

# Crear factorías de cache
user_cache = CacheFactory(
    config=CacheConfig(
        ttl=3600,
        max_size=1000,
        namespace="users"
    ),
    loader=load_user
)

product_cache = CacheFactory(
    config=CacheConfig(
        ttl=7200,
        max_size=5000,
        namespace="products"
    ),
    loader=load_product
)

@app.get("/users/{user_id}")
async def get_user(
    user: dict = Depends(user_cache.create_dependency())
):
    return user

@app.get("/products/{product_id}")
async def get_product(
    product: dict = Depends(product_cache.create_dependency())
):
    return product
```

(Este ejemplo muestra cómo usar el patrón factoría para crear dependencias parametrizadas reutilizables para caching.)
