## A - Dependencias parametrizadas

**Definición:**  
En FastAPI, las dependencias suelen ser funciones o clases fijas. Sin embargo, en algunos casos, es útil poder parametrizar una dependencia sin tener que crear múltiples funciones o clases. Esto se logra utilizando una instancia de una clase que sea "llamable" (es decir, que implemente el método `__call__`).

**Ejemplo:**

```python
from typing import Annotated
from fastapi import Depends, FastAPI

app = FastAPI()

class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False

checker = FixedContentQueryChecker("bar")

@app.get("/query-checker/")
async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
    return {"fixed_content_in_query": fixed_content_included}
```

**Descripción del ejemplo:**

1.  Se define una clase `FixedContentQueryChecker` que toma un parámetro `fixed_content` en su constructor (`__init__`).
2.  El método `__call__` permite que una instancia de la clase sea llamada como una función. Aquí, verifica si el parámetro de consulta `q` contiene el contenido fijo (`fixed_content`).
3.  Se crea una instancia de la clase con `fixed_content="bar"`.
4.  La ruta GET (`/query-checker/`) utiliza esta instancia como dependencia (`Depends(checker)`), lo que permite parametrizar la dependencia sin necesidad de crear múltiples funciones.

---

## B - Instancia "llamable" (`__call__`)

**Definición:**  
En Python, una instancia de una clase puede ser "llamable" si la clase implementa el método `__call__`. Esto permite que la instancia se comporte como una función. FastAPI utiliza este método para resolver dependencias y pasar valores a los parámetros de las funciones de operación de ruta.

**Ejemplo:**

```python
class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False
```

**Descripción del ejemplo:**

1.  La clase `FixedContentQueryChecker` tiene un método `__call__` que toma un parámetro `q` (por defecto vacío).
2.  Si `q` no está vacío, el método verifica si `fixed_content` está contenido en `q`.
3.  Este método es lo que FastAPI llama cuando se resuelve la dependencia.

---

## C - Parametrizar la instancia

**Definición:**  
El método `__init__` de una clase se utiliza para inicializar la instancia con parámetros específicos. Esto permite "parametrizar" la dependencia, es decir, configurarla con valores específicos cuando se crea la instancia.

**Ejemplo:**

```python
checker = FixedContentQueryChecker("bar")
```

**Descripción del ejemplo:**

1.  Se crea una instancia de `FixedContentQueryChecker` con `fixed_content="bar"`.
2.  Esta instancia ahora está configurada para buscar la cadena `"bar"` en el parámetro de consulta `q`.

---

## D - Usar la instancia como dependencia

**Definición:**  
Una vez que se ha creado una instancia parametrizada, se puede utilizar como dependencia en una operación de ruta. FastAPI llamará al método `__call__` de la instancia para resolver la dependencia y pasar el resultado a la función de operación de ruta.

**Ejemplo:**

```python
@app.get("/query-checker/")
async def read_query_check(fixed_content_included: Annotated[bool, Depends(checker)]):
    return {"fixed_content_in_query": fixed_content_included}
```

**Descripción del ejemplo:**

1.  La ruta GET (`/query-checker/`) utiliza la instancia `checker` como dependencia.
2.  FastAPI llama a `checker(q="somequery")` para resolver la dependencia.
3.  El resultado (un booleano que indica si `"bar"` está en `q`) se pasa al parámetro `fixed_content_included` de la función.

---

## E - Versiones alternativas (sin `Annotated`)

**Definición:**  
Si no estás utilizando Python 3.9+ o prefieres no usar `Annotated`, puedes declarar dependencias de la manera tradicional, utilizando `Depends` directamente en el parámetro de la función.

**Ejemplo:**

```python
from fastapi import Depends, FastAPI

app = FastAPI()

class FixedContentQueryChecker:
    def __init__(self, fixed_content: str):
        self.fixed_content = fixed_content

    def __call__(self, q: str = ""):
        if q:
            return self.fixed_content in q
        return False

checker = FixedContentQueryChecker("bar")

@app.get("/query-checker/")
async def read_query_check(fixed_content_included: bool = Depends(checker)):
    return {"fixed_content_in_query": fixed_content_included}
```

**Descripción del ejemplo:**

1.  Este ejemplo es similar al anterior, pero no utiliza `Annotated`.
2.  La dependencia se declara directamente en el parámetro de la función usando `Depends(checker)`.

---

## F - Utilidad en seguridad

**Definición:**  
Este patrón de dependencias parametrizadas es especialmente útil en el contexto de seguridad, donde es común tener funciones de utilidad que verifican credenciales, tokens, etc. Estas funciones suelen implementarse de manera similar, utilizando instancias llamables para parametrizar su comportamiento.

**Ejemplo (contexto de seguridad):**

```python
class TokenVerifier:
    def __init__(self, token_prefix: str):
        self.token_prefix = token_prefix

    def __call__(self, token: str = Header(None)):
        if token and token.startswith(self.token_prefix):
            return True
        return False

token_verifier = TokenVerifier("Bearer")

@app.get("/secure-endpoint/")
async def secure_endpoint(is_verified: bool = Depends(token_verifier)):
    if not is_verified:
        raise HTTPException(status_code=403, detail="Token inválido")
    return {"message": "Acceso concedido"}
```

**Descripción del ejemplo:**

1.  Se define una clase `TokenVerifier` que verifica si un token comienza con un prefijo específico.
2.  Se crea una instancia `token_verifier` con `token_prefix="Bearer"`.
3.  La ruta `/secure-endpoint/` utiliza esta instancia como dependencia para verificar el token.
