## A - Modelos Múltiples (Multiple Models)

**Definición:**  
En aplicaciones complejas, es común tener varios modelos relacionados para diferentes propósitos. Por ejemplo, un modelo para la entrada de datos (`UserIn`), otro para la salida (`UserOut`), y otro para la base de datos (`UserInDB`). Esto es especialmente útil para manejar datos sensibles, como contraseñas, que no deben exponerse en las respuestas.

**Ejemplo:**

```python
from fastapi import FastAPI
from pydantic import BaseModel, EmailStr

app = FastAPI()

class UserIn(BaseModel):
    username: str
    password: str
    email: EmailStr
    full_name: str | None = None

class UserOut(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None

class UserInDB(BaseModel):
    username: str
    hashed_password: str
    email: EmailStr
    full_name: str | None = None

@app.post("/user/", response_model=UserOut)
async def create_user(user_in: UserIn):
    hashed_password = "supersecret" + user_in.password
    user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password)
    return user_in_db
```

**Descripción del ejemplo:**

- `UserIn` se usa para recibir datos del usuario, incluyendo la contraseña.
- `UserOut` se usa para devolver datos al usuario, excluyendo la contraseña.
- `UserInDB` se usa para almacenar datos en la base de datos, incluyendo una versión hasheada de la contraseña.

---

## B - Reducción de Duplicación (Reduce Duplication)

**Definición:**  
Para evitar la duplicación de código, puedes crear un modelo base (`UserBase`) que contenga los campos comunes. Luego, otros modelos pueden heredar de este modelo base y agregar campos específicos.

**Ejemplo:**

```python
class UserBase(BaseModel):
    username: str
    email: EmailStr
    full_name: str | None = None

class UserIn(UserBase):
    password: str

class UserOut(UserBase):
    pass

class UserInDB(UserBase):
    hashed_password: str
```

**Descripción del ejemplo:**

- `UserBase` contiene los campos comunes (`username`, `email`, `full_name`).
- `UserIn` hereda de `UserBase` y agrega el campo `password`.
- `UserOut` hereda de `UserBase` sin agregar campos adicionales.
- `UserInDB` hereda de `UserBase` y agrega el campo `hashed_password`.

---

## C - Uso de `Union` o `anyOf`

**Definición:**  
Puedes declarar que una respuesta puede ser de varios tipos usando `Union`. Esto es útil cuando una ruta puede devolver diferentes tipos de objetos.

**Ejemplo:**

```python
from typing import Union

class CarItem(BaseModel):
    type: str = "car"

class PlaneItem(BaseModel):
    type: str = "plane"
    size: int

@app.get("/items/{item_id}", response_model=Union[PlaneItem, CarItem])
async def read_item(item_id: str):
    if item_id == "item1":
        return CarItem(type="car")
    else:
        return PlaneItem(type="plane", size=5)
```

**Descripción del ejemplo:**

- La ruta puede devolver un objeto `CarItem` o `PlaneItem`.
- `Union[PlaneItem, CarItem]` indica que la respuesta puede ser cualquiera de los dos tipos.

---

## D - Lista de Modelos (List of Models)

**Definición:**  
Puedes declarar que una respuesta es una lista de objetos de un modelo específico. Esto es útil para devolver múltiples elementos en una sola respuesta.

**Ejemplo:**

```python
from typing import List

class Item(BaseModel):
    name: str
    description: str

@app.get("/items/", response_model=List[Item])
async def read_items():
    return [
        {"name": "Foo", "description": "There comes my hero"},
        {"name": "Red", "description": "It's my aeroplane"},
    ]
```

**Descripción del ejemplo:**

- La ruta devuelve una lista de objetos `Item`.
- `List[Item]` indica que la respuesta es una lista de elementos del tipo `Item`.

---

## E - Respuesta con `dict` Arbitrario (Response with Arbitrary `dict`)

**Definición:**  
Puedes declarar una respuesta como un diccionario arbitrario, especificando solo los tipos de las claves y valores. Esto es útil cuando no conoces los nombres de los campos de antemano.

**Ejemplo:**

```python
from typing import Dict

@app.get("/keyword-weights/", response_model=Dict[str, float])
async def read_keyword_weights():
    return {"foo": 2.3, "bar": 3.4}
```

**Descripción del ejemplo:**

- La ruta devuelve un diccionario donde las claves son strings y los valores son floats.
- `Dict[str, float]` indica que la respuesta es un diccionario con claves de tipo `str` y valores de tipo `float`.

---

## F - Uso de `**user_in.dict()`

**Definición:**  
El método `.dict()` de un modelo Pydantic convierte el modelo en un diccionario. Al usar `**` antes del diccionario, puedes "desempaquetar" sus valores para pasarlos como argumentos a una función o constructor.

**Ejemplo:**

```python
user_in = UserIn(username="john", password="secret", email="john@example.com")
user_dict = user_in.dict()  # Convierte el modelo en un diccionario
user_in_db = UserInDB(**user_dict, hashed_password="hashed_secret")
```

**Descripción del ejemplo:**

- `user_in.dict()` convierte el modelo `UserIn` en un diccionario.
- `UserInDB(**user_dict, hashed_password="hashed_secret")` crea un objeto `UserInDB` usando los valores del diccionario y un campo adicional.
