## A - Modelos Pydantic para Formularios (Form Models)

**Definición:**  
Puedes usar modelos Pydantic para declarar campos de formulario en FastAPI. Esto te permite definir la estructura de los datos del formulario y aprovechar las validaciones y documentación automática de Pydantic.

**Requisito:**  
Para usar formularios, primero debes instalar la librería `python-multipart`.

```bash
pip install python-multipart
```

---

## B - Declarar un Modelo Pydantic para Formularios

**Definición:**  
Crea un modelo Pydantic con los campos que deseas recibir como campos de formulario. Luego, declara el parámetro en la operación de ruta usando `Form()`.

**Ejemplo:**

```python
from fastapi import FastAPI, Form
from pydantic import BaseModel
from typing import Annotated

app = FastAPI()

class FormData(BaseModel):
    username: str
    password: str

@app.post("/login/")
async def login(data: Annotated[FormData, Form()]):
    return data
```

**Descripción del ejemplo:**

- `FormData` es un modelo Pydantic que define los campos `username` y `password`.
- `Annotated[FormData, Form()]` indica que los datos provienen de un formulario y deben ser validados según el modelo `FormData`.

---

## C - Verificar la Documentación

**Definición:**  
FastAPI genera automáticamente la documentación de la API en `/docs`. Puedes verificar cómo se manejan los campos del formulario en la interfaz de Swagger UI.

**Ejemplo:**

```python
from fastapi import FastAPI, Form
from pydantic import BaseModel

app = FastAPI()

class FormData(BaseModel):
    username: str
    password: str

@app.post("/login/")
async def login(data: FormData = Form()):
    return data
```

**Descripción del ejemplo:**

- En la documentación de Swagger UI, verás que los campos `username` y `password` son obligatorios y deben enviarse como campos de formulario.

---

## D - Prohibir Campos Adicionales en el Formulario

**Definición:**  
Puedes configurar un modelo Pydantic para prohibir campos adicionales que no estén declarados en el modelo. Esto es útil si deseas asegurarte de que no se envíen datos no esperados.

**Ejemplo:**

```python
from fastapi import FastAPI, Form
from pydantic import BaseModel
from typing import Annotated

app = FastAPI()

class FormData(BaseModel):
    username: str
    password: str
    model_config = {"extra": "forbid"}  # Prohibir campos adicionales

@app.post("/login/")
async def login(data: Annotated[FormData, Form()]):
    return data
```

**Descripción del ejemplo:**

- Si el cliente intenta enviar un campo adicional (por ejemplo, `extra`), FastAPI devolverá un error indicando que los campos adicionales no están permitidos.

---

## E - Manejo de Errores con Campos Adicionales

**Definición:**  
Si el cliente envía campos adicionales no declarados en el modelo Pydantic, FastAPI devolverá un error detallado indicando que los campos adicionales no están permitidos.

**Ejemplo de Error:**

```json
{
  "detail": [
    {
      "type": "extra_forbidden",
      "loc": ["body", "extra"],
      "msg": "Extra inputs are not permitted",
      "input": "Mr. Poopybutthole"
    }
  ]
}
```

**Descripción del ejemplo:**

- El error indica que el campo `extra` no está permitido en el formulario.
- Esto ayuda a mantener la integridad de los datos y evitar problemas de seguridad.

---

## F - Uso de `Annotated` vs. Sin `Annotated`

**Definición:**  
Puedes usar `Annotated` para mejorar la legibilidad y el soporte de herramientas de desarrollo. Sin embargo, también puedes declarar los formularios sin `Annotated`.

**Ejemplo sin `Annotated`:**

```python
from fastapi import FastAPI, Form
from pydantic import BaseModel

app = FastAPI()

class FormData(BaseModel):
    username: str
    password: str

@app.post("/login/")
async def login(data: FormData = Form()):
    return data
```

**Descripción del ejemplo:**

- Este código funciona igual que el ejemplo con `Annotated`, pero es menos explícito en cuanto a los tipos y metadatos.
