## A - Clases como dependencias

**Definición:**  
En FastAPI, las dependencias no solo pueden ser funciones, sino también clases. Esto es útil cuando necesitas encapsular lógica más compleja o cuando quieres aprovechar las ventajas de la programación orientada a objetos (POO).

**Ventajas:**

- Mejor organización del código.
- Soporte de autocompletado y verificación de tipos en editores.
- Reutilización de lógica.

---

## B - Crear una clase como dependencia

**Definición:**  
Una clase puede ser una dependencia si es "llamable" (es decir, si se puede instanciar). FastAPI analiza los parámetros del método `__init__` de la clase para resolver las dependencias.

Ejemplo:

```python
from fastapi import FastAPI, Depends

app = FastAPI()

class CommonQueryParams:
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit

@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    response.update({"items": items[commons.skip : commons.skip + commons.limit]})
    return response
```

**Descripción:**

- `CommonQueryParams` es una clase que actúa como dependencia.
- El método `__init__` define los parámetros que FastAPI resolverá automáticamente.
- `Depends(CommonQueryParams)` indica que `read_items` depende de una instancia de `CommonQueryParams`.

---

## C - Uso de `Annotated` para dependencias de clases

**Definición:**  
`Annotated` permite combinar el tipo de la dependencia con la declaración de `Depends`, lo que mejora la legibilidad y el soporte de herramientas como editores y verificadores de tipos.

Ejemplo:

```python
from typing import Annotated
from fastapi import FastAPI, Depends

app = FastAPI()

class CommonQueryParams:
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit

@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends()]):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    response.update({"items": items[commons.skip : commons.skip + commons.limit]})
    return response
```

**Descripción:**

- `Annotated[CommonQueryParams, Depends()]` combina el tipo y la dependencia en una sola declaración.
- Esto permite que los editores proporcionen autocompletado y verificación de tipos.

---

## D - Atajo para dependencias de clases

**Definición:**  
FastAPI proporciona un atajo para dependencias que son clases. En lugar de escribir `Depends(CommonQueryParams)`, puedes simplemente usar `Depends()` si el tipo de la dependencia es una clase.

Ejemplo:

```python
@app.get("/items/")
async def read_items(commons: CommonQueryParams = Depends()):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    response.update({"items": items[commons.skip : commons.skip + commons.limit]})
    return response
```

**Descripción:**

- `Depends()` sin argumentos infiere que la dependencia es una instancia de `CommonQueryParams`.
- Esto reduce la repetición de código.

---

## E - Comparación entre `Annotated` y `Depends`

**Definición:**

- `Annotated` combina el tipo y la dependencia en una sola declaración, lo que mejora la legibilidad y el soporte de herramientas.
- `Depends` se usa para indicar que un parámetro depende de una función o clase.

Ejemplo con `Annotated`:

```python
commons: Annotated[CommonQueryParams, Depends()]
```

Ejemplo con `Depends`:

```python
commons: CommonQueryParams = Depends(CommonQueryParams)
```

**Descripción:**

- Ambas formas son válidas, pero `Annotated` es más moderna y recomendada.

---

## F - Resumen de dependencias de clases

**Definición:**  
Las clases como dependencias permiten encapsular lógica compleja y aprovechar las ventajas de la POO. FastAPI resuelve automáticamente los parámetros del método `__init__` y proporciona soporte para autocompletado y verificación de tipos.

**Ejemplo completo:**

```python
from typing import Annotated
from fastapi import FastAPI, Depends

app = FastAPI()

class CommonQueryParams:
    def __init__(self, q: str | None = None, skip: int = 0, limit: int = 100):
        self.q = q
        self.skip = skip
        self.limit = limit

@app.get("/items/")
async def read_items(commons: Annotated[CommonQueryParams, Depends()]):
    response = {}
    if commons.q:
        response.update({"q": commons.q})
    items = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]
    response.update({"items": items[commons.skip : commons.skip + commons.limit]})
    return response
```

**Descripción:**

- `CommonQueryParams` es una clase que actúa como dependencia.
- `Annotated` combina el tipo y la dependencia en una sola declaración.
- FastAPI resuelve automáticamente los parámetros y pasa una instancia de `CommonQueryParams` a `read_items`.
