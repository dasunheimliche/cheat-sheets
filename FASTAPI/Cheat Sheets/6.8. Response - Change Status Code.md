## A - Status Code Dinámico con Response Parameter

**Definición:** Permite modificar el código de estado HTTP de una respuesta dinámicamente mientras se mantiene la capacidad de usar response_model y retornar objetos normales.

**Ejemplo:**

```python

from fastapi import FastAPI, Response, status
from pydantic import BaseModel
from typing import Optional

class Item(BaseModel):
    name: str
    description: Optional[str] = None
    price: float

app = FastAPI()

# Simular base de datos
items_db = {}

@app.put("/items/{item_id}", response_model=Item)
async def upsert_item(
    item_id: str,
    item: Item,
    response: Response
):
    # Verificar si el item existe
    if item_id in items_db:
        # Actualizar item existente
        items_db[item_id].update(item.dict())
        response.status_code = status.HTTP_200_OK
    else:
        # Crear nuevo item
        items_db[item_id] = item.dict()
        response.status_code = status.HTTP_201_CREATED

    return items_db[item_id]
```

(Este ejemplo muestra cómo cambiar dinámicamente entre códigos 200 y 201 dependiendo de si se crea o actualiza un recurso.)

## B - Status Codes en Operaciones Asíncronas

**Definición:** Demuestra el manejo de códigos de estado en operaciones asíncronas y procesos largos, utilizando códigos apropiados para indicar el estado del proceso.

**Ejemplo:**

```python

from fastapi import FastAPI, Response, status, BackgroundTasks
from pydantic import BaseModel
from typing import Optional
import time
import asyncio

class TaskRequest(BaseModel):
    name: str
    duration: int

class TaskResponse(BaseModel):
    task_id: str
    status: str
    eta: Optional[int] = None

app = FastAPI()

# Simular almacén de tareas
tasks_store = {}

async def process_long_task(task_id: str, duration: int):
    """Simula una tarea larga"""
    await asyncio.sleep(duration)
    tasks_store[task_id]['status'] = 'completed'

@app.post(
    "/tasks/",
    response_model=TaskResponse,
    status_code=status.HTTP_202_ACCEPTED
)
async def create_task(
    task: TaskRequest,
    background_tasks: BackgroundTasks,
    response: Response
):
    task_id = f"task_{int(time.time())}"

    # Si la duración es muy corta, procesar inmediatamente
    if task.duration <= 1:
        await asyncio.sleep(task.duration)
        response.status_code = status.HTTP_201_CREATED
        return TaskResponse(
            task_id=task_id,
            status="completed"
        )

    # Para tareas largas, procesar en background
    tasks_store[task_id] = {
        'status': 'processing',
        'duration': task.duration
    }

    background_tasks.add_task(
        process_long_task,
        task_id,
        task.duration
    )

    return TaskResponse(
        task_id=task_id,
        status="processing",
        eta=task.duration
    )

@app.get(
    "/tasks/{task_id}",
    response_model=TaskResponse
)
async def get_task_status(
    task_id: str,
    response: Response
):
    if task_id not in tasks_store:
        response.status_code = status.HTTP_404_NOT_FOUND
        return TaskResponse(
            task_id=task_id,
            status="not_found"
        )

    task_info = tasks_store[task_id]

    if task_info['status'] == 'processing':
        response.status_code = status.HTTP_202_ACCEPTED
    else:
        response.status_code = status.HTTP_200_OK

    return TaskResponse(
        task_id=task_id,
        status=task_info['status'],
        eta=task_info.get('duration')
    )
```

(Este ejemplo muestra cómo manejar códigos de estado en operaciones asíncronas, usando 202 para procesos en curso y 201/200 para completados.)

## C - Status Codes en Dependencies

**Definición:** Muestra cómo establecer códigos de estado desde funciones de dependencia, útil para manejar autenticación, autorización y validaciones comunes.

**Ejemplo:**

```python

from fastapi import FastAPI, Response, status, Depends, HTTPException
from fastapi.security import OAuth2PasswordBearer
from typing import Optional
import time

app = FastAPI()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

async def verify_token(
    response: Response,
    token: str = Depends(oauth2_scheme)
):
    """Dependency para verificar token y establecer status codes"""
    if token == "expired":
        response.status_code = status.HTTP_401_UNAUTHORIZED
        return None

    if token == "invalid_scope":
        response.status_code = status.HTTP_403_FORBIDDEN
        return None

    # Token válido
    return {"sub": "user123", "scope": "read write"}

async def check_resource_exists(
    resource_id: str,
    response: Response
) -> Optional[dict]:
    """Dependency para verificar existencia de recurso"""
    # Simular búsqueda en base de datos
    if resource_id == "404":
        response.status_code = status.HTTP_404_NOT_FOUND
        return None

    return {"id": resource_id, "name": "Example Resource"}

@app.get("/resources/{resource_id}")
async def get_resource(
    resource: Optional[dict] = Depends(check_resource_exists),
    token_data: Optional[dict] = Depends(verify_token)
):
    if not token_data or not resource:
        return {"error": "Unable to process request"}

    return {
        "resource": resource,
        "token_data": token_data
    }
```

(Este ejemplo muestra cómo establecer códigos de estado en dependencies para manejar diferentes casos de error y autorización.)

## D - Status Codes en Manejo de Errores

**Definición:** Demuestra el manejo adecuado de códigos de estado en diferentes situaciones de error y validación.

**Ejemplo:**

```python

from fastapi import FastAPI, Response, status, HTTPException
from fastapi.responses import JSONResponse
from pydantic import BaseModel, ValidationError
from typing import Optional
import time

class ErrorResponse(BaseModel):
    error_code: str
    message: str
    details: Optional[dict] = None

app = FastAPI()

@app.exception_handler(ValidationError)
async def validation_error_handler(request, exc):
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content=ErrorResponse(
            error_code="VALIDATION_ERROR",
            message="Error validando datos",
            details={"errors": exc.errors()}
        ).dict()
    )

@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    return JSONResponse(
        status_code=exc.status_code,
        content=ErrorResponse(
            error_code=f"HTTP_{exc.status_code}",
            message=exc.detail,
            details=getattr(exc, "details", None)
        ).dict()
    )

@app.get("/items/{item_id}")
async def get_item(
    item_id: str,
    response: Response,
    version: Optional[str] = None
):
    # Validar versión de API
    if not version:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="API version is required",
            headers={"X-Error-Code": "VERSION_REQUIRED"}
        )

    # Verificar rate limiting
    if item_id == "rate_limited":
        response.status_code = status.HTTP_429_TOO_MANY_REQUESTS
        response.headers["Retry-After"] = "60"
        return ErrorResponse(
            error_code="RATE_LIMITED",
            message="Too many requests",
            details={"retry_after": 60}
        )

    # Verificar mantenimiento
    if item_id == "maintenance":
        response.status_code = status.HTTP_503_SERVICE_UNAVAILABLE
        return ErrorResponse(
            error_code="MAINTENANCE",
            message="Service under maintenance",
            details={"estimated_duration": "1 hour"}
        )

    # Simular timeout
    if item_id == "timeout":
        time.sleep(1)  # Simular proceso lento
        response.status_code = status.HTTP_504_GATEWAY_TIMEOUT
        return ErrorResponse(
            error_code="TIMEOUT",
            message="Request timed out",
            details={"timeout_after": "1s"}
        )

    # Respuesta exitosa
    return {
        "item_id": item_id,
        "version": version,
        "status": "active"
    }

@app.post("/items/")
async def create_item(
    response: Response,
    item: dict,
    notify: bool = False
):
    try:
        # Simular creación de item
        if "error" in item:
            raise ValueError("Error creating item")

        # Si se requiere notificación
        if notify:
            response.status_code = status.HTTP_202_ACCEPTED
            return {
                "message": "Item creation in progress",
                "item_id": "123"
            }

        # Creación normal
        response.status_code = status.HTTP_201_CREATED
        return {
            "message": "Item created",
            "item_id": "123"
        }

    except ValueError as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=str(e),
            headers={"X-Error-Code": "CREATION_FAILED"}
        )
```

(Este ejemplo muestra un manejo comprensivo de códigos de estado para diferentes situaciones de error, incluyendo validación, rate limiting, mantenimiento y timeouts.)
