## A - List fields (Campos de lista)

**Definición:**  
En FastAPI, puedes definir un atributo como una lista en un modelo Pydantic. Esto permite que el campo contenga múltiples valores, pero sin especificar el tipo de datos que la lista debe contener.

**Ejemplo:**

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: list = []  # Lista sin tipo específico

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

**Descripción:**  
En este ejemplo, `tags` es una lista que puede contener cualquier tipo de dato, ya que no se ha especificado un tipo interno.

---

## B - List fields with type parameter (Campos de lista con tipo específico)

**Definición:**  
Puedes definir listas con tipos específicos usando la sintaxis de Python para "parámetros de tipo". Esto asegura que todos los elementos de la lista sean del tipo especificado.

**Ejemplo:**

```python
from typing import List  # Para Python < 3.9
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: List[str] = []  # Lista de strings

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

**Descripción:**  
Aquí, `tags` es una lista que solo puede contener strings. En Python 3.9+, puedes usar `list[str]` en lugar de `List[str]`.

---

## C - Set types (Tipos de conjunto)

**Definición:**  
Si necesitas que los elementos de una lista sean únicos, puedes usar un `set`. Un `set` es una colección que no permite duplicados.

**Ejemplo:**

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()  # Conjunto de strings únicos

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

**Descripción:**  
En este caso, `tags` es un conjunto de strings, lo que garantiza que no habrá duplicados.

---

## D - Nested Models (Modelos anidados)

**Definición:**  
Puedes anidar modelos Pydantic dentro de otros modelos. Esto es útil para representar estructuras de datos complejas y jerárquicas.

**Ejemplo:**

```python
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Image(BaseModel):
    url: str
    name: str

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    image: Image | None = None  # Modelo anidado

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

**Descripción:**  
Aquí, `Item` tiene un campo `image` que es otro modelo Pydantic (`Image`). Esto permite estructuras de datos complejas.

---

## E - Special types and validation (Tipos especiales y validación)

**Definición:**  
Pydantic ofrece tipos especiales, como `HttpUrl`, que validan automáticamente que un string sea una URL válida.

**Ejemplo:**

```python
from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()

class Image(BaseModel):
    url: HttpUrl  # Valida que sea una URL válida
    name: str

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    image: Image | None = None

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

**Descripción:**  
El campo `url` en `Image` se valida automáticamente para asegurarse de que sea una URL válida.

---

## F - Attributes with lists of submodels (Atributos con listas de submodelos)

**Definición:**  
Puedes tener listas de modelos Pydantic como atributos de otro modelo. Esto es útil para representar relaciones uno a muchos.

**Ejemplo:**

```python
from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()

class Image(BaseModel):
    url: HttpUrl
    name: str

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    images: list[Image] | None = None  # Lista de modelos

@app.put("/items/{item_id}")
async def update_item(item_id: int, item: Item):
    results = {"item_id": item_id, "item": item}
    return results
```

**Descripción:**  
El campo `images` es una lista de objetos `Image`, lo que permite múltiples imágenes asociadas a un ítem.

---

## G - Deeply nested models (Modelos profundamente anidados)

**Definición:**  
Puedes anidar modelos de manera arbitraria, creando estructuras de datos complejas y jerárquicas.

**Ejemplo:**

```python
from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()

class Image(BaseModel):
    url: HttpUrl
    name: str

class Item(BaseModel):
    name: str
    description: str | None = None
    price: float
    tax: float | None = None
    tags: set[str] = set()
    images: list[Image] | None = None

class Offer(BaseModel):
    name: str
    description: str | None = None
    price: float
    items: list[Item]  # Lista de modelos anidados

@app.post("/offers/")
async def create_offer(offer: Offer):
    return offer
```

**Descripción:**  
`Offer` contiene una lista de `Item`, y cada `Item` puede contener una lista de `Image`. Esto permite estructuras de datos muy complejas.

---

## H - Bodies of pure lists (Cuerpos de listas puras)

**Definición:**  
Si el cuerpo de una solicitud es una lista, puedes declarar el tipo directamente en el parámetro de la función.

**Ejemplo:**

```python
from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()

class Image(BaseModel):
    url: HttpUrl
    name: str

@app.post("/images/multiple/")
async def create_multiple_images(images: list[Image]):  # Lista pura
    return images
```

**Descripción:**  
El endpoint espera un cuerpo que sea una lista de objetos `Image`.

---

## I - Bodies of arbitrary dicts (Cuerpos de diccionarios arbitrarios)

**Definición:**  
Puedes aceptar diccionarios con claves y valores de tipos específicos. Esto es útil cuando no conoces de antemano las claves válidas.

**Ejemplo:**

```python
from fastapi import FastAPI

app = FastAPI()

@app.post("/index-weights/")
async def create_index_weights(weights: dict[int, float]):  # Diccionario con claves int y valores float
    return weights
```

**Descripción:**  
El endpoint acepta un diccionario donde las claves son enteros y los valores son flotantes. Pydantic convierte automáticamente las claves de string a int si es posible.
