## A - `useMutation`: Tu Mensajero para Cambiar Datos en el Servidor 🔴

#### 1. **Introducción:**

`useMutation` es el hook que usas cuando necesitas **crear, actualizar o eliminar** datos en tu servidor; es tu herramienta para decirle al backend: "¡Oye, necesito que cambies algo!".

#### 2. **Ejemplo:**

Imagina que estás construyendo una lista de tareas y quieres añadir una nueva.

```tsx
import { useMutation } from "@tanstack/react-query";
import axios from "axios";

function App() {
  // 1. Configuramos nuestro "mensajero" (la mutación)
  const addTodoMutation = useMutation({
    // 2. Le damos las instrucciones: "Cuando te pida añadir una tarea, haz esto"
    mutationFn: (nuevaTarea) => {
      // axios.post es como enviar un paquete con la nueva tarea a la dirección '/todos'
      return axios.post("/todos", nuevaTarea);
    },
  });

  return (
    <div>
      <button
        onClick={() => {
          // 3. Le damos la orden de empezar: "¡Mensajero, lleva esta nueva tarea!"
          addTodoMutation.mutate({ id: Date.now(), title: "Lavar la ropa" });
        }}
      >
        Añadir Tarea
      </button>

      {/* Aquí mostraremos mensajes según el estado del "envío" */}
    </div>
  );
}
```

**Explicación del ejemplo:**

1.  **Configuración (`useMutation`)**: Creamos una "instancia de mensajero" llamada `addTodoMutation`. Es un objeto que contiene todo lo necesario para realizar y rastrear una operación de cambio.
2.  **Instrucciones (`mutationFn`)**: Esta es la función que hace el trabajo de verdad. Le dice a nuestro mensajero _qué hacer_ cuando lo activemos. En este caso, es enviar (`axios.post`) un objeto `nuevaTarea` a la URL `/todos` de nuestro servidor.
3.  **La Orden (`mutate`)**: Cuando el usuario hace clic en el botón, llamamos a `addTodoMutation.mutate(...)`. Esto es como decirle al mensajero: "¡Ahora! Toma este paquete (`{ id: ..., title: ... }`) y sigue las instrucciones que te di".

#### 3. **Desarrollo**:

A diferencia de `useQuery`, que es para _leer_ o _consultar_ datos, `useMutation` es para _modificarlos_. Piensa en `useQuery` como preguntar "¿Qué hora es?" y en `useMutation` como "¡Adelanta el reloj una hora!".

La función que pasas a `mutate` (en el ejemplo, `{ id: ..., title: 'Lavar la ropa' }`) se convierte en el argumento de tu `mutationFn`. Es la información que necesitas enviar para que el cambio se realice. ¡Y solo puedes pasarle **un** argumento! Si necesitas enviar varias cosas, agrúpalas en un solo objeto, como hicimos en el ejemplo.

🔴 **Fundamental**: No puedes construir una aplicación interactiva que modifique datos sin `useMutation` (o una alternativa). Es la contraparte esencial de `useQuery` y la base para cualquier acción que altere el estado en tu backend.

---

## B - Los 4 Estados de una Mutación: El Semáforo de tu Petición 🔴

#### 1. **Introducción:**

Una mutación siempre se encuentra en uno de cuatro estados posibles, que te permiten saber exactamente qué está pasando con tu petición y mostrar la interfaz adecuada al usuario.

#### 2. **Ejemplo:**

Continuando con nuestro ejemplo de la lista de tareas, ahora vamos a mostrar mensajes al usuario dependiendo del estado de la mutación.

```tsx
function App() {
  const addTodoMutation = useMutation({
    mutationFn: (nuevaTarea) => axios.post("/todos", nuevaTarea),
  });

  return (
    <div>
      <button
        onClick={() => {
          addTodoMutation.mutate({ id: Date.now(), title: "Lavar la ropa" });
        }}
        // Deshabilitamos el botón mientras se añade la tarea para evitar clics duplicados
        disabled={addTodoMutation.isPending}
      >
        {/* Cambiamos el texto del botón si está en proceso */}
        {addTodoMutation.isPending ? "Añadiendo..." : "Añadir Tarea"}
      </button>

      {/* Muestra un mensaje de éxito */}
      {addTodoMutation.isSuccess ? <div>¡Tarea añadida con éxito!</div> : null}

      {/* Muestra un mensaje de error si algo salió mal */}
      {addTodoMutation.isError ? (
        <div>Error: {addTodoMutation.error.message}</div>
      ) : null}
    </div>
  );
}
```

**Explicación del ejemplo:**

Usamos las propiedades booleanas que nos da `useMutation` para renderizar condicionalmente partes de nuestra UI:

- `isPending`: Es `true` mientras la petición está en curso. Lo usamos para deshabilitar el botón y mostrar "Añadiendo...". Es el semáforo en ámbar: "Espera, por favor".
- `isSuccess`: Se vuelve `true` si la petición tuvo éxito. Lo usamos para mostrar un mensaje de confirmación. Es el semáforo en verde: "¡Puedes pasar!".
- `isError`: Se vuelve `true` si la petición falló. Lo usamos para mostrar un mensaje de error. La propiedad `error` contendrá el objeto de error para que puedas mostrar detalles. Es el semáforo en rojo: "¡Alto, algo salió mal!".
- `isIdle` (no se usa en el ejemplo): Es el estado inicial, antes de que se haya disparado la mutación. Es como tener el coche aparcado, esperando a arrancar.

#### 3. **Desarrollo**:

Estos cuatro estados son la clave para crear una experiencia de usuario fluida. Sin ellos, el usuario haría clic en un botón y no tendría ni idea de si su acción funcionó, está en proceso o falló.

- `isIdle` o `status === 'idle'`: La mutación está esperando a ser llamada.
- `isPending` o `status === 'pending'`: ¡En marcha! La petición ha sido enviada y estamos esperando respuesta.
- `isSuccess` o `status === 'success'`: ¡Éxito! La operación se completó y los datos de la respuesta (si los hay) están disponibles en `mutation.data`.
- `isError` o `status === 'error'`: ¡Fracaso! La operación falló y los detalles del error están en `mutation.error`.

🔴 **Fundamental**: Controlar estos estados no es opcional, es la base para construir interfaces de usuario robustas y comunicativas. Siempre debes manejar los estados `pending`, `success` y `error`.

---

## C - Efectos Secundarios (`onSuccess`, `onError`): Acciones Post-Misión 🟡

#### 1. **Introducción:**

Los "efectos secundarios" son funciones que puedes configurar para que se ejecuten automáticamente después de que una mutación termine, ya sea con éxito o con error.

#### 2. **Ejemplo:**

Imagina que después de añadir una nueva tarea, quieres que la lista de tareas se actualice automáticamente para mostrar la nueva. Y si falla, quieres registrar el error en algún sitio.

```tsx
import { useMutation, useQueryClient } from "@tanstack/react-query";

function App() {
  // 1. Obtenemos el Query Client
  const queryClient = useQueryClient();

  const addTodoMutation = useMutation({
    mutationFn: (nuevaTarea) => axios.post("/todos", nuevaTarea),

    // 2. ¡SI TODO SALE BIEN!
    onSuccess: () => {
      // Invalida la query 'todos'. Esto le dice a TanStack Query:
      // "La lista de 'todos' está desactualizada, ¡vuelve a pedirla!"
      queryClient.invalidateQueries({ queryKey: ["todos"] });
      console.log("¡La tarea se añadió y la lista se refrescará!");
    },

    // 3. ¡SI ALGO SALE MAL!
    onError: (error, variables, context) => {
      console.error("¡Oh no, algo falló!", error.message);
      // 'variables' son los datos que intentaste enviar: { id: ..., title: ... }
      console.log("Datos que fallaron:", variables);
    },

    // 4. ¡CUANDO TODO TERMINE (BIEN O MAL)!
    onSettled: () => {
      console.log("La misión ha terminado, para bien o para mal.");
    },
  });

  // ... el resto del componente ...
}
```

**Explicación del ejemplo:**

1.  **`useQueryClient`**: Necesitamos esta herramienta para poder interactuar con otras queries de nuestra aplicación.
2.  **`onSuccess`**: Este bloque de código se ejecuta _solo si_ la `mutationFn` termina sin errores. Aquí, lo usamos para `invalidateQueries`. Invalidar una query es la forma más común y potente de mantener tu UI sincronizada con los datos del servidor.
3.  **`onError`**: Este se ejecuta _solo si_ la `mutationFn` lanza un error. Es el lugar perfecto para mostrar notificaciones de error, enviar reportes a un servicio de logging, o intentar revertir cambios optimistas (un tema más avanzado).
4.  **`onSettled`**: Este se ejecuta _siempre_ que la mutación termina, sin importar si fue un éxito o un error. Es útil para tareas de limpieza que deben ocurrir en ambos casos, como ocultar un spinner de carga general.

#### 3. **Desarrollo**:

Estos callbacks son el pegamento que conecta tus mutaciones con el resto de tu aplicación. El patrón más común es: **Mutación exitosa (`onSuccess`) -> Invalidar queries relacionadas -> UI se actualiza automáticamente.**

- `onMutate`: Se ejecuta _justo antes_ de la `mutationFn`. Es útil para actualizaciones optimistas (actualizar la UI _antes_ de que el servidor confirme).
- `onSuccess(data, variables, context)`: Recibe los datos de la respuesta (`data`), las variables que enviaste (`variables`) y el contexto de `onMutate`.
- `onError(error, variables, context)`: Recibe el error, las variables y el contexto.
- `onSettled(data, error, variables, context)`: Recibe el resultado (data o undefined) y el error (error o undefined).

🟡 **Importante**: Usar `onSuccess` para invalidar queries es una técnica central en TanStack Query. Dominar esto hará que tus aplicaciones se sientan increíblemente rápidas y reactivas.

---

## D - `mutate` vs. `mutateAsync`: ¿"Dispara y Olvida" o "Espera la Respuesta"? 🟡

#### 1. **Introducción:**

TanStack Query te da dos formas de ejecutar una mutación: `mutate` para acciones que no necesitan esperar, y `mutateAsync` para cuando necesitas que tu código se detenga hasta que la mutación termine.

#### 2. **Ejemplo Comparativo:**

**Escenario 1: Usando `mutate` (Dispara y Olvida)**
Quieres cerrar un modal después de enviar un formulario, sin importar si la petición ya terminó.

```tsx
// El componente que contiene el formulario
function EditProfileForm({ closeModal }) {
  const mutation = useMutation({
    mutationFn: updateUser,
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ["profile"] }),
  });

  const handleSubmit = (data) => {
    mutation.mutate(data); // Lanza la petición...
    closeModal(); // ...e inmediatamente cierra el modal. No espera.
  };

  return <form onSubmit={handleSubmit}>...</form>;
}
```

**Explicación:** `mutate` inicia la petición y el código sigue ejecutándose inmediatamente. Es perfecto para cuando la acción de la UI (cerrar el modal) no depende del resultado de la mutación. Los estados (`isPending`, `isSuccess`) y los callbacks (`onSuccess`) se encargarán del resto en segundo plano.

**Escenario 2: Usando `mutateAsync` (Espera la Respuesta)**
Quieres crear un nuevo post y, _solo si tiene éxito_, redirigir al usuario a la página de ese nuevo post.

```tsx
import { useNavigate } from "react-router-dom";

function NewPostForm() {
  const navigate = useNavigate();
  const mutation = useMutation({ mutationFn: createPost });

  const handleSubmit = async (data) => {
    try {
      // Lanza la petición y ESPERA a que termine
      const newPost = await mutation.mutateAsync(data);
      // Esta línea solo se ejecuta si la mutación tuvo éxito
      navigate(`/posts/${newPost.id}`); // Redirige usando el ID de la respuesta
    } catch (error) {
      // Esta bloque se ejecuta si la mutación falla
      console.error("No se pudo crear el post:", error);
      alert("Error al crear el post. Inténtalo de nuevo.");
    }
  };

  return <form onSubmit={handleSubmit}>...</form>;
}
```

**Explicación:** `mutateAsync` devuelve una Promesa. Usando `await`, pausamos la ejecución de la función `handleSubmit` hasta que la promesa se resuelva (éxito) o se rechace (error). Esto te da un control imperativo y secuencial sobre el flujo de tu lógica.

#### 3. **Desarrollo**:

La elección es simple y depende de lo que necesites hacer _justo después_ de iniciar la mutación:

- **Usa `mutate` (el 90% de las veces):** Cuando la lógica de éxito/error puede ser manejada de forma declarativa con los estados (`isPending`, etc.) y los callbacks (`onSuccess`, `onError`). Es el modo "TanStack Query".
- **Usa `mutateAsync`:** Cuando necesitas encadenar acciones de forma secuencial. Por ejemplo: "haz esto, y SI Y SOLO SI funciona, haz esto otro, y si falla, haz aquello". Es útil para flujos de trabajo complejos o para integrar con código que espera promesas.

🟡 **Importante**: Entender esta diferencia es clave para escribir un código limpio y predecible. Abusa de `mutate` y los callbacks, y reserva `mutateAsync` para esos casos especiales donde el control secuencial es indispensable.

---

## E - `reset()`: Limpiando el Estado de la Mutación 🔵

#### 1. **Introducción:**

La función `reset` te permite devolver manualmente una mutación a su estado inicial (`idle`), limpiando cualquier dato o error que pudiera tener.

#### 2. **Ejemplo:**

Imagina que un formulario de login falla. Quieres mostrar el error, pero también darle al usuario la oportunidad de "descartar" ese error y volver a intentarlo.

```tsx
function LoginForm() {
  const [email, setEmail] = useState("");
  const loginMutation = useMutation({ mutationFn: api.login });

  const handleSubmit = (e) => {
    e.preventDefault();
    loginMutation.mutate({ email });
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Si hay un error, muéstralo con un botón para descartarlo */}
      {loginMutation.isError && (
        <div>
          <span>Error: {loginMutation.error.message}</span>
          {/* Al hacer clic, limpiamos el estado de la mutación */}
          <button type="button" onClick={() => loginMutation.reset()}>
            Descartar
          </button>
        </div>
      )}

      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <button type="submit" disabled={loginMutation.isPending}>
        {loginMutation.isPending ? "Iniciando sesión..." : "Login"}
      </button>
    </form>
  );
}
```

**Explicación del ejemplo:**

Cuando `loginMutation` falla, `isError` se vuelve `true` y el mensaje de error aparece. Si no hiciéramos nada, ese mensaje se quedaría ahí para siempre. Al llamar a `loginMutation.reset()`, estamos diciendo: "Ok, ya vi el error. Olvídalo y volvamos al principio". Esto hace que `isError` vuelva a ser `false`, `error` se vuelva `null`, y el mensaje de error desaparezca de la UI.

#### 3. **Desarrollo**:

Normalmente no necesitas llamar a `reset()` muy a menudo. Una nueva llamada a `mutate()` limpiará automáticamente el estado anterior. Sin embargo, `reset()` es muy útil en situaciones donde la UI necesita ser limpiada _sin_ iniciar una nueva mutación. El caso más común es permitir al usuario descartar un mensaje de error de un formulario que no se ha vuelto a enviar.

🔵 **Específico**: Es una herramienta útil para casos de uso de UI muy concretos, principalmente para mejorar la experiencia del usuario al manejar errores. No la necesitarás en cada mutación, pero es bueno saber que existe para cuando la necesites.
