## A - `useMutation`: Tu Mensajero para Cambiar Datos en el Servidor 

#### 1. **Introducci贸n:**

`useMutation` es el hook que usas cuando necesitas **crear, actualizar o eliminar** datos en tu servidor; es tu herramienta para decirle al backend: "隆Oye, necesito que cambies algo!".

#### 2. **Ejemplo:**

Imagina que est谩s construyendo una lista de tareas y quieres a帽adir una nueva.

```tsx
import { useMutation } from "@tanstack/react-query";
import axios from "axios";

function App() {
  // 1. Configuramos nuestro "mensajero" (la mutaci贸n)
  const addTodoMutation = useMutation({
    // 2. Le damos las instrucciones: "Cuando te pida a帽adir una tarea, haz esto"
    mutationFn: (nuevaTarea) => {
      // axios.post es como enviar un paquete con la nueva tarea a la direcci贸n '/todos'
      return axios.post("/todos", nuevaTarea);
    },
  });

  return (
    <div>
      <button
        onClick={() => {
          // 3. Le damos la orden de empezar: "隆Mensajero, lleva esta nueva tarea!"
          addTodoMutation.mutate({ id: Date.now(), title: "Lavar la ropa" });
        }}
      >
        A帽adir Tarea
      </button>

      {/* Aqu铆 mostraremos mensajes seg煤n el estado del "env铆o" */}
    </div>
  );
}
```

**Explicaci贸n del ejemplo:**

1.  **Configuraci贸n (`useMutation`)**: Creamos una "instancia de mensajero" llamada `addTodoMutation`. Es un objeto que contiene todo lo necesario para realizar y rastrear una operaci贸n de cambio.
2.  **Instrucciones (`mutationFn`)**: Esta es la funci贸n que hace el trabajo de verdad. Le dice a nuestro mensajero _qu茅 hacer_ cuando lo activemos. En este caso, es enviar (`axios.post`) un objeto `nuevaTarea` a la URL `/todos` de nuestro servidor.
3.  **La Orden (`mutate`)**: Cuando el usuario hace clic en el bot贸n, llamamos a `addTodoMutation.mutate(...)`. Esto es como decirle al mensajero: "隆Ahora! Toma este paquete (`{ id: ..., title: ... }`) y sigue las instrucciones que te di".

#### 3. **Desarrollo**:

A diferencia de `useQuery`, que es para _leer_ o _consultar_ datos, `useMutation` es para _modificarlos_. Piensa en `useQuery` como preguntar "驴Qu茅 hora es?" y en `useMutation` como "隆Adelanta el reloj una hora!".

La funci贸n que pasas a `mutate` (en el ejemplo, `{ id: ..., title: 'Lavar la ropa' }`) se convierte en el argumento de tu `mutationFn`. Es la informaci贸n que necesitas enviar para que el cambio se realice. 隆Y solo puedes pasarle **un** argumento! Si necesitas enviar varias cosas, agr煤palas en un solo objeto, como hicimos en el ejemplo.

 **Fundamental**: No puedes construir una aplicaci贸n interactiva que modifique datos sin `useMutation` (o una alternativa). Es la contraparte esencial de `useQuery` y la base para cualquier acci贸n que altere el estado en tu backend.

---

## B - Los 4 Estados de una Mutaci贸n: El Sem谩foro de tu Petici贸n 

#### 1. **Introducci贸n:**

Una mutaci贸n siempre se encuentra en uno de cuatro estados posibles, que te permiten saber exactamente qu茅 est谩 pasando con tu petici贸n y mostrar la interfaz adecuada al usuario.

#### 2. **Ejemplo:**

Continuando con nuestro ejemplo de la lista de tareas, ahora vamos a mostrar mensajes al usuario dependiendo del estado de la mutaci贸n.

```tsx
function App() {
  const addTodoMutation = useMutation({
    mutationFn: (nuevaTarea) => axios.post("/todos", nuevaTarea),
  });

  return (
    <div>
      <button
        onClick={() => {
          addTodoMutation.mutate({ id: Date.now(), title: "Lavar la ropa" });
        }}
        // Deshabilitamos el bot贸n mientras se a帽ade la tarea para evitar clics duplicados
        disabled={addTodoMutation.isPending}
      >
        {/* Cambiamos el texto del bot贸n si est谩 en proceso */}
        {addTodoMutation.isPending ? "A帽adiendo..." : "A帽adir Tarea"}
      </button>

      {/* Muestra un mensaje de 茅xito */}
      {addTodoMutation.isSuccess ? <div>隆Tarea a帽adida con 茅xito!</div> : null}

      {/* Muestra un mensaje de error si algo sali贸 mal */}
      {addTodoMutation.isError ? (
        <div>Error: {addTodoMutation.error.message}</div>
      ) : null}
    </div>
  );
}
```

**Explicaci贸n del ejemplo:**

Usamos las propiedades booleanas que nos da `useMutation` para renderizar condicionalmente partes de nuestra UI:

- `isPending`: Es `true` mientras la petici贸n est谩 en curso. Lo usamos para deshabilitar el bot贸n y mostrar "A帽adiendo...". Es el sem谩foro en 谩mbar: "Espera, por favor".
- `isSuccess`: Se vuelve `true` si la petici贸n tuvo 茅xito. Lo usamos para mostrar un mensaje de confirmaci贸n. Es el sem谩foro en verde: "隆Puedes pasar!".
- `isError`: Se vuelve `true` si la petici贸n fall贸. Lo usamos para mostrar un mensaje de error. La propiedad `error` contendr谩 el objeto de error para que puedas mostrar detalles. Es el sem谩foro en rojo: "隆Alto, algo sali贸 mal!".
- `isIdle` (no se usa en el ejemplo): Es el estado inicial, antes de que se haya disparado la mutaci贸n. Es como tener el coche aparcado, esperando a arrancar.

#### 3. **Desarrollo**:

Estos cuatro estados son la clave para crear una experiencia de usuario fluida. Sin ellos, el usuario har铆a clic en un bot贸n y no tendr铆a ni idea de si su acci贸n funcion贸, est谩 en proceso o fall贸.

- `isIdle` o `status === 'idle'`: La mutaci贸n est谩 esperando a ser llamada.
- `isPending` o `status === 'pending'`: 隆En marcha! La petici贸n ha sido enviada y estamos esperando respuesta.
- `isSuccess` o `status === 'success'`: 隆xito! La operaci贸n se complet贸 y los datos de la respuesta (si los hay) est谩n disponibles en `mutation.data`.
- `isError` o `status === 'error'`: 隆Fracaso! La operaci贸n fall贸 y los detalles del error est谩n en `mutation.error`.

 **Fundamental**: Controlar estos estados no es opcional, es la base para construir interfaces de usuario robustas y comunicativas. Siempre debes manejar los estados `pending`, `success` y `error`.

---

## C - Efectos Secundarios (`onSuccess`, `onError`): Acciones Post-Misi贸n 

#### 1. **Introducci贸n:**

Los "efectos secundarios" son funciones que puedes configurar para que se ejecuten autom谩ticamente despu茅s de que una mutaci贸n termine, ya sea con 茅xito o con error.

#### 2. **Ejemplo:**

Imagina que despu茅s de a帽adir una nueva tarea, quieres que la lista de tareas se actualice autom谩ticamente para mostrar la nueva. Y si falla, quieres registrar el error en alg煤n sitio.

```tsx
import { useMutation, useQueryClient } from "@tanstack/react-query";

function App() {
  // 1. Obtenemos el Query Client
  const queryClient = useQueryClient();

  const addTodoMutation = useMutation({
    mutationFn: (nuevaTarea) => axios.post("/todos", nuevaTarea),

    // 2. 隆SI TODO SALE BIEN!
    onSuccess: () => {
      // Invalida la query 'todos'. Esto le dice a TanStack Query:
      // "La lista de 'todos' est谩 desactualizada, 隆vuelve a pedirla!"
      queryClient.invalidateQueries({ queryKey: ["todos"] });
      console.log("隆La tarea se a帽adi贸 y la lista se refrescar谩!");
    },

    // 3. 隆SI ALGO SALE MAL!
    onError: (error, variables, context) => {
      console.error("隆Oh no, algo fall贸!", error.message);
      // 'variables' son los datos que intentaste enviar: { id: ..., title: ... }
      console.log("Datos que fallaron:", variables);
    },

    // 4. 隆CUANDO TODO TERMINE (BIEN O MAL)!
    onSettled: () => {
      console.log("La misi贸n ha terminado, para bien o para mal.");
    },
  });

  // ... el resto del componente ...
}
```

**Explicaci贸n del ejemplo:**

1.  **`useQueryClient`**: Necesitamos esta herramienta para poder interactuar con otras queries de nuestra aplicaci贸n.
2.  **`onSuccess`**: Este bloque de c贸digo se ejecuta _solo si_ la `mutationFn` termina sin errores. Aqu铆, lo usamos para `invalidateQueries`. Invalidar una query es la forma m谩s com煤n y potente de mantener tu UI sincronizada con los datos del servidor.
3.  **`onError`**: Este se ejecuta _solo si_ la `mutationFn` lanza un error. Es el lugar perfecto para mostrar notificaciones de error, enviar reportes a un servicio de logging, o intentar revertir cambios optimistas (un tema m谩s avanzado).
4.  **`onSettled`**: Este se ejecuta _siempre_ que la mutaci贸n termina, sin importar si fue un 茅xito o un error. Es 煤til para tareas de limpieza que deben ocurrir en ambos casos, como ocultar un spinner de carga general.

#### 3. **Desarrollo**:

Estos callbacks son el pegamento que conecta tus mutaciones con el resto de tu aplicaci贸n. El patr贸n m谩s com煤n es: **Mutaci贸n exitosa (`onSuccess`) -> Invalidar queries relacionadas -> UI se actualiza autom谩ticamente.**

- `onMutate`: Se ejecuta _justo antes_ de la `mutationFn`. Es 煤til para actualizaciones optimistas (actualizar la UI _antes_ de que el servidor confirme).
- `onSuccess(data, variables, context)`: Recibe los datos de la respuesta (`data`), las variables que enviaste (`variables`) y el contexto de `onMutate`.
- `onError(error, variables, context)`: Recibe el error, las variables y el contexto.
- `onSettled(data, error, variables, context)`: Recibe el resultado (data o undefined) y el error (error o undefined).

 **Importante**: Usar `onSuccess` para invalidar queries es una t茅cnica central en TanStack Query. Dominar esto har谩 que tus aplicaciones se sientan incre铆blemente r谩pidas y reactivas.

---

## D - `mutate` vs. `mutateAsync`: 驴"Dispara y Olvida" o "Espera la Respuesta"? 

#### 1. **Introducci贸n:**

TanStack Query te da dos formas de ejecutar una mutaci贸n: `mutate` para acciones que no necesitan esperar, y `mutateAsync` para cuando necesitas que tu c贸digo se detenga hasta que la mutaci贸n termine.

#### 2. **Ejemplo Comparativo:**

**Escenario 1: Usando `mutate` (Dispara y Olvida)**
Quieres cerrar un modal despu茅s de enviar un formulario, sin importar si la petici贸n ya termin贸.

```tsx
// El componente que contiene el formulario
function EditProfileForm({ closeModal }) {
  const mutation = useMutation({
    mutationFn: updateUser,
    onSuccess: () => queryClient.invalidateQueries({ queryKey: ["profile"] }),
  });

  const handleSubmit = (data) => {
    mutation.mutate(data); // Lanza la petici贸n...
    closeModal(); // ...e inmediatamente cierra el modal. No espera.
  };

  return <form onSubmit={handleSubmit}>...</form>;
}
```

**Explicaci贸n:** `mutate` inicia la petici贸n y el c贸digo sigue ejecut谩ndose inmediatamente. Es perfecto para cuando la acci贸n de la UI (cerrar el modal) no depende del resultado de la mutaci贸n. Los estados (`isPending`, `isSuccess`) y los callbacks (`onSuccess`) se encargar谩n del resto en segundo plano.

**Escenario 2: Usando `mutateAsync` (Espera la Respuesta)**
Quieres crear un nuevo post y, _solo si tiene 茅xito_, redirigir al usuario a la p谩gina de ese nuevo post.

```tsx
import { useNavigate } from "react-router-dom";

function NewPostForm() {
  const navigate = useNavigate();
  const mutation = useMutation({ mutationFn: createPost });

  const handleSubmit = async (data) => {
    try {
      // Lanza la petici贸n y ESPERA a que termine
      const newPost = await mutation.mutateAsync(data);
      // Esta l铆nea solo se ejecuta si la mutaci贸n tuvo 茅xito
      navigate(`/posts/${newPost.id}`); // Redirige usando el ID de la respuesta
    } catch (error) {
      // Esta bloque se ejecuta si la mutaci贸n falla
      console.error("No se pudo crear el post:", error);
      alert("Error al crear el post. Int茅ntalo de nuevo.");
    }
  };

  return <form onSubmit={handleSubmit}>...</form>;
}
```

**Explicaci贸n:** `mutateAsync` devuelve una Promesa. Usando `await`, pausamos la ejecuci贸n de la funci贸n `handleSubmit` hasta que la promesa se resuelva (茅xito) o se rechace (error). Esto te da un control imperativo y secuencial sobre el flujo de tu l贸gica.

#### 3. **Desarrollo**:

La elecci贸n es simple y depende de lo que necesites hacer _justo despu茅s_ de iniciar la mutaci贸n:

- **Usa `mutate` (el 90% de las veces):** Cuando la l贸gica de 茅xito/error puede ser manejada de forma declarativa con los estados (`isPending`, etc.) y los callbacks (`onSuccess`, `onError`). Es el modo "TanStack Query".
- **Usa `mutateAsync`:** Cuando necesitas encadenar acciones de forma secuencial. Por ejemplo: "haz esto, y SI Y SOLO SI funciona, haz esto otro, y si falla, haz aquello". Es 煤til para flujos de trabajo complejos o para integrar con c贸digo que espera promesas.

 **Importante**: Entender esta diferencia es clave para escribir un c贸digo limpio y predecible. Abusa de `mutate` y los callbacks, y reserva `mutateAsync` para esos casos especiales donde el control secuencial es indispensable.

---

## E - `reset()`: Limpiando el Estado de la Mutaci贸n 

#### 1. **Introducci贸n:**

La funci贸n `reset` te permite devolver manualmente una mutaci贸n a su estado inicial (`idle`), limpiando cualquier dato o error que pudiera tener.

#### 2. **Ejemplo:**

Imagina que un formulario de login falla. Quieres mostrar el error, pero tambi茅n darle al usuario la oportunidad de "descartar" ese error y volver a intentarlo.

```tsx
function LoginForm() {
  const [email, setEmail] = useState("");
  const loginMutation = useMutation({ mutationFn: api.login });

  const handleSubmit = (e) => {
    e.preventDefault();
    loginMutation.mutate({ email });
  };

  return (
    <form onSubmit={handleSubmit}>
      {/* Si hay un error, mu茅stralo con un bot贸n para descartarlo */}
      {loginMutation.isError && (
        <div>
          <span>Error: {loginMutation.error.message}</span>
          {/* Al hacer clic, limpiamos el estado de la mutaci贸n */}
          <button type="button" onClick={() => loginMutation.reset()}>
            Descartar
          </button>
        </div>
      )}

      <input
        type="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <button type="submit" disabled={loginMutation.isPending}>
        {loginMutation.isPending ? "Iniciando sesi贸n..." : "Login"}
      </button>
    </form>
  );
}
```

**Explicaci贸n del ejemplo:**

Cuando `loginMutation` falla, `isError` se vuelve `true` y el mensaje de error aparece. Si no hici茅ramos nada, ese mensaje se quedar铆a ah铆 para siempre. Al llamar a `loginMutation.reset()`, estamos diciendo: "Ok, ya vi el error. Olv铆dalo y volvamos al principio". Esto hace que `isError` vuelva a ser `false`, `error` se vuelva `null`, y el mensaje de error desaparezca de la UI.

#### 3. **Desarrollo**:

Normalmente no necesitas llamar a `reset()` muy a menudo. Una nueva llamada a `mutate()` limpiar谩 autom谩ticamente el estado anterior. Sin embargo, `reset()` es muy 煤til en situaciones donde la UI necesita ser limpiada _sin_ iniciar una nueva mutaci贸n. El caso m谩s com煤n es permitir al usuario descartar un mensaje de error de un formulario que no se ha vuelto a enviar.

 **Espec铆fico**: Es una herramienta 煤til para casos de uso de UI muy concretos, principalmente para mejorar la experiencia del usuario al manejar errores. No la necesitar谩s en cada mutaci贸n, pero es bueno saber que existe para cuando la necesites.
