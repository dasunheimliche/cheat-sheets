### A - `placeholderData`: El "Doble de Acci√≥n" de tus Datos üü°

#### 1. **Introducci√≥n:**

Usa `placeholderData` para mostrar datos temporales o parciales de inmediato, haciendo que tu aplicaci√≥n se sienta s√∫per r√°pida, mientras los datos reales se cargan en segundo plano.

#### 2. **Ejemplo:**

Imagina que tienes una lista de art√≠culos en tu blog y quieres ver uno en detalle. Puedes usar la informaci√≥n que ya tienes de la lista (el t√≠tulo) como placeholder mientras cargas el contenido completo.

```tsx
function BlogPost({ postId }) {
  const queryClient = useQueryClient();

  const { data, isPlaceholderData } = useQuery({
    queryKey: ["post", postId],
    queryFn: () => fetchFullPost(postId), // Funci√≥n que trae el post completo

    // ¬°Aqu√≠ est√° la magia!
    placeholderData: () => {
      // Buscamos en los datos de OTRA query (la lista de posts)
      const previewData = queryClient
        .getQueryData(["posts"]) // La lista de todos los posts
        ?.find((post) => post.id === postId); // Encontramos el nuestro

      // Si lo encontramos, lo usamos como placeholder
      return previewData;
    },
  });

  // Si isPlaceholderData es true, podr√≠as mostrar el t√≠tulo con un efecto de "cargando"
  return (
    <div>
      <h1>{data.title}</h1>
      {isPlaceholderData ? (
        <p>Cargando contenido completo...</p>
      ) : (
        <p>{data.fullContent}</p>
      )}
    </div>
  );
}
```

**Explicaci√≥n del ejemplo:**

1.  **`queryKey: ['post', postId]`**: Identifica de forma √∫nica esta petici√≥n. Si `postId` cambia, TanStack Query sabe que es una nueva petici√≥n.
2.  **`queryFn: () => fetchFullPost(postId)`**: Esta es la funci√≥n que va a la red a buscar los datos _reales_ y completos del art√≠culo.
3.  **`placeholderData: () => { ... }`**: ¬°El coraz√≥n del asunto! Antes de ejecutar `queryFn`, TanStack Query ejecuta esta funci√≥n.
4.  **`queryClient.getQueryData(['posts'])`**: Le pedimos a TanStack Query: "Oye, ¬øtienes por ah√≠ los datos cacheados de la lista de 'posts'?".
5.  **`.find(...)`**: Buscamos en esa lista el art√≠culo espec√≠fico que coincide con nuestro `postId`.
6.  **`return previewData`**: Si encontramos ese art√≠culo "de vista previa", lo devolvemos. La UI se renderizar√° **inmediatamente** con este dato.
7.  **`isPlaceholderData`**: Esta es tu bandera. Es un booleano que te dice: "¬°Ojo! Lo que est√°s viendo ahora es el 'doble de acci√≥n', no el actor principal". Cuando los datos reales de `queryFn` llegan, `isPlaceholderData` se vuelve `false`.

#### 3. **Desarrollo**:

`placeholderData` es tu mejor aliado para mejorar la experiencia de usuario (UX). Su caracter√≠stica principal, y la que **DEBES** recordar para no confundirte, es que **estos datos no se guardan en la cach√© como datos "reales"**. Son como un post-it que pones y quitas.

**Confusi√≥n Com√∫n: `placeholderData` vs. `initialData`**

¬°CUIDADO AQU√ç! Esta es la duda n√∫mero uno y quiero que quede clar√≠sima.

- **`placeholderData`**: Es un "pr√©stamo". Lo usas para que la UI no se vea vac√≠a, pero en cuanto llegan los datos de verdad, se descarta. La query empieza en estado `success`, pero con la bandera `isPlaceholderData: true`. Es ideal para mostrar datos parciales que ya tienes de otra fuente (como en el ejemplo).
- **`initialData`**: Es un "pago inicial". Le das a la query unos datos iniciales que **s√≠ se guardan en la cach√©** como si fueran datos reales y frescos. La query tambi√©n empieza en estado `success`, pero sin ninguna bandera especial. Se usa cuando tienes los datos completos y actualizados desde el principio (por ejemplo, si vienen del servidor en el HTML inicial).

En resumen: ¬øQuieres mostrar datos temporales que no son la "verdad absoluta"? Usa `placeholderData`. ¬øTienes los datos reales y completos desde el inicio? Usa `initialData`.

üü° **Importante**: Es una herramienta clave para crear interfaces fluidas y con sensaci√≥n de inmediatez. No es estrictamente fundamental para que la librer√≠a funcione, pero dominarla separa una buena app de una app genial.

---

### B - `placeholderData` como Valor Fijo: Tu "Maqueta" de Datos üü°

#### 1. **Introducci√≥n:**

Puedes proporcionar un objeto o un array directamente como `placeholderData`, ideal para cuando tienes datos falsos o una estructura base que mostrar.

#### 2. **Ejemplo:**

Imagina que est√°s cargando una lista de tareas. Mientras esperas las tareas reales del servidor, puedes mostrar una estructura predefinida para que el usuario vea c√≥mo se ver√° la lista.

```tsx
// Unas tareas de mentira que tenemos en nuestro c√≥digo
const placeholderTodos = [
  { id: 1, text: "Cargando primera tarea..." },
  { id: 2, text: "Cargando segunda tarea..." },
];

function Todos() {
  const { data, isPlaceholderData } = useQuery({
    queryKey: ["todos"],
    queryFn: () => fetch("/api/todos"), // Va a buscar las tareas reales

    // Le pasamos directamente nuestro array de tareas falsas
    placeholderData: placeholderTodos,
  });

  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id} style={{ opacity: isPlaceholderData ? 0.5 : 1 }}>
          {todo.text}
        </li>
      ))}
    </ul>
  );
}
```

**Explicaci√≥n del ejemplo:**

1.  **`placeholderTodos`**: Es un simple array de objetos que hemos definido nosotros mismos. Es nuestra "maqueta".
2.  **`placeholderData: placeholderTodos`**: Le decimos a `useQuery`: "Si no tienes datos reales para la `queryKey` ['todos'], usa este array `placeholderTodos` mientras tanto".
3.  **`style={{ opacity: isPlaceholderData ? 0.5 : 1 }}`**: Este es un truco visual genial. Mientras los datos sean el placeholder (`isPlaceholderData` es `true`), los mostramos con un poco de opacidad. Cuando llegan los datos reales, la opacidad vuelve a 1. El usuario percibe una transici√≥n suave.

#### 3. **Desarrollo**:

Esta es la forma m√°s sencilla de usar `placeholderData`. Es perfecta para "esqueletos" de UI (UI Skeletons), donde muestras la forma del contenido antes de que el contenido mismo llegue.

**¬°Ojo con la memoizaci√≥n!** Si en lugar de un objeto simple, tuvieras una funci√≥n que _genera_ esos datos falsos (`generateFakeTodos()`), esa funci√≥n se ejecutar√≠a en cada re-renderizado del componente. Si es una funci√≥n pesada, podr√≠a afectar el rendimiento. Para eso, pasamos al siguiente concepto...

üü° **Importante**: Es una t√©cnica muy com√∫n y efectiva para evitar pantallas de carga vac√≠as. F√°cil de implementar y con un gran impacto en la UX.

---

### C - `useMemo` con `placeholderData`: Optimizando tu "Maqueta" üîµ

#### 1. **Introducci√≥n:**

Si la creaci√≥n de tus datos de placeholder es un proceso costoso, envu√©lvelo en `useMemo` para asegurarte de que solo se calcule una vez.

#### 2. **Ejemplo:**

Supongamos que la funci√≥n `generateFakeTodos()` es compleja: crea 100 tareas con nombres y fechas aleatorias. No queremos que se ejecute en cada render.

```tsx
import { useMemo } from "react";

// Funci√≥n que podr√≠a ser "pesada"
function generateFakeTodos() {
  console.log("¬°Generando datos falsos! (Esto solo deber√≠a pasar una vez)");
  // ...l√≥gica compleja para crear un array de tareas...
  return [{ id: 1, text: "Tarea falsa compleja" }];
}

function Todos() {
  // ¬°Aqu√≠ est√° la optimizaci√≥n!
  const placeholderData = useMemo(() => generateFakeTodos(), []);

  const { data } = useQuery({
    queryKey: ["todos"],
    queryFn: () => fetch("/api/todos"),
    placeholderData, // Usamos la variable memoizada
  });

  // ... el resto del componente ...
}
```

**Explicaci√≥n del ejemplo:**

1.  **`useMemo(() => generateFakeTodos(), [])`**: Esto le dice a React: "Ejecuta la funci√≥n `generateFakeTodos()` la primera vez que se renderice este componente. Guarda el resultado. En los siguientes renders, **no la vuelvas a ejecutar**, simplemente devu√©lveme el resultado que ya guardaste".
2.  **`[]`**: El array de dependencias vac√≠o significa que `useMemo` nunca encontrar√° una raz√≥n para recalcular el valor. Solo lo har√° una vez.
3.  **`placeholderData`**: Ahora, esta variable contiene el resultado de `generateFakeTodos()` y podemos pasarla a `useQuery` de forma segura, sabiendo que no estamos causando c√°lculos innecesarios en cada render.

#### 3. **Desarrollo**:

¬øCu√°ndo necesitas esto? La regla es simple: si tu `placeholderData` es un valor est√°tico (como en el concepto B), no necesitas `useMemo`. Si lo generas con una funci√≥n que hace algo m√°s que devolver un objeto simple (bucles, c√°lculos, etc.), **usa `useMemo`**.

Es una pr√°ctica de optimizaci√≥n. Tu aplicaci√≥n funcionar√° sin √©l, pero si notas que el componente se vuelve lento, esta es una de las primeras cosas que debes revisar. Es como afinar un instrumento: no es estrictamente necesario para tocar una nota, pero es crucial para que suene bien.

üîµ **Espec√≠fico**: Esta es una t√©cnica de optimizaci√≥n. No la necesitas siempre, pero es fundamental conocerla para casos donde la generaci√≥n de datos de placeholder pueda impactar el rendimiento.

---

### D - `placeholderData` como Funci√≥n: Transiciones Suaves entre P√°ginas üü°

#### 1. **Introducci√≥n:**

Al pasar `placeholderData` como una funci√≥n, puedes acceder a los datos de una query anterior para crear transiciones perfectas, como en una paginaci√≥n.

#### 2. **Ejemplo:**

Est√°s en la p√°gina 2 de una lista de tareas. Cuando haces clic para ir a la p√°gina 3, en lugar de ver un loader, quieres seguir viendo los datos de la p√°gina 2 hasta que los de la 3 est√©n listos.

```tsx
function Todos({ page }) {
  const { data, isPlaceholderData } = useQuery({
    // La queryKey ahora depende de la p√°gina
    queryKey: ["todos", page],
    queryFn: () => fetchTodos(page),

    // ¬°Aqu√≠ la funci√≥n m√°gica!
    // Recibe los datos de la √∫ltima ejecuci√≥n exitosa de esta query.
    placeholderData: (previousData, previousQuery) => {
      // Si hay datos anteriores, √∫salos como placeholder.
      // `previousQuery` tambi√©n est√° disponible si necesitas m√°s contexto.
      return previousData;
    },
    // Consejo extra: keepPreviousData hace algo similar pero MANTIENE los datos
    // anteriores como data real, no como placeholder. ¬°Otra herramienta √∫til!
  });

  // ... renderizas la lista y los botones de paginaci√≥n ...
}
```

**Explicaci√≥n del ejemplo:**

1.  **`queryKey: ['todos', page]`**: Cuando `page` cambia (de 2 a 3), TanStack Query sabe que es una nueva query.
2.  **`placeholderData: (previousData) => previousData`**: Aqu√≠ est√° el truco. TanStack Query te dice: "Ok, vas a hacer una nueva petici√≥n para `['todos', 3]`. ¬øQuieres usar los datos de la √∫ltima vez que esta query (con una key similar) tuvo √©xito? Aqu√≠ los tienes en `previousData`".
3.  **`return previousData`**: Simplemente devolvemos esos datos antiguos. El resultado es que la UI sigue mostrando la lista de la p√°gina 2, pero `isPlaceholderData` ser√° `true`. Cuando los datos de la p√°gina 3 llegan, la UI se actualiza y `isPlaceholderData` se vuelve `false`. ¬°Cero pantallas de carga!

#### 3. **Desarrollo**:

Esta t√©cnica es la piedra angular de las "Paginated Queries" y "Infinite Queries" en TanStack Query. Permite que el usuario navegue entre conjuntos de datos sin interrupciones visuales.

La funci√≥n recibe dos argumentos: `(previousData, previousQuery)`.

- `previousData`: Los datos de la √∫ltima ejecuci√≥n exitosa.
- `previousQuery`: El objeto completo de la query anterior, por si necesitas acceder a la `queryKey` antigua u otra metadata.

Esto te da un control incre√≠ble sobre la experiencia de transici√≥n de datos.

üü° **Importante**: Fundamental para cualquiera que implemente paginaci√≥n o cualquier funcionalidad donde la `queryKey` cambia y se desea una transici√≥n suave. Es una de las caracter√≠sticas m√°s potentes de la librer√≠a.

### E - `initialData` vs. `placeholderData`: El Duelo de los Datos Iniciales üî¥

#### 1. **Introducci√≥n:**

Usa `initialData` cuando tienes los datos **reales y completos** desde el principio, y `placeholderData` cuando solo tienes datos **temporales o parciales** para que la pantalla no se vea vac√≠a mientras esperas los de verdad.

#### 2. **Ejemplo Comparativo:**

Imagina que estamos cargando el perfil de un usuario. Veremos c√≥mo se comporta cada opci√≥n.

**Escenario 1: Usando `initialData` (Tienes los datos reales)**

Supongamos que el servidor nos envi√≥ los datos b√°sicos del usuario al cargar la p√°gina (Server-Side Rendering). ¬°Ya los tenemos! No hay necesidad de mostrarlos y luego pedir lo mismo.

```tsx
// Estos datos vinieron del servidor, son FRESCOS y REALES.
const userFromServer = { id: 1, name: "Ana", email: "ana@ejemplo.com" };

function UserProfile({ userId }) {
  const { data, status } = useQuery({
    queryKey: ["user", userId],
    queryFn: () => fetchUser(userId), // Se ejecutar√° si los datos se vuelven "viejos"

    // ¬°Aqu√≠ est√°! Le damos los datos REALES.
    initialData: userFromServer,
  });

  // `status` ser√° 'success' INMEDIATAMENTE.
  // `isPlaceholderData` NO EXISTE aqu√≠, siempre ser√° `undefined` o `false`.
  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.email}</p>
      {/* No hay indicador de carga porque ya ten√≠amos los datos */}
    </div>
  );
}
```

**Explicaci√≥n del ejemplo `initialData`:**
Le estamos diciendo a TanStack Query: "Conf√≠a en m√≠, estos son los datos correctos y frescos para `['user', 1]`. Ponlos en la cach√© **ahora mismo**". La query nace en estado `success`. No hay sensaci√≥n de carga ni datos temporales.

---

**Escenario 2: Usando `placeholderData` (Tienes datos parciales)**

Ahora imagina que venimos de una lista de usuarios donde solo ten√≠amos el nombre. Queremos mostrar ese nombre al instante mientras cargamos el resto del perfil (como el email).

```tsx
// Solo tenemos el nombre del usuario desde la pantalla anterior.
const userNameFromList = "Ana";

function UserProfile({ userId }) {
  const { data, isPlaceholderData } = useQuery({
    queryKey: ["user", userId],
    queryFn: () => fetchUser(userId), // Esta S√ç se ejecutar√° en segundo plano.

    // ¬°Aqu√≠ est√°! Le damos datos PARCIALES como un "mientras tanto".
    placeholderData: { name: userNameFromList },
  });

  // `isPlaceholderData` ser√° `true` al principio.
  return (
    <div>
      {/* El nombre se muestra al instante */}
      <h1>{data.name}</h1>

      {/* Mostramos un indicador mientras se carga el resto */}
      {isPlaceholderData ? <p>Cargando email...</p> : <p>{data.email}</p>}
    </div>
  );
}
```

**Explicaci√≥n del ejemplo `placeholderData`:**
Aqu√≠ le decimos a TanStack Query: "Oye, no tengo los datos reales, pero para que la pantalla no se vea vac√≠a, muestra este objeto `{ name: 'Ana' }` **temporalmente**. Mientras tanto, por favor, ve y busca los datos completos con `fetchUser`". La bandera `isPlaceholderData` es nuestra se√±al para saber que estamos viendo al "doble de acci√≥n".

#### 3. **Desarrollo: La Tabla Definitiva de la Verdad**

Para que no quede ni una sola sombra de duda, he aqu√≠ la comparaci√≥n directa. Piensa en esto cada vez que dudes.

| Caracter√≠stica           | `initialData` (El Pago Inicial üí∞)                                                                  | `placeholderData` (El Doble de Acci√≥n üé¨)                                                                                            |
| :----------------------- | :-------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| **Prop√≥sito Principal**  | Evitar una petici√≥n de red inicial si ya tienes los datos **reales**.                               | Mejorar la experiencia de usuario (UX) mostrando datos **temporales** para evitar pantallas de carga.                                |
| **¬øSe guarda en cach√©?** | **S√ç, ¬°ABSOLUTAMENTE!** Se escribe en la cach√© como si viniera de una petici√≥n exitosa.             | **¬°NO, NUNCA!** Es un dato fantasma. No se persiste en la cach√©. Se descarta en cuanto llegan los datos reales.                      |
| **Estado de la Query**   | Inicia en `status: 'success'`.                                                                      | Inicia en `status: 'success'`, PERO con la bandera `isPlaceholderData: true`.                                                        |
| **¬øDispara `queryFn`?**  | No inmediatamente. Solo si los datos se marcan como "viejos" (`stale`).                             | S√≠, `queryFn` se ejecuta siempre en segundo plano para obtener los datos reales.                                                     |
| **Analog√≠a Clave**       | Es como comprar un coche pagando el total por adelantado. El coche es tuyo desde el primer segundo. | Es como probar una maqueta de cart√≥n del coche en tu garaje. Te da una idea, pero no es el coche real. El coche real est√° en camino. |

---

### **La Trampa Mortal que Debes Evitar (¬°Mi Paranoia te Salvar√°!)**

El error m√°s peligroso que puedes cometer es **usar `initialData` con datos que podr√≠an estar desactualizados o ser parciales**.

**¬øPor qu√© es tan peligroso?**
Si le das a `initialData` un objeto con datos viejos, TanStack Query se lo creer√°. Pensar√°: "¬°Genial, datos frescos!", y los pondr√° en la cach√©. Dependiendo de tu configuraci√≥n de `staleTime`, podr√≠a pasar un buen rato antes de que la librer√≠a decida que necesita verificar si hay datos nuevos. Durante todo ese tiempo, **¬°le estar√°s mostrando informaci√≥n incorrecta a tu usuario!**

**Regla de Oro:**

- Si los datos que tienes son la **verdad absoluta y actual** en el momento de renderizar (ej: vienen del servidor en esa misma carga de p√°gina), usa `initialData`.
- Si los datos son una **aproximaci√≥n, parciales, o podr√≠an estar viejos** (ej: vienen de la cach√© de otra query, o de una lista anterior), usa SIEMPRE `placeholderData`.
