## A - Herramientas de Depuraci칩n (DevTools): Tus Ojos Dentro de React Query 游리

#### 1. **Introducci칩n:**

Para poder "ver" lo que React Query est치 haciendo por dentro (el estado de tus datos, si est치n cargando, si hay errores), necesitas unas herramientas especiales que se conectan a tu app.

#### 2. **Ejemplo (Opciones disponibles):**

No hay un c칩digo que escribir aqu칤, sino herramientas que puedes instalar. 춰Son como las gafas que te pones para ver el mundo de los datos!

- **Para macOS:** Una aplicaci칩n nativa que funciona con cualquier app de JavaScript.
  - [rn-better-dev-tools](https://github.com/LovesWorking/rn-better-dev-tools)
- **Para usuarios de Flipper:** Un plugin que se integra con la popular herramienta de depuraci칩n Flipper.
  - [react-query-native-devtools](https://github.com/bgaleotti/react-query-native-devtools)
- **Para usuarios de Reactotron:** Si ya usas Reactotron, este plugin es para ti.
  - [reactotron-react-query](https://github.com/hsndmr/reactotron-react-query)

#### 3. **Desarrollo:**

A diferencia del desarrollo web, donde las herramientas de depuraci칩n del navegador son un est치ndar, en React Native necesitas elegir e instalar una de estas opciones. Es un peque침o paso extra, pero te juro que te ahorrar치 horas de frustraci칩n. Poder visualizar el ciclo de vida de tus datos es como tener superpoderes.

游리 **Importante**: Podr칤as programar sin esto, claro, pero ser칤a como intentar montar un mueble de IKEA con los ojos vendados. Es una de esas cosas que, una vez que las usas, no entiendes c칩mo pudiste vivir sin ellas. 춰Instala una, la que prefieras, pero hazte ese favor!

---

## B - `onlineManager`: El Guardi치n de tu Conexi칩n a Internet 游리

#### 1. **Introducci칩n:**

Le ense침a a React Query a saber si el tel칠fono est치 conectado a internet o no, para que pueda reintentar las peticiones de datos autom치ticamente cuando la conexi칩n vuelva.

#### 2. **Ejemplo:**

```tsx
// Primero, necesitas instalar esta librer칤a: npm install @react-native-community/netinfo
import NetInfo from "@react-native-community/netinfo";
import { onlineManager } from "@tanstack/react-query";

onlineManager.setEventListener((setOnline) => {
  // Le decimos a NetInfo que empiece a escuchar los cambios de conexi칩n
  return NetInfo.addEventListener((state) => {
    // Cuando hay un cambio, le avisamos a React Query si estamos conectados o no
    setOnline(!!state.isConnected);
  });
});
```

**Explicaci칩n del ejemplo:**
Imagina que React Query es un director de orquesta y `NetInfo` es un m칰sico que tiene la partitura del "estado de internet".

1.  `onlineManager.setEventListener(...)`: El director (React Query) le dice: "Voy a poner un 'escuchador' para que me avises del estado de la conexi칩n".
2.  `NetInfo.addEventListener(...)`: El m칰sico (`NetInfo`) empieza a leer la partitura (el estado de la red del tel칠fono) constantemente.
3.  `setOnline(!!state.isConnected)`: Cada vez que la partitura cambia (el tel칠fono se conecta o desconecta), el m칰sico le grita al director: "춰Hey, ahora estamos conectados!" (`true`) o "춰Perdimos la conexi칩n!" (`false`). El `!!` es un truco genial para asegurarse de que el valor sea un booleano puro (`true` o `false`), sin ambig칲edades.

#### 3. **Desarrollo:**

En una aplicaci칩n m칩vil, la conexi칩n a internet es fr치gil. El usuario puede entrar en un t칰nel, un ascensor o simplemente quedarse sin datos. Sin esta configuraci칩n, si una petici칩n de datos falla por falta de conexi칩n, React Query no sabr칤a por qu칠 y podr칤a no reintentarlo de forma inteligente. Al usar `onlineManager`, le das a React Query la inteligencia para pausar sus intentos cuando no hay conexi칩n y reanudarlos triunfalmente en cuanto vuelve.

游리 **Importante**: Esto es clave para una buena experiencia de usuario en m칩vil. Hace que tu aplicaci칩n se sienta robusta y consciente de su entorno, en lugar de simplemente fallar sin explicaci칩n.

---

## C - `focusManager`: Refrescando Datos Cuando el Usuario Vuelve a la App 游리

#### 1. **Introducci칩n:**

Actualiza autom치ticamente los datos de tu aplicaci칩n cuando el usuario la vuelve a poner en primer plano despu칠s de haberla minimizado o cambiado a otra app.

#### 2. **Ejemplo:**

```tsx
import { useEffect } from "react";
import { AppState, Platform } from "react-native";
import { focusManager } from "@tanstack/react-query";

function onAppStateChange(status) {
  // Solo nos interesa en m칩vil, no en web
  if (Platform.OS !== "web") {
    // Le decimos a React Query si la app est치 "enfocada" (activa) o no
    focusManager.setFocused(status === "active");
  }
}

// Este c칩digo deber칤as ponerlo en el componente principal de tu app, como App.js
useEffect(() => {
  // Empezamos a escuchar los cambios de estado de la app
  const subscription = AppState.addEventListener("change", onAppStateChange);

  // 춰MUY IMPORTANTE! Limpiamos el "escuchador" cuando el componente se desmonta
  return () => subscription.remove();
}, []);
```

**Explicaci칩n del ejemplo:**
Piensa que `focusManager` es el portero de una discoteca.

1.  `AppState.addEventListener('change', ...)`: Contratamos a un vigilante (`AppState`) para que nos avise cada vez que la puerta principal de la discoteca (tu app) se abre o se cierra.
2.  `onAppStateChange(status)`: Cada vez que el vigilante ve un cambio, llama al portero (`focusManager`).
3.  `focusManager.setFocused(status === 'active')`: El portero entonces actualiza el estado de la discoteca. Si el `status` es `'active'` (la gente est치 entrando y la fiesta est치 en su apogeo), el portero dice "춰Estamos abiertos y activos!". Si no, dice "Estamos cerrados por ahora". React Query usa esta informaci칩n para saber si debe refrescar los datos.
4.  `return () => subscription.remove()`: Esto es crucial. Es como decirle al vigilante que su turno ha terminado cuando la discoteca cierra para siempre. Si no lo haces, el vigilante se queda ah칤 para siempre, consumiendo recursos (un problema conocido como "fuga de memoria").

#### 3. **Desarrollo:**

Cuando un usuario cambia a WhatsApp y luego vuelve a tu app, espera ver la informaci칩n m치s reciente, no lo que hab칤a hace 5 minutos. Este mecanismo se encarga de eso autom치ticamente. Le da a tu app una sensaci칩n de estar siempre "viva" y actualizada.

游리 **Importante**: Al igual que el `onlineManager`, esto es fundamental para una experiencia de usuario moderna y fluida en dispositivos m칩viles. Es una de las caracter칤sticas estrella de React Query.

---

## D - `useRefreshOnFocus`: Refrescando Datos al Volver a una Pantalla Espec칤fica 游댯

#### 1. **Introducci칩n:**

Este es un _hook_ personalizado que creas t칰 mismo para volver a pedir los datos de una **pantalla espec칤fica** cada vez que el usuario navega hacia ella (no confundir con volver a la app entera).

#### 2. **Ejemplo (Creando el hook):**

```tsx
// Este es el c칩digo de tu hook personalizado. Gu치rdalo en un archivo, ej: useRefreshOnFocus.js
import React from "react";
import { useFocusEffect } from "@react-navigation/native";

export function useRefreshOnFocus(refetch) {
  const firstTimeRef = React.useRef(true);

  useFocusEffect(
    React.useCallback(() => {
      // Si es la primera vez que la pantalla se carga, no hacemos nada.
      if (firstTimeRef.current) {
        firstTimeRef.current = false;
        return;
      }

      // En las siguientes veces que se enfoca la pantalla, 춰refrescamos los datos!
      refetch();
    }, [refetch])
  );
}
```

**Explicaci칩n del ejemplo:**
Imagina que cada pantalla es una habitaci칩n y `useFocusEffect` es un sensor de movimiento.

1.  `const firstTimeRef = React.useRef(true)`: Colocamos una peque침a nota en la puerta que dice "No he entrado nunca". `useRef` es perfecto para esto, porque el valor de la nota no se pierde aunque la habitaci칩n se re-decore (re-renderice).
2.  `useFocusEffect(...)`: El sensor de movimiento se activa cada vez que alguien entra en la habitaci칩n (la pantalla se enfoca).
3.  `if (firstTimeRef.current)`: La primera vez que entras, el sensor lee la nota, ve que dice "No he entrado nunca", as칤 que cambia la nota a "Ya he entrado" y apaga la luz (con `return`). No hace nada m치s.
4.  `refetch()`: La _pr칩xima vez_ que entres, el sensor leer치 la nota "Ya he entrado", ignorar치 el `if` y encender치 la luz principal (`refetch`), que en este caso es pedir los datos de nuevo.

#### 3. **Desarrollo:**

Esto es 칰til para escenarios donde los datos de una pantalla pueden quedar desactualizados mientras el usuario navega por _otras pantallas_ de la misma app. Por ejemplo, imagina una pantalla con una lista de "Mis Tareas" y otra pantalla para "A침adir Tarea". Despu칠s de a침adir una tarea, cuando el usuario vuelve a la lista, quieres que la nueva tarea aparezca. Este hook lo hace posible.

游댯 **Espec칤fico**: No lo necesitas en todas las pantallas. 칔salo estrat칠gicamente en aquellas donde los datos deben estar s칰per frescos cada vez que el usuario las visita.

---

## E - `subscribed`: Pausando Queries en Pantallas Fuera de Foco 游댯

#### 1. **Introducci칩n:**

Es una opci칩n de `useQuery` que te permite "apagar" temporalmente una consulta de datos para que no consuma recursos (bater칤a, datos de internet) cuando el usuario no est치 viendo esa pantalla.

#### 2. **Ejemplo:**

```tsx
import { useIsFocused } from '@react-navigation/native';
import { useQuery } from '@tanstack/react-query';
import { Text } from 'react-native';

function MiComponenteDePantalla() {
  // useIsFocused nos da un simple `true` o `false`
  const isFocused = useIsFocused();

  const { data } = useQuery({
    queryKey: ['datos-importantes'],
    queryFn: () => fetch(...),
    // 춰La magia est치 aqu칤! La query solo "vive" si la pantalla est치 enfocada.
    subscribed: isFocused,
  });

  return <Text>Datos: {JSON.stringify(data)}</Text>;
}
```

**Explicaci칩n del ejemplo:**
Piensa en la query como una radio que reproduce m칰sica (datos frescos).

1.  `const isFocused = useIsFocused()`: Tenemos un interruptor que nos dice si alguien est치 en la habitaci칩n para escuchar la radio (`true`) o no (`false`).
2.  `subscribed: isFocused`: Conectamos ese interruptor directamente al enchufe de la radio.
3.  **쯈u칠 pasa?**
    - Cuando el usuario est치 en la pantalla, `isFocused` es `true`. La radio est치 encendida y recibe la se침al (pide datos, se actualiza, etc.).
    - Cuando el usuario se va a otra pantalla, `isFocused` se vuelve `false`. La radio se apaga por completo. No consume electricidad (recursos) y no hace ruido (no causa re-renders).
    - Cuando el usuario vuelve, `isFocused` se vuelve `true` de nuevo, la radio se enciende y vuelve a sintonizar la emisora.

#### 3. **Desarrollo:**

Esta es una herramienta de optimizaci칩n. Es especialmente 칰til para pantallas que muestran datos en tiempo real o que se actualizan con mucha frecuencia. Si el usuario no est치 viendo la pantalla, 쯣ara qu칠 gastar bater칤a y datos en actualizar algo que nadie ve? Es una forma elegante de hacer que tu app sea m치s eficiente y respetuosa con el dispositivo del usuario.

游댯 **Espec칤fico**: Es una optimizaci칩n para casos concretos. No es necesario (ni recomendable) aplicarlo a todas las queries de tu aplicaci칩n, solo a las que son particularmente "costosas" o de alta frecuencia.
