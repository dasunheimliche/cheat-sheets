## A - Herramientas de Depuración (DevTools): Tus Ojos Dentro de React Query 🟡

#### 1. **Introducción:**

Para poder "ver" lo que React Query está haciendo por dentro (el estado de tus datos, si están cargando, si hay errores), necesitas unas herramientas especiales que se conectan a tu app.

#### 2. **Ejemplo (Opciones disponibles):**

No hay un código que escribir aquí, sino herramientas que puedes instalar. ¡Son como las gafas que te pones para ver el mundo de los datos!

- **Para macOS:** Una aplicación nativa que funciona con cualquier app de JavaScript.
  - [rn-better-dev-tools](https://github.com/LovesWorking/rn-better-dev-tools)
- **Para usuarios de Flipper:** Un plugin que se integra con la popular herramienta de depuración Flipper.
  - [react-query-native-devtools](https://github.com/bgaleotti/react-query-native-devtools)
- **Para usuarios de Reactotron:** Si ya usas Reactotron, este plugin es para ti.
  - [reactotron-react-query](https://github.com/hsndmr/reactotron-react-query)

#### 3. **Desarrollo:**

A diferencia del desarrollo web, donde las herramientas de depuración del navegador son un estándar, en React Native necesitas elegir e instalar una de estas opciones. Es un pequeño paso extra, pero te juro que te ahorrará horas de frustración. Poder visualizar el ciclo de vida de tus datos es como tener superpoderes.

🟡 **Importante**: Podrías programar sin esto, claro, pero sería como intentar montar un mueble de IKEA con los ojos vendados. Es una de esas cosas que, una vez que las usas, no entiendes cómo pudiste vivir sin ellas. ¡Instala una, la que prefieras, pero hazte ese favor!

---

## B - `onlineManager`: El Guardián de tu Conexión a Internet 🟡

#### 1. **Introducción:**

Le enseña a React Query a saber si el teléfono está conectado a internet o no, para que pueda reintentar las peticiones de datos automáticamente cuando la conexión vuelva.

#### 2. **Ejemplo:**

```tsx
// Primero, necesitas instalar esta librería: npm install @react-native-community/netinfo
import NetInfo from "@react-native-community/netinfo";
import { onlineManager } from "@tanstack/react-query";

onlineManager.setEventListener((setOnline) => {
  // Le decimos a NetInfo que empiece a escuchar los cambios de conexión
  return NetInfo.addEventListener((state) => {
    // Cuando hay un cambio, le avisamos a React Query si estamos conectados o no
    setOnline(!!state.isConnected);
  });
});
```

**Explicación del ejemplo:**
Imagina que React Query es un director de orquesta y `NetInfo` es un músico que tiene la partitura del "estado de internet".

1.  `onlineManager.setEventListener(...)`: El director (React Query) le dice: "Voy a poner un 'escuchador' para que me avises del estado de la conexión".
2.  `NetInfo.addEventListener(...)`: El músico (`NetInfo`) empieza a leer la partitura (el estado de la red del teléfono) constantemente.
3.  `setOnline(!!state.isConnected)`: Cada vez que la partitura cambia (el teléfono se conecta o desconecta), el músico le grita al director: "¡Hey, ahora estamos conectados!" (`true`) o "¡Perdimos la conexión!" (`false`). El `!!` es un truco genial para asegurarse de que el valor sea un booleano puro (`true` o `false`), sin ambigüedades.

#### 3. **Desarrollo:**

En una aplicación móvil, la conexión a internet es frágil. El usuario puede entrar en un túnel, un ascensor o simplemente quedarse sin datos. Sin esta configuración, si una petición de datos falla por falta de conexión, React Query no sabría por qué y podría no reintentarlo de forma inteligente. Al usar `onlineManager`, le das a React Query la inteligencia para pausar sus intentos cuando no hay conexión y reanudarlos triunfalmente en cuanto vuelve.

🟡 **Importante**: Esto es clave para una buena experiencia de usuario en móvil. Hace que tu aplicación se sienta robusta y consciente de su entorno, en lugar de simplemente fallar sin explicación.

---

## C - `focusManager`: Refrescando Datos Cuando el Usuario Vuelve a la App 🟡

#### 1. **Introducción:**

Actualiza automáticamente los datos de tu aplicación cuando el usuario la vuelve a poner en primer plano después de haberla minimizado o cambiado a otra app.

#### 2. **Ejemplo:**

```tsx
import { useEffect } from "react";
import { AppState, Platform } from "react-native";
import { focusManager } from "@tanstack/react-query";

function onAppStateChange(status) {
  // Solo nos interesa en móvil, no en web
  if (Platform.OS !== "web") {
    // Le decimos a React Query si la app está "enfocada" (activa) o no
    focusManager.setFocused(status === "active");
  }
}

// Este código deberías ponerlo en el componente principal de tu app, como App.js
useEffect(() => {
  // Empezamos a escuchar los cambios de estado de la app
  const subscription = AppState.addEventListener("change", onAppStateChange);

  // ¡MUY IMPORTANTE! Limpiamos el "escuchador" cuando el componente se desmonta
  return () => subscription.remove();
}, []);
```

**Explicación del ejemplo:**
Piensa que `focusManager` es el portero de una discoteca.

1.  `AppState.addEventListener('change', ...)`: Contratamos a un vigilante (`AppState`) para que nos avise cada vez que la puerta principal de la discoteca (tu app) se abre o se cierra.
2.  `onAppStateChange(status)`: Cada vez que el vigilante ve un cambio, llama al portero (`focusManager`).
3.  `focusManager.setFocused(status === 'active')`: El portero entonces actualiza el estado de la discoteca. Si el `status` es `'active'` (la gente está entrando y la fiesta está en su apogeo), el portero dice "¡Estamos abiertos y activos!". Si no, dice "Estamos cerrados por ahora". React Query usa esta información para saber si debe refrescar los datos.
4.  `return () => subscription.remove()`: Esto es crucial. Es como decirle al vigilante que su turno ha terminado cuando la discoteca cierra para siempre. Si no lo haces, el vigilante se queda ahí para siempre, consumiendo recursos (un problema conocido como "fuga de memoria").

#### 3. **Desarrollo:**

Cuando un usuario cambia a WhatsApp y luego vuelve a tu app, espera ver la información más reciente, no lo que había hace 5 minutos. Este mecanismo se encarga de eso automáticamente. Le da a tu app una sensación de estar siempre "viva" y actualizada.

🟡 **Importante**: Al igual que el `onlineManager`, esto es fundamental para una experiencia de usuario moderna y fluida en dispositivos móviles. Es una de las características estrella de React Query.

---

## D - `useRefreshOnFocus`: Refrescando Datos al Volver a una Pantalla Específica 🔵

#### 1. **Introducción:**

Este es un _hook_ personalizado que creas tú mismo para volver a pedir los datos de una **pantalla específica** cada vez que el usuario navega hacia ella (no confundir con volver a la app entera).

#### 2. **Ejemplo (Creando el hook):**

```tsx
// Este es el código de tu hook personalizado. Guárdalo en un archivo, ej: useRefreshOnFocus.js
import React from "react";
import { useFocusEffect } from "@react-navigation/native";

export function useRefreshOnFocus(refetch) {
  const firstTimeRef = React.useRef(true);

  useFocusEffect(
    React.useCallback(() => {
      // Si es la primera vez que la pantalla se carga, no hacemos nada.
      if (firstTimeRef.current) {
        firstTimeRef.current = false;
        return;
      }

      // En las siguientes veces que se enfoca la pantalla, ¡refrescamos los datos!
      refetch();
    }, [refetch])
  );
}
```

**Explicación del ejemplo:**
Imagina que cada pantalla es una habitación y `useFocusEffect` es un sensor de movimiento.

1.  `const firstTimeRef = React.useRef(true)`: Colocamos una pequeña nota en la puerta que dice "No he entrado nunca". `useRef` es perfecto para esto, porque el valor de la nota no se pierde aunque la habitación se re-decore (re-renderice).
2.  `useFocusEffect(...)`: El sensor de movimiento se activa cada vez que alguien entra en la habitación (la pantalla se enfoca).
3.  `if (firstTimeRef.current)`: La primera vez que entras, el sensor lee la nota, ve que dice "No he entrado nunca", así que cambia la nota a "Ya he entrado" y apaga la luz (con `return`). No hace nada más.
4.  `refetch()`: La _próxima vez_ que entres, el sensor leerá la nota "Ya he entrado", ignorará el `if` y encenderá la luz principal (`refetch`), que en este caso es pedir los datos de nuevo.

#### 3. **Desarrollo:**

Esto es útil para escenarios donde los datos de una pantalla pueden quedar desactualizados mientras el usuario navega por _otras pantallas_ de la misma app. Por ejemplo, imagina una pantalla con una lista de "Mis Tareas" y otra pantalla para "Añadir Tarea". Después de añadir una tarea, cuando el usuario vuelve a la lista, quieres que la nueva tarea aparezca. Este hook lo hace posible.

🔵 **Específico**: No lo necesitas en todas las pantallas. Úsalo estratégicamente en aquellas donde los datos deben estar súper frescos cada vez que el usuario las visita.

---

## E - `subscribed`: Pausando Queries en Pantallas Fuera de Foco 🔵

#### 1. **Introducción:**

Es una opción de `useQuery` que te permite "apagar" temporalmente una consulta de datos para que no consuma recursos (batería, datos de internet) cuando el usuario no está viendo esa pantalla.

#### 2. **Ejemplo:**

```tsx
import { useIsFocused } from '@react-navigation/native';
import { useQuery } from '@tanstack/react-query';
import { Text } from 'react-native';

function MiComponenteDePantalla() {
  // useIsFocused nos da un simple `true` o `false`
  const isFocused = useIsFocused();

  const { data } = useQuery({
    queryKey: ['datos-importantes'],
    queryFn: () => fetch(...),
    // ¡La magia está aquí! La query solo "vive" si la pantalla está enfocada.
    subscribed: isFocused,
  });

  return <Text>Datos: {JSON.stringify(data)}</Text>;
}
```

**Explicación del ejemplo:**
Piensa en la query como una radio que reproduce música (datos frescos).

1.  `const isFocused = useIsFocused()`: Tenemos un interruptor que nos dice si alguien está en la habitación para escuchar la radio (`true`) o no (`false`).
2.  `subscribed: isFocused`: Conectamos ese interruptor directamente al enchufe de la radio.
3.  **¿Qué pasa?**
    - Cuando el usuario está en la pantalla, `isFocused` es `true`. La radio está encendida y recibe la señal (pide datos, se actualiza, etc.).
    - Cuando el usuario se va a otra pantalla, `isFocused` se vuelve `false`. La radio se apaga por completo. No consume electricidad (recursos) y no hace ruido (no causa re-renders).
    - Cuando el usuario vuelve, `isFocused` se vuelve `true` de nuevo, la radio se enciende y vuelve a sintonizar la emisora.

#### 3. **Desarrollo:**

Esta es una herramienta de optimización. Es especialmente útil para pantallas que muestran datos en tiempo real o que se actualizan con mucha frecuencia. Si el usuario no está viendo la pantalla, ¿para qué gastar batería y datos en actualizar algo que nadie ve? Es una forma elegante de hacer que tu app sea más eficiente y respetuosa con el dispositivo del usuario.

🔵 **Específico**: Es una optimización para casos concretos. No es necesario (ni recomendable) aplicarlo a todas las queries de tu aplicación, solo a las que son particularmente "costosas" o de alta frecuencia.
