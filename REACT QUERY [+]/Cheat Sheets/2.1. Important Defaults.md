## A - Datos "Stale" (Obsoletos) por Defecto: El Estado de Alerta Constante üî¥

#### 1. **Introducci√≥n:**

Por defecto, TanStack Query considera que los datos que tiene en cach√© est√°n "obsoletos" (`stale`) en el instante en que los recibe, lo que lo mantiene listo para actualizarlos.

#### 2. **Ejemplo (Conceptual):**

Imagina que le preguntas la hora a un amigo. Te dice: "Son las 10:00 AM". Inmediatamente despu√©s de dec√≠rtelo, √©l ya piensa: "Ok, esa hora ya es del pasado, podr√≠a haber cambiado". No te va a gritar la hora nueva cada segundo, pero si le vuelves a preguntar, mirar√° su reloj de nuevo (har√° una nueva petici√≥n) en lugar de repetirte "las 10:00 AM".

**Explicaci√≥n del ejemplo:**
As√≠ funciona TanStack Query. En cuanto una consulta (`useQuery`) obtiene los datos, los etiqueta internamente como `stale`. Esto no significa que sean malos o incorrectos, solo que la librer√≠a est√° "en alerta" y aprovechar√° la pr√≥xima oportunidad (como que cambies de pesta√±a) para revalidarlos.

#### 3. **Desarrollo:**

Esta es la famosa configuraci√≥n "agresiva pero sensata". Es "agresiva" porque siempre quiere tener los datos m√°s frescos, lo que puede llevar a m√°s peticiones de las que un principiante esperar√≠a. Es "sensata" porque previene que tu aplicaci√≥n muestre informaci√≥n desactualizada, un problema muy com√∫n y dif√≠cil de depurar. Entender este concepto es la clave para dominar la librer√≠a y no sentir que hace "magia" por detr√°s.

üî¥ **Fundamental**: Este es el concepto **n√∫mero uno** que debes entender. Si no lo interiorizas, te preguntar√°s constantemente: "¬øPor qu√© mi aplicaci√≥n est√° haciendo tantas peticiones a la API?". La respuesta casi siempre est√° aqu√≠.

---

## B - `staleTime`: Poni√©ndole Fecha de Caducidad a tus Datos üî¥

#### 1. **Introducci√≥n:**

`staleTime` es la opci√≥n que te permite decirle a TanStack Query: "Oye, rel√°jate. Conf√≠a en estos datos durante X tiempo antes de empezar a considerarlos obsoletos (`stale`)".

#### 2. **Ejemplo:**

```javascript
import { useQuery } from "@tanstack/react-query";

function UserProfile() {
  const { data } = useQuery({
    queryKey: ["userProfile", 1], // Una clave √∫nica para esta consulta
    queryFn: fetchUserProfile, // La funci√≥n que pide los datos

    // ¬°Aqu√≠ est√° la magia!
    staleTime: 1000 * 60 * 5, // 5 minutos
  });

  // ...
}
```

**Explicaci√≥n del ejemplo:**
Con `staleTime: 300000`, le estamos diciendo a TanStack Query: "Una vez que obtengas el perfil de este usuario, considera que esos datos son frescos (`fresh`) durante los pr√≥ximos 5 minutos". Durante ese tiempo, no importa si el usuario cambia de pesta√±a, si un nuevo componente pide los mismos datos... TanStack Query simplemente devolver√° los datos de la cach√© al instante, sin hacer una nueva llamada a la API. ¬°Adi√≥s, peticiones innecesarias!

#### 3. **Desarrollo:**

`staleTime` es tu principal herramienta para optimizar el rendimiento.

- **`staleTime: 0`**: El comportamiento por defecto (los datos son `stale` inmediatamente).
- **`staleTime: 60000`**: Los datos son frescos durante 1 minuto. Ideal para datos que no cambian constantemente.
- **`staleTime: Infinity`**: Los datos se consideran frescos para siempre. Solo se actualizar√°n si los invalidas manualmente. ¬°√ösalo con cuidado! Es perfecto para datos que NUNCA cambian, como una lista de pa√≠ses.
- **`staleTime: 'static'`**: A√∫n m√°s estricto que `Infinity`. Los datos NUNCA se actualizar√°n, ni siquiera si los invalidas manualmente. Esto es muy raro de usar.

üî¥ **Fundamental**: Junto con el concepto de `stale` (ver **Concepto A**), `staleTime` es la palanca m√°s importante que tienes para controlar el comportamiento de TanStack Query. Aprender a ajustarlo bien es la diferencia entre una app normal y una app s√∫per r√°pida y eficiente.

---

## C - Refrescos Autom√°ticos: Los "Gatillos" de TanStack Query üî¥

#### 1. **Introducci√≥n:**

Cuando una consulta tiene datos `stale` (ver **Concepto A**), TanStack Query los actualizar√° autom√°ticamente en segundo plano si ocurre uno de estos tres eventos comunes.

#### 2. **Ejemplo (Conceptual):**

Pensemos de nuevo en el men√∫ del restaurante que ya es `stale` (el camarero sospecha que pudo haber cambiado). El camarero no te interrumpe mientras comes, pero ir√° a la cocina a confirmar el men√∫ si:

1.  **Un nuevo componente se monta (`refetchOnMount`):** Un nuevo amigo se sienta en tu mesa y pregunta por el men√∫. ¬°Oportunidad perfecta para que el camarero vaya a la cocina a comprobarlo!
2.  **La ventana recupera el foco (`refetchOnWindowFocus`):** Te distraes mirando el m√≥vil (cambias a otra pesta√±a o programa). Cuando vuelves a mirar la mesa (la ventana de tu app recupera el foco), el camarero, muy atento, va a la cocina por si acaso el men√∫ cambi√≥ mientras no mirabas.
3.  **La red se reconecta (`refetchOnReconnect`):** Se va la luz en el restaurante (pierdes la conexi√≥n a internet). Cuando vuelve, lo primero que hace el camarero es correr a la cocina para asegurarse de que todo sigue igual.

#### 3. **Desarrollo:**

Estos tres "gatillos" son la raz√≥n por la que TanStack Query se siente tan "vivo" y responsivo. Mantiene los datos de tu UI sincronizados con el servidor casi sin esfuerzo por tu parte. Si este comportamiento no te gusta para una consulta espec√≠fica, puedes desactivarlo:

```javascript
useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
  refetchOnWindowFocus: false, // No actualices al cambiar de pesta√±a
  refetchOnMount: false, // No actualices si otro componente lo usa
});
```

Recuerda: estos gatillos solo se activan si los datos son `stale`. Si tienes un `staleTime` de 1 hora (ver **Concepto B**), nada de esto ocurrir√° durante esa hora.

üî¥ **Fundamental**: Entender estos gatillos es crucial para evitar sorpresas. Si alguna vez te preguntas "¬øpor qu√© se ha disparado esta petici√≥n si no he hecho nada?", la respuesta probablemente sea uno de estos tres eventos.

---

## D - Consultas "Inactivas" y `gcTime`: El Recolector de Basura de la Cach√© üü°

#### 1. **Introducci√≥n:**

Cuando ning√∫n componente est√° usando activamente una consulta, esta se marca como "inactiva" y `gcTime` (Garbage Collector Time) define cu√°nto tiempo permanecer√° en la cach√© antes de ser eliminada por completo.

#### 2. **Ejemplo:**

Imagina que est√°s viendo una lista de productos. Sales de esa p√°gina para ver tu perfil. En ese momento, la consulta de "lista de productos" ya no tiene ning√∫n componente `useQuery` observ√°ndola, as√≠ que se vuelve **inactiva**.

Por defecto, TanStack Query la mantiene en la cach√© durante **5 minutos** (`gcTime`).

- **Si vuelves a la p√°gina de productos antes de 5 minutos:** ¬°Genial! Los datos siguen ah√≠. TanStack Query los reutiliza instant√°neamente (y si son `stale`, los refrescar√° en segundo plano).
- **Si vuelves despu√©s de 5 minutos:** La consulta ya fue borrada por el "recolector de basura". TanStack Query tendr√° que pedir los datos desde cero, mostrando un estado de carga.

Puedes cambiar este tiempo as√≠:

```javascript
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 10, // 10 minutos
    },
  },
});
```

#### 3. **Desarrollo:**

**¬°No confundas `gcTime` con `staleTime`!** Esta es la duda m√°s com√∫n.

- `staleTime`: ¬øCu√°ndo se consideran los datos **viejos**? (Afecta a si se hacen peticiones).
- `gcTime`: ¬øCu√°ndo se **borran** los datos de la memoria si nadie los usa? (Afecta a la gesti√≥n de memoria).

Una consulta puede ser `stale` (vieja) pero `active` (en uso). Una consulta solo puede ser eliminada por el recolector de basura cuando est√° `inactive`. Por defecto, `gcTime` (5 min) es mayor que `staleTime` (0 seg), lo cual es una configuraci√≥n muy l√≥gica.

üü° **Importante**: No es algo que necesites cambiar todos los d√≠as, pero entender `gcTime` es clave para comprender c√≥mo TanStack Query gestiona la memoria y por qu√© a veces los datos "desaparecen" de la cach√© si tardas en volver a una pantalla.

---

## E - Reintentos Autom√°ticos: El Optimista Incansable üü°

#### 1. **Introducci√≥n:**

Si una petici√≥n para obtener datos falla (por un error de red, por ejemplo), TanStack Query no se rinde a la primera: la reintenta silenciosamente 3 veces antes de rendirse y mostrarte un error.

#### 2. **Ejemplo (Conceptual):**

Llamas por tel√©fono a la pizzer√≠a para pedir la cena, pero la l√≠nea est√° ocupada.

- **Intento 1:** Falla.
- **T√∫ (TanStack Query) piensas:** "Vaya, mala suerte. Esperar√© un segundo y volver√© a intentarlo".
- **Intento 2:** Falla de nuevo.
- **T√∫ (TanStack Query) piensas:** "Uhm, qu√© raro. Esperar√© un poco m√°s esta vez, quiz√°s unos segundos, y lo intentar√© de nuevo".
- **Intento 3:** ¬°Funciona! Haces tu pedido. El usuario final (el que tiene hambre) ni se enter√≥ de los dos primeros fallos.

Solo si el tercer intento tambi√©n falla, te das por vencido y le dices al usuario: "Lo siento, no hemos podido contactar con la pizzer√≠a (ha ocurrido un error)".

#### 3. **Desarrollo:**

Este comportamiento es fant√°stico para mejorar la resiliencia de tu aplicaci√≥n frente a redes inestables. Los reintentos no son inmediatos; usan una estrategia de "espera exponencial" (exponential backoff), esperando un poco m√°s de tiempo entre cada reintento fallido para no saturar el servidor. Puedes configurar tanto el n√∫mero de reintentos (`retry`) como el tiempo de espera (`retryDelay`).

üü° **Importante**: Es una de esas caracter√≠sticas que "simplemente funcionan" y hacen tu app m√°s robusta sin que escribas una l√≠nea de c√≥digo. Es bueno saber que existe para que no te extra√±e ver m√∫ltiples peticiones fallidas en la pesta√±a de red antes de que un error aparezca en la UI.

---

## F - `refetchInterval`: Actualizaci√≥n en Piloto Autom√°tico üîµ

#### 1. **Introducci√≥n:**

Puedes configurar una consulta para que se actualice autom√°ticamente cada cierto intervalo de tiempo, como un reloj, independientemente de la interacci√≥n del usuario.

#### 2. **Ejemplo:**

```javascript
import { useQuery } from "@tanstack/react-query";

function StockTicker() {
  const { data } = useQuery({
    queryKey: ["liveStockPrice", "AAPL"],
    queryFn: fetchAppleStockPrice,

    // ¬°Actual√≠zate cada 2 segundos!
    refetchInterval: 2000,
  });

  // ... muestra el precio de la acci√≥n
}
```

**Explicaci√≥n del ejemplo:**
Este `useQuery` pedir√° el precio de las acciones de Apple cada 2 segundos, sin parar, mientras el componente `StockTicker` est√© montado. Es perfecto para datos que cambian muy r√°pido y necesitan mostrarse en tiempo real, como precios de criptomonedas, resultados deportivos en vivo o notificaciones.

#### 3. **Desarrollo:**

El `refetchInterval` funciona de forma independiente a `staleTime` y a los gatillos autom√°ticos (ver **Concepto C**). Incluso si tienes un `staleTime` de una hora, la consulta se seguir√° refrescando cada 2 segundos si as√≠ lo has configurado. Una caracter√≠stica √∫til es que si el usuario cambia de pesta√±a, las actualizaciones en intervalo se pausan para no gastar recursos, y se reanudan cuando vuelve (puedes cambiar este comportamiento con `refetchIntervalInBackground: true`).

üîµ **Espec√≠fico**: No lo usar√°s en todas tus consultas, ni mucho menos. Es una herramienta para casos de uso muy concretos de "datos en tiempo real". Es bueno saber que existe para cuando la necesites.

---

## G - Structural Sharing: El Optimizador de Renderizados Inteligente üîµ

#### 1. **Introducci√≥n:**

Por defecto, TanStack Query compara inteligentemente los datos nuevos con los que ya tiene y, si nada ha cambiado, mantiene la referencia del objeto original para evitar que React haga re-renderizados innecesarios.

#### 2. **Ejemplo (Conceptual):**

Imagina que tu componente React es un pintor muy sensible.

1.  Pides una lista de tareas (`todos`). TanStack Query te da un objeto `data`. El pintor dibuja la lista.
2.  Se dispara una actualizaci√≥n (por ejemplo, cambias de pesta√±a). TanStack Query pide la lista de nuevo.
3.  **El servidor devuelve la misma lista, byte por byte.**
4.  **Sin Structural Sharing:** TanStack Query te dar√≠a un _nuevo_ objeto en memoria, aunque contenga los mismos datos. El pintor (React) ve un objeto nuevo y, por si acaso, borra todo y vuelve a pintar la lista. Un trabajo innecesario.
5.  **Con Structural Sharing:** TanStack Query detecta que los datos son id√©nticos, descarta el objeto nuevo y te sigue dando la referencia al objeto `data` original. El pintor ve que el objeto no ha cambiado y dice: "¬°Perfecto, no tengo que hacer nada!".

#### 3. **Desarrollo:**

Esta es una optimizaci√≥n de rendimiento que obtienes gratis y que el 99.9% de las veces no necesitas ni pensar en ella. Funciona de maravilla con datos compatibles con JSON (objetos, arrays, strings, n√∫meros...). Si trabajas con datos m√°s ex√≥ticos (como `Map`, `Set`, o clases complejas), esta comparaci√≥n podr√≠a no funcionar como esperas. En esos casos (muy raros), podr√≠as necesitar desactivarla (`structuralSharing: false`) o proveer tu propia funci√≥n de comparaci√≥n.

üîµ **Espec√≠fico**: Es un concepto m√°s avanzado. No necesitas entenderlo a fondo para empezar, pero es bueno saber que esta magia est√° ocurriendo por debajo, haciendo tu app m√°s r√°pida sin que te des cuenta. Si alguna vez tienes problemas de rendimiento extra√±os, podr√≠as echarle un vistazo.
