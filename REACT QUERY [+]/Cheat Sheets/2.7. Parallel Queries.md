
## A - Consultas Paralelas Manuales: ¬°Lanzando varias redes a la vez! üî¥

#### 1. **Introducci√≥n:**

Si sabes de antemano exactamente cu√°ntas piezas de datos necesitas (por ejemplo, siempre necesitas datos de usuarios, equipos y proyectos), simplemente coloca un `useQuery` debajo del otro en tu componente.

#### 2. **Ejemplo:**

```tsx
import { useQuery } from '@tanstack/react-query';

function Dashboard() {
  // Estas 3 consultas se ejecutar√°n AL MISMO TIEMPO. ¬°Magia!
  const usersQuery = useQuery({ 
    queryKey: ['users'], 
    queryFn: fetchUsers 
  });

  const teamsQuery = useQuery({ 
    queryKey: ['teams'], 
    queryFn: fetchTeams 
  });

  const projectsQuery = useQuery({ 
    queryKey: ['projects'], 
    queryFn: fetchProjects 
  });

  // ...luego puedes usar usersQuery.data, teamsQuery.data, etc.
}
```

**Explicaci√≥n del ejemplo:**
Imagina que est√°s en un restaurante de comida r√°pida. En lugar de decir "deme una hamburguesa", esperar a que te la den, y LUEGO decir "ahora deme unas papas fritas", y esperar de nuevo... simplemente dices: "¬°Quiero una hamburguesa, unas papas y un refresco, por favor!".

Eso es exactamente lo que hace este c√≥digo. TanStack Query ve las tres llamadas a `useQuery` y, en lugar de ejecutarlas en secuencia, las lanza todas a la vez. Esto ahorra un tiempo valios√≠simo y hace que tu aplicaci√≥n se sienta s√∫per r√°pida.

#### 3. **Desarrollo:**

Esta es la forma m√°s com√∫n y directa de hacer consultas paralelas. Si el n√∫mero de consultas es fijo y conocido, no necesitas hacer nada especial. Es el comportamiento por defecto y es maravilloso.

**üö® ¬°CUIDADO! ¬°ALERTA DE POSIBLE CONFUSI√ìN! üö®**
El texto original menciona una excepci√≥n muy importante: el **modo `suspense` de React**. Si lo est√°s usando, este m√©todo NO funciona como esperas.

*   **¬øPor qu√© no funciona?** En modo `suspense`, el primer `useQuery` que se encuentra "pausar√°" o "suspender√°" el renderizado del componente hasta que tenga sus datos. Es como si el cajero del restaurante te dijera "¬°ALTO AH√ç!" despu√©s de que pediste la hamburguesa y no te dejara pedir nada m√°s hasta que la hamburguesa est√© lista. Como resultado, las otras dos consultas (`teamsQuery` y `projectsQuery`) ni siquiera llegar√°n a ejecutarse hasta que la primera termine. Se pierde todo el paralelismo.
*   **¬øLa soluci√≥n?** Para mantener el paralelismo en modo `suspense`, el texto te recomienda usar un hook espec√≠fico llamado `useSuspenseQueries` (que veremos m√°s adelante) o dividir cada consulta en su propio componente hijo. ¬°No caigas en esta trampa!

üî¥ **Fundamental**: Esta t√©cnica es el pan de cada d√≠a. La usar√°s constantemente para cargar los datos iniciales de cualquier pantalla que dependa de m√°s de una fuente de datos. Es la base del fetching de datos en componentes complejos.

---

## B - Consultas Paralelas Din√°micas (`useQueries`): Pidiendo un caf√© para cada amigo de tu lista üü°

#### 1. **Introducci√≥n:**

Cuando el n√∫mero de consultas que necesitas hacer depende de una lista que puede cambiar (por ejemplo, obtener el perfil de cada usuario en una lista de amigos), `useQueries` es la herramienta perfecta para el trabajo.

#### 2. **Ejemplo:**

```tsx
import { useQueries } from '@tanstack/react-query';

// Imagina que 'users' es un array que recibes, puede tener 2, 5 o 100 usuarios.
// users = [{ id: 1, name: 'Ana' }, { id: 2, name: 'Luis' }, ...]
function UserProfiles({ users }) {
  
  const userQueries = useQueries({
    // La clave 'queries' espera una lista de "√≥rdenes de trabajo"
    queries: users.map((user) => {
      // Por cada usuario, creamos un objeto de configuraci√≥n para su consulta
      return {
        queryKey: ['user', user.id], // Una clave √∫nica para cada usuario
        queryFn: () => fetchUserById(user.id), // La funci√≥n que busca a ESE usuario
      };
    }),
  });

  // userQueries ser√° un array con los resultados de cada consulta
  // [{ data: userData1, ... }, { data: userData2, ... }, ...]
}
```

**Explicaci√≥n del ejemplo:**
Sigamos con las analog√≠as. Ahora imagina que eres el organizador de una fiesta y necesitas pedir la bebida favorita de cada invitado. No sabes si vendr√°n 5 o 50. Lo que haces es:
1.  Tomas tu lista de invitados (`users`).
2.  Para cada invitado, escribes en un post-it su pedido espec√≠fico (`{ queryKey: [...], queryFn: ... }`).
3.  Juntas todos los post-its en una sola pila (el array que creas con `.map()`).
4.  Le entregas la pila completa de post-its al camarero (`useQueries`).

El camarero (`useQueries`) toma la pila y se encarga de preparar todos los pedidos a la vez. Al final, te devuelve una bandeja (`userQueries`) con todos los pedidos, en el mismo orden en que se los diste.

#### 3. **Desarrollo:**

La pregunta clave aqu√≠ es: **"¬øY por qu√© no puedo simplemente poner un `useQuery` dentro de un `.map()`?"**

¬°Excelente pregunta! Y la respuesta es crucial para entender React.

**üö® ¬°ALERTA DE REGLA DE ORO DE REACT! üö®**
React tiene "Reglas de los Hooks" que son inquebrantables. Una de las m√°s importantes es: **No puedes llamar Hooks (como `useQuery`, `useState`, etc.) dentro de bucles, condiciones o funciones anidadas como un `.map()`**. React necesita que la cantidad de Hooks y su orden de llamada sea exactamente el mismo en cada renderizado del componente. Un `.map()` rompe esta regla, porque si la lista cambia de tama√±o, el n√∫mero de llamadas a `useQuery` cambiar√≠a.

`useQueries` fue creado precisamente para resolver este problema. Le entregas un array de configuraciones (tu "lista de pedidos"), y √©l se encarga internamente de la magia de forma segura y eficiente, sin romper ninguna regla.

üü° **Importante**: No lo usar√°s en cada componente, pero para el caso de uso de "renderizar una lista donde cada elemento necesita su propia llamada a la API" (piensa en un carrito de compras, una lista de posts, perfiles de usuario, etc.), `useQueries` es la soluci√≥n correcta, limpia y oficial. Saber que existe te ahorrar√° muchos dolores de cabeza.

---

## üß† `useQuery` vs. `useQueries`: El Duelo Final - ¬øCu√°ndo uso cu√°l?

¬°Que no cunda el p√°nico! Es s√∫per simple. Hagamos una tabla comparativa para que quede grabado a fuego.

| Caracter√≠stica | M√∫ltiples `useQuery` (Manual) | `useQueries` (Din√°mico) |
| :--- | :--- | :--- |
| **El Escenario Ideal** | Sabes de antemano cu√°ntas consultas necesitas. **El n√∫mero es fijo**. | El n√∫mero de consultas depende de un array o lista que **puede cambiar de tama√±o**. |
| **Ejemplo Pr√°ctico** | "En el `Dashboard`, siempre necesito: 1. Datos del usuario. 2. Sus notificaciones. 3. La lista de amigos." (Siempre 3 consultas) | "En la p√°gina de `Chat`, necesito cargar el perfil de **cada participante** en la conversaci√≥n." (El n√∫mero de participantes var√≠a) |
| **C√≥mo se ve el c√≥digo** | Varios `const resultado = useQuery(...)` uno debajo del otro. | Una sola llamada a `useQueries({ queries: array.map(...) })`. |
| **La Trampa a Evitar** | No funciona bien en modo `suspense` de React sin precauciones. | **NUNCA** intentes reemplazarlo con un `useQuery` dentro de un `.map()`. ¬°Romper√°s las reglas de React! |
| **Analog√≠a Final** | Pedir 3 platos espec√≠ficos del men√∫. | Darle al camarero una lista de compras para que traiga todo lo que hay en ella. |