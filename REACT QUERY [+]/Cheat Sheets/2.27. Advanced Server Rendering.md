## A - Server Components vs. Client Components: ¬øQui√©n es Qui√©n en Esta Fiesta? üî¥

#### 1. **Introducci√≥n:**

Antes de empezar, aclaremos los nombres para no confundirnos: un "Client Component" puede ejecutarse tanto en el servidor como en el navegador, pero un "Server Component" _solo y exclusivamente_ vive en el servidor.

#### 2. **Ejemplo Visual (Analog√≠a):**

Imagina que est√°s construyendo una casa de LEGO:

- **Server Component (El Arquitecto en la F√°brica):** Es un robot en la f√°brica de LEGO que solo puede construir una parte de la casa (ej: la pared frontal). Una vez que la construye, la env√≠a y ya no puede modificarla m√°s. Su trabajo se hace _√∫nicamente_ en la f√°brica (el servidor).
- **Client Component (El Constructor en Casa):** Eres t√∫, en tu casa. Recibes la pared que hizo el robot. Puedes usarla tal cual, pero tambi√©n puedes a√±adirle ventanas, puertas, o incluso construir el resto de la casa a su alrededor. Puedes trabajar en tu casa (el navegador), pero tambi√©n podr√≠as haber recibido instrucciones para hacer un pre-ensamblaje inicial (renderizado en el servidor o SSR).

**Explicaci√≥n de la analog√≠a:**
La clave es que el "Server Component" es como un especialista que solo trabaja en el servidor. El "Client Component" es m√°s flexible; hace un primer trabajo en el servidor (SSR) para que la p√°gina cargue r√°pido, y luego sigue trabajando interactivamente en el navegador del usuario.

#### 3. **Desarrollo:**

Es s√∫per f√°cil confundirse y pensar que "Server Component" se ejecuta en el servidor y "Client Component" en el cliente (navegador). ¬°Pero no es tan simple!

- **Server Components**: Garantizado que solo se ejecutan en el servidor. Son geniales para acceder directamente a bases de datos o servicios internos sin exponer nada al navegador. Piensa en ellos como los "cargadores de datos" (`loaders`) de otros frameworks, pero con superpoderes porque pueden renderizar JSX.
- **Client Components**: Se marcan con la directiva `'use client'`. Aunque su nombre diga "Client", ¬°pueden ejecutarse en ambos lados! Primero se renderizan en el servidor para generar el HTML inicial (esto se llama SSR - Server-Side Rendering) y luego "cobran vida" en el navegador para que puedas interactuar con ellos (usar `useState`, `useEffect`, etc.).

üî¥ **Fundamental**: Entender esta diferencia es la base de todo lo que sigue. Si confundes estos t√©rminos, te perder√°s en los siguientes pasos. Es como aprender a diferenciar entre "acelerar" y "frenar" antes de conducir.

---

## B - La Configuraci√≥n Inicial: Montando el Taller de React Query üü°

#### 1. **Introducci√≥n:**

Para usar React Query, primero necesitas un "cerebro" central (`QueryClient`) y un "proveedor" (`QueryClientProvider`) que lo haga accesible para toda tu aplicaci√≥n.

#### 2. **Ejemplo:**

Necesitamos dos archivos para organizar esto en Next.js App Router.

**Archivo 1: El cerebro y su guardi√°n (`app/providers.tsx`)**

```typescript
// app/providers.tsx
"use client"; // ¬°Importante! Este componente usa 'context', as√≠ que debe ser un Client Component.

import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";
import React from "react";

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        // Le decimos a React Query: "Oye, si acabas de recibir datos del servidor,
        // no te apresures a pedirlos de nuevo. Espera al menos 1 minuto".
        staleTime: 60 * 1000,
      },
    },
  });
}

// Esta es la parte crucial para no crear clientes a lo loco.
let browserQueryClient: QueryClient | undefined = undefined;

function getQueryClient() {
  if (isServer) {
    // En el servidor, cada petici√≥n es un mundo nuevo. Siempre creamos un cliente nuevo
    // para evitar que los datos de un usuario se filtren a otro. ¬°Seguridad primero!
    return makeQueryClient();
  } else {
    // En el navegador, queremos un √∫nico cliente para toda la sesi√≥n del usuario.
    // Si no existe, lo creamos. Si ya existe, lo reutilizamos.
    if (!browserQueryClient) browserQueryClient = makeQueryClient();
    return browserQueryClient;
  }
}

export default function Providers({ children }: { children: React.ReactNode }) {
  // Obtenemos el cliente de nuestra funci√≥n guardiana.
  const queryClient = getQueryClient();

  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
}
```

**Archivo 2: Envolviendo toda la aplicaci√≥n (`app/layout.tsx`)**

```typescript
// app/layout.tsx
import Providers from "./providers";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        {/* Aqu√≠ envolvemos toda nuestra app con el proveedor que creamos */}
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}
```

**Explicaci√≥n del ejemplo:**
El truco aqu√≠ es la funci√≥n `getQueryClient`. Act√∫a como un portero inteligente. Si la petici√≥n viene del servidor, crea una instancia de `QueryClient` fresca y limpia para esa petici√≥n espec√≠fica. Si estamos en el navegador del usuario, reutiliza la misma instancia una y otra vez para que el estado de los datos se mantenga consistente mientras el usuario navega. El archivo `layout.tsx` simplemente se asegura de que _toda_ la aplicaci√≥n est√© dentro de este `Provider`.

#### 3. **Desarrollo:**

La l√≥gica de `getQueryClient` es la pieza m√°s importante aqu√≠. La principal trampa a evitar es crear un nuevo `QueryClient` en cada renderizado en el navegador. Si hicieras `useState(() => new QueryClient())` sin cuidado, podr√≠as perder todo el cach√© de datos si un componente se "suspende" (pausa su renderizado para esperar algo). La soluci√≥n del ejemplo (usar una variable externa `browserQueryClient`) es una forma robusta de garantizar que solo haya un cliente en el navegador.

üü° **Importante**: Esta configuraci√≥n es el pilar de tu aplicaci√≥n. Sin ella, React Query no funciona. Aunque es c√≥digo que escribes una vez y olvidas, hacerlo bien desde el principio te ahorrar√° dolores de cabeza inimaginables.

---

## C - Prefetching y Hydration: Preparando los Datos en el Servidor üü°

#### 1. **Introducci√≥n:**

Este es el patr√≥n principal: usamos un "Server Component" para buscar los datos por adelantado (`prefetchQuery`), los "empaquetamos" (`dehydrate`), y se los pasamos a los "Client Components" para que los usen al instante.

#### 2. **Ejemplo:**

Imagina que quieres mostrar una lista de posts.

**Paso 1: El Server Component busca y empaqueta los datos (`app/posts/page.tsx`)**

```typescript
// app/posts/page.tsx (Este es un Server Component por defecto)
import {
  dehydrate,
  HydrationBoundary,
  QueryClient,
} from "@tanstack/react-query";
import Posts from "./posts"; // Este ser√° nuestro Client Component
import { getPosts } from "../api"; // Funci√≥n que hace el fetch

export default async function PostsPage() {
  const queryClient = new QueryClient();

  // 1. PREFETCH: Le decimos a React Query: "Adelanta el trabajo y busca los posts".
  // 'await' asegura que no continuamos hasta que los datos est√©n listos.
  await queryClient.prefetchQuery({
    queryKey: ["posts"],
    queryFn: getPosts,
  });

  // 2. DEHYDRATE & HYDRATE: Empaquetamos los datos y los dejamos listos
  // para que el cliente los "hidrate" (absorba).
  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <Posts />
    </HydrationBoundary>
  );
}
```

**Paso 2: El Client Component consume los datos (`app/posts/posts.tsx`)**

```typescript
// app/posts/posts.tsx
"use client"; // ¬°Marcado como Client Component!

import { useQuery } from "@tanstack/react-query";
import { getPosts } from "../api";

export default function Posts() {
  // 3. USEQUERY: Usamos useQuery con la misma 'queryKey'.
  // React Query es inteligente y dir√°: "¬°Hey, estos datos ya los tengo del servidor!".
  // No har√° una nueva petici√≥n, simplemente los tomar√° del cach√©.
  const { data } = useQuery({
    queryKey: ["posts"],
    queryFn: getPosts,
  });

  // 'data' estar√° disponible INMEDIATAMENTE, sin pantallas de carga.
  return (
    <ul>
      {data?.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

**Explicaci√≥n del ejemplo:**
El flujo es como un servicio de catering:

1.  **`prefetchQuery` (El chef cocina por adelantado):** En el servidor (`PostsPage`), el chef prepara el plato principal (los posts).
2.  **`dehydrate` (Empaquetar la comida):** El chef empaqueta la comida en un contenedor especial (`dehydratedState`).
3.  **`HydrationBoundary` (El repartidor entrega el paquete):** Este componente entrega el paquete al cliente.
4.  **`useQuery` (El comensal abre el paquete):** En el navegador (`Posts`), el comensal abre el paquete y la comida est√° lista para comer al instante, sin tener que esperar a que se cocine.

#### 3. **Desarrollo:**

Este patr√≥n es el coraz√≥n del SSR con React Query en el App Router de Next.js. `HydrationBoundary` es un Client Component que se encarga de la magia de tomar el estado deshidratado del servidor y "rehidratarlo" en el `QueryClient` del navegador. Por eso, cualquier `useQuery` dentro de √©l con la misma `queryKey` encontrar√° los datos ya cacheados.

Una nota importante: usamos `useQuery` y no `useSuspenseQuery` en el cliente. ¬øPor qu√©? Porque _sabemos_ que los datos ya han sido precargados. No hay necesidad de "suspender" el componente, ya que los datos est√°n garantizados. Si por error olvid√°ramos el `prefetch`, `useQuery` simplemente har√≠a la petici√≥n en el cliente, mientras que `useSuspenseQuery` podr√≠a causar efectos no deseados.

üü° **Importante**: Este es el flujo de trabajo que usar√°s el 90% del tiempo. Dominar `prefetch` -> `dehydrate` -> `HydrationBoundary` -> `useQuery` es clave para construir aplicaciones r√°pidas y eficientes.

---

## D - Data Ownership: ¬øQui√©n es el Due√±o de los Datos? üî¥

#### 1. **Introducci√≥n:**

Ten mucho cuidado con qui√©n "posee" y muestra los datos; si el servidor y el cliente muestran los mismos datos, pueden desincronizarse y causar bugs muy confusos.

#### 2. **El Contraste Clave: `prefetchQuery` vs. `fetchQuery`**

Imagina que quieres mostrar el n√∫mero de posts y tambi√©n la lista de posts.

**El Enfoque PELIGROSO (usando `fetchQuery` y mostrando el resultado en el servidor):**

```typescript
// app/posts/page.tsx (Server Component) - ¬°NO HAGAS ESTO!

export default async function PostsPage() {
  const queryClient = new QueryClient();

  // fetchQuery devuelve los datos directamente. ¬°Tentador pero peligroso!
  const posts = await queryClient.fetchQuery({
    queryKey: ["posts"],
    queryFn: getPosts,
  });

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      {/* PROBLEMA: Este n√∫mero viene del servidor y NUNCA se actualizar√°. */}
      <div>N√∫mero de posts (del servidor): {posts.length}</div>

      {/* El componente cliente mostrar√° la lista, que S√ç se puede actualizar. */}
      <Posts />
    </HydrationBoundary>
  );
}
```

**Explicaci√≥n del peligro:**

1.  **Carga inicial:** La p√°gina muestra "N√∫mero de posts: 10" y la lista con 10 posts. Todo parece correcto.
2.  **Pasa un tiempo:** Los datos en el cliente se vuelven "stale" (obsoletos). React Query hace una nueva petici√≥n en segundo plano.
3.  **¬°Desastre!** La nueva petici√≥n devuelve 11 posts. El componente `<Posts />` se actualiza y muestra 11 posts. Pero el `<div>` que renderiz√≥ el servidor sigue diciendo "N√∫mero de posts: 10". ¬°Tu UI est√° desincronizada y miente al usuario!

**El Enfoque SEGURO (usando `prefetchQuery`):**

```typescript
// app/posts/page.tsx (Server Component) - ¬°LA FORMA CORRECTA!

export default async function PostsPage() {
  const queryClient = new QueryClient();

  // prefetchQuery solo calienta la cach√©. No devuelve nada.
  await queryClient.prefetchQuery({
    queryKey: ["posts"],
    queryFn: getPosts,
  });

  return (
    // Pasamos los datos deshidratados...
    <HydrationBoundary state={dehydrate(queryClient)}>
      {/* ...y dejamos que el CLIENTE se encargue de renderizar TODO. */}
      <Posts />
    </HydrationBoundary>
  );
}
```

En el componente `<Posts />` (cliente), ahora renderizar√≠as tanto el contador como la lista, asegurando que ambos se actualicen juntos.

#### 3. **Desarrollo:**

La regla de oro es simple: **trata a los Server Components como un lugar para PREPARAR datos, no para MOSTRARLOS**.

- Usa `prefetchQuery` para cargar datos en la cach√© del servidor. Su √∫nica misi√≥n es calentar el asiento para el cliente.
- Usa `fetchQuery` con extremo cuidado. Si lo usas, **NO** renderices su resultado en el JSX del Server Component. Su √∫nico uso seguro aqu√≠ ser√≠a para, por ejemplo, capturar errores en el servidor.

Piensa en los datos de React Query como propiedad exclusiva del "mundo del cliente" (Client Components). El servidor solo act√∫a como un asistente que prepara todo antes de que el due√±o llegue. Si el asistente empieza a colocar los muebles (renderizar datos), y luego el due√±o llega y los mueve (refetch en el cliente), el caos est√° garantizado.

üî¥ **Fundamental**: Ignorar este principio es la receta para bugs sutiles y frustrantes. Es la diferencia entre una aplicaci√≥n robusta y una que se rompe de formas misteriosas. ¬°Gr√°batelo a fuego!

---

## E - Streaming con "No Await": Enviando la UI Primero, los Datos Despu√©s üü°

#### 1. **Introducci√≥n:**

Podemos hacer que nuestra p√°gina cargue a√∫n m√°s r√°pido enviando el HTML al navegador inmediatamente, sin esperar a que las peticiones de datos terminen, y React Query se encargar√° de "rellenar" los datos cuando lleguen.

#### 2. **Ejemplo:**

Vamos a modificar nuestra configuraci√≥n y nuestro componente para habilitar este truco.

**Paso 1: Actualizar la configuraci√≥n del `QueryClient` (`app/get-query-client.ts`)**

```typescript
// app/get-query-client.ts (Nuevo archivo o movido desde providers.tsx)
import {
  QueryClient,
  defaultShouldDehydrateQuery,
  isServer,
} from "@tanstack/react-query";

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: { staleTime: 60 * 1000 },
      dehydrate: {
        // LA MAGIA: Le decimos que tambi√©n empaquete las queries que est√°n "pendientes".
        shouldDehydrateQuery: (query) =>
          defaultShouldDehydrateQuery(query) ||
          query.state.status === "pending",
      },
    },
  });
}

// ... (el resto de la l√≥gica de getQueryClient sigue igual)
let browserQueryClient: QueryClient | undefined = undefined;
export function getQueryClient() {
  /* ... */
}
```

**Paso 2: El Server Component que ya no espera (`app/posts/page.tsx`)**

```typescript
// app/posts/page.tsx
import { dehydrate, HydrationBoundary } from "@tanstack/react-query";
import { getQueryClient } from "./get-query-client";
import Posts from "./posts";

// ¬°La funci√≥n ya no necesita ser 'async'!
export default function PostsPage() {
  const queryClient = getQueryClient();

  // ¬°MIRA, MAM√Å, SIN 'await'!
  // Simplemente iniciamos la petici√≥n y seguimos adelante.
  queryClient.prefetchQuery({
    queryKey: ["posts"],
    queryFn: getPosts,
  });

  // Devolvemos la UI inmediatamente. React Query enviar√° la "promesa" de los datos.
  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <Posts />
    </HydrationBoundary>
  );
}
```

**Paso 3: El Client Component que ahora usa `useSuspenseQuery` (`app/posts/posts.tsx`)**

```typescript
// app/posts/posts.tsx
"use client";
import { useSuspenseQuery } from "@tanstack/react-query"; // ¬°Ahora con Suspense!

export default function Posts() {
  // useSuspenseQuery recibe la "promesa" del servidor y sabe c√≥mo esperar.
  // Mientras espera, React y Next.js pueden mostrar un 'fallback' (ej: un spinner).
  const { data } = useSuspenseQuery({ queryKey: ["posts"], queryFn: getPosts });

  // ... renderizar la lista de posts
}
```

**Explicaci√≥n del ejemplo:**

1.  El servidor inicia la petici√≥n de `getPosts` pero **no espera**.
2.  Inmediatamente, env√≠a el HTML de la p√°gina al navegador. Dentro de este HTML, en lugar de los datos, viaja una "promesa" serializada (un "te prometo que estos datos llegar√°n").
3.  El navegador renderiza la p√°gina. El componente `<Posts />` intenta usar los datos.
4.  `useSuspenseQuery` ve que los datos son una promesa y "suspende" el renderizado de ese componente, mostrando un fallback (definido por ti con `<Suspense>` o en `loading.tsx` de Next.js).
5.  Cuando la petici√≥n de datos original (iniciada en el servidor) termina, los datos se "transmiten" (stream) al cliente, la promesa se resuelve, y el componente `<Posts />` se renderiza con los datos reales.

#### 3. **Desarrollo:**

Este enfoque es fant√°stico para el rendimiento percibido (Time to First Byte - TTFB). El usuario ve la estructura de la p√°gina casi al instante, en lugar de una pantalla en blanco mientras el servidor espera a la base de datos.

La clave es la opci√≥n `shouldDehydrateQuery`. Por defecto, React Query solo deshidrata queries que han terminado (`status: 'success'`). Al a√±adir `query.state.status === 'pending'`, le damos permiso para empaquetar tambi√©n las que est√°n en curso. React es capaz de serializar estas promesas y pasarlas a los Client Components, donde `useSuspenseQuery` sabe c√≥mo manejarlas.

üü° **Importante**: Este es un patr√≥n moderno y muy potente. Mejora la experiencia del usuario significativamente en p√°ginas con peticiones de datos lentas. Es el siguiente paso l√≥gico una vez que dominas el prefetching b√°sico.

---

## F - Experimental: Streaming sin Prefetching (La V√≠a R√°pida con Peaje) üîµ

#### 1. **Introducci√≥n:**

Existe un paquete experimental que te permite saltarte por completo el `prefetchQuery` en los Server Components y simplemente usar `useSuspenseQuery` en un Client Component, logrando streaming SSR con una simplicidad incre√≠ble.

#### 2. **Ejemplo:**

**Paso 1: Instalar el paquete experimental**
`npm install @tanstack/react-query-next-experimental`

**Paso 2: Envolver la aplicaci√≥n con `ReactQueryStreamedHydration` (`app/providers.tsx`)**

```typescript
// app/providers.tsx
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryStreamedHydration } from "@tanstack/react-query-next-experimental";
import React from "react";

// ... (la l√≥gica de getQueryClient sigue igual)

export function Providers({ children }: { children: React.ReactNode }) {
  const queryClient = getQueryClient();

  return (
    <QueryClientProvider client={queryClient}>
      {/* Este nuevo componente m√°gico se encarga de todo */}
      <ReactQueryStreamedHydration>{children}</ReactQueryStreamedHydration>
    </QueryClientProvider>
  );
}
```

**Paso 3: ¬°Y ya est√°! Ahora solo usa `useSuspenseQuery` donde quieras.**

```typescript
// app/posts/posts.tsx (Un Client Component)
"use client";
import { useSuspenseQuery } from "@tanstack/react-query";
import { Suspense } from "react";

function PostList() {
  // ¬°Sin prefetch en ning√∫n Server Component!
  // Esto simplemente funciona. Har√° la petici√≥n en el servidor y streamear√° el resultado.
  const { data } = useSuspenseQuery({ queryKey: ["posts"], queryFn: getPosts });
  // ... renderizar posts
}

export default function PostsPage() {
  return (
    <Suspense fallback={<div>Cargando posts...</div>}>
      <PostList />
    </Suspense>
  );
}
```

**Explicaci√≥n del ejemplo:**
Con este enfoque, te olvidas de los Server Components para buscar datos. Escribes tu c√≥digo como si fuera una aplicaci√≥n puramente de cliente, pero `ReactQueryStreamedHydration` intercepta las llamadas a `useSuspenseQuery` durante el renderizado en el servidor, ejecuta las peticiones de datos all√≠, y transmite los resultados al cliente a medida que se completan. La experiencia de desarrollo (DX) es fenomenal.

#### 3. **Desarrollo y ¬°LA GRAN ADVERTENCIA!**

Este m√©todo parece m√°gico, y para la carga inicial de la p√°gina, lo es. Aplana las cascadas de peticiones (request waterfalls) de forma autom√°tica.

**El problema (el "peaje"):** Esta magia solo funciona para la **carga inicial de la p√°gina**. Cuando el usuario navega a otra p√°gina dentro de la aplicaci√≥n (navegaci√≥n del lado del cliente), este mecanismo no se activa. La aplicaci√≥n se comportar√° como una SPA (Single Page Application) normal, lo que significa que volver√°s a tener las cascadas de peticiones que quer√≠as evitar.

**Comparaci√≥n de Enfoques:**

| Caracter√≠stica                  | Prefetching Manual (Concepto C y E)              | Streaming Experimental (Este concepto)                                                                            |
| :------------------------------ | :----------------------------------------------- | :---------------------------------------------------------------------------------------------------------------- |
| **Complejidad del C√≥digo**      | Mayor (necesitas `prefetch`, `dehydrate`, etc.)  | M√≠nima (solo `useSuspenseQuery`)                                                                                  |
| **Rendimiento (Carga Inicial)** | Excelente (aplana cascadas)                      | Excelente (aplana cascadas)                                                                                       |
| **Rendimiento (Navegaci√≥n)**    | **Excelente** (el prefetching sigue funcionando) | **Malo** (vuelven las cascadas)                                                                                   |
| **Recomendaci√≥n**               | **El m√©todo robusto y recomendado.**             | Bueno para prototipos, apps simples o si priorizas la velocidad de desarrollo sobre el rendimiento en navegaci√≥n. |

üîµ **Espec√≠fico**: √ösalo si entiendes perfectamente el compromiso. Es una herramienta incre√≠ble para ir r√°pido, pero puede costarte rendimiento a largo plazo si tu aplicaci√≥n tiene anidamiento de datos complejo y muchas navegaciones internas. Es como tomar un atajo por un camino de tierra: llegas r√°pido, pero el viaje puede ser accidentado.
