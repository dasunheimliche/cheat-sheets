### **A - El Problema: La Paginaci칩n "Saltarina"** 游리

#### 1. **Introducci칩n:**

Cuando implementas una paginaci칩n simple, al cambiar de p치gina la interfaz parpadea entre los estados de "cargando" y "listo", lo cual es una experiencia de usuario bastante pobre.

#### 2. **Ejemplo:**

Imagina que tienes este c칩digo. Cada vez que el usuario cambia de p치gina, el valor de `page` se actualiza.

```tsx
// Este es el enfoque "ingenuo" o b치sico
const { isPending, data } = useQuery({
  queryKey: ["projects", page], // 'page' es un estado, ej: 0, 1, 2...
  queryFn: () => fetchProjects(page),
});

// En tu UI...
if (isPending) return "Cargando la nueva p치gina...";
return <div>{/* Muestras los datos de 'data' */}</div>;
```

**Explicaci칩n del ejemplo:**
Cuando el estado `page` cambia (por ejemplo, de `1` a `2`), la `queryKey` cambia de `['projects', 1]` a `['projects', 2]`. Para TanStack Query, estas son dos consultas **completamente distintas**. Es como si borraras la consulta de la p치gina 1 y crearas una nueva desde cero para la p치gina 2. Por eso, la variable `isPending` se vuelve `true` otra vez, y tu UI muestra "Cargando la nueva p치gina...", creando ese molesto parpadeo.

#### 3. **Desarrollo:**

Este comportamiento es l칩gico desde el punto de vista de la librer칤a, pero no es lo que un usuario espera. Un usuario quiere ver el contenido de la p치gina 1 _mientras_ la p치gina 2 se carga en segundo plano, y luego ver una transici칩n suave. El parpadeo constante entre un estado de carga y el contenido es visualmente disruptivo y da una sensaci칩n de lentitud. Afortunadamente, 춰TanStack Query tiene una soluci칩n brillante para esto!

游리 **Importante**: Entender este problema es crucial. Es el "쯇or qu칠 necesito algo m치s?" que justifica la existencia de la siguiente herramienta. Si no entiendes por qu칠 esto es un problema, la soluci칩n no te parecer치 tan genial como realmente es.

---

### **B - La Soluci칩n: `placeholderData: keepPreviousData`** 游댮

#### 1. **Introducci칩n:**

Esta es la soluci칩n m치gica de TanStack Query para evitar la paginaci칩n "saltarina": mantener los datos de la p치gina anterior visibles mientras se cargan los de la nueva.

#### 2. **Ejemplo:**

F칤jate en la 칰nica l칤nea que cambia y lo arregla todo.

```tsx
import { keepPreviousData, useQuery } from "@tanstack/react-query";

function Todos() {
  const [page, setPage] = React.useState(0);

  const fetchProjects = (page = 0) =>
    fetch("/api/projects?page=" + page).then((res) => res.json());

  const {
    isPending,
    isError,
    error,
    data,
    isFetching,
    isPlaceholderData, // 춰Hola, nueva variable! Hablaremos de ti en un segundo.
  } = useQuery({
    queryKey: ["projects", page],
    queryFn: () => fetchProjects(page),
    // 춰춰춰AQU칈 EST츼 LA MAGIA!!!
    placeholderData: keepPreviousData,
  });

  // ... el resto del componente para mostrar los datos y botones ...
}
```

**Explicaci칩n del ejemplo:**
Al a침adir `placeholderData: keepPreviousData`, le est치s diciendo a TanStack Query:
"Oye, s칠 que la `queryKey` ha cambiado y que tienes que ir a buscar datos nuevos. 춰Genial! Pero mientras lo haces, por favor, no me dejes con una pantalla de carga. **Sigue mostr치ndome los datos de la 칰ltima consulta exitosa que tuviste**".

`keepPreviousData` es una funci칩n de utilidad que la librer칤a te regala. No tienes que escribirla, solo importarla y usarla. Es como un hechizo que le lanzas a `useQuery`.

#### 3. **Desarrollo:**

Cuando usas `keepPreviousData`, ocurren dos cosas maravillosas:

1.  **La data anterior persiste:** Mientras se busca la nueva p치gina, el objeto `data` sigue conteniendo la informaci칩n de la p치gina anterior. 춰Adi칩s, pantalla de carga que interrumpe todo!
2.  **Transici칩n suave:** Una vez que los nuevos datos llegan, TanStack Query los intercambia de forma transparente. El usuario simplemente ve el nuevo contenido aparecer.

游댮 **Fundamental**: Esta es LA forma de implementar paginaci칩n con TanStack Query. Es la t칠cnica principal que resuelve el problema m치s com칰n de esta funcionalidad. Usar `keepPreviousData` deber칤a ser tu reflejo autom치tico al pensar en paginaci칩n.

---

### **C - Los Esp칤as: `isPlaceholderData` y `isFetching`** 游댮

#### 1. **Introducci칩n:**

Para que la experiencia sea perfecta, necesitas saber dos cosas: si los datos que ves son "viejos" (`isPlaceholderData`) y si hay una carga ocurriendo en segundo plano (`isFetching`).

#### 2. **Ejemplo:**

Veamos c칩mo usar estas dos variables booleanas para mejorar nuestra UI.

```tsx
// ... dentro de tu componente ...

return (
  <div>
    {/* ... aqu칤 muestras tus datos ... */}

    <button
      onClick={() => {
        // Solo permitimos ir a la siguiente p치gina si NO estamos viendo datos de marcador de posici칩n
        if (!isPlaceholderData && data.hasMore) {
          setPage((old) => old + 1);
        }
      }}
      // Deshabilitamos el bot칩n si estamos viendo datos "viejos" O si no hay m치s p치ginas
      disabled={isPlaceholderData || !data?.hasMore}
    >
      Next Page
    </button>

    {/* Mostramos un indicador de carga sutil cuando hay una petici칩n en curso */}
    {isFetching ? <span> Loading...</span> : null}
  </div>
);
```

**Explicaci칩n del ejemplo:**

- **`disabled={isPlaceholderData}`**: Esta es la parte crucial. `isPlaceholderData` se vuelve `true` cuando est치s viendo los datos de la p치gina 1, pero la aplicaci칩n ya est치 pidiendo los de la p치gina 2. Deshabilitar el bot칩n "Next Page" en este momento evita que el usuario haga clic como un loco y dispare 10 peticiones seguidas. Es una medida de seguridad y de buena UX.
- **`{isFetching ? <span> Loading...</span> : null}`**: F칤jate que aqu칤 usamos `isFetching`, no `isPending`.
  - `isPending`: Solo es `true` la **primera vez** que la consulta carga (cuando no hay datos de ning칰n tipo).
  - `isFetching`: Es `true` **cada vez** que se hace una petici칩n, incluyendo las cargas en segundo plano. Es perfecto para mostrar un peque침o _spinner_ o un texto "Cargando..." que le dice al usuario "algo est치 pasando", sin quitarle el contenido que ya est치 viendo.

#### 3. **Desarrollo:**

Pi칠nsalo as칤:

- `isPlaceholderData`: Es tu bandera que dice: "춰Atenci칩n! Lo que ves en pantalla es del pasado. Lo nuevo est치 en camino". Es `true` durante el breve periodo entre que pides una nueva p치gina y esta llega.
- `isFetching`: Es tu luz de "motor en marcha". Se enciende siempre que TanStack Query est치 hablando con tu servidor.

Dominar estas dos variables te permite crear interfaces de paginaci칩n robustas y a prueba de usuarios impacientes.

游댮 **Fundamental**: Sin entender y usar `isPlaceholderData` y `isFetching`, tu implementaci칩n con `keepPreviousData` est치 incompleta. Corres el riesgo de que los usuarios inicien m칰ltiples peticiones o no entiendan por qu칠 no pueden interactuar con la UI. Son el complemento indispensable de `keepPreviousData`.

---

### **D - Paginaci칩n en `useInfiniteQuery`** 游댯

#### 1. **Introducci칩n:**

La misma t칠cnica de `placeholderData` tambi칠n funciona con `useInfiniteQuery`, ideal para cuando la clave de la consulta cambia (por ejemplo, al aplicar un filtro).

#### 2. **Ejemplo:**

No hay un ejemplo de c칩digo completo en el texto, pero la idea es id칠ntica. Imagina que tienes una lista infinita de productos y a침ades un filtro.

```tsx
// Concepto: La misma idea se aplica aqu칤
const { data, isPlaceholderData, isFetching } = useInfiniteQuery({
  queryKey: ["products", filters], // 'filters' es un objeto con los filtros aplicados
  queryFn: fetchProducts,
  placeholderData: keepPreviousData,
  // ... otras opciones de useInfiniteQuery
});
```

**Explicaci칩n del ejemplo:**
Si el usuario cambia los `filters` (por ejemplo, de `{ category: 'electronics' }` a `{ category: 'books' }`), la `queryKey` cambiar치. Normalmente, esto limpiar칤a toda la lista de productos y mostrar칤a un cargador. Pero con `placeholderData: keepPreviousData`, la lista de productos electr칩nicos se mantendr칤a visible mientras se carga la nueva lista de libros, ofreciendo una transici칩n mucho m치s agradable.

#### 3. **Desarrollo:**

Aunque el caso de uso m치s com칰n para `useInfiniteQuery` es a침adir p치ginas a una lista existente (donde la `queryKey` no cambia), hay situaciones donde la consulta base s칤 se modifica. En esos momentos, `keepPreviousData` es tu mejor amigo para evitar que toda la lista infinita que el usuario ha cargado desaparezca de repente.

游댯 **Espec칤fico**: Es una aplicaci칩n de la misma t칠cnica en un contexto diferente. No lo usar치s todos los d칤as, pero es incre칤blemente 칰til saber que esta opci칩n existe para cuando te enfrentes a un redise침o de una lista infinita basada en filtros.
