### **A - El Problema: La Paginación "Saltarina"** 🟡

#### 1. **Introducción:**

Cuando implementas una paginación simple, al cambiar de página la interfaz parpadea entre los estados de "cargando" y "listo", lo cual es una experiencia de usuario bastante pobre.

#### 2. **Ejemplo:**

Imagina que tienes este código. Cada vez que el usuario cambia de página, el valor de `page` se actualiza.

```tsx
// Este es el enfoque "ingenuo" o básico
const { isPending, data } = useQuery({
  queryKey: ["projects", page], // 'page' es un estado, ej: 0, 1, 2...
  queryFn: () => fetchProjects(page),
});

// En tu UI...
if (isPending) return "Cargando la nueva página...";
return <div>{/* Muestras los datos de 'data' */}</div>;
```

**Explicación del ejemplo:**
Cuando el estado `page` cambia (por ejemplo, de `1` a `2`), la `queryKey` cambia de `['projects', 1]` a `['projects', 2]`. Para TanStack Query, estas son dos consultas **completamente distintas**. Es como si borraras la consulta de la página 1 y crearas una nueva desde cero para la página 2. Por eso, la variable `isPending` se vuelve `true` otra vez, y tu UI muestra "Cargando la nueva página...", creando ese molesto parpadeo.

#### 3. **Desarrollo:**

Este comportamiento es lógico desde el punto de vista de la librería, pero no es lo que un usuario espera. Un usuario quiere ver el contenido de la página 1 _mientras_ la página 2 se carga en segundo plano, y luego ver una transición suave. El parpadeo constante entre un estado de carga y el contenido es visualmente disruptivo y da una sensación de lentitud. Afortunadamente, ¡TanStack Query tiene una solución brillante para esto!

🟡 **Importante**: Entender este problema es crucial. Es el "¿Por qué necesito algo más?" que justifica la existencia de la siguiente herramienta. Si no entiendes por qué esto es un problema, la solución no te parecerá tan genial como realmente es.

---

### **B - La Solución: `placeholderData: keepPreviousData`** 🔴

#### 1. **Introducción:**

Esta es la solución mágica de TanStack Query para evitar la paginación "saltarina": mantener los datos de la página anterior visibles mientras se cargan los de la nueva.

#### 2. **Ejemplo:**

Fíjate en la única línea que cambia y lo arregla todo.

```tsx
import { keepPreviousData, useQuery } from "@tanstack/react-query";

function Todos() {
  const [page, setPage] = React.useState(0);

  const fetchProjects = (page = 0) =>
    fetch("/api/projects?page=" + page).then((res) => res.json());

  const {
    isPending,
    isError,
    error,
    data,
    isFetching,
    isPlaceholderData, // ¡Hola, nueva variable! Hablaremos de ti en un segundo.
  } = useQuery({
    queryKey: ["projects", page],
    queryFn: () => fetchProjects(page),
    // ¡¡¡AQUÍ ESTÁ LA MAGIA!!!
    placeholderData: keepPreviousData,
  });

  // ... el resto del componente para mostrar los datos y botones ...
}
```

**Explicación del ejemplo:**
Al añadir `placeholderData: keepPreviousData`, le estás diciendo a TanStack Query:
"Oye, sé que la `queryKey` ha cambiado y que tienes que ir a buscar datos nuevos. ¡Genial! Pero mientras lo haces, por favor, no me dejes con una pantalla de carga. **Sigue mostrándome los datos de la última consulta exitosa que tuviste**".

`keepPreviousData` es una función de utilidad que la librería te regala. No tienes que escribirla, solo importarla y usarla. Es como un hechizo que le lanzas a `useQuery`.

#### 3. **Desarrollo:**

Cuando usas `keepPreviousData`, ocurren dos cosas maravillosas:

1.  **La data anterior persiste:** Mientras se busca la nueva página, el objeto `data` sigue conteniendo la información de la página anterior. ¡Adiós, pantalla de carga que interrumpe todo!
2.  **Transición suave:** Una vez que los nuevos datos llegan, TanStack Query los intercambia de forma transparente. El usuario simplemente ve el nuevo contenido aparecer.

🔴 **Fundamental**: Esta es LA forma de implementar paginación con TanStack Query. Es la técnica principal que resuelve el problema más común de esta funcionalidad. Usar `keepPreviousData` debería ser tu reflejo automático al pensar en paginación.

---

### **C - Los Espías: `isPlaceholderData` y `isFetching`** 🔴

#### 1. **Introducción:**

Para que la experiencia sea perfecta, necesitas saber dos cosas: si los datos que ves son "viejos" (`isPlaceholderData`) y si hay una carga ocurriendo en segundo plano (`isFetching`).

#### 2. **Ejemplo:**

Veamos cómo usar estas dos variables booleanas para mejorar nuestra UI.

```tsx
// ... dentro de tu componente ...

return (
  <div>
    {/* ... aquí muestras tus datos ... */}

    <button
      onClick={() => {
        // Solo permitimos ir a la siguiente página si NO estamos viendo datos de marcador de posición
        if (!isPlaceholderData && data.hasMore) {
          setPage((old) => old + 1);
        }
      }}
      // Deshabilitamos el botón si estamos viendo datos "viejos" O si no hay más páginas
      disabled={isPlaceholderData || !data?.hasMore}
    >
      Next Page
    </button>

    {/* Mostramos un indicador de carga sutil cuando hay una petición en curso */}
    {isFetching ? <span> Loading...</span> : null}
  </div>
);
```

**Explicación del ejemplo:**

- **`disabled={isPlaceholderData}`**: Esta es la parte crucial. `isPlaceholderData` se vuelve `true` cuando estás viendo los datos de la página 1, pero la aplicación ya está pidiendo los de la página 2. Deshabilitar el botón "Next Page" en este momento evita que el usuario haga clic como un loco y dispare 10 peticiones seguidas. Es una medida de seguridad y de buena UX.
- **`{isFetching ? <span> Loading...</span> : null}`**: Fíjate que aquí usamos `isFetching`, no `isPending`.
  - `isPending`: Solo es `true` la **primera vez** que la consulta carga (cuando no hay datos de ningún tipo).
  - `isFetching`: Es `true` **cada vez** que se hace una petición, incluyendo las cargas en segundo plano. Es perfecto para mostrar un pequeño _spinner_ o un texto "Cargando..." que le dice al usuario "algo está pasando", sin quitarle el contenido que ya está viendo.

#### 3. **Desarrollo:**

Piénsalo así:

- `isPlaceholderData`: Es tu bandera que dice: "¡Atención! Lo que ves en pantalla es del pasado. Lo nuevo está en camino". Es `true` durante el breve periodo entre que pides una nueva página y esta llega.
- `isFetching`: Es tu luz de "motor en marcha". Se enciende siempre que TanStack Query está hablando con tu servidor.

Dominar estas dos variables te permite crear interfaces de paginación robustas y a prueba de usuarios impacientes.

🔴 **Fundamental**: Sin entender y usar `isPlaceholderData` y `isFetching`, tu implementación con `keepPreviousData` está incompleta. Corres el riesgo de que los usuarios inicien múltiples peticiones o no entiendan por qué no pueden interactuar con la UI. Son el complemento indispensable de `keepPreviousData`.

---

### **D - Paginación en `useInfiniteQuery`** 🔵

#### 1. **Introducción:**

La misma técnica de `placeholderData` también funciona con `useInfiniteQuery`, ideal para cuando la clave de la consulta cambia (por ejemplo, al aplicar un filtro).

#### 2. **Ejemplo:**

No hay un ejemplo de código completo en el texto, pero la idea es idéntica. Imagina que tienes una lista infinita de productos y añades un filtro.

```tsx
// Concepto: La misma idea se aplica aquí
const { data, isPlaceholderData, isFetching } = useInfiniteQuery({
  queryKey: ["products", filters], // 'filters' es un objeto con los filtros aplicados
  queryFn: fetchProducts,
  placeholderData: keepPreviousData,
  // ... otras opciones de useInfiniteQuery
});
```

**Explicación del ejemplo:**
Si el usuario cambia los `filters` (por ejemplo, de `{ category: 'electronics' }` a `{ category: 'books' }`), la `queryKey` cambiará. Normalmente, esto limpiaría toda la lista de productos y mostraría un cargador. Pero con `placeholderData: keepPreviousData`, la lista de productos electrónicos se mantendría visible mientras se carga la nueva lista de libros, ofreciendo una transición mucho más agradable.

#### 3. **Desarrollo:**

Aunque el caso de uso más común para `useInfiniteQuery` es añadir páginas a una lista existente (donde la `queryKey` no cambia), hay situaciones donde la consulta base sí se modifica. En esos momentos, `keepPreviousData` es tu mejor amigo para evitar que toda la lista infinita que el usuario ha cargado desaparezca de repente.

🔵 **Específico**: Es una aplicación de la misma técnica en un contexto diferente. No lo usarás todos los días, pero es increíblemente útil saber que esta opción existe para cuando te enfrentes a un rediseño de una lista infinita basada en filtros.
