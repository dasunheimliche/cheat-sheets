## A - `retry`: El Plan B (y C, y D...) para tus Peticiones ğŸŸ¡

#### 1. **IntroducciÃ³n:**

Esta opciÃ³n es tu red de seguridad; le dice a TanStack Query cuÃ¡ntas veces debe volver a intentar una peticiÃ³n a la red si esta falla, antes de rendirse y mostrar un error.

#### 2. **Ejemplo:**

Imagina que estÃ¡s pidiendo una pizza por telÃ©fono, pero la lÃ­nea estÃ¡ ocupada. No te rindes a la primera, Â¿verdad? Vuelves a llamar. `retry` es exactamente eso.

```tsx
import { useQuery } from "@tanstack/react-query";

// Una funciÃ³n que SIMULA que la pizzerÃ­a no contesta al principio.
const pedirPizza = async () => {
  console.log("ğŸ“ Llamando a la pizzerÃ­a...");
  // Simulamos que la conexiÃ³n falla aleatoriamente.
  if (Math.random() > 0.3) {
    // Hay un 70% de probabilidad de que falle.
    throw new Error("Â¡LÃ­nea ocupada! Volviendo a intentar...");
  }
  // Â¡Ã‰xito!
  return { pizza: "Pepperoni", status: "Â¡En camino!" };
};

function App() {
  const { data, error, isError, isLoading } = useQuery({
    queryKey: ["pedidoPizza"],
    queryFn: pedirPizza,
    // Â¡AquÃ­ estÃ¡ la magia!
    // Lo intentaremos hasta 4 veces antes de darnos por vencidos.
    // (El primer intento + 3 reintentos)
    retry: 3,
  });

  // Mientras estÃ¡ intentando (y reintentando), mostramos esto.
  if (isLoading)
    return (
      <span>Intentando contactar con la pizzerÃ­a... (mira la consola)</span>
    );

  // Si despuÃ©s de todos los intentos falla, mostramos el error final.
  if (isError) return <span>Error: Â¡No hubo suerte! {error.message}</span>;

  // Si funciona, Â¡celebramos!
  return (
    <h1>
      Â¡Pedido confirmado! Tu pizza de {data.pizza} estÃ¡ {data.status}
    </h1>
  );
}
```

**ExplicaciÃ³n del ejemplo:**
En este cÃ³digo, `pedirPizza` es una funciÃ³n que probablemente falle. Al configurar `retry: 3`, le estamos diciendo a `useQuery`: "Oye, intenta llamar a la pizzerÃ­a. Si falla, no te preocupes, descansa un poquito (eso lo veremos en `retryDelay`) y vuelve a intentarlo hasta 3 veces mÃ¡s. Solo si fallas en todos los intentos, muÃ©strale al usuario el mensaje de error". VerÃ¡s en la consola del navegador el mensaje "ğŸ“ Llamando..." varias veces hasta que la llamada finalmente "entra" o se agotan los reintentos.

#### 3. **Desarrollo**:

PiÃ©nsalo como las diferentes personalidades que puedes darle a tu aplicaciÃ³n para manejar fallos:

- `retry: 3` (El valor por defecto): **El Optimista Cauteloso**. Lo intenta una vez, y si falla, lo vuelve a intentar 3 veces mÃ¡s. Es un buen equilibrio para la mayorÃ­a de las situaciones.
- `retry: false` o `retry: 0`: **El Pesimista**. Si falla una vez, se rinde inmediatamente. Perfecto para casos donde sabes que el error no es temporal (ej: un error "404 - No Encontrado". Si algo no existe, no va a aparecer por mucho que insistas).
- `retry: 10`: **El Insistente**. Ideal para conexiones muy, muy inestables, como en un mÃ³vil que entra y sale de un tÃºnel. Le da muchas oportunidades.
- `retry: true`: **El Obsesivo**. Â¡Nunca se rinde! ReintentarÃ¡ para siempre. **Â¡Mucho cuidado con esto!** Si el servidor estÃ¡ caÃ­do de verdad, tu aplicaciÃ³n crearÃ¡ un bucle infinito de peticiones que puede agotar la baterÃ­a del usuario o sus datos mÃ³viles. Ãšsalo solo si tienes una muy buena razÃ³n.
- `retry: (failureCount, error) => boolean`: **El Estratega**. Te da control total. Puedes mirar el tipo de `error` y decidir si vale la pena reintentar. Por ejemplo:
  - Si el `error` es un "503 - Servicio no disponible" (problema del servidor), devuelves `true` para reintentar.
  - Si el `error` es un "401 - No autorizado" (problema de permisos), devuelves `false` porque reintentar no solucionarÃ¡ nada.

> **Â¡OJO! Una trampa comÃºn:** En el servidor (cuando haces Server-Side Rendering), el valor por defecto de `retry` es `0`. Esto es a propÃ³sito para que la pÃ¡gina se genere lo mÃ¡s rÃ¡pido posible y no se quede esperando por una API que no responde. Â¡Tenlo en cuenta!

ğŸŸ¡ **Importante**: Saber cÃ³mo y cuÃ¡ndo reintentar una peticiÃ³n fallida es clave para crear aplicaciones robustas y amigables. Ignorar esto puede hacer que tu app parezca rota cuando solo hay un problema de red temporal.

---

## B - `retryDelay`: La Pausa Inteligente Entre Intentos ğŸŸ¡

#### 1. **IntroducciÃ³n:**

Esta opciÃ³n controla _cuÃ¡nto tiempo_ debe esperar TanStack Query entre un intento fallido y el siguiente, evitando asÃ­ bombardear a un servidor que ya estÃ¡ en problemas.

#### 2. **Ejemplo:**

Volvamos a la pizzerÃ­a. Si la lÃ­nea estÃ¡ ocupada, no cuelgas y marcas al instante un microsegundo despuÃ©s. Esperas unos segundos, y si vuelve a fallar, quizÃ¡s esperas un poco mÃ¡s. Esa espera es el `retryDelay`.

```tsx
import { useQuery } from "@tanstack/react-query";

const fetchDatosCriticos = async () => {
  console.log("Intentando obtener datos crÃ­ticos...");
  throw new Error("El servidor estÃ¡ sobrecargado.");
};

// Escenario 1: Delay que aumenta (Â¡La forma mÃ¡s educada y recomendada!)
const queryConDelayInteligente = useQuery({
  queryKey: ["datosCriticos"],
  queryFn: fetchDatosCriticos,
  retry: 3,
  // Esto es lo que hace por defecto, no necesitas escribirlo.
  // 1er reintento: espera 1s. 2do: espera 2s. 3ro: espera 4s.
  retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
});

// Escenario 2: Un delay fijo y predecible
const queryConDelayFijo = useQuery({
  queryKey: ["datosSecundarios"],
  queryFn: fetchDatosCriticos,
  retry: 3,
  // Siempre esperarÃ¡ exactamente 2 segundos entre cada reintento.
  retryDelay: 2000,
});
```

**ExplicaciÃ³n del ejemplo:**
El primer escenario (`queryConDelayInteligente`) usa una estrategia llamada **"Exponential Backoff"**. Es como dar un paso atrÃ¡s cada vez que te tropiezas. La espera se duplica con cada fallo, dÃ¡ndole al servidor mÃ¡s y mÃ¡s tiempo para recuperarse. Es el comportamiento por defecto porque es muy efectivo.

El segundo escenario (`queryConDelayFijo`) es mÃ¡s simple: si falla, espera 2 segundos. Si vuelve a fallar, espera otros 2 segundos. Es constante y predecible.

#### 3. **Desarrollo**:

La estrategia de "pausa inteligente" (Exponential Backoff) es la preferida por una razÃ³n fundamental: **la cortesÃ­a digital**. Si un servidor estÃ¡ fallando, hacerle peticiones sin parar es como gritarle a alguien que estÃ¡ mareado. Solo empeora las cosas. Al aumentar la pausa, reduces la carga sobre el servidor y aumentas la probabilidad de que tu siguiente intento tenga Ã©xito.

Vamos a desglosar la fÃ³rmula por defecto, para que no le tengas miedo: `(attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000)`

- `attemptIndex`: Es el contador de reintentos, que empieza en `0`.
- `1000 * 2 ** attemptIndex`: Esta es la parte exponencial.
  - Para el 1er reintento (`attemptIndex` es 0): `1000 * 2^0` = `1000 * 1` = 1000ms (1 segundo).
  - Para el 2do reintento (`attemptIndex` es 1): `1000 * 2^1` = `1000 * 2` = 2000ms (2 segundos).
  - Para el 3er reintento (`attemptIndex` es 2): `1000 * 2^2` = `1000 * 4` = 4000ms (4 segundos).
  - ...y asÃ­ sucesivamente.
- `Math.min(..., 30000)`: Este es un tope de seguridad. Le dice: "Oye, duplica la espera, pero nunca esperes mÃ¡s de 30 segundos". Evita que la espera se vuelva absurdamente larga.

Puedes, por supuesto, poner un nÃºmero fijo como `retryDelay: 1000` (esperar siempre 1 segundo), pero casi siempre es mejor la estrategia por defecto.

> **Anticipando una duda:** "Â¿`retry` y `retryDelay` siempre van juntos?" Â¡SÃ­! Son como Batman y Robin. `retry` decide _si_ reintentar, y `retryDelay` decide _cuÃ¡nto esperar_ antes de hacerlo. No puedes tener una pausa de reintento si no hay reintentos.

ğŸŸ¡ **Importante**: Usar un `retryDelay` adecuado es tan crucial como el `retry` mismo. Un mal `retryDelay` (o no tenerlo) puede convertir tu aplicaciÃ³n de una soluciÃ³n a parte del problema, contribuyendo a la caÃ­da de un servidor.
