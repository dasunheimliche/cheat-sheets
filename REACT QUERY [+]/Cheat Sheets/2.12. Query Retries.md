## A - `retry`: El Plan B (y C, y D...) para tus Peticiones 🟡

#### 1. **Introducción:**

Esta opción es tu red de seguridad; le dice a TanStack Query cuántas veces debe volver a intentar una petición a la red si esta falla, antes de rendirse y mostrar un error.

#### 2. **Ejemplo:**

Imagina que estás pidiendo una pizza por teléfono, pero la línea está ocupada. No te rindes a la primera, ¿verdad? Vuelves a llamar. `retry` es exactamente eso.

```tsx
import { useQuery } from "@tanstack/react-query";

// Una función que SIMULA que la pizzería no contesta al principio.
const pedirPizza = async () => {
  console.log("📞 Llamando a la pizzería...");
  // Simulamos que la conexión falla aleatoriamente.
  if (Math.random() > 0.3) {
    // Hay un 70% de probabilidad de que falle.
    throw new Error("¡Línea ocupada! Volviendo a intentar...");
  }
  // ¡Éxito!
  return { pizza: "Pepperoni", status: "¡En camino!" };
};

function App() {
  const { data, error, isError, isLoading } = useQuery({
    queryKey: ["pedidoPizza"],
    queryFn: pedirPizza,
    // ¡Aquí está la magia!
    // Lo intentaremos hasta 4 veces antes de darnos por vencidos.
    // (El primer intento + 3 reintentos)
    retry: 3,
  });

  // Mientras está intentando (y reintentando), mostramos esto.
  if (isLoading)
    return (
      <span>Intentando contactar con la pizzería... (mira la consola)</span>
    );

  // Si después de todos los intentos falla, mostramos el error final.
  if (isError) return <span>Error: ¡No hubo suerte! {error.message}</span>;

  // Si funciona, ¡celebramos!
  return (
    <h1>
      ¡Pedido confirmado! Tu pizza de {data.pizza} está {data.status}
    </h1>
  );
}
```

**Explicación del ejemplo:**
En este código, `pedirPizza` es una función que probablemente falle. Al configurar `retry: 3`, le estamos diciendo a `useQuery`: "Oye, intenta llamar a la pizzería. Si falla, no te preocupes, descansa un poquito (eso lo veremos en `retryDelay`) y vuelve a intentarlo hasta 3 veces más. Solo si fallas en todos los intentos, muéstrale al usuario el mensaje de error". Verás en la consola del navegador el mensaje "📞 Llamando..." varias veces hasta que la llamada finalmente "entra" o se agotan los reintentos.

#### 3. **Desarrollo**:

Piénsalo como las diferentes personalidades que puedes darle a tu aplicación para manejar fallos:

- `retry: 3` (El valor por defecto): **El Optimista Cauteloso**. Lo intenta una vez, y si falla, lo vuelve a intentar 3 veces más. Es un buen equilibrio para la mayoría de las situaciones.
- `retry: false` o `retry: 0`: **El Pesimista**. Si falla una vez, se rinde inmediatamente. Perfecto para casos donde sabes que el error no es temporal (ej: un error "404 - No Encontrado". Si algo no existe, no va a aparecer por mucho que insistas).
- `retry: 10`: **El Insistente**. Ideal para conexiones muy, muy inestables, como en un móvil que entra y sale de un túnel. Le da muchas oportunidades.
- `retry: true`: **El Obsesivo**. ¡Nunca se rinde! Reintentará para siempre. **¡Mucho cuidado con esto!** Si el servidor está caído de verdad, tu aplicación creará un bucle infinito de peticiones que puede agotar la batería del usuario o sus datos móviles. Úsalo solo si tienes una muy buena razón.
- `retry: (failureCount, error) => boolean`: **El Estratega**. Te da control total. Puedes mirar el tipo de `error` y decidir si vale la pena reintentar. Por ejemplo:
  - Si el `error` es un "503 - Servicio no disponible" (problema del servidor), devuelves `true` para reintentar.
  - Si el `error` es un "401 - No autorizado" (problema de permisos), devuelves `false` porque reintentar no solucionará nada.

> **¡OJO! Una trampa común:** En el servidor (cuando haces Server-Side Rendering), el valor por defecto de `retry` es `0`. Esto es a propósito para que la página se genere lo más rápido posible y no se quede esperando por una API que no responde. ¡Tenlo en cuenta!

🟡 **Importante**: Saber cómo y cuándo reintentar una petición fallida es clave para crear aplicaciones robustas y amigables. Ignorar esto puede hacer que tu app parezca rota cuando solo hay un problema de red temporal.

---

## B - `retryDelay`: La Pausa Inteligente Entre Intentos 🟡

#### 1. **Introducción:**

Esta opción controla _cuánto tiempo_ debe esperar TanStack Query entre un intento fallido y el siguiente, evitando así bombardear a un servidor que ya está en problemas.

#### 2. **Ejemplo:**

Volvamos a la pizzería. Si la línea está ocupada, no cuelgas y marcas al instante un microsegundo después. Esperas unos segundos, y si vuelve a fallar, quizás esperas un poco más. Esa espera es el `retryDelay`.

```tsx
import { useQuery } from "@tanstack/react-query";

const fetchDatosCriticos = async () => {
  console.log("Intentando obtener datos críticos...");
  throw new Error("El servidor está sobrecargado.");
};

// Escenario 1: Delay que aumenta (¡La forma más educada y recomendada!)
const queryConDelayInteligente = useQuery({
  queryKey: ["datosCriticos"],
  queryFn: fetchDatosCriticos,
  retry: 3,
  // Esto es lo que hace por defecto, no necesitas escribirlo.
  // 1er reintento: espera 1s. 2do: espera 2s. 3ro: espera 4s.
  retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
});

// Escenario 2: Un delay fijo y predecible
const queryConDelayFijo = useQuery({
  queryKey: ["datosSecundarios"],
  queryFn: fetchDatosCriticos,
  retry: 3,
  // Siempre esperará exactamente 2 segundos entre cada reintento.
  retryDelay: 2000,
});
```

**Explicación del ejemplo:**
El primer escenario (`queryConDelayInteligente`) usa una estrategia llamada **"Exponential Backoff"**. Es como dar un paso atrás cada vez que te tropiezas. La espera se duplica con cada fallo, dándole al servidor más y más tiempo para recuperarse. Es el comportamiento por defecto porque es muy efectivo.

El segundo escenario (`queryConDelayFijo`) es más simple: si falla, espera 2 segundos. Si vuelve a fallar, espera otros 2 segundos. Es constante y predecible.

#### 3. **Desarrollo**:

La estrategia de "pausa inteligente" (Exponential Backoff) es la preferida por una razón fundamental: **la cortesía digital**. Si un servidor está fallando, hacerle peticiones sin parar es como gritarle a alguien que está mareado. Solo empeora las cosas. Al aumentar la pausa, reduces la carga sobre el servidor y aumentas la probabilidad de que tu siguiente intento tenga éxito.

Vamos a desglosar la fórmula por defecto, para que no le tengas miedo: `(attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000)`

- `attemptIndex`: Es el contador de reintentos, que empieza en `0`.
- `1000 * 2 ** attemptIndex`: Esta es la parte exponencial.
  - Para el 1er reintento (`attemptIndex` es 0): `1000 * 2^0` = `1000 * 1` = 1000ms (1 segundo).
  - Para el 2do reintento (`attemptIndex` es 1): `1000 * 2^1` = `1000 * 2` = 2000ms (2 segundos).
  - Para el 3er reintento (`attemptIndex` es 2): `1000 * 2^2` = `1000 * 4` = 4000ms (4 segundos).
  - ...y así sucesivamente.
- `Math.min(..., 30000)`: Este es un tope de seguridad. Le dice: "Oye, duplica la espera, pero nunca esperes más de 30 segundos". Evita que la espera se vuelva absurdamente larga.

Puedes, por supuesto, poner un número fijo como `retryDelay: 1000` (esperar siempre 1 segundo), pero casi siempre es mejor la estrategia por defecto.

> **Anticipando una duda:** "¿`retry` y `retryDelay` siempre van juntos?" ¡Sí! Son como Batman y Robin. `retry` decide _si_ reintentar, y `retryDelay` decide _cuánto esperar_ antes de hacerlo. No puedes tener una pausa de reintento si no hay reintentos.

🟡 **Importante**: Usar un `retryDelay` adecuado es tan crucial como el `retry` mismo. Un mal `retryDelay` (o no tenerlo) puede convertir tu aplicación de una solución a parte del problema, contribuyendo a la caída de un servidor.
