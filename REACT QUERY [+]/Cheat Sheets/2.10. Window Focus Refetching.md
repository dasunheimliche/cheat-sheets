## A - `refetchOnWindowFocus`: El Guardi√°n Atento de tus Datos üü°

#### 1. **Introducci√≥n:**

Imagina que TanStack Query es un guardi√°n s√∫per atento para los datos de tu aplicaci√≥n; por defecto, cada vez que te vas a otra pesta√±a y luego regresas, √©l revisa si los datos que ves podr√≠an estar "viejos" y, si es as√≠, los actualiza autom√°ticamente por ti en segundo plano.

#### 2. **Ejemplo (Conceptual):**

Piensa en una aplicaci√≥n de chat en tiempo real.

1.  **T√∫:** Est√°s viendo una conversaci√≥n con tu amigo Juan. El √∫ltimo mensaje es "Nos vemos a las 5".
2.  **Te vas:** Abres otra pesta√±a para ver un video de gatitos. Mientras tanto, Juan te escribe: "Mejor a las 6, ¬øvale?".
3.  **Vuelves:** Regresas a la pesta√±a del chat. ¬°_BAM_! Sin que hagas nada, TanStack Query detecta que has vuelto, sospecha que los datos pueden ser antiguos (`stale`), vuelve a pedir los mensajes al servidor y la pantalla se actualiza sola para mostrar el nuevo mensaje de Juan.

**Explicaci√≥n del "ejemplo":**
Este comportamiento es el que viene **activado por defecto**. No necesitas escribir ning√∫n c√≥digo para que funcione. La magia de `refetchOnWindowFocus: true` (su valor predeterminado) es que mantiene la interfaz de usuario de tus usuarios sincronizada con la realidad del servidor, creando una experiencia mucho m√°s fluida y fiable.

#### 3. **Desarrollo:**

Esta es una de las caracter√≠sticas estrella de TanStack Query. La idea central es evitar que el usuario vea informaci√≥n desactualizada.

- **¬øQu√© significa "stale" (viejo/rancio)?** Despu√©s de que una consulta se resuelve por primera vez, TanStack Query la considera "fresca". Pero despu√©s de un tiempo (que t√∫ puedes configurar con `staleTime`), la marca como "stale". Una consulta "stale" no significa que est√© _mal_, solo que _podr√≠a_ estarlo. Es una candidata a ser actualizada la pr√≥xima vez que sea necesario, como cuando vuelves a enfocar la ventana.

- **¬øPor qu√© es tan √∫til?** Porque el estado de tu servidor puede cambiar en cualquier momento por acciones de otros usuarios o procesos autom√°ticos. Esta funci√≥n asegura que lo que tu usuario ve es un reflejo fiel de la base de datos, sin necesidad de que apriete F5.

üü° **Importante**: Es fundamental que entiendas este comportamiento porque es el n√∫cleo de la filosof√≠a de "sincronizaci√≥n autom√°tica" de TanStack Query. Aunque a veces quieras desactivarlo (como veremos a continuaci√≥n), saber que existe y por qu√© funciona as√≠ es crucial.

---

## B - Desactivando `refetchOnWindowFocus`: D√°ndole un Descanso al Guardi√°n üîµ

#### 1. **Introducci√≥n:**

Aunque la actualizaci√≥n autom√°tica es genial, a veces no la necesitas (o no la quieres); puedes desactivarla para toda tu aplicaci√≥n o solo para una consulta espec√≠fica.

#### 2. **Ejemplo (Comparativa):**

Imagina que est√°s construyendo una app que muestra dos cosas: una lista de tareas que cambia constantemente y una lista de pa√≠ses que casi nunca cambia.

**Opci√≥n 1: Desactivarlo para TODA la app (Globalmente)**
_Ideal si la mayor√≠a de tus datos no cambian mucho._

```tsx
// En tu archivo principal, donde configuras el cliente.
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // Le decimos a TODAS las consultas: "No se actualicen al volver a la ventana".
      refetchOnWindowFocus: false,
    },
  },
});

function App() {
  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>;
}
```

**Opci√≥n 2: Desactivarlo para UNA SOLA consulta (Por Consulta)**
_Ideal para hacer excepciones, como con nuestra lista de pa√≠ses._

```tsx
// En el componente que muestra la lista de pa√≠ses.
useQuery({
  queryKey: ["countries"],
  queryFn: fetchCountries,
  // Le decimos SOLO a esta consulta: "T√∫ qu√©date quieta, no te actualices".
  refetchOnWindowFocus: false,
});

// Mientras tanto, la consulta de la lista de tareas (que no tiene esta opci√≥n)
// seguir√° actualiz√°ndose autom√°ticamente como siempre.
useQuery({
  queryKey: ["todos"],
  queryFn: fetchTodos,
  // No ponemos nada, as√≠ que usa el valor por defecto (true).
});
```

**Explicaci√≥n del ejemplo:**
En la **Opci√≥n 1**, estableces una regla general para toda tu aplicaci√≥n. Es como poner un cartel en la entrada de una f√°brica que dice: "PROHIBIDO TRABAJAR HORAS EXTRA". Ninguna consulta har√° este trabajo extra de refrescarse al enfocar la ventana, a menos que se lo permitas expl√≠citamente.

En la **Opci√≥n 2**, la regla general sigue siendo la de por defecto (`true`), pero para la consulta espec√≠fica de los pa√≠ses, le das una instrucci√≥n directa y personal: "T√∫ no, descansa". Esto es √∫til para datos que sabes que son muy estables, y as√≠ te ahorras una llamada innecesaria a la API.

#### 3. **Desarrollo:**

La pregunta clave es **"¬øPor qu√© querr√≠a desactivar algo tan √∫til?"**. ¬°Excelente pregunta! Aqu√≠ tienes algunos motivos:

- **Datos Inmutables:** Para datos que nunca o casi nunca cambian (una lista de categor√≠as, provincias, datos hist√≥ricos). Refrescarlos es un gasto in√∫til de recursos.
- **Ahorro de API:** Si tu API tiene un l√≠mite de peticiones o si quieres minimizar el tr√°fico de red (especialmente en dispositivos m√≥viles).
- **Evitar "Flickering":** A veces, un refresco r√°pido puede causar un peque√±o parpadeo en la UI que, aunque sea moment√°neo, puede resultar molesto en ciertos contextos.
- **Formularios:** Si un usuario est√° rellenando un formulario basado en datos de una consulta, un refresco autom√°tico podr√≠a resetear o alterar los campos, ¬°ser√≠a una pesadilla para el usuario!

üîµ **Espec√≠fico**: No es algo que har√°s todos los d√≠as, pero saber c√≥mo y cu√°ndo desactivar esta funci√≥n te da un control mucho m√°s fino sobre el comportamiento de tu aplicaci√≥n y la experiencia de usuario. Es una herramienta de optimizaci√≥n.

---

## C - `focusManager`: Tomando el Control Manual del Foco ‚ö™

#### 1. **Introducci√≥n:**

El `focusManager` es una herramienta avanzada que te permite ignorar los detectores autom√°ticos del navegador y decirle a TanStack Query exactamente cu√°ndo debe considerar que la aplicaci√≥n est√° "enfocada".

#### 2. **Ejemplo:**

Imagina que quieres que los datos solo se refresquen si el usuario, despu√©s de volver a la pesta√±a, mueve el rat√≥n. El evento por defecto (`visibilitychange`) no es suficiente para ti.

```tsx
import { focusManager } from "@tanstack/react-query";

// Le decimos a TanStack Query que ignore su l√≥gica de foco...
focusManager.setEventListener((handleFocus) => {
  // ...y que en su lugar, use la nuestra.

  // Creamos nuestro propio listener para el movimiento del rat√≥n.
  const onMouseMove = () => {
    // Cuando el rat√≥n se mueva, llamamos a la funci√≥n que TanStack Query nos dio.
    // Esto le dice: "¬°Oye, considera la ventana enfocada AHORA!"
    handleFocus(true);
  };

  // A√±adimos nuestro listener al 'window'.
  window.addEventListener("mousemove", onMouseMove, false);

  // ¬°MUY IMPORTANTE! Debemos devolver una funci√≥n de limpieza.
  // Se ejecutar√° si pones otro listener o el componente se desmonta.
  return () => {
    window.removeEventListener("mousemove", onMouseMove);
  };
});
```

**Explicaci√≥n del ejemplo:**
Con `setEventListener`, b√°sicamente est√°s haciendo un pacto con TanStack Query. Le dices: "Dame tu interruptor (`handleFocus`) y yo me encargo de encenderlo cuando crea conveniente". En el ejemplo, conectamos ese interruptor al movimiento del rat√≥n. Cada vez que el rat√≥n se mueve, llamamos a `handleFocus(true)`, lo que desencadena la misma l√≥gica de refresco que ocurrir√≠a normalmente al enfocar la ventana.

#### 3. **Desarrollo:**

Esto es como abrir el cap√≥ del coche para modificar el motor. No es para principiantes y el 99% de las veces no lo necesitar√°s. El comportamiento por defecto es robusto y funciona en casi todos los casos. Solo recurrir√≠as a esto si tienes un requisito de negocio muy ex√≥tico o si est√°s integrando TanStack Query en un entorno no est√°ndar que no tiene un concepto claro de "foco de ventana".

‚ö™ **Raramente usado**: Es una herramienta de poder para situaciones muy espec√≠ficas. Es bueno saber que existe por si alguna vez te encuentras en un escenario muy particular, pero no es algo que debas memorizar al principio.

---

## D - `focusManager` en React Native: Adaptando el Foco al Mundo M√≥vil üîµ

#### 1. **Introducci√≥n:**

En una app m√≥vil no hay "pesta√±as de navegador", as√≠ que para lograr el mismo efecto de "refrescar al volver", usamos el sistema `AppState` de React Native para detectar si la app est√° en primer o segundo plano.

#### 2. **Ejemplo:**

Este c√≥digo se suele poner en el componente ra√≠z de tu aplicaci√≥n (como `App.js`).

```tsx
import { useEffect } from "react";
import { AppState } from "react-native";
import { focusManager } from "@tanstack/react-query";

function onAppStateChange(status) {
  // Cuando el estado de la app cambia, esta funci√≥n se ejecuta.
  // 'status' puede ser 'active', 'background', o 'inactive'.

  // Le decimos a TanStack Query que considere la app "enfocada"
  // SOLAMENTE si el estado es 'active'.
  focusManager.setFocused(status === "active");
}

// Dentro de tu componente App
useEffect(() => {
  // Nos suscribimos a los cambios de estado de la app.
  const subscription = AppState.addEventListener("change", onAppStateChange);

  // Cuando el componente se desmonte, nos damos de baja para evitar fugas de memoria.
  return () => subscription.remove();
}, []);
```

**Explicaci√≥n del ejemplo:**

1.  **`AppState`**: Es el chismoso de React Native. Nos cuenta si el usuario est√° viendo la app (`active`) o si la tiene en segundo plano (`background`).
2.  **`addEventListener('change', ...)`**: Nos apuntamos a ese chismorreo. Le decimos: "Oye, `AppState`, av√≠same cada vez que el estado de la app cambie".
3.  **`focusManager.setFocused(...)`**: Esta es la pieza clave. Es una forma m√°s directa de controlar el foco que `setEventListener`. Cuando `AppState` nos dice que la app est√° `active`, nosotros le decimos a TanStack Query: `setFocused(true)`. Si el estado es otro, le decimos `setFocused(false)`.
4.  **`useEffect` y la limpieza**: Envolvemos todo en un `useEffect` para que se configure una sola vez y nos aseguramos de limpiar la suscripci√≥n al final. ¬°Higiene ante todo!

#### 3. **Desarrollo:**

Este es el m√©todo est√°ndar y recomendado para implementar el "refetch on focus" en React Native. A diferencia de la web, aqu√≠ s√≠ que tienes que configurarlo t√∫ mismo, pero como ves, es un c√≥digo bastante est√°ndar que puedes copiar y pegar. Es la adaptaci√≥n necesaria para llevar la genialidad de TanStack Query al ecosistema m√≥vil.

üîµ **Espec√≠fico**: Es absolutamente esencial si usas TanStack Query con React Native. Si solo trabajas en web, puedes ignorarlo. Pero para un desarrollador de RN, esto es pan de cada d√≠a.
