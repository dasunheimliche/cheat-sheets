## A - Query Keys: El DNI de tus Datos üî¥

#### 1. **Introducci√≥n:**

Las `Query Keys` son el identificador **√∫nico e irrepetible** que TanStack Query usa para cada pedacito de informaci√≥n que pides, permiti√©ndole guardarla en cach√© y recuperarla despu√©s sin volver a preguntar al servidor.

#### 2. **Ejemplo:**

Imagina que est√°s creando una aplicaci√≥n de gesti√≥n de tareas (un "To-Do list").

```tsx
import { useQuery } from "@tanstack/react-query";

// 1. Pides la LISTA COMPLETA de todas las tareas
useQuery({
  queryKey: ["todos"], // El DNI para "todas las tareas"
  queryFn: fetchAllTodos,
});

// 2. Pides UNA TAREA ESPEC√çFICA, por ejemplo, la que tiene el ID 5
useQuery({
  queryKey: ["todos", 5], // El DNI para "la tarea con id 5"
  queryFn: () => fetchTodoById(5),
});
```

**Explicaci√≥n del ejemplo:**
F√≠jate bien. En el primer caso, la "matr√≠cula" o DNI de nuestros datos es `['todos']`. Es simple y gen√©rica. En el segundo, la matr√≠cula es `['todos', 5]`. Aunque ambas empiezan igual, el `5` al final la hace **completamente diferente**.

Para TanStack Query, `['todos']` y `['todos', 5]` son dos cosas tan distintas como un "autob√∫s" y un "coche con matr√≠cula 5". Guardar√° los datos de cada uno en compartimentos separados de su memoria (cach√©).

#### 3. **Desarrollo**:

Pi√©nsalo como el sistema de almacenamiento de un almac√©n gigante. Cada paquete (tus datos) necesita una etiqueta √∫nica (la `queryKey`) para que los trabajadores (TanStack Query) puedan encontrarlo sin dudar. Si dos paquetes tuvieran la misma etiqueta, ¬°ser√≠a un caos!

La regla fundamental es que esta etiqueta **siempre debe ser un array** (`[...]`). Dentro de ese array puedes poner casi lo que quieras (texto, n√∫meros, objetos), siempre que sea "serializable" (es decir, que se pueda convertir a un texto plano con `JSON.stringify` sin perder informaci√≥n).

üî¥ **Fundamental**: Este es el concepto **m√°s importante** de toda la librer√≠a. Sin entender c√≥mo identificar tus datos, no puedes usar TanStack Query. Es como intentar conducir sin saber qu√© es un volante. Todo lo dem√°s se construye sobre esta idea.

---

## B - Query Keys Simples: Etiquetas para los Cajones Generales üî¥

#### 1. **Introducci√≥n:**

Este es el tipo de clave m√°s b√°sico, perfecto para pedir recursos que no dependen de ninguna variable, como una lista completa de elementos.

#### 2. **Ejemplo:**

Supongamos que en tu app de comercio electr√≥nico quieres mostrar una lista con todas las categor√≠as de productos disponibles. Esa lista es siempre la misma para todos los usuarios.

```tsx
// Pedimos la lista de TODAS las categor√≠as de productos.
// No hay filtros, ni IDs, ni nada. Solo la lista completa.
useQuery({
  queryKey: ["product-categories"],
  queryFn: fetchProductCategories,
});
```

**Explicaci√≥n del ejemplo:**
La clave `['product-categories']` es como ponerle una etiqueta a un caj√≥n que dice "CATEGOR√çAS". Es una etiqueta fija. Cada vez que cualquier parte de tu aplicaci√≥n necesite la lista completa de categor√≠as, usar√° esta misma clave, y TanStack Query le dar√° los datos que ya tiene guardados (si a√∫n son v√°lidos), ahorr√°ndote una llamada innecesaria al servidor.

#### 3. **Desarrollo**:

Usa este patr√≥n para datos "globales" o "maestros": una lista de pa√≠ses, los tipos de usuario de tu sistema, la configuraci√≥n general de la aplicaci√≥n, etc. Son datos que no suelen cambiar en funci√≥n de lo que el usuario haga en la pantalla. La clave suele ser un array con una o m√°s cadenas de texto que describen el recurso de forma clara.

üî¥ **Fundamental**: Es el punto de partida. Aunque simple, lo usar√°s constantemente para los datos base de tu aplicaci√≥n. Es el "Hola, Mundo" de las `Query Keys`.

---

## C - Query Keys con Variables: Etiquetas para Datos Espec√≠ficos üî¥

#### 1. **Introducci√≥n:**

Cuando los datos que necesitas dependen de un valor que puede cambiar (como un ID, un t√©rmino de b√∫squeda o un filtro), **debes** incluir esa variable en la `queryKey`.

#### 2. **Ejemplo:**

Continuemos con nuestra tienda. Ahora queremos ver los detalles de un producto espec√≠fico y tambi√©n una lista de productos filtrados.

```tsx
// CASO 1: Ver los detalles de UN producto, seg√∫n su ID.
function ProductDetailsPage({ productId }) {
  const { data } = useQuery({
    // La clave ahora depende del `productId`.
    queryKey: ["products", productId], // ej: ['products', 'xyz-123']
    queryFn: () => fetchProductById(productId),
  });
  // ...
}

// CASO 2: Ver una lista de productos que est√°n en oferta.
function SalePage() {
  const { data } = useQuery({
    // La clave incluye un objeto que describe el filtro.
    queryKey: ["products", { status: "on-sale", page: 1 }],
    queryFn: () => fetchProducts({ status: "on-sale", page: 1 }),
  });
  // ...
}
```

**Explicaci√≥n del ejemplo:**

- **Caso 1:** Si `productId` es `'xyz-123'`, la clave ser√° `['products', 'xyz-123']`. Si el usuario navega a otro producto con ID `'abc-987'`, la clave cambiar√° a `['products', 'abc-987']`. TanStack Query ve que la clave es diferente y autom√°ticamente buscar√° los datos del nuevo producto. ¬°Magia autom√°tica!
- **Caso 2:** La clave `['products', { status: 'on-sale', page: 1 }]` identifica de forma √∫nica la "primera p√°gina de productos en oferta". Si el usuario va a la p√°gina 2, la clave cambiar√≠a a `['products', { status: 'on-sale', page: 2 }]`, desencadenando una nueva b√∫squeda.

#### 3. **Desarrollo**:

**¬°ATENCI√ìN! ESTA ES LA REGLA DE ORO:** Si una variable se usa dentro de tu funci√≥n de fetching (`queryFn`), **TIENE que estar en tu `queryKey`**. Si te olvidas de esto, TanStack Query se har√° un l√≠o. Creer√° que est√°s pidiendo siempre lo mismo (porque la clave no cambia) y te devolver√° datos viejos y err√≥neos. Este es el error m√°s com√∫n de los principiantes, ¬°pero t√∫ ya lo sabes y no caer√°s en √©l!

üî¥ **Fundamental**: Las aplicaciones reales son din√°micas. Filtrar, paginar, buscar y ver detalles son el pan de cada d√≠a. Este patr√≥n es absolutamente esencial y lo usar√°s en el 90% de los casos.

---

## D - El "Hashing" de las Keys: El Orden de los Factores S√ç Altera el Producto (a veces) üü°

#### 1. **Introducci√≥n:**

TanStack Query es muy listo con los **objetos** dentro de las claves (no le importa el orden de sus propiedades), pero es muy estricto con el **orden de los elementos** en el array.

#### 2. **Ejemplo:**

Observa esta sutileza, ¬°es clave para no tener errores inesperados!

```tsx
// ‚úÖ ESTAS DOS KEYS SON ID√âNTICAS para TanStack Query
// No importa si 'page' va antes o despu√©s que 'status' en el objeto.
useQuery({ queryKey: ["todos", { status: "done", page: 1 }] });
useQuery({ queryKey: ["todos", { page: 1, status: "done" }] });

// ‚ùå PERO ESTAS DOS KEYS SON TOTALMENTE DIFERENTES
// ¬°Aqu√≠ el orden en el array S√ç importa!
useQuery({ queryKey: ["todos", "done", 1] });
useQuery({ queryKey: ["todos", 1, "done"] });
```

**Explicaci√≥n del ejemplo:**
En el primer par, TanStack Query, antes de generar su identificador interno, ordena alfab√©ticamente las propiedades del objeto. Por tanto, para √©l, `{ page: 1, status: 'done' }` se convierte internamente en lo mismo que `{ status: 'done', page: 1 }`. ¬°Muy conveniente!

Sin embargo, en el segundo par, trata al array tal cual lo ve. Para √©l, `['todos', 'done', 1]` y `['todos', 1, 'done']` son dos etiquetas completamente distintas, como si fueran "Calle Mayor, n√∫mero 2" y "Calle 2, n√∫mero Mayor". No tienen nada que ver.

#### 3. **Desarrollo**:

¬øY esto para qu√© me sirve? ¬°Para escribir c√≥digo m√°s limpio y seguro!

- **Usa objetos `{}`** para par√°metros de consulta como filtros, paginaci√≥n o b√∫squedas. As√≠ no tienes que preocuparte por el orden en que los defines. Es m√°s legible y menos propenso a errores.
- **Usa el orden del array** para datos que tienen una jerarqu√≠a natural. Por ejemplo: `['continentes', 'Europa', 'Espa√±a', 'ciudades']`. Aqu√≠ el orden tiene un significado l√≥gico.

üü° **Importante**: Puede que no te topes con este problema el primer d√≠a, pero entender esta diferencia te salvar√° de futuros dolores de cabeza cuando tus claves se vuelvan m√°s complejas. Saber esto te distingue de un principiante y te ayuda a estructurar tus claves de la forma m√°s robusta posible.
