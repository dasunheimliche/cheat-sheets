### **Actualizaciones desde Mutaciones: ¬°Magia Instant√°nea para tu UI!**

Imagina que editas un elemento en tu aplicaci√≥n. Lo normal ser√≠a:

1.  Enviar el cambio al servidor.
2.  Esperar a que el servidor diga "¬°OK, guardado!".
3.  Volver a pedirle al servidor _todos_ los datos para asegurarte de que ves el cambio.

¬°Pero eso es lento y derrochador! El servidor, en el paso 2, ¬°ya te devuelve el dato actualizado! Vamos a usar ese regalo para actualizar nuestra aplicaci√≥n al instante, sin ese viaje extra.

---

## A - `setQueryData`: Actualizando el Cache al Instante sin Viajes Extra üü°

#### 1. **Introducci√≥n:**

Esta funci√≥n es tu atajo para decirle a TanStack Query: "¬°Oye, acabo de recibir datos frescos del servidor, √∫salos para actualizar esta parte de la aplicaci√≥n AHORA MISMO!", evitando as√≠ una nueva llamada a la red.

#### 2. **Ejemplo:**

Imagina que tienes una lista de tareas ("todos") y editas una.

```tsx
// 1. Obtenemos acceso al "cerebro" de TanStack Query
const queryClient = useQueryClient();

// 2. Definimos nuestra "misi√≥n" de edici√≥n
const mutation = useMutation({
  mutationFn: editarTareaEnElServidor, // La funci√≥n que realmente habla con el servidor

  // 3. ¬°La parte M√ÅGICA! ¬øQu√© hacer cuando todo sale bien?
  onSuccess: (datosNuevos) => {
    // Le decimos al cerebro: "Para la tarea con id 5, usa estos datos nuevos"
    queryClient.setQueryData(["tarea", { id: 5 }], datosNuevos);
  },
});

// 4. Ejecutamos la misi√≥n con los nuevos datos
mutation.mutate({
  id: 5,
  texto: "Lavar la ropa (¬°y no mezclar colores!)",
});

// 5. ¬°Resultado! Cualquier componente que est√© usando esta query...
const { data } = useQuery({ queryKey: ["tarea", { id: 5 }] });
// ...se actualizar√° instant√°neamente con "Lavar la ropa (¬°y no mezclar colores!)"
// ¬°SIN volver a preguntar al servidor!
```

**Explicaci√≥n del ejemplo:**

- **Paso 1 y 2:** Preparamos el terreno. `useQueryClient()` nos da el control sobre el cache (el "cerebro" donde se guardan los datos) y `useMutation` define la operaci√≥n que cambiar√° algo en el servidor (como `editarTareaEnElServidor`).
- **Paso 3 (`onSuccess`):** Este es el coraz√≥n del truco. `onSuccess` se ejecuta autom√°ticamente cuando el servidor responde con √©xito. El par√°metro `datosNuevos` contiene la respuesta del servidor (la tarea ya actualizada).
- **`queryClient.setQueryData(...)`:** Aqu√≠ es donde ocurre la magia. Le pasamos dos cosas:
  1.  La `queryKey` (`['tarea', { id: 5 }]`) que identifica EXACTAMENTE qu√© dato queremos actualizar en el cache.
  2.  Los `datosNuevos` que recibimos del servidor.
- **Resultado:** La interfaz de usuario que depend√≠a de `useQuery` con la llave `['tarea', { id: 5 }]` se refresca al instante. El usuario ve el cambio de inmediato, y nos ahorramos una petici√≥n a la red. ¬°M√°s r√°pido y eficiente!

#### 3. **Desarrollo:**

Piensa en `setQueryData` como una actualizaci√≥n manual y optimista. En lugar de invalidar la query y forzar a que se vuelva a pedir (lo que implica un tiempo de carga), tomamos el control y colocamos los datos frescos directamente donde deben estar. Es la diferencia entre demoler una pared para cambiar un cuadro y simplemente descolgar el viejo y colgar el nuevo.

üü° **Importante**: Esta no es la √∫nica forma de actualizar datos, pero es una t√©cnica de optimizaci√≥n fundamental. Aprender a usarla har√° que tus aplicaciones se sientan incre√≠blemente r√°pidas y responsivas. Es un pilar para crear experiencias de usuario de alta calidad con TanStack Query.

---

## B - Inmutabilidad: ¬°Regla de Oro! No Modifiques los Datos Viejos üî¥

#### 1. **Introducci√≥n:**

Cuando actualices el cache, NUNCA modifiques el objeto de datos antiguo directamente; en su lugar, crea siempre una copia nueva con tus cambios.

#### 2. **Ejemplo:**

Supongamos que quieres cambiar el t√≠tulo de un post que ya tienes en el cache.

```tsx
// La llave del dato que queremos cambiar
const queryKey = ["posts", { id: 1 }];

// ‚ùå ¬°EL CAMINO DEL DOLOR Y EL SUFRIMIENTO! ‚ùå
queryClient.setQueryData(queryKey, (datosViejos) => {
  if (datosViejos) {
    // ¬°NO, NO, NO! Est√°s "pintando" sobre el libro original de la biblioteca.
    datosViejos.title = "Mi nuevo t√≠tulo";
  }
  return datosViejos; // Devuelves el mismo objeto modificado. ¬°MAL!
});

// ‚úÖ ¬°EL CAMINO DE LA LUZ Y LA ARMON√çA! ‚úÖ
queryClient.setQueryData(queryKey, (datosViejos) => {
  // Si no hay datos viejos, no hacemos nada.
  if (!datosViejos) return;

  // ¬°S√ç! Hacemos una fotocopia, escribimos en ella y la devolvemos.
  return {
    ...datosViejos, // 1. Copia todas las propiedades del objeto viejo...
    title: "Mi nuevo t√≠tulo", // 2. ...y sobrescribe solo la que quieres cambiar.
  };
});
```

**Explicaci√≥n del ejemplo:**

- **El Error (`‚ùå`):** Al hacer `datosViejos.title = '...'`, est√°s mutando (modificando directamente) el objeto que vive en el cache. React y TanStack Query dependen de la referencia de los objetos para detectar cambios. Si la referencia del objeto no cambia (porque sigues usando el mismo `datosViejos`), a menudo no se dar√°n cuenta de que algo ha cambiado y tu interfaz no se actualizar√°. Esto provoca bugs sutiles y frustrantes.
- **La Soluci√≥n (`‚úÖ`):** El "spread operator" (`...datosViejos`) crea un objeto **completamente nuevo** en memoria, copiando todas las propiedades del original. Luego, especificamos `title: 'Mi nuevo t√≠tulo'`, que sobrescribe esa propiedad en la _nueva copia_. Al devolver este nuevo objeto, TanStack Query ve una referencia diferente, sabe sin lugar a dudas que los datos han cambiado y actualiza la interfaz de forma fiable.

#### 3. **Desarrollo:**

La inmutabilidad es un concepto sagrado en el desarrollo moderno con React. Forzarte a crear nuevos objetos en lugar de modificar los existentes previene una categor√≠a entera de errores llamados "efectos secundarios". Hace que tu c√≥digo sea m√°s predecible: si los datos cambian, es porque se cre√≥ un nuevo estado, punto. No hay modificaciones misteriosas ocurriendo por debajo.

üî¥ **Fundamental**: Esto no es una sugerencia, es una regla de hierro. Violar el principio de inmutabilidad te llevar√° por un camino de frustraci√≥n con componentes que no se actualizan cuando deber√≠an. Gr√°batelo a fuego: **"No mutar√°s el estado"**.

---

## C - Hooks de Mutaci√≥n Personalizados: ¬°Crea tus Propias Herramientas! üü°

#### 1. **Introducci√≥n:**

Para evitar repetir la misma l√≥gica de mutaci√≥n una y otra vez, puedes empaquetarla en tu propio "custom hook" reutilizable.

#### 2. **Ejemplo:**

En lugar de configurar la mutaci√≥n de `editarTarea` en cada componente que la necesite, creamos una herramienta √∫nica.

```tsx
// 1. Creamos nuestro propio hook: `useEditarTarea`
const useEditarTarea = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: editarTareaEnElServidor,

    // 2. La l√≥gica de actualizaci√≥n ahora vive aqu√≠, ¬°para siempre!
    // `variables` son los datos que le pasas a `mutate` (ej: { id: 7, texto: '...' })
    onSuccess: (datosNuevos, variables) => {
      // 3. Usamos el `id` de las variables para actualizar la tarea correcta. ¬°Es din√°mico!
      queryClient.setQueryData(["tarea", { id: variables.id }], datosNuevos);
    },
  });
};

// --- C√ìMO USARLO EN CUALQUIER COMPONENTE ---

function BotonEditarTarea({ idDeLaTarea }) {
  // 4. Usamos nuestra herramienta personalizada. ¬°Limpio y f√°cil!
  const editarTarea = useEditarTarea();

  const handleClick = () => {
    editarTarea.mutate({ id: idDeLaTarea, texto: "¬°Tarea actualizada!" });
  };

  return <button onClick={handleClick}>Editar Tarea</button>;
}
```

**Explicaci√≥n del ejemplo:**

- **Paso 1 y 2:** Creamos una funci√≥n `useEditarTarea` que contiene toda la configuraci√≥n de `useMutation`, incluyendo la l√≥gica de `onSuccess`.
- **El Secreto (`variables`):** El callback `onSuccess` recibe un segundo argumento muy √∫til: `variables`. Este objeto contiene exactamente lo que le pasaste a la funci√≥n `mutate`. En nuestro caso, `{ id: idDeLaTarea, texto: '...' }`.
- **Paso 3 (Dinamismo):** Gracias a `variables`, ahora podemos hacer que nuestra l√≥gica de `setQueryData` sea gen√©rica. En lugar de escribir un `id` fijo como `5`, usamos `variables.id`. Esto significa que el hook funcionar√° para editar CUALQUIER tarea, no solo una espec√≠fica.
- **Paso 4 (Reutilizaci√≥n):** Ahora, en cualquier componente, en lugar de reescribir toda la l√≥gica, simplemente llamamos a `useEditarTarea()`. El c√≥digo del componente se vuelve mucho m√°s limpio, legible y nos aseguramos de que la actualizaci√≥n del cache se haga siempre de la misma manera correcta.

#### 3. **Desarrollo:**

Esto es aplicar el principio "Don't Repeat Yourself" (DRY). Centralizar la l√≥gica de la mutaci√≥n en un solo lugar tiene enormes ventajas:

1.  **Mantenimiento f√°cil:** Si necesitas cambiar c√≥mo funciona la actualizaci√≥n (por ejemplo, a√±adir una notificaci√≥n), solo lo cambias en un sitio: el hook.
2.  **Menos errores:** Al no copiar y pegar c√≥digo, reduces la posibilidad de cometer errores tontos.
3.  **C√≥digo m√°s limpio:** Los componentes que usan la mutaci√≥n solo se preocupan de _cu√°ndo_ llamarla, no de _c√≥mo_ funciona por dentro.

üü° **Importante**: Crear hooks personalizados es una pr√°ctica est√°ndar y muy recomendada en el ecosistema de React. Es la forma idiom√°tica de compartir l√≥gica con estado entre componentes. Te animo a que lo conviertas en un h√°bito.
