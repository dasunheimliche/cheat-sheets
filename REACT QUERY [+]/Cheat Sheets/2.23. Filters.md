## A - Query Filters: El "Control Remoto" para tus Queries 游댮

#### 1. **Introducci칩n:**

Los filtros de query son como un panel de control que te permite seleccionar y dar 칩rdenes a grupos espec칤ficos de queries que viven en la cach칠 de TanStack Query.

#### 2. **Ejemplo:**

Imagina que tienes una app de gesti칩n de proyectos. Quieres forzar la recarga de los datos de **todos** los proyectos que est치n siendo mostrados en la pantalla en este momento.

```javascript
// Forzar la recarga de todas las queries ACTIVAS cuya clave empiece con ['proyectos']
await queryClient.refetchQueries({ queryKey: ["proyectos"], type: "active" });
```

**Explicaci칩n del ejemplo:**

- `queryClient.refetchQueries`: Le est치s diciendo a TanStack Query: "춰Oye! Necesito que vuelvas a pedir los datos de unas queries que te voy a indicar".
- `{ queryKey: ['proyectos'], type: 'active' }`: Este objeto es tu orden espec칤fica, el filtro. Es como decirle a un robot de almac칠n:
  - `queryKey: ['proyectos']`: "Ve a la secci칩n de cajas etiquetadas como 'proyectos'". Esto incluye la caja `['proyectos']` (la lista general), la caja `['proyectos', 1]` (el detalle del proyecto 1), la caja `['proyectos', 1, 'tareas']`, etc.
  - `type: 'active'`: "...pero de todas esas, solo tr치eme las que est치n 'activas', es decir, las que se est치n usando en alg칰n componente que el usuario est치 viendo _ahora mismo_".

#### 3. **Desarrollo**:

Piensa en la cach칠 de TanStack Query como un gigantesco almac칠n lleno de cajas. Cada caja es una "query" (una petici칩n de datos guardada) y tiene una etiqueta 칰nica (la `queryKey`).

Los filtros son las instrucciones que le das a un robot para que vaya a ese almac칠n y haga algo (`refetch` - volver a llenar, `remove` - tirar, `cancel` - detener el llenado) solo con las cajas que cumplen ciertos requisitos. Puedes filtrar por su etiqueta (`queryKey`), si la caja est치 "en uso" en la tienda (`type: 'active'`), si su contenido est치 "pasado de fecha" (`stale: true`), etc.

Es una herramienta incre칤blemente poderosa para gestionar el estado de tu aplicaci칩n de forma masiva, en lugar de ir query por query.

游댮 **Fundamental**: Usar치s filtros constantemente para interactuar con la cach칠. Es una de las herramientas de gesti칩n m치s importantes y comunes de la librer칤a. Dominarlos es dominar TanStack Query.

---

## B - `queryKey` y `exact`: Apuntando con Puntero L치ser vs. una Linterna 游댮

#### 1. **Introducci칩n:**

La propiedad `queryKey` en un filtro te permite seleccionar queries por su etiqueta, y `exact: true` cambia el modo de selecci칩n de "aproximado" a "milim칠trico".

#### 2. **Ejemplo:**

- **Escenario:** En tu almac칠n (la cach칠) tienes estas tres queries:

  1.  `['proyectos']` (la lista de todos los proyectos)
  2.  `['proyectos', 5]` (el detalle del proyecto con ID 5)
  3.  `['usuarios']` (la lista de usuarios)

- **B칰squeda con Linterna (por defecto, `exact` es `false`):** Ilumina un 치rea amplia.

  ```javascript
  // Esto afectar치 a ['proyectos'] y ['proyectos', 5]
  queryClient.removeQueries({ queryKey: ["proyectos"] });
  ```

- **B칰squeda con Puntero L치ser (`exact: true`):** Apunta a un solo punto.
  ```javascript
  // Esto afectar치 SOLAMENTE a ['proyectos']
  queryClient.removeQueries({ queryKey: ["proyectos"], exact: true });
  ```

**Explicaci칩n del ejemplo:**

- **B칰squeda con Linterna (sin `exact`):** Cuando usas `queryKey: ['proyectos']`, TanStack Query es servicial y busca todas las claves que _empiecen_ con `['proyectos']`. Por eso encuentra tanto a `['proyectos']` como a `['proyectos', 5]`. La query `['usuarios']` queda fuera del haz de luz.
- **B칰squeda con Puntero L치ser (con `exact: true`):** Al a침adir `exact: true`, le das una orden tajante: "No quiero aproximaciones. Quiero _exactamente_ la query cuya clave es `['proyectos']` y ninguna otra". Ahora solo coincide con la primera query, ignorando a `['proyectos', 5]`.

#### 3. **Desarrollo**:

춰Esta es una de las confusiones m치s comunes y quiero que te quede grabada a fuego! Por defecto, TanStack Query es "inclusivo". Asume que si quieres hacer algo con `['proyectos']`, probablemente tambi칠n te interese afectar a todo lo que cuelga de ah칤 (como los detalles de proyectos individuales). Esto es genial para invalidar o refrescar secciones enteras de tu app con una sola l칤nea.

Pero a veces necesitas cirug칤a de precisi칩n. Ah칤 es donde brilla `exact: true`. 칔salo cuando quieras manipular una y solo una query espec칤fica, sin tocar a sus "hijas" o queries relacionadas.

游댮 **Fundamental**: Entender la diferencia entre el matching por defecto (inclusivo) y el `exact` (preciso) es absolutamente crucial para no cometer errores y manipular la cach칠 exactamente como deseas.

---

## C - `type`: Filtrando por "Qui칠n est치 en el Escenario" 游리

#### 1. **Introducci칩n:**

El filtro `type` te permite seleccionar queries bas치ndote en si est치n siendo usadas activamente por alg칰n componente en la pantalla o si est치n "en el banquillo".

#### 2. **Ejemplo:**

```javascript
// 1. Elimina de la cach칠 todas las queries que NO se est칠n usando actualmente.
// 춰Una forma genial de hacer limpieza y liberar memoria!
queryClient.removeQueries({ type: "inactive" });

// 2. Refresca solo las queries que el usuario est치 viendo en este momento.
await queryClient.refetchQueries({ type: "active" });
```

**Explicaci칩n del ejemplo:**

- `type: 'inactive'`: Selecciona queries "inactivas". Una query se vuelve inactiva cuando el 칰ltimo componente que la usaba se desmonta (por ejemplo, el usuario navega a otra p치gina). Estas queries se quedan en la cach칠 por un tiempo (configurable) antes de ser eliminadas. Con este filtro, puedes forzar su eliminaci칩n inmediata.
- `type: 'active'`: Selecciona queries "activas". Son las que tienen al menos un componente "escuchando" sus datos en este momento. Son los datos que "viven" en la UI.
- `'all'` (valor por defecto): Si no especificas `type`, el filtro se aplica a todas las queries, sin importar si est치n activas o inactivas.

#### 3. **Desarrollo**:

Piensa en tus queries como actores de una obra de teatro.

- Las queries `active` son los actores que est치n en el escenario, actuando para el p칰blico (el usuario).
- Las queries `inactive` son los que est치n en el camerino, esperando a ver si tienen que volver a salir o si ya pueden irse a casa.

Este filtro te permite dar 칩rdenes solo a los actores del escenario, solo a los del camerino, o a todos a la vez. Es muy 칰til para optimizar el rendimiento y la gesti칩n de memoria de tu aplicaci칩n.

游리 **Importante**: Es una herramienta de optimizaci칩n muy com칰n y potente. No la usar치s todos los d칤as, pero cuando la necesites, te salvar치 la vida para mantener tu app 치gil y limpia.

---

## D - `stale` y `fetchStatus`: El Estado de Salud de tus Datos 游리

#### 1. **Introducci칩n:**

Estos dos filtros te permiten seleccionar queries seg칰n si sus datos se consideran "viejos" (`stale`) o por la acci칩n que est치n realizando en este preciso instante (`fetchStatus`).

#### 2. **Ejemplo:**

```javascript
// 1. Refrescar todas las queries cuyos datos se consideran "viejos" (stale).
// Perfecto para un bot칩n de "Refrescar todo lo desactualizado".
await queryClient.refetchQueries({ stale: true });

// 2. Cancelar todas las queries que est치n pidiendo datos AHORA MISMO.
// 칔til si el usuario navega muy r치pido y quieres abortar peticiones en curso.
await queryClient.cancelQueries({ fetchStatus: "fetching" });
```

**Explicaci칩n del ejemplo:**

- `stale: true`: Selecciona queries cuyos datos ya no se consideran "frescos". TanStack Query marca los datos como `stale` (obsoletos/viejos) justo despu칠s de obtenerlos, o cuando pasa un tiempo (`staleTime`). **Importante:** `stale` no significa "incorrecto", solo significa "candidato a ser actualizado".
- `fetchStatus: 'fetching'`: Selecciona queries que est치n en medio de una petici칩n de red. Sus posibles estados son:
  - `fetching`: Pidiendo datos al servidor.
  - `paused`: Quer칤a pedir datos pero se paus칩 (ej: se perdi칩 la conexi칩n).
  - `idle`: No est치 haciendo nada, est치 en reposo.

#### 3. **Desarrollo**:

**춰ALERTA DE CONFUSI칍N COM칔N!** No confundas `stale` con `fetchStatus`. Son dos cosas totalmente diferentes.

- `stale` se refiere a la **EDAD de los DATOS** que ya tienes. 쯉on frescos o viejos?
- `fetchStatus` se refiere a la **ACCI칍N de la QUERY**. 쮼st치 pidiendo datos ahora o est치 quieta?

Una query puede tener datos `stale` (viejos) y un `fetchStatus` de `idle` (est치 quieta). O puede tener datos `fresh` (frescos) y un `fetchStatus` de `fetching` (est치 volviendo a pedirlos en segundo plano). Son dos dimensiones distintas del estado de una query.

游리 **Importante**: Filtrar por `stale` es muy com칰n para refetches masivos. Filtrar por `fetchStatus` es m치s espec칤fico, pero muy 칰til para controlar el comportamiento de las peticiones en curso.

---

## E - `predicate`: El Filtro "A tu Medida" con Superpoderes 游댯

#### 1. **Introducci칩n:**

El `predicate` es una funci칩n que te da el poder absoluto para decidir si una query debe ser seleccionada, bas치ndote en CUALQUIER propiedad interna de la query.

#### 2. **Ejemplo:**

Quieres refrescar solo las queries de "proyectos" que tienen m치s de 10 tareas asociadas y cuyos datos fueron guardados en cach칠 hace m치s de 5 minutos.

```javascript
const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;

await queryClient.refetchQueries({
  // Primero filtramos por la llave para ser m치s eficientes y no revisar toda la cach칠
  queryKey: ["proyectos"],
  // Ahora, el filtro de precisi칩n
  predicate: (query) => {
    const hasMoreThanTenTasks = query.state.data?.tasks?.length > 10;
    const isOldData = query.state.dataUpdatedAt < fiveMinutesAgo;
    return hasMoreThanTenTasks && isOldData;
  },
});
```

**Explicaci칩n del ejemplo:**

- `predicate: (query) => { ... }`: Le pasas una funci칩n. TanStack Query ejecutar치 esta funci칩n para cada query que haya pasado los filtros anteriores (en este caso, las que empiezan con `['proyectos']`).
- `query`: Dentro de la funci칩n, recibes el objeto completo de la query, con acceso a todo su interior: `state` (donde est치n los datos `data` y la fecha de actualizaci칩n `dataUpdatedAt`), `queryKey`, etc.
- `return ...`: Si tu funci칩n devuelve `true`, la query se selecciona. Si devuelve `false`, se ignora.

#### 3. **Desarrollo**:

El `predicate` es tu navaja suiza para cuando los filtros est치ndar no son suficientes. Es el "modo experto". Sin embargo, un gran poder conlleva una gran responsabilidad: si no pones otros filtros (como `queryKey`), tu funci칩n se ejecutar치 para CADA query en la cach칠, lo que podr칤a ser lento si tienes miles.

**Mi consejo paranoico:** Siempre que puedas, combina `predicate` con otros filtros m치s generales (`queryKey`, `type`) para acotar la b칰squeda primero. Es como usar un mapa para llegar al barrio correcto antes de empezar a buscar la casa por su color.

游댯 **Espec칤fico**: Es una herramienta muy potente para casos de uso avanzados. No la necesitar치s en el d칤a a d칤a, pero es fundamental saber que existe para cuando te enfrentes a un problema de filtrado muy, muy particular.

---

## F - Mutation Filters: El "Tablero de Control" para tus Cambios 游리

#### 1. **Introducci칩n:**

De forma similar a los filtros de query, los filtros de mutaci칩n te permiten seleccionar y, sobre todo, obtener informaci칩n sobre las mutaciones (crear, actualizar, borrar datos) que est치n ocurriendo.

#### 2. **Ejemplo:**

Quieres mostrar un spinner global o deshabilitar un bot칩n de "Guardar" mientras se est치 creando un nuevo post para evitar env칤os duplicados.

```javascript
// Devuelve el N칔MERO de mutaciones en estado 'pending' (ejecut치ndose)
// cuya clave de mutaci칩n sea ['crear-post'].
const pendingPostCreations = queryClient.isMutating({
  mutationKey: ["crear-post"],
});

if (pendingPostCreations > 0) {
  // Mostrar un spinner o un mensaje de "Guardando..."
}
```

**Explicaci칩n del ejemplo:**

- `queryClient.isMutating`: Este m칠todo no manipula, sino que _pregunta_. Devuelve el n칰mero de mutaciones que coinciden con el filtro y que est치n actualmente en estado `pending` (se han disparado pero a칰n no han terminado).
- `{ mutationKey: ['crear-post'] }`: Este es el filtro. Le decimos que solo nos interesan las mutaciones que identificamos con la clave `['crear-post']`.

#### 3. **Desarrollo**:

Las mutaciones son m치s "fugaces" que las queries. No se guardan en la cach칠 de la misma forma. Por eso, sus filtros se usan principalmente para _comprobar el estado actual_ (`isMutating`) m치s que para manipularlas en masa. Los filtros disponibles son `mutationKey`, `exact`, `status` (`pending`, `success`, `error`) y `predicate`. Son tus herramientas para saber "qu칠 se est치 cambiando en el servidor en este momento".

游리 **Importante**: Usar `isMutating` con un `mutationKey` es una forma muy com칰n y 칰til de controlar el estado de la UI mientras se realizan cambios en el backend. Es clave para una buena experiencia de usuario.

---

## G - `matchQuery` y `matchMutation`: El "Verificador" Manual 游댯

#### 1. **Introducci칩n:**

Son funciones de utilidad de bajo nivel que te permiten comprobar si una query o mutaci칩n _individual_ cumple con un conjunto de filtros, sin ejecutar ninguna acci칩n sobre ella.

#### 2. **Ejemplo:**

Est치s creando una herramienta de desarrollo personalizada y quieres resaltar en una lista todas las queries que est치n inactivas y obsoletas.

```javascript
import { matchQuery } from "@tanstack/react-query";

// Supongamos que tienes una lista de todas las queries de la cach칠
const allQueries = queryClient.getQueryCache().getAll();

// Defines los filtros que te interesan
const filters = { type: "inactive", stale: true };

// Mapeas sobre tus queries y usas matchQuery para comprobar cada una
const queriesConEstado = allQueries.map((query) => ({
  ...query,
  // matchQuery devuelve true o false
  estaResaltada: matchQuery(filters, query),
}));
```

**Explicaci칩n del ejemplo:**

- `matchQuery(filters, query)`: Esta funci칩n toma dos argumentos: el objeto de filtros que quieres aplicar y una instancia de una query.
- Devuelve un booleano simple: `true` si la `query` cumple con todas las condiciones de los `filters`, y `false` si no. No hace nada m치s.

#### 3. **Desarrollo**:

Estas utilidades son para situaciones muy espec칤ficas, a menudo fuera del flujo normal de una aplicaci칩n. Son para cuando est치s construyendo herramientas _sobre_ TanStack Query, o necesitas una l칩gica de filtrado muy personalizada y desacoplada de los m칠todos del `queryClient`. No las usar치s para refrescar datos en un componente. Para eso, usa `queryClient.refetchQueries` directamente. `matchQuery` es para "preguntar" si algo coincide, no para "actuar".

游댯 **Espec칤fico**: Son herramientas para casos de uso avanzados o para construir librer칤as/utilidades sobre TanStack Query. La mayor칤a de los desarrolladores no las necesitar치n directamente, pero es bueno saber que existen en la caja de herramientas.
