## A - Query Filters: El "Control Remoto" para tus Queries üî¥

#### 1. **Introducci√≥n:**

Los filtros de query son como un panel de control que te permite seleccionar y dar √≥rdenes a grupos espec√≠ficos de queries que viven en la cach√© de TanStack Query.

#### 2. **Ejemplo:**

Imagina que tienes una app de gesti√≥n de proyectos. Quieres forzar la recarga de los datos de **todos** los proyectos que est√°n siendo mostrados en la pantalla en este momento.

```javascript
// Forzar la recarga de todas las queries ACTIVAS cuya clave empiece con ['proyectos']
await queryClient.refetchQueries({ queryKey: ["proyectos"], type: "active" });
```

**Explicaci√≥n del ejemplo:**

- `queryClient.refetchQueries`: Le est√°s diciendo a TanStack Query: "¬°Oye! Necesito que vuelvas a pedir los datos de unas queries que te voy a indicar".
- `{ queryKey: ['proyectos'], type: 'active' }`: Este objeto es tu orden espec√≠fica, el filtro. Es como decirle a un robot de almac√©n:
  - `queryKey: ['proyectos']`: "Ve a la secci√≥n de cajas etiquetadas como 'proyectos'". Esto incluye la caja `['proyectos']` (la lista general), la caja `['proyectos', 1]` (el detalle del proyecto 1), la caja `['proyectos', 1, 'tareas']`, etc.
  - `type: 'active'`: "...pero de todas esas, solo tr√°eme las que est√°n 'activas', es decir, las que se est√°n usando en alg√∫n componente que el usuario est√° viendo _ahora mismo_".

#### 3. **Desarrollo**:

Piensa en la cach√© de TanStack Query como un gigantesco almac√©n lleno de cajas. Cada caja es una "query" (una petici√≥n de datos guardada) y tiene una etiqueta √∫nica (la `queryKey`).

Los filtros son las instrucciones que le das a un robot para que vaya a ese almac√©n y haga algo (`refetch` - volver a llenar, `remove` - tirar, `cancel` - detener el llenado) solo con las cajas que cumplen ciertos requisitos. Puedes filtrar por su etiqueta (`queryKey`), si la caja est√° "en uso" en la tienda (`type: 'active'`), si su contenido est√° "pasado de fecha" (`stale: true`), etc.

Es una herramienta incre√≠blemente poderosa para gestionar el estado de tu aplicaci√≥n de forma masiva, en lugar de ir query por query.

üî¥ **Fundamental**: Usar√°s filtros constantemente para interactuar con la cach√©. Es una de las herramientas de gesti√≥n m√°s importantes y comunes de la librer√≠a. Dominarlos es dominar TanStack Query.

---

## B - `queryKey` y `exact`: Apuntando con Puntero L√°ser vs. una Linterna üî¥

#### 1. **Introducci√≥n:**

La propiedad `queryKey` en un filtro te permite seleccionar queries por su etiqueta, y `exact: true` cambia el modo de selecci√≥n de "aproximado" a "milim√©trico".

#### 2. **Ejemplo:**

- **Escenario:** En tu almac√©n (la cach√©) tienes estas tres queries:

  1.  `['proyectos']` (la lista de todos los proyectos)
  2.  `['proyectos', 5]` (el detalle del proyecto con ID 5)
  3.  `['usuarios']` (la lista de usuarios)

- **B√∫squeda con Linterna (por defecto, `exact` es `false`):** Ilumina un √°rea amplia.

  ```javascript
  // Esto afectar√° a ['proyectos'] y ['proyectos', 5]
  queryClient.removeQueries({ queryKey: ["proyectos"] });
  ```

- **B√∫squeda con Puntero L√°ser (`exact: true`):** Apunta a un solo punto.
  ```javascript
  // Esto afectar√° SOLAMENTE a ['proyectos']
  queryClient.removeQueries({ queryKey: ["proyectos"], exact: true });
  ```

**Explicaci√≥n del ejemplo:**

- **B√∫squeda con Linterna (sin `exact`):** Cuando usas `queryKey: ['proyectos']`, TanStack Query es servicial y busca todas las claves que _empiecen_ con `['proyectos']`. Por eso encuentra tanto a `['proyectos']` como a `['proyectos', 5]`. La query `['usuarios']` queda fuera del haz de luz.
- **B√∫squeda con Puntero L√°ser (con `exact: true`):** Al a√±adir `exact: true`, le das una orden tajante: "No quiero aproximaciones. Quiero _exactamente_ la query cuya clave es `['proyectos']` y ninguna otra". Ahora solo coincide con la primera query, ignorando a `['proyectos', 5]`.

#### 3. **Desarrollo**:

¬°Esta es una de las confusiones m√°s comunes y quiero que te quede grabada a fuego! Por defecto, TanStack Query es "inclusivo". Asume que si quieres hacer algo con `['proyectos']`, probablemente tambi√©n te interese afectar a todo lo que cuelga de ah√≠ (como los detalles de proyectos individuales). Esto es genial para invalidar o refrescar secciones enteras de tu app con una sola l√≠nea.

Pero a veces necesitas cirug√≠a de precisi√≥n. Ah√≠ es donde brilla `exact: true`. √ösalo cuando quieras manipular una y solo una query espec√≠fica, sin tocar a sus "hijas" o queries relacionadas.

üî¥ **Fundamental**: Entender la diferencia entre el matching por defecto (inclusivo) y el `exact` (preciso) es absolutamente crucial para no cometer errores y manipular la cach√© exactamente como deseas.

---

## C - `type`: Filtrando por "Qui√©n est√° en el Escenario" üü°

#### 1. **Introducci√≥n:**

El filtro `type` te permite seleccionar queries bas√°ndote en si est√°n siendo usadas activamente por alg√∫n componente en la pantalla o si est√°n "en el banquillo".

#### 2. **Ejemplo:**

```javascript
// 1. Elimina de la cach√© todas las queries que NO se est√©n usando actualmente.
// ¬°Una forma genial de hacer limpieza y liberar memoria!
queryClient.removeQueries({ type: "inactive" });

// 2. Refresca solo las queries que el usuario est√° viendo en este momento.
await queryClient.refetchQueries({ type: "active" });
```

**Explicaci√≥n del ejemplo:**

- `type: 'inactive'`: Selecciona queries "inactivas". Una query se vuelve inactiva cuando el √∫ltimo componente que la usaba se desmonta (por ejemplo, el usuario navega a otra p√°gina). Estas queries se quedan en la cach√© por un tiempo (configurable) antes de ser eliminadas. Con este filtro, puedes forzar su eliminaci√≥n inmediata.
- `type: 'active'`: Selecciona queries "activas". Son las que tienen al menos un componente "escuchando" sus datos en este momento. Son los datos que "viven" en la UI.
- `'all'` (valor por defecto): Si no especificas `type`, el filtro se aplica a todas las queries, sin importar si est√°n activas o inactivas.

#### 3. **Desarrollo**:

Piensa en tus queries como actores de una obra de teatro.

- Las queries `active` son los actores que est√°n en el escenario, actuando para el p√∫blico (el usuario).
- Las queries `inactive` son los que est√°n en el camerino, esperando a ver si tienen que volver a salir o si ya pueden irse a casa.

Este filtro te permite dar √≥rdenes solo a los actores del escenario, solo a los del camerino, o a todos a la vez. Es muy √∫til para optimizar el rendimiento y la gesti√≥n de memoria de tu aplicaci√≥n.

üü° **Importante**: Es una herramienta de optimizaci√≥n muy com√∫n y potente. No la usar√°s todos los d√≠as, pero cuando la necesites, te salvar√° la vida para mantener tu app √°gil y limpia.

---

## D - `stale` y `fetchStatus`: El Estado de Salud de tus Datos üü°

#### 1. **Introducci√≥n:**

Estos dos filtros te permiten seleccionar queries seg√∫n si sus datos se consideran "viejos" (`stale`) o por la acci√≥n que est√°n realizando en este preciso instante (`fetchStatus`).

#### 2. **Ejemplo:**

```javascript
// 1. Refrescar todas las queries cuyos datos se consideran "viejos" (stale).
// Perfecto para un bot√≥n de "Refrescar todo lo desactualizado".
await queryClient.refetchQueries({ stale: true });

// 2. Cancelar todas las queries que est√°n pidiendo datos AHORA MISMO.
// √ötil si el usuario navega muy r√°pido y quieres abortar peticiones en curso.
await queryClient.cancelQueries({ fetchStatus: "fetching" });
```

**Explicaci√≥n del ejemplo:**

- `stale: true`: Selecciona queries cuyos datos ya no se consideran "frescos". TanStack Query marca los datos como `stale` (obsoletos/viejos) justo despu√©s de obtenerlos, o cuando pasa un tiempo (`staleTime`). **Importante:** `stale` no significa "incorrecto", solo significa "candidato a ser actualizado".
- `fetchStatus: 'fetching'`: Selecciona queries que est√°n en medio de una petici√≥n de red. Sus posibles estados son:
  - `fetching`: Pidiendo datos al servidor.
  - `paused`: Quer√≠a pedir datos pero se paus√≥ (ej: se perdi√≥ la conexi√≥n).
  - `idle`: No est√° haciendo nada, est√° en reposo.

#### 3. **Desarrollo**:

**¬°ALERTA DE CONFUSI√ìN COM√öN!** No confundas `stale` con `fetchStatus`. Son dos cosas totalmente diferentes.

- `stale` se refiere a la **EDAD de los DATOS** que ya tienes. ¬øSon frescos o viejos?
- `fetchStatus` se refiere a la **ACCI√ìN de la QUERY**. ¬øEst√° pidiendo datos ahora o est√° quieta?

Una query puede tener datos `stale` (viejos) y un `fetchStatus` de `idle` (est√° quieta). O puede tener datos `fresh` (frescos) y un `fetchStatus` de `fetching` (est√° volviendo a pedirlos en segundo plano). Son dos dimensiones distintas del estado de una query.

üü° **Importante**: Filtrar por `stale` es muy com√∫n para refetches masivos. Filtrar por `fetchStatus` es m√°s espec√≠fico, pero muy √∫til para controlar el comportamiento de las peticiones en curso.

---

## E - `predicate`: El Filtro "A tu Medida" con Superpoderes üîµ

#### 1. **Introducci√≥n:**

El `predicate` es una funci√≥n que te da el poder absoluto para decidir si una query debe ser seleccionada, bas√°ndote en CUALQUIER propiedad interna de la query.

#### 2. **Ejemplo:**

Quieres refrescar solo las queries de "proyectos" que tienen m√°s de 10 tareas asociadas y cuyos datos fueron guardados en cach√© hace m√°s de 5 minutos.

```javascript
const fiveMinutesAgo = Date.now() - 5 * 60 * 1000;

await queryClient.refetchQueries({
  // Primero filtramos por la llave para ser m√°s eficientes y no revisar toda la cach√©
  queryKey: ["proyectos"],
  // Ahora, el filtro de precisi√≥n
  predicate: (query) => {
    const hasMoreThanTenTasks = query.state.data?.tasks?.length > 10;
    const isOldData = query.state.dataUpdatedAt < fiveMinutesAgo;
    return hasMoreThanTenTasks && isOldData;
  },
});
```

**Explicaci√≥n del ejemplo:**

- `predicate: (query) => { ... }`: Le pasas una funci√≥n. TanStack Query ejecutar√° esta funci√≥n para cada query que haya pasado los filtros anteriores (en este caso, las que empiezan con `['proyectos']`).
- `query`: Dentro de la funci√≥n, recibes el objeto completo de la query, con acceso a todo su interior: `state` (donde est√°n los datos `data` y la fecha de actualizaci√≥n `dataUpdatedAt`), `queryKey`, etc.
- `return ...`: Si tu funci√≥n devuelve `true`, la query se selecciona. Si devuelve `false`, se ignora.

#### 3. **Desarrollo**:

El `predicate` es tu navaja suiza para cuando los filtros est√°ndar no son suficientes. Es el "modo experto". Sin embargo, un gran poder conlleva una gran responsabilidad: si no pones otros filtros (como `queryKey`), tu funci√≥n se ejecutar√° para CADA query en la cach√©, lo que podr√≠a ser lento si tienes miles.

**Mi consejo paranoico:** Siempre que puedas, combina `predicate` con otros filtros m√°s generales (`queryKey`, `type`) para acotar la b√∫squeda primero. Es como usar un mapa para llegar al barrio correcto antes de empezar a buscar la casa por su color.

üîµ **Espec√≠fico**: Es una herramienta muy potente para casos de uso avanzados. No la necesitar√°s en el d√≠a a d√≠a, pero es fundamental saber que existe para cuando te enfrentes a un problema de filtrado muy, muy particular.

---

## F - Mutation Filters: El "Tablero de Control" para tus Cambios üü°

#### 1. **Introducci√≥n:**

De forma similar a los filtros de query, los filtros de mutaci√≥n te permiten seleccionar y, sobre todo, obtener informaci√≥n sobre las mutaciones (crear, actualizar, borrar datos) que est√°n ocurriendo.

#### 2. **Ejemplo:**

Quieres mostrar un spinner global o deshabilitar un bot√≥n de "Guardar" mientras se est√° creando un nuevo post para evitar env√≠os duplicados.

```javascript
// Devuelve el N√öMERO de mutaciones en estado 'pending' (ejecut√°ndose)
// cuya clave de mutaci√≥n sea ['crear-post'].
const pendingPostCreations = queryClient.isMutating({
  mutationKey: ["crear-post"],
});

if (pendingPostCreations > 0) {
  // Mostrar un spinner o un mensaje de "Guardando..."
}
```

**Explicaci√≥n del ejemplo:**

- `queryClient.isMutating`: Este m√©todo no manipula, sino que _pregunta_. Devuelve el n√∫mero de mutaciones que coinciden con el filtro y que est√°n actualmente en estado `pending` (se han disparado pero a√∫n no han terminado).
- `{ mutationKey: ['crear-post'] }`: Este es el filtro. Le decimos que solo nos interesan las mutaciones que identificamos con la clave `['crear-post']`.

#### 3. **Desarrollo**:

Las mutaciones son m√°s "fugaces" que las queries. No se guardan en la cach√© de la misma forma. Por eso, sus filtros se usan principalmente para _comprobar el estado actual_ (`isMutating`) m√°s que para manipularlas en masa. Los filtros disponibles son `mutationKey`, `exact`, `status` (`pending`, `success`, `error`) y `predicate`. Son tus herramientas para saber "qu√© se est√° cambiando en el servidor en este momento".

üü° **Importante**: Usar `isMutating` con un `mutationKey` es una forma muy com√∫n y √∫til de controlar el estado de la UI mientras se realizan cambios en el backend. Es clave para una buena experiencia de usuario.

---

## G - `matchQuery` y `matchMutation`: El "Verificador" Manual üîµ

#### 1. **Introducci√≥n:**

Son funciones de utilidad de bajo nivel que te permiten comprobar si una query o mutaci√≥n _individual_ cumple con un conjunto de filtros, sin ejecutar ninguna acci√≥n sobre ella.

#### 2. **Ejemplo:**

Est√°s creando una herramienta de desarrollo personalizada y quieres resaltar en una lista todas las queries que est√°n inactivas y obsoletas.

```javascript
import { matchQuery } from "@tanstack/react-query";

// Supongamos que tienes una lista de todas las queries de la cach√©
const allQueries = queryClient.getQueryCache().getAll();

// Defines los filtros que te interesan
const filters = { type: "inactive", stale: true };

// Mapeas sobre tus queries y usas matchQuery para comprobar cada una
const queriesConEstado = allQueries.map((query) => ({
  ...query,
  // matchQuery devuelve true o false
  estaResaltada: matchQuery(filters, query),
}));
```

**Explicaci√≥n del ejemplo:**

- `matchQuery(filters, query)`: Esta funci√≥n toma dos argumentos: el objeto de filtros que quieres aplicar y una instancia de una query.
- Devuelve un booleano simple: `true` si la `query` cumple con todas las condiciones de los `filters`, y `false` si no. No hace nada m√°s.

#### 3. **Desarrollo**:

Estas utilidades son para situaciones muy espec√≠ficas, a menudo fuera del flujo normal de una aplicaci√≥n. Son para cuando est√°s construyendo herramientas _sobre_ TanStack Query, o necesitas una l√≥gica de filtrado muy personalizada y desacoplada de los m√©todos del `queryClient`. No las usar√°s para refrescar datos en un componente. Para eso, usa `queryClient.refetchQueries` directamente. `matchQuery` es para "preguntar" si algo coincide, no para "actuar".

üîµ **Espec√≠fico**: Son herramientas para casos de uso avanzados o para construir librer√≠as/utilidades sobre TanStack Query. La mayor√≠a de los desarrolladores no las necesitar√°n directamente, pero es bueno saber que existen en la caja de herramientas.
