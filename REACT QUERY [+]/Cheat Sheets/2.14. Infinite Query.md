## A - `useInfiniteQuery`: El Corazón de las Listas Interminables 🔴

#### 1. **Introducción:**

Este es el hook (gancho) que usas cuando necesitas mostrar datos que se cargan por partes, como el _feed_ de una red social o una tienda online con muchísimos productos.

#### 2. **Ejemplo:**

Imagina que tienes una API que te da proyectos de 3 en 3. Primero pides los 3 primeros, luego los 3 siguientes, y así sucesivamente.

```jsx
import { useInfiniteQuery } from "@tanstack/react-query";
import React from "react";

function ProjectsFeed() {
  // 1. La función que busca los datos. Recibe un 'pageParam' que le dice qué página buscar.
  const fetchProjects = async ({ pageParam = 0 }) => {
    const res = await fetch(`/api/projects?cursor=${pageParam}`);
    return res.json(); // Esto devuelve algo como: { data: [...], nextCursor: 3 }
  };

  const {
    data,
    error,
    fetchNextPage, // La función para cargar la siguiente página
    hasNextPage, // Un booleano que nos dice si hay más páginas
    isFetching,
    isFetchingNextPage, // Un booleano para saber si se está cargando la *siguiente* página
    status,
  } = useInfiniteQuery({
    queryKey: ["projects"], // Una "etiqueta" única para esta consulta
    queryFn: fetchProjects, // La función que acabamos de definir
    initialPageParam: 0, // Le decimos por dónde empezar. La primera vez, pageParam será 0.
    // 2. La magia: Cómo saber cuál es la siguiente página
    getNextPageParam: (lastPage) => lastPage.nextCursor,
  });

  if (status === "pending") return <p>Cargando tus proyectos...</p>;
  if (status === "error") return <p>¡Oh no! Algo salió mal: {error.message}</p>;

  return (
    <>
      {/* 3. Mostramos los datos, página por página */}
      {data.pages.map((group, i) => (
        <React.Fragment key={i}>
          {group.data.map((project) => (
            <p key={project.id}>{project.name}</p>
          ))}
        </React.Fragment>
      ))}

      {/* 4. El botón para cargar más */}
      <button
        onClick={() => fetchNextPage()}
        disabled={!hasNextPage || isFetchingNextPage}
      >
        {isFetchingNextPage
          ? "Cargando más proyectos..."
          : hasNextPage
          ? "Quiero ver más"
          : "¡Eso es todo, amigos!"}
      </button>

      <div>
        {isFetching && !isFetchingNextPage
          ? "Refrescando en segundo plano..."
          : null}
      </div>
    </>
  );
}
```

**Explicación del ejemplo:**

1.  **`fetchProjects`**: Es tu "mensajero". Le das un número de página (el `cursor` o `pageParam`) y él va a la API a buscar los datos correspondientes.
2.  **`getNextPageParam`**: Esta es la pieza CLAVE. Después de cada viaje exitoso de tu mensajero, esta función mira el "paquete" que trajo (`lastPage`) y busca la dirección para el siguiente viaje (`lastPage.nextCursor`). Si no encuentra una dirección (`nextCursor` es `undefined` o `null`), asume que no hay más paquetes que buscar.
3.  **`data.pages.map(...)`**: Aquí es donde abres todos los paquetes que han llegado. `data.pages` es un array que contiene _todos_ los grupos de datos que has cargado. Por eso hacemos un `map` dentro de otro `map`: para recorrer cada "página" y luego cada "proyecto" dentro de esa página.
4.  **El botón `onClick`**: Al hacer clic, simplemente llamas a `fetchNextPage()`. Esta función, internamente, ejecutará de nuevo a tu mensajero (`fetchProjects`), pero esta vez le pasará el `pageParam` que `getNextPageParam` calculó en el paso anterior. ¡Es un ciclo perfecto!

#### 3. **Desarrollo**:

`useInfiniteQuery` es una variante especializada de `useQuery`. Mientras que `useQuery` está diseñado para traer un conjunto de datos de una sola vez, `useInfiniteQuery` está hecho para traer esos datos en "trozos" o "páginas" que se van acumulando.

La principal diferencia es cómo organiza los datos y te da herramientas específicas para manejar la paginación, como `fetchNextPage` y `getNextPageParam`. Sin estas herramientas, implementar un "Cargar más" sería un verdadero dolor de cabeza manual.

🔴 **Fundamental**: Es la única herramienta que ofrece la librería para este patrón de UI tan común. Si necesitas carga infinita o un botón "Cargar más", este es tu hook. No hay otro.

## B - El Objeto `data`: Tus Páginas y Sus "Direcciones" 🟡

#### 1. **Introducción:**

En `useInfiniteQuery`, la variable `data` no contiene tus datos directamente, sino un objeto que los organiza en páginas y guarda los parámetros que se usaron para pedirlas.

#### 2. **Ejemplo:**

Así se ve el objeto `data` por dentro después de cargar dos páginas:

```json
{
  "pages": [
    { "data": [{ "id": 1, "name": "Proyecto A" }], "nextCursor": 3 },
    { "data": [{ "id": 4, "name": "Proyecto D" }], "nextCursor": 6 }
  ],
  "pageParams": [0, 3]
}
```

**Explicación del ejemplo:**

- **`data.pages`**: Es un array donde cada elemento es el resultado COMPLETO de una llamada a tu `queryFn`. En nuestro caso, cada elemento es un objeto `{ data: [...], nextCursor: ... }`. ¡Aquí viven los datos que muestras en pantalla!
- **`data.pageParams`**: Es un array que funciona como un "historial" de las "direcciones" (los `pageParam`) que has usado para pedir cada página. El primer elemento (`0`) se usó para pedir la primera página, el segundo (`3`) para la segunda, y así sucesivamente.

#### 3. **Desarrollo**:

Entender esta estructura es CRUCIAL. Un error muy común es intentar hacer `data.map(...)`. ¡Eso fallará! Siempre debes hacer `data.pages.map(...)`. Piensa en `data` como la caja grande que contiene dos compartimentos: `pages` (los tesoros encontrados) y `pageParams` (el mapa que usaste para encontrarlos).

🟡 **Importante**: No puedes renderizar nada si no entiendes esta estructura. Es el primer obstáculo que encuentra un principiante y, una vez superado, todo lo demás tiene más sentido.

## C - `isFetching` vs. `isFetchingNextPage`: ¿Qué tipo de "Cargando" es? 🟡

#### 1. **Introducción:**

Ambos indican que se están pidiendo datos, pero saber la diferencia te permite dar una información mucho más precisa al usuario.

#### 2. **Ejemplo de Contraste:**

Imagina estas dos situaciones en tu UI:

```jsx
// Situación 1: El usuario acaba de hacer clic en "Cargar Más"
// isFetching será true
// isFetchingNextPage también será true

<button disabled={true}>
  Cargando más... {/* <-- Esto se muestra gracias a isFetchingNextPage */}
</button>

// Situación 2: El usuario vuelve a la pestaña y la librería refresca los datos en segundo plano
// isFetching será true
// isFetchingNextPage será false

<div>
  Refrescando datos... {/* <-- Esto se muestra gracias a isFetching && !isFetchingNextPage */}
</div>
```

**Explicación del ejemplo:**

- **`isFetchingNextPage`**: Solo se pone en `true` cuando la carga de datos fue iniciada por la función `fetchNextPage` (o `fetchPreviousPage`). Es perfecto para cambiar el texto de tu botón "Cargar más".
- **`isFetching`**: Es un indicador general. Se pone en `true` para CUALQUIER petición: la carga inicial, cuando el usuario hace clic en "Cargar más", o cuando TanStack Query decide que los datos están "viejos" (stale) y los refresca automáticamente.

#### 3. **Desarrollo:**

**La trampa a evitar:** Si solo usas `isFetching` para el texto de tu botón "Cargar más", el texto podría cambiar a "Cargando..." cuando no es el usuario quien ha iniciado la acción, ¡lo cual es muy confuso!

**¿Por qué elegir uno sobre el otro?**

- Usa `isFetchingNextPage` para feedback directo a una acción del usuario (clic en el botón).
- Usa `isFetching && !isFetchingNextPage` para mostrar un indicador de carga más sutil y global, como un spinner en la esquina, que le dice al usuario que "algo está pasando en segundo plano".

🟡 **Importante**: Dominar esta diferencia eleva la calidad de tu interfaz de usuario de "funcional" a "intuitiva y clara". Evita que el usuario se pregunte por qué la UI parece estar cargando algo que él no pidió.

## D - ¿Y si mi API no tiene "cursores"? ¡Usa números de página! 🟡

#### 1. **Introducción:**

No todas las APIs te dan un práctico `nextCursor`. Muchas usan un sistema clásico de números de página (`/api/items?page=1`, `?page=2`, etc.). ¡No hay problema, podemos adaptarnos!

#### 2. **Ejemplo:**

```jsx
function NumberedPageExample() {
  const fetchProjectsByPage = async ({ pageParam = 1 }) => {
    // Empezamos en la página 1
    const res = await fetch(`/api/projects?page=${pageParam}&limit=10`);
    return res.json(); // Esto devuelve solo un array de datos: [...]
  };

  const { data, fetchNextPage, hasNextPage } = useInfiniteQuery({
    queryKey: ["projectsByPage"],
    queryFn: fetchProjectsByPage,
    initialPageParam: 1, // El número de la primera página que pediremos

    // Aquí está el truco:
    getNextPageParam: (lastPage, allPages, lastPageParam) => {
      // Si la última página que recibimos vino vacía, es que no hay más datos.
      if (lastPage.length === 0) {
        return undefined; // ¡Esto detiene la paginación!
      }
      // La siguiente página es simplemente el número de la página anterior + 1.
      return lastPageParam + 1;
    },
  });

  // ... el resto del componente para renderizar y el botón ...
}
```

**Explicación del ejemplo:**

La clave está en `getNextPageParam`. Ahora recibe un tercer argumento súper útil: `lastPageParam`.

- `lastPage`: Son los datos que acabamos de recibir (un array de proyectos).
- `allPages`: Son todas las páginas acumuladas hasta ahora.
- `lastPageParam`: ¡Este es nuestro salvador! Es el número de página que se usó para pedir `lastPage`.

La lógica es simple: si la página anterior fue la `3` (`lastPageParam`), la siguiente será la `4`. ¿Y cómo sabemos cuándo parar? Si la API nos devuelve un array vacío (`lastPage.length === 0`), significa que hemos llegado al final. En ese momento, devolvemos `undefined` y `hasNextPage` se convertirá en `false`.

#### 3. **Desarrollo**:

Este es un escenario increíblemente común. La belleza de `useInfiniteQuery` es su flexibilidad. No te obliga a usar un sistema de cursores. Simplemente te da las herramientas (`lastPage`, `allPages`, `lastPageParam`) y tú defines la lógica. Recordar que `return undefined` es la señal para detenerse es el 90% del trabajo aquí.

🟡 **Importante**: Saber esto te libera de depender de un formato de API específico. Te hace mucho más versátil como desarrollador.

## E - Actualización Manual con `setQueryData`: Cirugía de Precisión 🔵

#### 1. **Introducción:**

A veces necesitas modificar los datos en caché directamente (por ejemplo, borrar un elemento que el usuario eliminó) sin tener que volver a pedir todo a la API.

#### 2. **Ejemplo:**

Imagina que el usuario borra un proyecto. Quieres que desaparezca de la lista al instante.

```jsx
import { useQueryClient } from "@tanstack/react-query";

function MyComponent() {
  const queryClient = useQueryClient();

  const handleDeleteProject = (projectIdToRemove) => {
    // Actualizamos la caché de 'projects'
    queryClient.setQueryData(["projects"], (oldData) => {
      // ¡OJO! Si no hay datos viejos, no hagas nada.
      if (!oldData) return oldData;

      // Creamos una nueva estructura de páginas
      const newPages = oldData.pages.map((page) => {
        // Filtramos el proyecto eliminado de cada página
        const filteredData = page.data.filter(
          (project) => project.id !== projectIdToRemove
        );
        // Devolvemos la página con los datos filtrados
        return { ...page, data: filteredData };
      });

      // Devolvemos el objeto completo con la estructura correcta
      return {
        pages: newPages,
        pageParams: oldData.pageParams, // Los pageParams no cambian
      };
    });
  };

  // ...
}
```

**Explicación del ejemplo:**

1.  Obtenemos el `queryClient`, que es el cerebro que gestiona toda la caché.
2.  Llamamos a `queryClient.setQueryData` con la `queryKey` de nuestra lista (`['projects']`).
3.  Le pasamos una función que recibe los datos actuales (`oldData`).
4.  **LA PARTE MÁS IMPORTANTE:** No modificamos `oldData` directamente. Creamos un nuevo array de páginas (`newPages`) donde filtramos el elemento a eliminar.
5.  Finalmente, devolvemos un **nuevo objeto** que respeta la estructura original: `{ pages: [...], pageParams: [...] }`. Si olvidas esto, ¡romperás el estado de tu `useInfiniteQuery`!

#### 3. **Desarrollo**:

Esto es una técnica avanzada pero increíblemente poderosa para crear interfaces rápidas y optimistas. La regla de oro, que repetiré hasta el cansancio porque es donde todo el mundo falla al principio, es: **SIEMPRE debes devolver un objeto con la misma estructura `{ pages, pageParams }` que `useInfiniteQuery` espera**. Si solo devuelves un array de páginas, o cualquier otra cosa, la próxima vez que el hook intente leer los datos, fallará.

🔵 **Específico**: No lo usarás todos los días, pero para interacciones de usuario como borrar, editar o añadir elementos a una lista, es la herramienta correcta. Saber que existe te abre un mundo de posibilidades para mejorar la experiencia de usuario.
