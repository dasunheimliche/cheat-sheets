## A - `useInfiniteQuery`: El Coraz칩n de las Listas Interminables 游댮

#### 1. **Introducci칩n:**

Este es el hook (gancho) que usas cuando necesitas mostrar datos que se cargan por partes, como el _feed_ de una red social o una tienda online con much칤simos productos.

#### 2. **Ejemplo:**

Imagina que tienes una API que te da proyectos de 3 en 3. Primero pides los 3 primeros, luego los 3 siguientes, y as칤 sucesivamente.

```jsx
import { useInfiniteQuery } from "@tanstack/react-query";
import React from "react";

function ProjectsFeed() {
  // 1. La funci칩n que busca los datos. Recibe un 'pageParam' que le dice qu칠 p치gina buscar.
  const fetchProjects = async ({ pageParam = 0 }) => {
    const res = await fetch(`/api/projects?cursor=${pageParam}`);
    return res.json(); // Esto devuelve algo como: { data: [...], nextCursor: 3 }
  };

  const {
    data,
    error,
    fetchNextPage, // La funci칩n para cargar la siguiente p치gina
    hasNextPage, // Un booleano que nos dice si hay m치s p치ginas
    isFetching,
    isFetchingNextPage, // Un booleano para saber si se est치 cargando la *siguiente* p치gina
    status,
  } = useInfiniteQuery({
    queryKey: ["projects"], // Una "etiqueta" 칰nica para esta consulta
    queryFn: fetchProjects, // La funci칩n que acabamos de definir
    initialPageParam: 0, // Le decimos por d칩nde empezar. La primera vez, pageParam ser치 0.
    // 2. La magia: C칩mo saber cu치l es la siguiente p치gina
    getNextPageParam: (lastPage) => lastPage.nextCursor,
  });

  if (status === "pending") return <p>Cargando tus proyectos...</p>;
  if (status === "error") return <p>춰Oh no! Algo sali칩 mal: {error.message}</p>;

  return (
    <>
      {/* 3. Mostramos los datos, p치gina por p치gina */}
      {data.pages.map((group, i) => (
        <React.Fragment key={i}>
          {group.data.map((project) => (
            <p key={project.id}>{project.name}</p>
          ))}
        </React.Fragment>
      ))}

      {/* 4. El bot칩n para cargar m치s */}
      <button
        onClick={() => fetchNextPage()}
        disabled={!hasNextPage || isFetchingNextPage}
      >
        {isFetchingNextPage
          ? "Cargando m치s proyectos..."
          : hasNextPage
          ? "Quiero ver m치s"
          : "춰Eso es todo, amigos!"}
      </button>

      <div>
        {isFetching && !isFetchingNextPage
          ? "Refrescando en segundo plano..."
          : null}
      </div>
    </>
  );
}
```

**Explicaci칩n del ejemplo:**

1.  **`fetchProjects`**: Es tu "mensajero". Le das un n칰mero de p치gina (el `cursor` o `pageParam`) y 칠l va a la API a buscar los datos correspondientes.
2.  **`getNextPageParam`**: Esta es la pieza CLAVE. Despu칠s de cada viaje exitoso de tu mensajero, esta funci칩n mira el "paquete" que trajo (`lastPage`) y busca la direcci칩n para el siguiente viaje (`lastPage.nextCursor`). Si no encuentra una direcci칩n (`nextCursor` es `undefined` o `null`), asume que no hay m치s paquetes que buscar.
3.  **`data.pages.map(...)`**: Aqu칤 es donde abres todos los paquetes que han llegado. `data.pages` es un array que contiene _todos_ los grupos de datos que has cargado. Por eso hacemos un `map` dentro de otro `map`: para recorrer cada "p치gina" y luego cada "proyecto" dentro de esa p치gina.
4.  **El bot칩n `onClick`**: Al hacer clic, simplemente llamas a `fetchNextPage()`. Esta funci칩n, internamente, ejecutar치 de nuevo a tu mensajero (`fetchProjects`), pero esta vez le pasar치 el `pageParam` que `getNextPageParam` calcul칩 en el paso anterior. 춰Es un ciclo perfecto!

#### 3. **Desarrollo**:

`useInfiniteQuery` es una variante especializada de `useQuery`. Mientras que `useQuery` est치 dise침ado para traer un conjunto de datos de una sola vez, `useInfiniteQuery` est치 hecho para traer esos datos en "trozos" o "p치ginas" que se van acumulando.

La principal diferencia es c칩mo organiza los datos y te da herramientas espec칤ficas para manejar la paginaci칩n, como `fetchNextPage` y `getNextPageParam`. Sin estas herramientas, implementar un "Cargar m치s" ser칤a un verdadero dolor de cabeza manual.

游댮 **Fundamental**: Es la 칰nica herramienta que ofrece la librer칤a para este patr칩n de UI tan com칰n. Si necesitas carga infinita o un bot칩n "Cargar m치s", este es tu hook. No hay otro.

## B - El Objeto `data`: Tus P치ginas y Sus "Direcciones" 游리

#### 1. **Introducci칩n:**

En `useInfiniteQuery`, la variable `data` no contiene tus datos directamente, sino un objeto que los organiza en p치ginas y guarda los par치metros que se usaron para pedirlas.

#### 2. **Ejemplo:**

As칤 se ve el objeto `data` por dentro despu칠s de cargar dos p치ginas:

```json
{
  "pages": [
    { "data": [{ "id": 1, "name": "Proyecto A" }], "nextCursor": 3 },
    { "data": [{ "id": 4, "name": "Proyecto D" }], "nextCursor": 6 }
  ],
  "pageParams": [0, 3]
}
```

**Explicaci칩n del ejemplo:**

- **`data.pages`**: Es un array donde cada elemento es el resultado COMPLETO de una llamada a tu `queryFn`. En nuestro caso, cada elemento es un objeto `{ data: [...], nextCursor: ... }`. 춰Aqu칤 viven los datos que muestras en pantalla!
- **`data.pageParams`**: Es un array que funciona como un "historial" de las "direcciones" (los `pageParam`) que has usado para pedir cada p치gina. El primer elemento (`0`) se us칩 para pedir la primera p치gina, el segundo (`3`) para la segunda, y as칤 sucesivamente.

#### 3. **Desarrollo**:

Entender esta estructura es CRUCIAL. Un error muy com칰n es intentar hacer `data.map(...)`. 춰Eso fallar치! Siempre debes hacer `data.pages.map(...)`. Piensa en `data` como la caja grande que contiene dos compartimentos: `pages` (los tesoros encontrados) y `pageParams` (el mapa que usaste para encontrarlos).

游리 **Importante**: No puedes renderizar nada si no entiendes esta estructura. Es el primer obst치culo que encuentra un principiante y, una vez superado, todo lo dem치s tiene m치s sentido.

## C - `isFetching` vs. `isFetchingNextPage`: 쯈u칠 tipo de "Cargando" es? 游리

#### 1. **Introducci칩n:**

Ambos indican que se est치n pidiendo datos, pero saber la diferencia te permite dar una informaci칩n mucho m치s precisa al usuario.

#### 2. **Ejemplo de Contraste:**

Imagina estas dos situaciones en tu UI:

```jsx
// Situaci칩n 1: El usuario acaba de hacer clic en "Cargar M치s"
// isFetching ser치 true
// isFetchingNextPage tambi칠n ser치 true

<button disabled={true}>
  Cargando m치s... {/* <-- Esto se muestra gracias a isFetchingNextPage */}
</button>

// Situaci칩n 2: El usuario vuelve a la pesta침a y la librer칤a refresca los datos en segundo plano
// isFetching ser치 true
// isFetchingNextPage ser치 false

<div>
  Refrescando datos... {/* <-- Esto se muestra gracias a isFetching && !isFetchingNextPage */}
</div>
```

**Explicaci칩n del ejemplo:**

- **`isFetchingNextPage`**: Solo se pone en `true` cuando la carga de datos fue iniciada por la funci칩n `fetchNextPage` (o `fetchPreviousPage`). Es perfecto para cambiar el texto de tu bot칩n "Cargar m치s".
- **`isFetching`**: Es un indicador general. Se pone en `true` para CUALQUIER petici칩n: la carga inicial, cuando el usuario hace clic en "Cargar m치s", o cuando TanStack Query decide que los datos est치n "viejos" (stale) y los refresca autom치ticamente.

#### 3. **Desarrollo:**

**La trampa a evitar:** Si solo usas `isFetching` para el texto de tu bot칩n "Cargar m치s", el texto podr칤a cambiar a "Cargando..." cuando no es el usuario quien ha iniciado la acci칩n, 춰lo cual es muy confuso!

**쯇or qu칠 elegir uno sobre el otro?**

- Usa `isFetchingNextPage` para feedback directo a una acci칩n del usuario (clic en el bot칩n).
- Usa `isFetching && !isFetchingNextPage` para mostrar un indicador de carga m치s sutil y global, como un spinner en la esquina, que le dice al usuario que "algo est치 pasando en segundo plano".

游리 **Importante**: Dominar esta diferencia eleva la calidad de tu interfaz de usuario de "funcional" a "intuitiva y clara". Evita que el usuario se pregunte por qu칠 la UI parece estar cargando algo que 칠l no pidi칩.

## D - 쯏 si mi API no tiene "cursores"? 춰Usa n칰meros de p치gina! 游리

#### 1. **Introducci칩n:**

No todas las APIs te dan un pr치ctico `nextCursor`. Muchas usan un sistema cl치sico de n칰meros de p치gina (`/api/items?page=1`, `?page=2`, etc.). 춰No hay problema, podemos adaptarnos!

#### 2. **Ejemplo:**

```jsx
function NumberedPageExample() {
  const fetchProjectsByPage = async ({ pageParam = 1 }) => {
    // Empezamos en la p치gina 1
    const res = await fetch(`/api/projects?page=${pageParam}&limit=10`);
    return res.json(); // Esto devuelve solo un array de datos: [...]
  };

  const { data, fetchNextPage, hasNextPage } = useInfiniteQuery({
    queryKey: ["projectsByPage"],
    queryFn: fetchProjectsByPage,
    initialPageParam: 1, // El n칰mero de la primera p치gina que pediremos

    // Aqu칤 est치 el truco:
    getNextPageParam: (lastPage, allPages, lastPageParam) => {
      // Si la 칰ltima p치gina que recibimos vino vac칤a, es que no hay m치s datos.
      if (lastPage.length === 0) {
        return undefined; // 춰Esto detiene la paginaci칩n!
      }
      // La siguiente p치gina es simplemente el n칰mero de la p치gina anterior + 1.
      return lastPageParam + 1;
    },
  });

  // ... el resto del componente para renderizar y el bot칩n ...
}
```

**Explicaci칩n del ejemplo:**

La clave est치 en `getNextPageParam`. Ahora recibe un tercer argumento s칰per 칰til: `lastPageParam`.

- `lastPage`: Son los datos que acabamos de recibir (un array de proyectos).
- `allPages`: Son todas las p치ginas acumuladas hasta ahora.
- `lastPageParam`: 춰Este es nuestro salvador! Es el n칰mero de p치gina que se us칩 para pedir `lastPage`.

La l칩gica es simple: si la p치gina anterior fue la `3` (`lastPageParam`), la siguiente ser치 la `4`. 쯏 c칩mo sabemos cu치ndo parar? Si la API nos devuelve un array vac칤o (`lastPage.length === 0`), significa que hemos llegado al final. En ese momento, devolvemos `undefined` y `hasNextPage` se convertir치 en `false`.

#### 3. **Desarrollo**:

Este es un escenario incre칤blemente com칰n. La belleza de `useInfiniteQuery` es su flexibilidad. No te obliga a usar un sistema de cursores. Simplemente te da las herramientas (`lastPage`, `allPages`, `lastPageParam`) y t칰 defines la l칩gica. Recordar que `return undefined` es la se침al para detenerse es el 90% del trabajo aqu칤.

游리 **Importante**: Saber esto te libera de depender de un formato de API espec칤fico. Te hace mucho m치s vers치til como desarrollador.

## E - Actualizaci칩n Manual con `setQueryData`: Cirug칤a de Precisi칩n 游댯

#### 1. **Introducci칩n:**

A veces necesitas modificar los datos en cach칠 directamente (por ejemplo, borrar un elemento que el usuario elimin칩) sin tener que volver a pedir todo a la API.

#### 2. **Ejemplo:**

Imagina que el usuario borra un proyecto. Quieres que desaparezca de la lista al instante.

```jsx
import { useQueryClient } from "@tanstack/react-query";

function MyComponent() {
  const queryClient = useQueryClient();

  const handleDeleteProject = (projectIdToRemove) => {
    // Actualizamos la cach칠 de 'projects'
    queryClient.setQueryData(["projects"], (oldData) => {
      // 춰OJO! Si no hay datos viejos, no hagas nada.
      if (!oldData) return oldData;

      // Creamos una nueva estructura de p치ginas
      const newPages = oldData.pages.map((page) => {
        // Filtramos el proyecto eliminado de cada p치gina
        const filteredData = page.data.filter(
          (project) => project.id !== projectIdToRemove
        );
        // Devolvemos la p치gina con los datos filtrados
        return { ...page, data: filteredData };
      });

      // Devolvemos el objeto completo con la estructura correcta
      return {
        pages: newPages,
        pageParams: oldData.pageParams, // Los pageParams no cambian
      };
    });
  };

  // ...
}
```

**Explicaci칩n del ejemplo:**

1.  Obtenemos el `queryClient`, que es el cerebro que gestiona toda la cach칠.
2.  Llamamos a `queryClient.setQueryData` con la `queryKey` de nuestra lista (`['projects']`).
3.  Le pasamos una funci칩n que recibe los datos actuales (`oldData`).
4.  **LA PARTE M츼S IMPORTANTE:** No modificamos `oldData` directamente. Creamos un nuevo array de p치ginas (`newPages`) donde filtramos el elemento a eliminar.
5.  Finalmente, devolvemos un **nuevo objeto** que respeta la estructura original: `{ pages: [...], pageParams: [...] }`. Si olvidas esto, 춰romper치s el estado de tu `useInfiniteQuery`!

#### 3. **Desarrollo**:

Esto es una t칠cnica avanzada pero incre칤blemente poderosa para crear interfaces r치pidas y optimistas. La regla de oro, que repetir칠 hasta el cansancio porque es donde todo el mundo falla al principio, es: **SIEMPRE debes devolver un objeto con la misma estructura `{ pages, pageParams }` que `useInfiniteQuery` espera**. Si solo devuelves un array de p치ginas, o cualquier otra cosa, la pr칩xima vez que el hook intente leer los datos, fallar치.

游댯 **Espec칤fico**: No lo usar치s todos los d칤as, pero para interacciones de usuario como borrar, editar o a침adir elementos a una lista, es la herramienta correcta. Saber que existe te abre un mundo de posibilidades para mejorar la experiencia de usuario.
