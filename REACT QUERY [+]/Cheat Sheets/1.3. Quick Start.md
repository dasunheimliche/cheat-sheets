## A - `QueryClient` y `QueryClientProvider`: El Cerebro y el Corazón de tu App 🔴

#### 1. **Introducción:**

Antes de poder hacer cualquier cosa con React Query, necesitas crear su "cerebro" (`QueryClient`) y luego "conectarlo" a tu aplicación (`QueryClientProvider`) para que todos los componentes puedan usarlo.

#### 2. **Ejemplo:**

```jsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

// 1. Creamos una instancia del "cerebro".
// Piensa en esto como el centro de control que guardará y gestionará todos tus datos.
const queryClient = new QueryClient();

function App() {
  return (
    // 2. "Envolvemos" nuestra aplicación con el Provider.
    // Esto es como darle a toda tu app acceso a ese cerebro central.
    // Cualquier componente dentro de <QueryClientProvider> podrá hablar con React Query.
    <QueryClientProvider client={queryClient}>
      <Todos />{" "}
      {/* <-- Ahora este componente (y sus hijos) tienen superpoderes */}
    </QueryClientProvider>
  );
}
```

**Explicación del ejemplo:**
Imagina que `queryClient` es el bibliotecario de tu aplicación. Sabe dónde está cada libro (dato), si es una edición nueva o vieja, y va a buscar los libros que le pides. El `QueryClientProvider` es la biblioteca misma. Al poner tu aplicación dentro, le das a todos los que están adentro un carnet para hablar con el bibliotecario. **Siempre, siempre, siempre** tienes que hacer estos dos pasos primero.

#### 3. **Desarrollo:**

El `QueryClient` es el motor de React Query. Es un objeto que contiene una **caché** para todos los datos que tu aplicación solicita. Sin él, React Query no tiene dónde guardar la información que trae del servidor.

El `QueryClientProvider` es un componente de React que utiliza el [Context API](https://react.dev/learn/passing-data-deeply-with-context) de React por debajo. Su único trabajo es hacer que la instancia de `queryClient` que creaste esté disponible para cualquier componente anidado dentro de él. Si olvidas envolver tu app (o una parte de ella) en el `Provider`, cualquier intento de usar un hook como `useQuery` fallará con un error que dirá algo como: "No query client has been set".

🔴 **Fundamental**: Esto no es opcional. Es el cimiento sobre el que se construye todo lo demás en React Query. Sin el cliente y el proveedor, la librería simplemente no funciona.

---

## B - `useQuery`: Pidiendo Datos al Servidor (y Recordándolos) 🔴

#### 1. **Introducción:**

Este es el hook que usarás el 90% del tiempo; sirve para **solicitar (consultar) y leer datos** de una fuente externa, como una API.

#### 2. **Ejemplo:**

```jsx
import { useQuery } from "@tanstack/react-query";
import { getTodos } from "../my-api"; // Una función que busca los datos

function Todos() {
  // Usamos el hook para buscar y gestionar nuestra lista de "todos"
  const query = useQuery({
    queryKey: ["todos"],
    queryFn: getTodos,
  });

  // React Query nos da el estado de la petición. Mientras carga:
  if (query.isLoading) {
    return <span>Cargando...</span>;
  }

  // Si hubo un error:
  if (query.isError) {
    return <span>¡Oh no, algo salió mal!</span>;
  }

  // Si todo salió bien, mostramos los datos:
  return (
    <ul>
      {/* Usamos '?' por si 'data' aún no existe, para evitar errores */}
      {query.data?.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  );
}
```

**Explicación del ejemplo:**

- **`queryKey: ['todos']`**: Esta es la parte más importante. Es una **etiqueta única** para esta consulta. Imagina que es el nombre que le pones a una caja para saber qué hay dentro. React Query usa esta "llave" para guardar y recuperar los datos de su caché. Si otro componente pide datos con la misma llave `['todos']`, React Query le dará los datos guardados al instante en lugar de volver a pedirlos al servidor. ¡Es crucial que sea un array!
- **`queryFn: getTodos`**: Esta es la **función que hace el trabajo de verdad**. Tiene que ser una función que devuelva una [Promesa](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise), que es lo que hacen las funciones que piden datos a una API (como `fetch` o `axios`).

#### 3. **Desarrollo:**

`useQuery` es mucho más que una simple llamada a una API. Gestiona automáticamente el estado de carga (`isLoading`), los errores (`isError`), si la petición fue exitosa (`isSuccess`) y, lo más importante, **mantiene tus datos actualizados en segundo plano**. Por defecto, volverá a solicitar los datos si el usuario cambia de pestaña y vuelve, o si la red se reconecta. Su objetivo es que los datos que ve el usuario sean lo más frescos posible, sin que tú tengas que escribir lógica compleja.

🔴 **Fundamental**: Es la herramienta principal de la librería. Su propósito es obtener y cachear datos. Entender `useQuery` es entender la mitad de React Query.

---

## C - `useMutation`: Modificando Datos en el Servidor 🔴

#### 1. **Introducción:**

Si `useQuery` es para leer datos, `useMutation` es para **cambiarlos**: crear, actualizar o borrar datos en el servidor.

#### 2. **Ejemplo:**

```jsx
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { postTodo } from "../my-api"; // Función que envía un nuevo "todo"

function Todos() {
  const queryClient = useQueryClient(); // Obtenemos el "cerebro" para interactuar con él

  // 1. Configuramos la mutación
  const mutation = useMutation({
    mutationFn: postTodo, // La función que envía los datos
    onSuccess: () => {
      // 3. Si todo sale bien, invalidamos la query de 'todos'
      // Esto le dice a React Query: "Los datos de 'todos' están viejos, ve a buscarlos de nuevo"
      queryClient.invalidateQueries({ queryKey: ["todos"] });
    },
  });

  return (
    <div>
      {/* ... aquí va la lista de todos que vimos en el ejemplo de useQuery ... */}

      <button
        onClick={() => {
          // 2. Ejecutamos la mutación con los datos del nuevo "todo"
          mutation.mutate({
            id: Date.now(),
            title: "Lavar la ropa",
          });
        }}
      >
        Añadir Todo
      </button>
    </div>
  );
}
```

**Explicación del ejemplo:**

- **`mutationFn: postTodo`**: Al igual que `queryFn`, esta es la función que hace el trabajo pesado, pero en este caso, envía datos al servidor (por ejemplo, una petición `POST`, `PUT`, o `DELETE`).
- **`mutation.mutate(...)`**: A diferencia de `useQuery` que se ejecuta solo, una mutación la tienes que **activar tú manualmente** llamando a la función `mutate`. Lo que le pases a `mutate` será el argumento que recibirá tu `mutationFn`.
- **`onSuccess: () => { ... }`**: Este es un "callback" que se ejecuta solo si la mutación tiene éxito. Es el lugar perfecto para decirle a React Query que actualice los datos relacionados (ver siguiente concepto).

#### 3. **Desarrollo:**

La diferencia clave entre `useQuery` y `useMutation` es la **intención**. Usa `useQuery` para operaciones "seguras" que solo leen datos (GET). Usa `useMutation` para operaciones que tienen "efectos secundarios" y cambian el estado en el servidor (POST, PUT, DELETE, PATCH). `useMutation` no se ejecuta al renderizar el componente; espera pacientemente a que tú lo llames con `mutate()`.

🔴 **Fundamental**: Es la otra mitad esencial de la librería. Si necesitas cambiar algo en tu base de datos, esta es la herramienta correcta.

---

## D - `queryClient.invalidateQueries`: "¡Oye, Actualiza Estos Datos!" 🟡

#### 1. **Introducción:**

Esta función es la forma de decirle a React Query: "La información que tienes guardada con esta etiqueta (`queryKey`) ya no es válida, está obsoleta".

#### 2. **Ejemplo:**

Este concepto está tan ligado a `useMutation` que el mejor ejemplo es el que ya vimos, pero vamos a aislar la parte clave:

```jsx
// Este código se encuentra dentro del `onSuccess` de una mutación.
// Después de añadir un nuevo "todo" con éxito...

// 1. Obtenemos acceso al cliente (el "cerebro" de React Query)
const queryClient = useQueryClient();

// 2. Le decimos: "Marca como inválida cualquier consulta que tenga la llave ['todos']"
queryClient.invalidateQueries({ queryKey: ["todos"] });
```

**Explicación del ejemplo:**
Cuando llamas a `invalidateQueries({ queryKey: ['todos'] })`, React Query recorre su caché y busca todas las consultas que coincidan con esa llave. Las marca como "stale" (viejas). Si un componente en pantalla está usando una de esas consultas (con `useQuery({ queryKey: ['todos'], ... })`), React Query **automáticamente la volverá a ejecutar** para obtener los datos frescos.

#### 3. **Desarrollo:**

¿Por qué hacemos esto en lugar de actualizar manualmente el estado local? Porque es más simple y menos propenso a errores. En lugar de intentar adivinar cómo debería ser el nuevo estado (por ejemplo, añadiendo el nuevo "todo" a un array local), simplemente le decimos a React Query que la fuente de la verdad (el servidor) ha cambiado. React Query se encarga del resto, asegurando que lo que ves en pantalla es un reflejo fiel de lo que hay en la base de datos. Es el pegamento que une las mutaciones (cambios) con las queries (lecturas), manteniendo tu UI sincronizada de forma elegante.

🟡 **Importante**: Aunque podrías vivir sin ella usando otras técnicas, la invalidación es el patrón más común y recomendado para actualizar datos después de una mutación. Dominarlo te hará la vida mucho más fácil.
