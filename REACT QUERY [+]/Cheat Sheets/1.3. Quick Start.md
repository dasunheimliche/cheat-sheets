## A - `QueryClient` y `QueryClientProvider`: El Cerebro y el Coraz칩n de tu App 游댮

#### 1. **Introducci칩n:**

Antes de poder hacer cualquier cosa con React Query, necesitas crear su "cerebro" (`QueryClient`) y luego "conectarlo" a tu aplicaci칩n (`QueryClientProvider`) para que todos los componentes puedan usarlo.

#### 2. **Ejemplo:**

```jsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

// 1. Creamos una instancia del "cerebro".
// Piensa en esto como el centro de control que guardar치 y gestionar치 todos tus datos.
const queryClient = new QueryClient();

function App() {
  return (
    // 2. "Envolvemos" nuestra aplicaci칩n con el Provider.
    // Esto es como darle a toda tu app acceso a ese cerebro central.
    // Cualquier componente dentro de <QueryClientProvider> podr치 hablar con React Query.
    <QueryClientProvider client={queryClient}>
      <Todos />{" "}
      {/* <-- Ahora este componente (y sus hijos) tienen superpoderes */}
    </QueryClientProvider>
  );
}
```

**Explicaci칩n del ejemplo:**
Imagina que `queryClient` es el bibliotecario de tu aplicaci칩n. Sabe d칩nde est치 cada libro (dato), si es una edici칩n nueva o vieja, y va a buscar los libros que le pides. El `QueryClientProvider` es la biblioteca misma. Al poner tu aplicaci칩n dentro, le das a todos los que est치n adentro un carnet para hablar con el bibliotecario. **Siempre, siempre, siempre** tienes que hacer estos dos pasos primero.

#### 3. **Desarrollo:**

El `QueryClient` es el motor de React Query. Es un objeto que contiene una **cach칠** para todos los datos que tu aplicaci칩n solicita. Sin 칠l, React Query no tiene d칩nde guardar la informaci칩n que trae del servidor.

El `QueryClientProvider` es un componente de React que utiliza el [Context API](https://react.dev/learn/passing-data-deeply-with-context) de React por debajo. Su 칰nico trabajo es hacer que la instancia de `queryClient` que creaste est칠 disponible para cualquier componente anidado dentro de 칠l. Si olvidas envolver tu app (o una parte de ella) en el `Provider`, cualquier intento de usar un hook como `useQuery` fallar치 con un error que dir치 algo como: "No query client has been set".

游댮 **Fundamental**: Esto no es opcional. Es el cimiento sobre el que se construye todo lo dem치s en React Query. Sin el cliente y el proveedor, la librer칤a simplemente no funciona.

---

## B - `useQuery`: Pidiendo Datos al Servidor (y Record치ndolos) 游댮

#### 1. **Introducci칩n:**

Este es el hook que usar치s el 90% del tiempo; sirve para **solicitar (consultar) y leer datos** de una fuente externa, como una API.

#### 2. **Ejemplo:**

```jsx
import { useQuery } from "@tanstack/react-query";
import { getTodos } from "../my-api"; // Una funci칩n que busca los datos

function Todos() {
  // Usamos el hook para buscar y gestionar nuestra lista de "todos"
  const query = useQuery({
    queryKey: ["todos"],
    queryFn: getTodos,
  });

  // React Query nos da el estado de la petici칩n. Mientras carga:
  if (query.isLoading) {
    return <span>Cargando...</span>;
  }

  // Si hubo un error:
  if (query.isError) {
    return <span>춰Oh no, algo sali칩 mal!</span>;
  }

  // Si todo sali칩 bien, mostramos los datos:
  return (
    <ul>
      {/* Usamos '?' por si 'data' a칰n no existe, para evitar errores */}
      {query.data?.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  );
}
```

**Explicaci칩n del ejemplo:**

- **`queryKey: ['todos']`**: Esta es la parte m치s importante. Es una **etiqueta 칰nica** para esta consulta. Imagina que es el nombre que le pones a una caja para saber qu칠 hay dentro. React Query usa esta "llave" para guardar y recuperar los datos de su cach칠. Si otro componente pide datos con la misma llave `['todos']`, React Query le dar치 los datos guardados al instante en lugar de volver a pedirlos al servidor. 춰Es crucial que sea un array!
- **`queryFn: getTodos`**: Esta es la **funci칩n que hace el trabajo de verdad**. Tiene que ser una funci칩n que devuelva una [Promesa](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise), que es lo que hacen las funciones que piden datos a una API (como `fetch` o `axios`).

#### 3. **Desarrollo:**

`useQuery` es mucho m치s que una simple llamada a una API. Gestiona autom치ticamente el estado de carga (`isLoading`), los errores (`isError`), si la petici칩n fue exitosa (`isSuccess`) y, lo m치s importante, **mantiene tus datos actualizados en segundo plano**. Por defecto, volver치 a solicitar los datos si el usuario cambia de pesta침a y vuelve, o si la red se reconecta. Su objetivo es que los datos que ve el usuario sean lo m치s frescos posible, sin que t칰 tengas que escribir l칩gica compleja.

游댮 **Fundamental**: Es la herramienta principal de la librer칤a. Su prop칩sito es obtener y cachear datos. Entender `useQuery` es entender la mitad de React Query.

---

## C - `useMutation`: Modificando Datos en el Servidor 游댮

#### 1. **Introducci칩n:**

Si `useQuery` es para leer datos, `useMutation` es para **cambiarlos**: crear, actualizar o borrar datos en el servidor.

#### 2. **Ejemplo:**

```jsx
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { postTodo } from "../my-api"; // Funci칩n que env칤a un nuevo "todo"

function Todos() {
  const queryClient = useQueryClient(); // Obtenemos el "cerebro" para interactuar con 칠l

  // 1. Configuramos la mutaci칩n
  const mutation = useMutation({
    mutationFn: postTodo, // La funci칩n que env칤a los datos
    onSuccess: () => {
      // 3. Si todo sale bien, invalidamos la query de 'todos'
      // Esto le dice a React Query: "Los datos de 'todos' est치n viejos, ve a buscarlos de nuevo"
      queryClient.invalidateQueries({ queryKey: ["todos"] });
    },
  });

  return (
    <div>
      {/* ... aqu칤 va la lista de todos que vimos en el ejemplo de useQuery ... */}

      <button
        onClick={() => {
          // 2. Ejecutamos la mutaci칩n con los datos del nuevo "todo"
          mutation.mutate({
            id: Date.now(),
            title: "Lavar la ropa",
          });
        }}
      >
        A침adir Todo
      </button>
    </div>
  );
}
```

**Explicaci칩n del ejemplo:**

- **`mutationFn: postTodo`**: Al igual que `queryFn`, esta es la funci칩n que hace el trabajo pesado, pero en este caso, env칤a datos al servidor (por ejemplo, una petici칩n `POST`, `PUT`, o `DELETE`).
- **`mutation.mutate(...)`**: A diferencia de `useQuery` que se ejecuta solo, una mutaci칩n la tienes que **activar t칰 manualmente** llamando a la funci칩n `mutate`. Lo que le pases a `mutate` ser치 el argumento que recibir치 tu `mutationFn`.
- **`onSuccess: () => { ... }`**: Este es un "callback" que se ejecuta solo si la mutaci칩n tiene 칠xito. Es el lugar perfecto para decirle a React Query que actualice los datos relacionados (ver siguiente concepto).

#### 3. **Desarrollo:**

La diferencia clave entre `useQuery` y `useMutation` es la **intenci칩n**. Usa `useQuery` para operaciones "seguras" que solo leen datos (GET). Usa `useMutation` para operaciones que tienen "efectos secundarios" y cambian el estado en el servidor (POST, PUT, DELETE, PATCH). `useMutation` no se ejecuta al renderizar el componente; espera pacientemente a que t칰 lo llames con `mutate()`.

游댮 **Fundamental**: Es la otra mitad esencial de la librer칤a. Si necesitas cambiar algo en tu base de datos, esta es la herramienta correcta.

---

## D - `queryClient.invalidateQueries`: "춰Oye, Actualiza Estos Datos!" 游리

#### 1. **Introducci칩n:**

Esta funci칩n es la forma de decirle a React Query: "La informaci칩n que tienes guardada con esta etiqueta (`queryKey`) ya no es v치lida, est치 obsoleta".

#### 2. **Ejemplo:**

Este concepto est치 tan ligado a `useMutation` que el mejor ejemplo es el que ya vimos, pero vamos a aislar la parte clave:

```jsx
// Este c칩digo se encuentra dentro del `onSuccess` de una mutaci칩n.
// Despu칠s de a침adir un nuevo "todo" con 칠xito...

// 1. Obtenemos acceso al cliente (el "cerebro" de React Query)
const queryClient = useQueryClient();

// 2. Le decimos: "Marca como inv치lida cualquier consulta que tenga la llave ['todos']"
queryClient.invalidateQueries({ queryKey: ["todos"] });
```

**Explicaci칩n del ejemplo:**
Cuando llamas a `invalidateQueries({ queryKey: ['todos'] })`, React Query recorre su cach칠 y busca todas las consultas que coincidan con esa llave. Las marca como "stale" (viejas). Si un componente en pantalla est치 usando una de esas consultas (con `useQuery({ queryKey: ['todos'], ... })`), React Query **autom치ticamente la volver치 a ejecutar** para obtener los datos frescos.

#### 3. **Desarrollo:**

쯇or qu칠 hacemos esto en lugar de actualizar manualmente el estado local? Porque es m치s simple y menos propenso a errores. En lugar de intentar adivinar c칩mo deber칤a ser el nuevo estado (por ejemplo, a침adiendo el nuevo "todo" a un array local), simplemente le decimos a React Query que la fuente de la verdad (el servidor) ha cambiado. React Query se encarga del resto, asegurando que lo que ves en pantalla es un reflejo fiel de lo que hay en la base de datos. Es el pegamento que une las mutaciones (cambios) con las queries (lecturas), manteniendo tu UI sincronizada de forma elegante.

游리 **Importante**: Aunque podr칤as vivir sin ella usando otras t칠cnicas, la invalidaci칩n es el patr칩n m치s com칰n y recomendado para actualizar datos despu칠s de una mutaci칩n. Dominarlo te har치 la vida mucho m치s f치cil.
