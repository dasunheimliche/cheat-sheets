## A - Query: Tu Petici칩n Inteligente de Datos 游댮

#### 1. **Introducci칩n:**

Una "query" es, en esencia, una forma elegante y organizada de pedir datos a un servidor, como si le dieras una orden clara y precisa que 칠l recordar치 para el futuro.

#### 2. **Ejemplo:**

```javascript
// Imagina que esto es lo que le pides a React Query:
const peticionDeTareas = {
  queryKey: ["todos"], // La "etiqueta" o nombre 칰nico de esta petici칩n
  queryFn: fetchTodoList, // La "instrucci칩n" de c칩mo conseguir los datos
};

// Y as칤 lo usas en tu componente:
const info = useQuery(peticionDeTareas);
```

**Explicaci칩n del ejemplo:**
Aqu칤 no estamos pidiendo los datos de cualquier manera. Le estamos dando dos cosas clave a React Query:

1.  `queryKey: ['todos']`: Una "etiqueta" 칰nica. Piensa en esto como el nombre que le pones a una caja donde guardar치s algo. React Query usar치 esta etiqueta para encontrar, actualizar y compartir estos datos en toda tu aplicaci칩n sin que tengas que preocuparte. 춰Es su sistema de organizaci칩n!
2.  `queryFn: fetchTodoList`: La funci칩n que _realmente_ va a internet y trae los datos. Es la instrucci칩n paso a paso de "c칩mo" obtener lo que pediste. Esta funci칩n debe devolver una [Promesa](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise) (que es la forma est치ndar de JavaScript de manejar operaciones que toman tiempo).

#### 3. **Desarrollo**:

Una query es el coraz칩n de React Query. No es solo "ir a buscar datos"; es una **declaraci칩n de dependencia**. Le dices a tu aplicaci칩n: "Oye, este componente _depende_ de los datos que se identifican con la clave `['todos']`". A partir de ah칤, React Query se encarga de la magia: lo busca, lo guarda (cach칠), te lo entrega, lo actualiza en segundo plano si se vuelve "viejo", y mucho m치s.

La clave 칰nica (`queryKey`) es crucial. Si otro componente en otra parte de tu app pide datos con la misma clave, React Query, en lugar de volver a pedirlos, le dar치 instant치neamente los que ya tiene guardados. 춰Eficiencia pura!

游댮 **Fundamental**: Este es el concepto m치s b치sico y esencial. Sin entender qu칠 es una "query" (la combinaci칩n de una clave y una funci칩n), nada m치s en la librer칤a tiene sentido. Es el ladrillo sobre el que se construye todo lo dem치s.

---

## B - `useQuery`: El Gancho para Pedir y Usar los Datos 游댮

#### 1. **Introducci칩n:**

`useQuery` es el "gancho" (hook) que traes a tus componentes de React para ejecutar una query y, lo m치s importante, para recibir el estado de esa petici칩n en tiempo real.

#### 2. **Ejemplo:**

```javascript
import { useQuery } from "@tanstack/react-query";

// Una funci칩n que busca los datos (debe devolver una Promesa)
async function fetchTodoList() {
  const response = await fetch("https://api.example.com/todos");
  if (!response.ok) {
    throw new Error("춰Algo sali칩 mal!");
  }
  return response.json();
}

function ListaDeTareas() {
  // Usamos el hook y "desempacamos" lo que nos interesa
  const { isPending, isError, data, error } = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodoList,
  });

  // 1. Mientras est치 cargando...
  if (isPending) {
    return <span>Cargando...</span>;
  }

  // 2. Si hubo un error...
  if (isError) {
    return <span>Error: {error.message}</span>;
  }

  // 3. Si todo sali칩 bien...
  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  );
}
```

**Explicaci칩n del ejemplo:**
Este c칩digo es un ciclo de vida completo y s칰per com칰n:

1.  Llamamos a `useQuery` y nos devuelve un objeto. De ese objeto, sacamos las 4 piezas m치s importantes:
    - `isPending`: Un booleano (`true`/`false`) que nos dice si la petici칩n est치 en su primer viaje, cargando datos por primera vez.
    - `isError`: Un booleano que nos avisa si la petici칩n fall칩.
    - `data`: 춰El premio! Aqu칤 estar치n tus datos cuando la petici칩n sea exitosa. Al principio, ser치 `undefined`.
    - `error`: Si `isError` es `true`, aqu칤 encontrar치s el objeto de error con los detalles de qu칠 fall칩.
2.  Luego, simplemente revisamos esas "banderas" en orden. 쮼st치 cargando? Muestra "Cargando...". 쮽all칩? Muestra el error. Si no es ninguna de las anteriores, 춰significa que tenemos los datos! Y los mostramos.

#### 3. **Desarrollo**:

El hook `useQuery` es tu principal herramienta de trabajo. Te suscribe a una query y te mantiene informado de su estado. El objeto que devuelve es incre칤blemente rico en informaci칩n, pero con `isPending`, `isError`, `data` y `error` tienes todo lo necesario para el 95% de los casos.

**춰Anticipando una duda!** Te preguntar치s: "쯏 qu칠 pasa con `isSuccess`?". 춰Buena pregunta! El ejemplo funciona porque sigue una l칩gica de descarte. Si `isPending` es falso y `isError` es falso, la 칰nica opci칩n que queda es que la petici칩n fue exitosa (`isSuccess` es `true`). Por eso podemos asumir con seguridad que `data` est치 disponible al final.

游댮 **Fundamental**: Este es el hook que usar치s sin parar. Es la forma pr치ctica de aplicar el concepto de "Query" (visto en el punto A) dentro de tus componentes de React. Dominar este patr칩n de `if (isPending)` / `if (isError)` es la clave para empezar a ser productivo con la librer칤a.

---

## C - `status` vs. `fetchStatus`: La Diferencia que te Ahorrar치 Dolores de Cabeza 游리

#### 1. **Introducci칩n:**

React Query te da dos tipos de "estados" para una misma query, y al principio puede ser confuso, pero te prometo que tiene mucho sentido: `status` te habla sobre los **datos**, mientras que `fetchStatus` te habla sobre la **petici칩n**.

#### 2. **Ejemplo:**

Imagina que pides una pizza a domicilio.

- **`status` (El estado de tus DATOS): "쯊engo pizza para comer?"**

  - `'pending'`: No, la caja est치 vac칤a. A칰n no ha llegado la primera pizza.
  - `'error'`: No, me trajeron una ensalada por error. No tengo pizza.
  - `'success'`: 춰S칤! Tengo una pizza deliciosa en la mesa.

- **`fetchStatus` (El estado de la PETICI칍N): "쮼l repartidor est치 en camino AHORA?"**
  - `'fetching'`: S칤, el repartidor est치 en la moto viniendo hacia ac치.
  - `'paused'`: El repartidor quer칤a salir, pero la moto no arranca (no hay conexi칩n a internet).
  - `'idle'`: No, el repartidor est치 quieto. O ya entreg칩 la pizza o todav칤a no ha salido.

**Explicaci칩n del ejemplo:**
춰Aqu칤 est치 la magia! Puedes tener `status: 'success'` (춰tienes pizza en la mesa!) y al mismo tiempo `fetchStatus: 'fetching'` (춰el repartidor viene con OTRA pizza porque la primera ya se estaba enfriando y la app pidi칩 una nueva autom치ticamente!). Esto es lo que se conoce como "refetch en segundo plano". Est치s viendo datos v치lidos mientras React Query ya est치 buscando una versi칩n m치s fresca por ti.

#### 3. **Desarrollo**:

Esta separaci칩n es una de las caracter칤sticas m치s potentes y, a la vez, m치s confusas para los principiantes. Vamos a grabarlo a fuego:

- **`status`**: Se preocupa por los **datos**. Su pregunta es: "쯊enemos datos v치lidos para mostrar en pantalla?". Sus posibles respuestas son:

  - `pending`: No tenemos nada todav칤a.
  - `error`: Intentamos obtener datos, pero fallamos.
  - `success`: 춰Lo logramos! Tenemos datos.

- **`fetchStatus`**: Se preocupa por la **funci칩n `queryFn`**. Su pregunta es: "쯉e est치 ejecutando la funci칩n que busca datos _ahora mismo_?". Sus posibles respuestas son:
  - `fetching`: S칤, est치 en plena ejecuci칩n.
  - `paused`: Quiso ejecutarse, pero algo la detuvo (normalmente, la falta de red).
  - `idle`: No, est치 en reposo.

La mayor칤a de las veces solo te importar치 `status` (o sus banderas `isPending`, `isError`, `isSuccess`) para renderizar tu UI. Usar치s `fetchStatus` en casos m치s espec칤ficos, como mostrar un indicador de carga m치s sutil para esas actualizaciones en segundo plano.

游리 **Importante**: No es 100% vital para tu primer componente, pero entender esta diferencia es el paso de "principiante" a "usuario competente" de React Query. Te evitar치 much칤sima confusi칩n sobre por qu칠 a veces ves un `isFetching` aunque ya tengas datos en pantalla.
