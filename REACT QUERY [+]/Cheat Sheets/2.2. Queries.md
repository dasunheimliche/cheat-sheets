## A - Query: Tu Petición Inteligente de Datos 🔴

#### 1. **Introducción:**

Una "query" es, en esencia, una forma elegante y organizada de pedir datos a un servidor, como si le dieras una orden clara y precisa que él recordará para el futuro.

#### 2. **Ejemplo:**

```javascript
// Imagina que esto es lo que le pides a React Query:
const peticionDeTareas = {
  queryKey: ["todos"], // La "etiqueta" o nombre único de esta petición
  queryFn: fetchTodoList, // La "instrucción" de cómo conseguir los datos
};

// Y así lo usas en tu componente:
const info = useQuery(peticionDeTareas);
```

**Explicación del ejemplo:**
Aquí no estamos pidiendo los datos de cualquier manera. Le estamos dando dos cosas clave a React Query:

1.  `queryKey: ['todos']`: Una "etiqueta" única. Piensa en esto como el nombre que le pones a una caja donde guardarás algo. React Query usará esta etiqueta para encontrar, actualizar y compartir estos datos en toda tu aplicación sin que tengas que preocuparte. ¡Es su sistema de organización!
2.  `queryFn: fetchTodoList`: La función que _realmente_ va a internet y trae los datos. Es la instrucción paso a paso de "cómo" obtener lo que pediste. Esta función debe devolver una [Promesa](https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Promise) (que es la forma estándar de JavaScript de manejar operaciones que toman tiempo).

#### 3. **Desarrollo**:

Una query es el corazón de React Query. No es solo "ir a buscar datos"; es una **declaración de dependencia**. Le dices a tu aplicación: "Oye, este componente _depende_ de los datos que se identifican con la clave `['todos']`". A partir de ahí, React Query se encarga de la magia: lo busca, lo guarda (caché), te lo entrega, lo actualiza en segundo plano si se vuelve "viejo", y mucho más.

La clave única (`queryKey`) es crucial. Si otro componente en otra parte de tu app pide datos con la misma clave, React Query, en lugar de volver a pedirlos, le dará instantáneamente los que ya tiene guardados. ¡Eficiencia pura!

🔴 **Fundamental**: Este es el concepto más básico y esencial. Sin entender qué es una "query" (la combinación de una clave y una función), nada más en la librería tiene sentido. Es el ladrillo sobre el que se construye todo lo demás.

---

## B - `useQuery`: El Gancho para Pedir y Usar los Datos 🔴

#### 1. **Introducción:**

`useQuery` es el "gancho" (hook) que traes a tus componentes de React para ejecutar una query y, lo más importante, para recibir el estado de esa petición en tiempo real.

#### 2. **Ejemplo:**

```javascript
import { useQuery } from "@tanstack/react-query";

// Una función que busca los datos (debe devolver una Promesa)
async function fetchTodoList() {
  const response = await fetch("https://api.example.com/todos");
  if (!response.ok) {
    throw new Error("¡Algo salió mal!");
  }
  return response.json();
}

function ListaDeTareas() {
  // Usamos el hook y "desempacamos" lo que nos interesa
  const { isPending, isError, data, error } = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodoList,
  });

  // 1. Mientras está cargando...
  if (isPending) {
    return <span>Cargando...</span>;
  }

  // 2. Si hubo un error...
  if (isError) {
    return <span>Error: {error.message}</span>;
  }

  // 3. Si todo salió bien...
  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  );
}
```

**Explicación del ejemplo:**
Este código es un ciclo de vida completo y súper común:

1.  Llamamos a `useQuery` y nos devuelve un objeto. De ese objeto, sacamos las 4 piezas más importantes:
    - `isPending`: Un booleano (`true`/`false`) que nos dice si la petición está en su primer viaje, cargando datos por primera vez.
    - `isError`: Un booleano que nos avisa si la petición falló.
    - `data`: ¡El premio! Aquí estarán tus datos cuando la petición sea exitosa. Al principio, será `undefined`.
    - `error`: Si `isError` es `true`, aquí encontrarás el objeto de error con los detalles de qué falló.
2.  Luego, simplemente revisamos esas "banderas" en orden. ¿Está cargando? Muestra "Cargando...". ¿Falló? Muestra el error. Si no es ninguna de las anteriores, ¡significa que tenemos los datos! Y los mostramos.

#### 3. **Desarrollo**:

El hook `useQuery` es tu principal herramienta de trabajo. Te suscribe a una query y te mantiene informado de su estado. El objeto que devuelve es increíblemente rico en información, pero con `isPending`, `isError`, `data` y `error` tienes todo lo necesario para el 95% de los casos.

**¡Anticipando una duda!** Te preguntarás: "¿Y qué pasa con `isSuccess`?". ¡Buena pregunta! El ejemplo funciona porque sigue una lógica de descarte. Si `isPending` es falso y `isError` es falso, la única opción que queda es que la petición fue exitosa (`isSuccess` es `true`). Por eso podemos asumir con seguridad que `data` está disponible al final.

🔴 **Fundamental**: Este es el hook que usarás sin parar. Es la forma práctica de aplicar el concepto de "Query" (visto en el punto A) dentro de tus componentes de React. Dominar este patrón de `if (isPending)` / `if (isError)` es la clave para empezar a ser productivo con la librería.

---

## C - `status` vs. `fetchStatus`: La Diferencia que te Ahorrará Dolores de Cabeza 🟡

#### 1. **Introducción:**

React Query te da dos tipos de "estados" para una misma query, y al principio puede ser confuso, pero te prometo que tiene mucho sentido: `status` te habla sobre los **datos**, mientras que `fetchStatus` te habla sobre la **petición**.

#### 2. **Ejemplo:**

Imagina que pides una pizza a domicilio.

- **`status` (El estado de tus DATOS): "¿Tengo pizza para comer?"**

  - `'pending'`: No, la caja está vacía. Aún no ha llegado la primera pizza.
  - `'error'`: No, me trajeron una ensalada por error. No tengo pizza.
  - `'success'`: ¡Sí! Tengo una pizza deliciosa en la mesa.

- **`fetchStatus` (El estado de la PETICIÓN): "¿El repartidor está en camino AHORA?"**
  - `'fetching'`: Sí, el repartidor está en la moto viniendo hacia acá.
  - `'paused'`: El repartidor quería salir, pero la moto no arranca (no hay conexión a internet).
  - `'idle'`: No, el repartidor está quieto. O ya entregó la pizza o todavía no ha salido.

**Explicación del ejemplo:**
¡Aquí está la magia! Puedes tener `status: 'success'` (¡tienes pizza en la mesa!) y al mismo tiempo `fetchStatus: 'fetching'` (¡el repartidor viene con OTRA pizza porque la primera ya se estaba enfriando y la app pidió una nueva automáticamente!). Esto es lo que se conoce como "refetch en segundo plano". Estás viendo datos válidos mientras React Query ya está buscando una versión más fresca por ti.

#### 3. **Desarrollo**:

Esta separación es una de las características más potentes y, a la vez, más confusas para los principiantes. Vamos a grabarlo a fuego:

- **`status`**: Se preocupa por los **datos**. Su pregunta es: "¿Tenemos datos válidos para mostrar en pantalla?". Sus posibles respuestas son:

  - `pending`: No tenemos nada todavía.
  - `error`: Intentamos obtener datos, pero fallamos.
  - `success`: ¡Lo logramos! Tenemos datos.

- **`fetchStatus`**: Se preocupa por la **función `queryFn`**. Su pregunta es: "¿Se está ejecutando la función que busca datos _ahora mismo_?". Sus posibles respuestas son:
  - `fetching`: Sí, está en plena ejecución.
  - `paused`: Quiso ejecutarse, pero algo la detuvo (normalmente, la falta de red).
  - `idle`: No, está en reposo.

La mayoría de las veces solo te importará `status` (o sus banderas `isPending`, `isError`, `isSuccess`) para renderizar tu UI. Usarás `fetchStatus` en casos más específicos, como mostrar un indicador de carga más sutil para esas actualizaciones en segundo plano.

🟡 **Importante**: No es 100% vital para tu primer componente, pero entender esta diferencia es el paso de "principiante" a "usuario competente" de React Query. Te evitará muchísima confusión sobre por qué a veces ves un `isFetching` aunque ya tengas datos en pantalla.
