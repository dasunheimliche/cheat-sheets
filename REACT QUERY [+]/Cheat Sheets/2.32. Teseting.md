## A - El Montaje Esencial: El "Wrapper" que da Contexto a tus Tests 🔴

#### 1. **Introducción:**

Para probar un hook de React Query, primero necesitas crear un pequeño "universo" de prueba para él, y esto se logra con un componente "envoltorio" o `wrapper`.

#### 2. **Ejemplo:**

```javascript
// 1. Importa las herramientas necesarias
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

// 2. Crea una instancia del cliente de React Query
const queryClient = new QueryClient();

// 3. ¡Aquí está la magia! Crea el componente "wrapper"
const wrapper = ({ children }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
);

// Ahora, este 'wrapper' está listo para ser usado en tus tests.
```

**Explicación del ejemplo:**

Imagina que tu hook (`useCustomHook`) es un pez. Este pez necesita agua para vivir, ¿verdad? En una aplicación de React, el `<QueryClientProvider>` es el "agua" que le da a todos los hooks de React Query lo que necesitan para funcionar.

- **Paso 2:** `new QueryClient()` crea una nueva "fuente de agua". Es el cerebro que gestiona toda la caché de datos.
- **Paso 3:** El `wrapper` es la "pecera". Es un componente simple que toma a cualquier otro componente (`children`) y lo rodea con el `<QueryClientProvider>`. Cuando probamos nuestro hook (el pez), lo metemos dentro de esta pecera (`wrapper`) para que tenga el "agua" (`QueryClient`) que necesita para vivir. Sin esto, el test fallaría al instante porque el hook no encontraría el contexto de React Query.

#### 3. **Desarrollo:**

La razón fundamental para usar este `wrapper` es el **aislamiento**. Al crear un `new QueryClient()` para cada test (o al menos limpiarlo antes de cada uno), te aseguras de que el resultado de un test no afecte a otro. Si un test deja datos en la caché, podría contaminar el siguiente test y darte resultados falsos. ¡Sería un desastre! El `wrapper` garantiza que cada test se ejecute en un entorno limpio y predecible.

🔴 **Fundamental**: No puedes probar un hook de React Query sin proveerle un `QueryClient` a través del `QueryClientProvider`. Este patrón de `wrapper` es la forma estándar y esencial de lograrlo en un entorno de pruebas. Es el cimiento sobre el que se construye todo lo demás.

---

## B - La Prueba en Acción: `renderHook` y la Paciencia de `waitFor` 🔴

#### 1. **Introducción:**

Una vez tienes tu "pecera" (`wrapper`), usas `renderHook` para poner tu hook a funcionar y `waitFor` para esperar pacientemente a que termine su tarea asíncrona (como una llamada a la API).

#### 2. **Ejemplo:**

```javascript
// Asumimos que ya tienes el 'wrapper' del concepto A

// El hook que vamos a probar
function useCustomHook() {
  return useQuery({ queryKey: ["customHook"], queryFn: () => "Hola Mundo" });
}

// El test
test('debería obtener "Hola Mundo"', async () => {
  // 1. "Renderiza" el hook usando nuestro wrapper
  const { result } = renderHook(() => useCustomHook(), { wrapper });

  // 2. ¡Espera! La data no es instantánea.
  await waitFor(() => expect(result.current.isSuccess).toBe(true));

  // 3. Ahora sí, comprueba el resultado
  expect(result.current.data).toBe("Hola Mundo");
});
```

**Explicación del ejemplo:**

- **Paso 1:** `renderHook` es la función que ejecuta tu hook en un entorno de prueba. Le pasamos nuestro hook (`() => useCustomHook()`) y, crucialmente, nuestro `{ wrapper }` del punto anterior. Esto devuelve un objeto, del cual nos interesa `result`.
- **Paso 2:** ¡**ALERTA DE CONFUSIÓN COMÚN**! Justo después de llamar a `renderHook`, la petición de datos aún no ha terminado. Si intentaras comprobar `result.current.data` inmediatamente, probablemente sería `undefined`. `useQuery` es asíncrono. Por eso usamos `await waitFor()`. Es como decirle al test: "No sigas. Detente aquí y observa. Solo cuando la condición `result.current.isSuccess` se cumpla, podrás continuar".
- **Paso 3:** Una vez que `waitFor` nos da luz verde, significa que la query fue exitosa. Ahora podemos comprobar con seguridad que `result.current.data` contiene el valor que esperábamos. `result.current` siempre tiene el estado más reciente de tu hook.

#### 3. **Desarrollo:**

La combinación de `renderHook` y `waitFor` es el pan de cada día al testear hooks. `renderHook` te da una ventana para observar tu hook, y `waitFor` sincroniza tu test con la naturaleza asíncrona de las operaciones de datos. Sin `waitFor`, estarías intentando adivinar cuándo estarán listos los datos, lo que llevaría a tests inestables ("flaky tests") que a veces pasan y a veces fallan.

🔴 **Fundamental**: Esta es la mecánica central para probar el ciclo de vida de cualquier hook que realice operaciones asíncronas. `renderHook` inicia el proceso y `waitFor` lo observa hasta su finalización. No se puede testear React Query de forma fiable sin esto.

---

## C - Evitando Tiempos de Espera: Desactivar los Reintentos 🟡

#### 1. **Introducción:**

Para que tus tests de errores sean rápidos y no fallen por "timeout", es una práctica muy recomendada desactivar los reintentos automáticos de React Query.

#### 2. **Ejemplo:**

```javascript
// Configura el cliente para que NO reintente las queries fallidas
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false, // <-- La clave está aquí
    },
  },
});

// Luego, usa este cliente en tu 'wrapper' como en el concepto A
const wrapper = ({ children }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
);
```

**Explicación del ejemplo:**

React Query es muy resiliente. Si una petición a la API falla, por defecto lo intentará un par de veces más antes de rendirse. En una aplicación real, ¡esto es genial! Pero en un test donde _quieres_ probar un estado de error, esperar a que todos esos reintentos fallen es una pérdida de tiempo enorme que puede hacer que tu test falle por exceder el límite de tiempo.

Al configurar `retry: false` en las `defaultOptions`, le estás diciendo a React Query: "Para los tests, si algo falla, quiero saberlo de inmediato. Falla a la primera, no pierdas tiempo reintentando".

#### 3. **Desarrollo:**

Esta configuración se aplica como una opción _por defecto_. Esto significa que si un `useQuery` específico en tu código tiene explícitamente `retry: 5`, esa configuración individual ganará y sí reintentará 5 veces. Las opciones por defecto son solo un respaldo cuando no especificas nada. Desactivar los reintentos globalmente en tu configuración de test es una de las primeras cosas que deberías hacer para tener un entorno de pruebas sano y rápido.

🟡 **Importante**: Aunque técnicamente podrías vivir sin esto, tus tests para casos de error serían lentos y frágiles. Es una configuración de calidad de vida tan crucial que se considera una práctica estándar en casi todos los proyectos.

---

## D - Simulando la Realidad: Probando Llamadas de Red con `nock` 🔴

#### 1. **Introducción:**

Para probar que tu código hace las llamadas de red correctas sin depender de un servidor real, usamos una librería como `nock` para interceptar y simular las respuestas de la API.

#### 2. **Ejemplo:**

````javascript
import nock from 'nock'; // Herramienta para simular la API

// El hook que hace una llamada de red real
function useFetchData() {
  return useQuery({
    queryKey: ['fetchData'],
    queryFn: () => fetch('https://api.example.com/data').then(res => res.json()),
  });
}

// El test
test('debería hacer una llamada de red y obtener los datos', async () => {
  // 1. Prepara la simulación con nock
  nock('https://api.example.com')
    .get('/data')
    .reply(200, { message: '¡Datos simulados!' });

  // 2. Renderiza el hook (usando el wrapper del concepto A)
  const { result } = renderHook(() => useFetchData(), { wrapper });

  // 3. Espera a que la llamada (simulada) sea exitosa
  await waitFor(() => expect(result.current.isSuccess).toBe(true));

  // 4. Verifica que los datos son los que 'nock' devolvió
  expect(result.current.data).toEqual({ message: '¡Datos simulados!' });
});```

**Explicación del ejemplo:**

*   **Paso 1:** Aquí está el truco. `nock` actúa como un guardia de tráfico para las peticiones de red de tu test. Le decimos: "¡Oye, `nock`! Si ves que alguien intenta hacer una petición `GET` a `https://api.example.com/data`, no dejes que salga a internet. Intercéptala y responde con un código 200 (éxito) y este objeto: `{ message: '¡Datos simulados!' }`".
*   **Pasos 2, 3 y 4:** El resto es igual que en el concepto B. Nuestro hook `useFetchData` cree que está hablando con una API real, pero en realidad es `nock` quien le responde. Esto hace que el test sea súper rápido y 100% predecible. No importa si tienes internet o si la API real está caída, tu test siempre funcionará igual.

#### 3. **Desarrollo:**

Usar simuladores de API como `nock` (o MSW, que es otra alternativa popular) es **crucial** para los tests de frontend. Separa la lógica de tu aplicación de las dependencias externas. Te permite probar fácilmente casos de éxito, errores de servidor (ej: `.reply(500, ...)`), respuestas lentas y cualquier otro escenario que sería difícil o imposible de replicar con una API real.

🔴 **Fundamental**: El propósito principal de React Query es gestionar datos de la red. Por lo tanto, probar la interacción con esa red (de forma simulada) no es opcional, es el núcleo de lo que necesitas verificar.

---

## E - El Reto del Scroll Infinito: Tests para `useInfiniteQuery` 🟡

#### 1. **Introducción:**

Para probar un hook de scroll infinito, necesitas que tu API simulada (`nock`) sea más inteligente y devuelva diferentes datos para cada "página" solicitada.

#### 2. **Ejemplo:**

```javascript
// 1. Simulación de API más avanzada con nock
nock('https://api.example.com')
  .persist() // Permite que esta simulación se use varias veces
  .get('/items')
  .query(true) // Coincide con la URL sin importar los parámetros de búsqueda (ej: ?page=1)
  .reply(200, (uri) => { // La respuesta es una FUNCIÓN, no un objeto fijo
    const page = new URL(`https://api.example.com${uri}`).searchParams.get('page');
    if (page === '2') {
      return { items: ['item 3', 'item 4'], nextPage: null };
    }
    return { items: ['item 1', 'item 2'], nextPage: 2 };
  });

// El test
test('debería cargar más datos al llamar a fetchNextPage', async () => {
  const { result } = renderHook(() => useInfiniteQueryHook(), { wrapper });

  // Espera a que la primera página cargue
  await waitFor(() => expect(result.current.isSuccess).toBe(true));
  expect(result.current.data.pages[0].items).toEqual(['item 1', 'item 2']);

  // Llama a la función para cargar la siguiente página
  result.current.fetchNextPage();

  // Espera a que la segunda página se añada a los datos
  await waitFor(() => expect(result.current.data.pages.length).toBe(2));
  expect(result.current.data.pages[1].items).toEqual(['item 3', 'item 4']);
});
````

**Explicación del ejemplo:**

- **Paso 1 (La simulación):**
  - `.persist()`: Como vamos a llamar a la misma URL (`/items`) varias veces (una por cada página), le decimos a `nock` que no se "desactive" después del primer uso.
  - `.reply((uri) => { ... })`: ¡Esta es la clave! En lugar de dar una respuesta fija, le damos una función. `nock` ejecutará esta función en cada llamada, pasándole la URL completa (`uri`). Dentro, extraemos el parámetro `page` de la URL y devolvemos una respuesta diferente según su valor. ¡Nuestra API simulada ahora es dinámica!
- **El Test:**
  - Primero, verificamos que la página 1 se cargó correctamente.
  - Luego, ejecutamos `result.current.fetchNextPage()`, que es la función que `useInfiniteQuery` nos da para cargar más.
  - Finalmente, usamos `waitFor` de nuevo para esperar a que el estado se actualice y la longitud del array `pages` sea 2.

#### 3. **Desarrollo:**

Probar el scroll infinito demuestra un dominio más profundo de las herramientas. Requiere entender cómo `useInfiniteQuery` estructura sus datos (en un array de `pages`) y cómo configurar tu herramienta de simulación para que responda dinámicamente. La técnica de usar una función en `.reply()` es muy poderosa y puede adaptarse para simular búsquedas, filtros y otras APIs complejas.

🟡 **Importante**: El scroll infinito es un patrón de UI muy común. Saber cómo testearlo de forma fiable es una habilidad muy valiosa y demuestra que puedes manejar escenarios de prueba más complejos que una simple petición de datos.

---

## F - El Pacificador de Jest: Configurando `gcTime` 🔵

#### 1. **Introducción:**

Si usas Jest y ves un error frustrante que dice "Jest did not exit one second after the test run completed", configurar el `gcTime` de React Query puede ser la solución.

#### 2. **Ejemplo:**

```javascript
// En tu configuración de cliente de prueba (como en el concepto C)
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
      gcTime: Infinity, // <-- La solución mágica
    },
  },
});
```

**Explicación del ejemplo:**

`gcTime` es "Garbage Collection Time" (tiempo de recolección de basura). Es el tiempo que React Query mantiene los datos en caché después de que todos los componentes que los usan se hayan "desmontado". Por defecto, este tiempo es de 5 minutos.

A veces, los temporizadores internos que React Query usa para gestionar este `gcTime` pueden confundir a Jest, haciéndole pensar que todavía hay algo "en ejecución" incluso después de que el test haya terminado. Esto provoca el temido error de "did not exit".

Al establecer `gcTime: Infinity` en los tests, le dices a React Query: "No te molestes en programar una limpieza de caché. Simplemente mantén los datos para siempre (dentro del ciclo de vida del test)". Esto desactiva esos temporizadores y, en la mayoría de los casos, apacigua a Jest.

#### 3. **Desarrollo:**

Esta es una solución muy específica para un problema de integración entre dos herramientas (React Query y Jest). No es algo que necesites entender a fondo para empezar, pero es increíblemente útil saber que existe. Si alguna vez te encuentras con ese error, recordar esta pequeña configuración te ahorrará horas de frustración.

🔵 **Específico**: Solo necesitas esto si te encuentras con el problema concreto del error de salida de Jest. No es un conocimiento fundamental para testear la lógica de tu aplicación, sino más bien un truco de configuración para un entorno de pruebas particular.
