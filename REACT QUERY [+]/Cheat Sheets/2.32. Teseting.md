## A - El Montaje Esencial: El "Wrapper" que da Contexto a tus Tests 游댮

#### 1. **Introducci칩n:**

Para probar un hook de React Query, primero necesitas crear un peque침o "universo" de prueba para 칠l, y esto se logra con un componente "envoltorio" o `wrapper`.

#### 2. **Ejemplo:**

```javascript
// 1. Importa las herramientas necesarias
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

// 2. Crea una instancia del cliente de React Query
const queryClient = new QueryClient();

// 3. 춰Aqu칤 est치 la magia! Crea el componente "wrapper"
const wrapper = ({ children }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
);

// Ahora, este 'wrapper' est치 listo para ser usado en tus tests.
```

**Explicaci칩n del ejemplo:**

Imagina que tu hook (`useCustomHook`) es un pez. Este pez necesita agua para vivir, 쯨erdad? En una aplicaci칩n de React, el `<QueryClientProvider>` es el "agua" que le da a todos los hooks de React Query lo que necesitan para funcionar.

- **Paso 2:** `new QueryClient()` crea una nueva "fuente de agua". Es el cerebro que gestiona toda la cach칠 de datos.
- **Paso 3:** El `wrapper` es la "pecera". Es un componente simple que toma a cualquier otro componente (`children`) y lo rodea con el `<QueryClientProvider>`. Cuando probamos nuestro hook (el pez), lo metemos dentro de esta pecera (`wrapper`) para que tenga el "agua" (`QueryClient`) que necesita para vivir. Sin esto, el test fallar칤a al instante porque el hook no encontrar칤a el contexto de React Query.

#### 3. **Desarrollo:**

La raz칩n fundamental para usar este `wrapper` es el **aislamiento**. Al crear un `new QueryClient()` para cada test (o al menos limpiarlo antes de cada uno), te aseguras de que el resultado de un test no afecte a otro. Si un test deja datos en la cach칠, podr칤a contaminar el siguiente test y darte resultados falsos. 춰Ser칤a un desastre! El `wrapper` garantiza que cada test se ejecute en un entorno limpio y predecible.

游댮 **Fundamental**: No puedes probar un hook de React Query sin proveerle un `QueryClient` a trav칠s del `QueryClientProvider`. Este patr칩n de `wrapper` es la forma est치ndar y esencial de lograrlo en un entorno de pruebas. Es el cimiento sobre el que se construye todo lo dem치s.

---

## B - La Prueba en Acci칩n: `renderHook` y la Paciencia de `waitFor` 游댮

#### 1. **Introducci칩n:**

Una vez tienes tu "pecera" (`wrapper`), usas `renderHook` para poner tu hook a funcionar y `waitFor` para esperar pacientemente a que termine su tarea as칤ncrona (como una llamada a la API).

#### 2. **Ejemplo:**

```javascript
// Asumimos que ya tienes el 'wrapper' del concepto A

// El hook que vamos a probar
function useCustomHook() {
  return useQuery({ queryKey: ["customHook"], queryFn: () => "Hola Mundo" });
}

// El test
test('deber칤a obtener "Hola Mundo"', async () => {
  // 1. "Renderiza" el hook usando nuestro wrapper
  const { result } = renderHook(() => useCustomHook(), { wrapper });

  // 2. 춰Espera! La data no es instant치nea.
  await waitFor(() => expect(result.current.isSuccess).toBe(true));

  // 3. Ahora s칤, comprueba el resultado
  expect(result.current.data).toBe("Hola Mundo");
});
```

**Explicaci칩n del ejemplo:**

- **Paso 1:** `renderHook` es la funci칩n que ejecuta tu hook en un entorno de prueba. Le pasamos nuestro hook (`() => useCustomHook()`) y, crucialmente, nuestro `{ wrapper }` del punto anterior. Esto devuelve un objeto, del cual nos interesa `result`.
- **Paso 2:** 춰**ALERTA DE CONFUSI칍N COM칔N**! Justo despu칠s de llamar a `renderHook`, la petici칩n de datos a칰n no ha terminado. Si intentaras comprobar `result.current.data` inmediatamente, probablemente ser칤a `undefined`. `useQuery` es as칤ncrono. Por eso usamos `await waitFor()`. Es como decirle al test: "No sigas. Detente aqu칤 y observa. Solo cuando la condici칩n `result.current.isSuccess` se cumpla, podr치s continuar".
- **Paso 3:** Una vez que `waitFor` nos da luz verde, significa que la query fue exitosa. Ahora podemos comprobar con seguridad que `result.current.data` contiene el valor que esper치bamos. `result.current` siempre tiene el estado m치s reciente de tu hook.

#### 3. **Desarrollo:**

La combinaci칩n de `renderHook` y `waitFor` es el pan de cada d칤a al testear hooks. `renderHook` te da una ventana para observar tu hook, y `waitFor` sincroniza tu test con la naturaleza as칤ncrona de las operaciones de datos. Sin `waitFor`, estar칤as intentando adivinar cu치ndo estar치n listos los datos, lo que llevar칤a a tests inestables ("flaky tests") que a veces pasan y a veces fallan.

游댮 **Fundamental**: Esta es la mec치nica central para probar el ciclo de vida de cualquier hook que realice operaciones as칤ncronas. `renderHook` inicia el proceso y `waitFor` lo observa hasta su finalizaci칩n. No se puede testear React Query de forma fiable sin esto.

---

## C - Evitando Tiempos de Espera: Desactivar los Reintentos 游리

#### 1. **Introducci칩n:**

Para que tus tests de errores sean r치pidos y no fallen por "timeout", es una pr치ctica muy recomendada desactivar los reintentos autom치ticos de React Query.

#### 2. **Ejemplo:**

```javascript
// Configura el cliente para que NO reintente las queries fallidas
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false, // <-- La clave est치 aqu칤
    },
  },
});

// Luego, usa este cliente en tu 'wrapper' como en el concepto A
const wrapper = ({ children }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
);
```

**Explicaci칩n del ejemplo:**

React Query es muy resiliente. Si una petici칩n a la API falla, por defecto lo intentar치 un par de veces m치s antes de rendirse. En una aplicaci칩n real, 춰esto es genial! Pero en un test donde _quieres_ probar un estado de error, esperar a que todos esos reintentos fallen es una p칠rdida de tiempo enorme que puede hacer que tu test falle por exceder el l칤mite de tiempo.

Al configurar `retry: false` en las `defaultOptions`, le est치s diciendo a React Query: "Para los tests, si algo falla, quiero saberlo de inmediato. Falla a la primera, no pierdas tiempo reintentando".

#### 3. **Desarrollo:**

Esta configuraci칩n se aplica como una opci칩n _por defecto_. Esto significa que si un `useQuery` espec칤fico en tu c칩digo tiene expl칤citamente `retry: 5`, esa configuraci칩n individual ganar치 y s칤 reintentar치 5 veces. Las opciones por defecto son solo un respaldo cuando no especificas nada. Desactivar los reintentos globalmente en tu configuraci칩n de test es una de las primeras cosas que deber칤as hacer para tener un entorno de pruebas sano y r치pido.

游리 **Importante**: Aunque t칠cnicamente podr칤as vivir sin esto, tus tests para casos de error ser칤an lentos y fr치giles. Es una configuraci칩n de calidad de vida tan crucial que se considera una pr치ctica est치ndar en casi todos los proyectos.

---

## D - Simulando la Realidad: Probando Llamadas de Red con `nock` 游댮

#### 1. **Introducci칩n:**

Para probar que tu c칩digo hace las llamadas de red correctas sin depender de un servidor real, usamos una librer칤a como `nock` para interceptar y simular las respuestas de la API.

#### 2. **Ejemplo:**

````javascript
import nock from 'nock'; // Herramienta para simular la API

// El hook que hace una llamada de red real
function useFetchData() {
  return useQuery({
    queryKey: ['fetchData'],
    queryFn: () => fetch('https://api.example.com/data').then(res => res.json()),
  });
}

// El test
test('deber칤a hacer una llamada de red y obtener los datos', async () => {
  // 1. Prepara la simulaci칩n con nock
  nock('https://api.example.com')
    .get('/data')
    .reply(200, { message: '춰Datos simulados!' });

  // 2. Renderiza el hook (usando el wrapper del concepto A)
  const { result } = renderHook(() => useFetchData(), { wrapper });

  // 3. Espera a que la llamada (simulada) sea exitosa
  await waitFor(() => expect(result.current.isSuccess).toBe(true));

  // 4. Verifica que los datos son los que 'nock' devolvi칩
  expect(result.current.data).toEqual({ message: '춰Datos simulados!' });
});```

**Explicaci칩n del ejemplo:**

*   **Paso 1:** Aqu칤 est치 el truco. `nock` act칰a como un guardia de tr치fico para las peticiones de red de tu test. Le decimos: "춰Oye, `nock`! Si ves que alguien intenta hacer una petici칩n `GET` a `https://api.example.com/data`, no dejes que salga a internet. Interc칠ptala y responde con un c칩digo 200 (칠xito) y este objeto: `{ message: '춰Datos simulados!' }`".
*   **Pasos 2, 3 y 4:** El resto es igual que en el concepto B. Nuestro hook `useFetchData` cree que est치 hablando con una API real, pero en realidad es `nock` quien le responde. Esto hace que el test sea s칰per r치pido y 100% predecible. No importa si tienes internet o si la API real est치 ca칤da, tu test siempre funcionar치 igual.

#### 3. **Desarrollo:**

Usar simuladores de API como `nock` (o MSW, que es otra alternativa popular) es **crucial** para los tests de frontend. Separa la l칩gica de tu aplicaci칩n de las dependencias externas. Te permite probar f치cilmente casos de 칠xito, errores de servidor (ej: `.reply(500, ...)`), respuestas lentas y cualquier otro escenario que ser칤a dif칤cil o imposible de replicar con una API real.

游댮 **Fundamental**: El prop칩sito principal de React Query es gestionar datos de la red. Por lo tanto, probar la interacci칩n con esa red (de forma simulada) no es opcional, es el n칰cleo de lo que necesitas verificar.

---

## E - El Reto del Scroll Infinito: Tests para `useInfiniteQuery` 游리

#### 1. **Introducci칩n:**

Para probar un hook de scroll infinito, necesitas que tu API simulada (`nock`) sea m치s inteligente y devuelva diferentes datos para cada "p치gina" solicitada.

#### 2. **Ejemplo:**

```javascript
// 1. Simulaci칩n de API m치s avanzada con nock
nock('https://api.example.com')
  .persist() // Permite que esta simulaci칩n se use varias veces
  .get('/items')
  .query(true) // Coincide con la URL sin importar los par치metros de b칰squeda (ej: ?page=1)
  .reply(200, (uri) => { // La respuesta es una FUNCI칍N, no un objeto fijo
    const page = new URL(`https://api.example.com${uri}`).searchParams.get('page');
    if (page === '2') {
      return { items: ['item 3', 'item 4'], nextPage: null };
    }
    return { items: ['item 1', 'item 2'], nextPage: 2 };
  });

// El test
test('deber칤a cargar m치s datos al llamar a fetchNextPage', async () => {
  const { result } = renderHook(() => useInfiniteQueryHook(), { wrapper });

  // Espera a que la primera p치gina cargue
  await waitFor(() => expect(result.current.isSuccess).toBe(true));
  expect(result.current.data.pages[0].items).toEqual(['item 1', 'item 2']);

  // Llama a la funci칩n para cargar la siguiente p치gina
  result.current.fetchNextPage();

  // Espera a que la segunda p치gina se a침ada a los datos
  await waitFor(() => expect(result.current.data.pages.length).toBe(2));
  expect(result.current.data.pages[1].items).toEqual(['item 3', 'item 4']);
});
````

**Explicaci칩n del ejemplo:**

- **Paso 1 (La simulaci칩n):**
  - `.persist()`: Como vamos a llamar a la misma URL (`/items`) varias veces (una por cada p치gina), le decimos a `nock` que no se "desactive" despu칠s del primer uso.
  - `.reply((uri) => { ... })`: 춰Esta es la clave! En lugar de dar una respuesta fija, le damos una funci칩n. `nock` ejecutar치 esta funci칩n en cada llamada, pas치ndole la URL completa (`uri`). Dentro, extraemos el par치metro `page` de la URL y devolvemos una respuesta diferente seg칰n su valor. 춰Nuestra API simulada ahora es din치mica!
- **El Test:**
  - Primero, verificamos que la p치gina 1 se carg칩 correctamente.
  - Luego, ejecutamos `result.current.fetchNextPage()`, que es la funci칩n que `useInfiniteQuery` nos da para cargar m치s.
  - Finalmente, usamos `waitFor` de nuevo para esperar a que el estado se actualice y la longitud del array `pages` sea 2.

#### 3. **Desarrollo:**

Probar el scroll infinito demuestra un dominio m치s profundo de las herramientas. Requiere entender c칩mo `useInfiniteQuery` estructura sus datos (en un array de `pages`) y c칩mo configurar tu herramienta de simulaci칩n para que responda din치micamente. La t칠cnica de usar una funci칩n en `.reply()` es muy poderosa y puede adaptarse para simular b칰squedas, filtros y otras APIs complejas.

游리 **Importante**: El scroll infinito es un patr칩n de UI muy com칰n. Saber c칩mo testearlo de forma fiable es una habilidad muy valiosa y demuestra que puedes manejar escenarios de prueba m치s complejos que una simple petici칩n de datos.

---

## F - El Pacificador de Jest: Configurando `gcTime` 游댯

#### 1. **Introducci칩n:**

Si usas Jest y ves un error frustrante que dice "Jest did not exit one second after the test run completed", configurar el `gcTime` de React Query puede ser la soluci칩n.

#### 2. **Ejemplo:**

```javascript
// En tu configuraci칩n de cliente de prueba (como en el concepto C)
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: false,
      gcTime: Infinity, // <-- La soluci칩n m치gica
    },
  },
});
```

**Explicaci칩n del ejemplo:**

`gcTime` es "Garbage Collection Time" (tiempo de recolecci칩n de basura). Es el tiempo que React Query mantiene los datos en cach칠 despu칠s de que todos los componentes que los usan se hayan "desmontado". Por defecto, este tiempo es de 5 minutos.

A veces, los temporizadores internos que React Query usa para gestionar este `gcTime` pueden confundir a Jest, haci칠ndole pensar que todav칤a hay algo "en ejecuci칩n" incluso despu칠s de que el test haya terminado. Esto provoca el temido error de "did not exit".

Al establecer `gcTime: Infinity` en los tests, le dices a React Query: "No te molestes en programar una limpieza de cach칠. Simplemente mant칠n los datos para siempre (dentro del ciclo de vida del test)". Esto desactiva esos temporizadores y, en la mayor칤a de los casos, apacigua a Jest.

#### 3. **Desarrollo:**

Esta es una soluci칩n muy espec칤fica para un problema de integraci칩n entre dos herramientas (React Query y Jest). No es algo que necesites entender a fondo para empezar, pero es incre칤blemente 칰til saber que existe. Si alguna vez te encuentras con ese error, recordar esta peque침a configuraci칩n te ahorrar치 horas de frustraci칩n.

游댯 **Espec칤fico**: Solo necesitas esto si te encuentras con el problema concreto del error de salida de Jest. No es un conocimiento fundamental para testear la l칩gica de tu aplicaci칩n, sino m치s bien un truco de configuraci칩n para un entorno de pruebas particular.
