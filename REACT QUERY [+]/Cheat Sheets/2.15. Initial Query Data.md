## A - `initialData`: El "Ya te lo tengo" para tus Datos üü°

#### 1. **Introducci√≥n:**

Esta opci√≥n te permite mostrar datos en la pantalla **inmediatamente**, usando informaci√≥n que ya tienes a mano (por ejemplo, ven√≠a del servidor), para que el usuario no tenga que ver una pantalla de "cargando...".

#### 2. **Ejemplo:**

Imagina que tu servidor te env√≠a una lista de tareas inicial (`initialTodos`) cuando la p√°gina carga por primera vez.

```tsx
// Tus tareas iniciales, ya las tienes en tu c√≥digo
const initialTodos = [
  { id: 1, title: "Comprar leche" },
  { id: 2, title: "Aprender React Query" },
];

function MisTareas() {
  const { data } = useQuery({
    queryKey: ["todos"],
    queryFn: () => fetch("/api/todos"), // React Query ir√° a buscar la versi√≥n m√°s nueva
    initialData: initialTodos, // ¬°Pero mientras tanto, muestra esto!
  });

  // ... tu componente que renderiza las tareas
}
```

**Explicaci√≥n del ejemplo:**

1.  `initialTodos`: Es un array con datos que ya existen. No hemos tenido que esperar a que `fetch` termine para tenerlos.
2.  `useQuery`: Cuando el componente se monta, mira y dice: "¬°Oye, tengo `initialData`!".
3.  **Resultado inmediato:** En lugar de mostrar un spinner, renderiza `initialTodos` al instante. El usuario ve la lista de tareas en un parpadeo.
4.  **En segundo plano:** Mientras el usuario admira la velocidad, React Query ejecuta `fetch('/api/todos')` silenciosamente para asegurarse de que los datos est√©n actualizados. Si hay cambios, actualizar√° la pantalla de forma transparente.

#### 3. **Desarrollo**:

Piensa en `initialData` como darle a tu aplicaci√≥n un "comienzo con ventaja". Es la herramienta perfecta para mejorar la experiencia de usuario (UX) porque elimina la espera inicial. Es como llegar a un restaurante y que ya tengan tu bebida favorita en la mesa.

**¬°Cuidado con la trampa!** No confundas `initialData` con `placeholderData`. Usa `initialData` cuando tienes los **datos reales y completos**. Si solo tienes datos parciales o de relleno, `placeholderData` es una mejor opci√≥n, porque React Query no los guarda en la cach√© como si fueran la verdad absoluta.

üü° **Importante**: No es estrictamente _fundamental_ para que una consulta funcione (puedes vivir con pantallas de carga), pero es tan incre√≠blemente √∫til para mejorar la percepci√≥n de velocidad de tu app que se convierte en una herramienta que querr√°s usar constantemente.

---

## B - El D√∫o Din√°mico: `staleTime` vs. `initialDataUpdatedAt` üü°

#### 1. **Introducci√≥n:**

Estas dos opciones le dicen a React Query si tus `initialData` son "reci√©n salidos del horno" o "de la semana pasada", para que decida de forma inteligente si necesita ir a buscar datos nuevos **inmediatamente**.

#### 2. **Ejemplo:**

Aqu√≠ la cosa se pone interesante. Observa tres escenarios. ¬°Quiero que la diferencia te quede grabada a fuego!

```tsx
// ESCENARIO 1: El Ansioso (Comportamiento por defecto)
// Muestra los datos iniciales, pero INMEDIATAMENTE va a buscar nuevos.
useQuery({
  queryKey: ["todos"],
  queryFn: () => fetch("/api/todos"),
  initialData: initialTodos,
  // staleTime por defecto es 0, as√≠ que los datos se consideran "viejos" al instante.
});

// ESCENARIO 2: El Confiado (Usando staleTime)
// Muestra los datos y conf√≠a en ellos durante 1 minuto. No buscar√° nuevos hasta que pase ese tiempo.
useQuery({
  queryKey: ["todos"],
  queryFn: () => fetch("/api/todos"),
  initialData: initialTodos,
  staleTime: 60 * 1000, // 60 segundos
});

// ESCENARIO 3: El Inteligente (Usando initialDataUpdatedAt)
// Le decimos exactamente cu√°ndo se crearon estos datos.
useQuery({
  queryKey: ["todos"],
  queryFn: () => fetch("/api/todos"),
  initialData: initialTodos,
  staleTime: 60 * 1000, // Regla: los datos deben tener menos de 1 minuto.
  // Le damos el "timestamp" de cu√°ndo se obtuvieron los datos iniciales.
  initialDataUpdatedAt: timestampDeCuandoSeObtuvoInitialTodos, // ej: 1678886400000
});
```

**Explicaci√≥n del ejemplo:**

- **Escenario 1 (El Ansioso):** Muestra `initialTodos` y, en el mismo instante, lanza la llamada a la API. ¬øPor qu√©? Porque por defecto, React Query considera que los datos iniciales est√°n "stale" (obsoletos) desde el segundo cero.
- **Escenario 2 (El Confiado):** Muestra `initialTodos` y se queda tranquilo. Le has dicho: "Estos datos son buenos durante 1 minuto (`staleTime`)". No har√° ninguna llamada a la API hasta que pase ese minuto o el usuario interact√∫e con la ventana. Es una confianza a ciegas.
- **Escenario 3 (El Inteligente):** Aqu√≠ est√° la magia. Le das la regla (`staleTime: '1 minuto'`) y tambi√©n el dato clave: la "fecha de fabricaci√≥n" de `initialTodos` (`initialDataUpdatedAt`). React Query hace la matem√°tica: `Ahora - fecha_fabricacion > 1 minuto`. Si es `true`, va a buscar datos nuevos. Si es `false`, se queda quieto. Es la forma m√°s precisa y eficiente.

#### 3. **Desarrollo**:

Esta es LA confusi√≥n m√°s com√∫n. Usas `initialData` esperando que no haya una llamada a la API y ¬°ZAS! ah√≠ est√°. Es porque no entendiste esta relaci√≥n.

- **`staleTime`**: Es un temporizador de confianza. Le dices: "No importa qu√© tan viejos sean estos datos, conf√≠a en ellos por X tiempo".
- **`initialDataUpdatedAt`**: Es un certificado de nacimiento. Le dices: "Estos datos nacieron en este preciso momento". React Query usar√° este certificado para ver si los datos ya vencieron seg√∫n tu regla de `staleTime`.

**¬øCu√°ndo elegir cu√°l?**
Casi siempre que puedas, usa el **Escenario 3**. Es el m√°s robusto. Le das a la librer√≠a toda la informaci√≥n para que tome la mejor decisi√≥n. El Escenario 2 es √∫til si no tienes la fecha de creaci√≥n de los datos pero quieres forzar un per√≠odo de calma.

üü° **Importante**: Entender esto es crucial para no llevarte sorpresas y evitar llamadas a la API innecesarias. Si usas `initialData`, tienes que pensar en su "frescura". No es opcional si quieres control total.

---

## C - `initialData` como Funci√≥n: Optimizando el Arranque üîµ

#### 1. **Introducci√≥n:**

Si el proceso para generar tus datos iniciales es costoso (por ejemplo, un c√°lculo pesado), puedes pasarlo como una funci√≥n para que se ejecute **una sola vez** y no en cada re-renderizado del componente.

#### 2. **Ejemplo:**

Imagina que `encontrarTareasViejas()` es una funci√≥n que recorre un array gigante y consume mucho tiempo.

```tsx
// MAL: Esto se ejecutar√≠a en CADA render, ralentizando tu app.
useQuery({
  queryKey: ["viejasTareas"],
  queryFn: () => fetch("/api/viejasTareas"),
  initialData: encontrarTareasViejas(todasMisTareas), // ¬°Ouch!
});

// BIEN: La funci√≥n flecha `() => ...` protege la llamada.
useQuery({
  queryKey: ["viejasTareas"],
  queryFn: () => fetch("/api/viejasTareas"),
  // React Query es listo y solo ejecutar√° esto UNA VEZ, al inicializar.
  initialData: () => encontrarTareasViejas(todasMisTareas),
});
```

**Explicaci√≥n del ejemplo:**
En el primer caso, cada vez que el componente se actualiza por cualquier motivo, `encontrarTareasViejas()` se vuelve a ejecutar. Un desastre para el rendimiento. Al envolverlo en `() => ...`, le est√°s diciendo a React Query: "Oye, tengo una receta para los datos iniciales. Ejec√∫tala t√∫ mismo, pero solo la primera vez que la necesites".

#### 3. **Desarrollo**:

Esto es pura optimizaci√≥n de rendimiento. No cambia lo que el usuario ve, pero s√≠ c√≥mo de fluida se siente tu aplicaci√≥n, especialmente en componentes complejos que se re-renderizan a menudo. Es una herramienta de precisi√≥n para casos espec√≠ficos.

üîµ **Espec√≠fico**: No lo necesitar√°s todos los d√≠as, pero cuando te encuentres con una funci√≥n de inicializaci√≥n de datos que es lenta, recordar este truco te convertir√° en un h√©roe del rendimiento. Es bueno saber que existe para cuando surja la necesidad.

---

## D - Reutilizando la Cach√©: `initialData` desde otra Query üîµ

#### 1. **Introducci√≥n:**

Puedes usar los datos que ya est√°n en la cach√© de una consulta (como una lista completa) para usarlos como los datos iniciales de otra consulta (como un elemento espec√≠fico de esa lista). ¬°Es el reciclaje de datos en su m√°xima expresi√≥n!

#### 2. **Ejemplo:**

Tienes una lista de tareas (`['todos']`) y el usuario hace clic en una para ver los detalles (`['todos', todoId]`).

```tsx
function DetalleTarea({ todoId }) {
  const queryClient = useQueryClient(); // El cerebro que gestiona la cach√©

  const { data } = useQuery({
    queryKey: ["todos", todoId], // Clave para ESTA tarea espec√≠fica
    queryFn: () => fetch(`/api/todos/${todoId}`),

    // ¬°Aqu√≠ est√° la magia!
    initialData: () => {
      // 1. Busca en la cach√© los datos de la lista completa de 'todos'
      const listaCompleta = queryClient.getQueryData(["todos"]);
      // 2. Si existe, encuentra la tarea que nos interesa
      return listaCompleta?.find((todo) => todo.id === todoId);
    },
  });
}
```

**Explicaci√≥n del ejemplo:**

1.  El usuario est√° en la p√°gina de detalles de la tarea con `id = 5`.
2.  `useQuery` para `['todos', 5]` se inicializa.
3.  Antes de mostrar "cargando...", ejecuta la funci√≥n de `initialData`.
4.  `queryClient.getQueryData(['todos'])` esp√≠a dentro de la cach√© y saca la lista completa de tareas que seguramente ya se hab√≠a cargado en la p√°gina anterior.
5.  Busca (`.find()`) la tarea con `id = 5` dentro de esa lista y la devuelve.
6.  **Resultado:** La p√°gina de detalles se muestra **instant√°neamente** con los datos que ya ten√≠amos. Mientras tanto, `fetch` se ejecuta en segundo plano para confirmar que no han cambiado.

#### 3. **Desarrollo**:

Este patr√≥n es oro puro para interfaces de tipo "lista-detalle" (piensa en una app de emails, un cat√°logo de productos, etc.). La transici√≥n entre p√°ginas se siente incre√≠blemente r√°pida y fluida, porque no hay parpadeo ni pantallas de carga.

**Pista importante:** Cuando haces esto, los datos que reciclas de la cach√© pueden ser algo viejos. Por eso, este patr√≥n casi siempre deber√≠a ir de la mano con `initialDataUpdatedAt` para que React Query sepa qu√© tan "frescos" son esos datos reciclados. ¬°Esto nos lleva directamente al siguiente nivel!

üîµ **Espec√≠fico**: Es una t√©cnica m√°s avanzada, pero fundamental para crear experiencias de usuario de primer nivel en flujos de navegaci√≥n comunes. Una vez que la entiendes, la ves aplicable en muchos sitios.

---

## E - `initialData` Condicional: Reciclando Datos... pero solo si son Frescos üîµ

#### 1. **Introducci√≥n:**

Esta es la versi√≥n "experto" del concepto anterior: revisas qu√© tan antiguos son los datos de la cach√© **antes** de decidir si los usas como `initialData`, o si es mejor simplemente mostrar "cargando" y buscar datos frescos desde cero.

#### 2. **Ejemplo:**

Igual que antes, pero ahora somos m√°s exigentes con la frescura de los datos.

```tsx
function DetalleTareaExigente({ todoId }) {
  const queryClient = useQueryClient();

  const { data } = useQuery({
    queryKey: ["todos", todoId],
    queryFn: () => fetch(`/api/todos/${todoId}`),

    initialData: () => {
      // 1. No solo pedimos los datos, sino el "estado" completo de la query
      const estadoDeLaQuery = queryClient.getQueryState(["todos"]);

      // 2. Si la query existe Y sus datos se actualizaron hace menos de 10 segundos...
      if (
        estadoDeLaQuery &&
        Date.now() - estadoDeLaQuery.dataUpdatedAt <= 10000
      ) {
        // ...entonces s√≠, reciclamos el dato. ¬°Es suficientemente fresco!
        return estadoDeLaQuery.data.find((todo) => todo.id === todoId);
      }

      // 3. Si no, devolvemos 'undefined'. Esto le dice a React Query:
      // "Olv√≠dalo, no hay datos iniciales. Muestra el 'cargando' y busca en la API".
      return undefined;
    },
  });
}
```

**Explicaci√≥n del ejemplo:**

1.  `queryClient.getQueryState(['todos'])` nos da m√°s informaci√≥n que solo los datos. Nos da metadatos, incluyendo `dataUpdatedAt`, que es la "fecha de fabricaci√≥n" de esos datos en la cach√©.
2.  Hacemos una comprobaci√≥n: si los datos tienen m√°s de 10 segundos de antig√ºedad, los consideramos demasiado viejos para ser mostrados, incluso por un instante.
3.  Si son viejos, devolvemos `undefined`. Esto desactiva `initialData` para esta carga, y el componente mostrar√° su estado de carga normal. Si son frescos, los devolvemos y obtenemos la carga instant√°nea del ejemplo anterior.

#### 3. **Desarrollo**:

Esto te da el control definitivo. Logras un equilibrio perfecto entre una UI s√∫per r√°pida y la garant√≠a de que no est√°s mostrando informaci√≥n potencialmente muy desactualizada. Es como decirle a tu app: "Intenta ser r√°pida, pero nunca a costa de mostrar datos incorrectos".

üîµ **Espec√≠fico**: Esta es una t√©cnica de optimizaci√≥n avanzada. La usar√°s en aplicaciones cr√≠ticas donde la frescura de los datos es tan importante como la velocidad de la interfaz. Es la herramienta de un artesano del desarrollo frontend.
