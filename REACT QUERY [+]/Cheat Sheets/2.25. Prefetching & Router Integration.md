## A - Prefetching: Pidiendo los datos antes de que el usuario los necesite üü°

#### 1. **Introducci√≥n:**

El "prefetching" es la t√©cnica m√°gica de cargar datos en segundo plano _antes_ de que se muestren en pantalla, para que cuando el usuario los necesite, ¬°BAM!, ya est√©n ah√≠, haciendo que tu aplicaci√≥n se sienta incre√≠blemente r√°pida.

#### 2. **Ejemplo (Analog√≠a):**

Imagina que vas a tu cafeter√≠a favorita. El barista, que ya te conoce, empieza a preparar tu caf√© con leche y avellanas en cuanto te ve cruzar la puerta. Para cuando llegas al mostrador a pedir, tu caf√© ya est√° listo. Eso, mi querido aprendiz, es _prefetching_. El barista se anticip√≥ a tu petici√≥n.

#### 3. **Desarrollo**:

En el mundo de las aplicaciones, esto significa que podemos iniciar una petici√≥n a la API (ir a buscar los datos) bas√°ndonos en una se√±al de que el usuario _probablemente_ va a necesitar esa informaci√≥n. Algunas formas comunes de hacerlo, que veremos en detalle, son:

- Cuando el usuario pasa el rat√≥n sobre un bot√≥n (`onMouseEnter`).
- Dentro de un componente que sabe que su componente hijo necesitar√° ciertos datos.
- Al definir las rutas de tu aplicaci√≥n (por ejemplo, cuando el usuario navega a `/perfil`, empezamos a cargar los datos del perfil).

El objetivo final es simple: reducir o eliminar los tiempos de espera visibles para el usuario, creando una experiencia fluida y casi instant√°nea.

üü° **Importante**: Esta no es una t√©cnica b√°sica, pero es una de las herramientas m√°s poderosas que tienes para mejorar dr√°sticamente el rendimiento percibido de tu aplicaci√≥n. Entenderla te diferencia de un programador novato a uno que se preocupa de verdad por la experiencia del usuario.

---

## B - `prefetchQuery`: El "Ve a buscar esto" para tus datos üü°

#### 1. **Introducci√≥n:**

Esta es la funci√≥n principal que usar√°s para decirle a TanStack Query: "Oye, ¬øpodr√≠as ir buscando estos datos y guardarlos por si los necesito luego? Gracias".

#### 2. **Ejemplo:**

```tsx
// Imagina que tienes un bot√≥n para ver una lista de "tareas pendientes" (todos)
const prefetchTodos = async () => {
  // Le decimos a queryClient que vaya buscando los datos con la clave ['todos']
  // y los guarde en la cach√©. No nos devuelve los datos, solo los guarda.
  await queryClient.prefetchQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos, // Esta es la funci√≥n que realmente hace la llamada a la API
  });
};
```

**Explicaci√≥n del ejemplo:**
Cuando se llama a `prefetchTodos`, TanStack Query ejecuta la funci√≥n `fetchTodos` en segundo plano. Si la llamada tiene √©xito, los datos resultantes se almacenan en la cach√© bajo la clave `['todos']`. M√°s tarde, si un componente usa `useQuery({ queryKey: ['todos'], ... })`, encontrar√° los datos ya listos y los mostrar√° al instante. ¬°Cero espera para el usuario!

#### 3. **Desarrollo**:

Aqu√≠ van algunos detalles cruciales que te salvar√°n de futuros dolores de cabeza, te lo prometo:

- **No devuelve datos:** Esta funci√≥n devuelve una promesa que se resuelve en `void` (nada). Su √∫nico trabajo es calentar la cach√©. Si necesitas los datos inmediatamente, debes usar `fetchQuery`.
- **No lanza errores:** Si la petici√≥n falla, `prefetchQuery` no explotar√°. Se queda calladita. La idea es que el `useQuery` que venga despu√©s lo intente de nuevo, lo que es un fallback bastante elegante. Si necesitas manejar errores, de nuevo, usa `fetchQuery`.
- **Respeta el `staleTime`:** Por defecto, si ya hay datos "frescos" en la cach√© para esa `queryKey`, no volver√° a pedirlos. "Fresco" se define por el `staleTime`. Puedes pasar un `staleTime` espec√≠fico para anular el comportamiento por defecto.
- **Se limpia con `gcTime`:** Si precargas algo y ning√∫n componente lo usa, los datos se borrar√°n de la cach√© despu√©s del tiempo definido en `gcTime` (Garbage Collection Time o tiempo de recolecci√≥n de basura).

üü° **Importante**: `prefetchQuery` es tu herramienta de cabecera para la mayor√≠a de escenarios de precarga. Es segura, eficiente y la base de casi todos los patrones que veremos a continuaci√≥n.

---

## C - `prefetchInfiniteQuery`: Precargando datos que vienen por partes üîµ

#### 1. **Introducci√≥n:**

Es la versi√≥n de `prefetchQuery` dise√±ada espec√≠ficamente para datos paginados, como un feed de noticias o una lista de productos con scroll infinito.

#### 2. **Ejemplo:**

```tsx
const prefetchProjects = async () => {
  await queryClient.prefetchInfiniteQuery({
    queryKey: ["projects"],
    queryFn: fetchProjects,
    initialPageParam: 0,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
    pages: 3, // ¬°La clave est√° aqu√≠! Precargamos las 3 primeras p√°ginas.
  });
};
```

**Explicaci√≥n del ejemplo:**
Este c√≥digo no solo precarga la primera p√°gina de proyectos, sino que, gracias a la opci√≥n `pages: 3`, busca y guarda en cach√© las tres primeras p√°ginas. Cuando el usuario llegue a la lista, no solo ver√° la primera p√°gina al instante, sino que las dos siguientes tambi√©n cargar√°n de inmediato al hacer scroll.

#### 3. **Desarrollo**:

La principal diferencia con `prefetchQuery` es su capacidad para manejar m√∫ltiples p√°ginas. Si no especificas la opci√≥n `pages`, por defecto solo precargar√° la primera p√°gina de resultados. Para precargar m√°s, necesitas dos cosas:

1.  La funci√≥n `getNextPageParam` para que sepa c√≥mo encontrar la p√°gina siguiente.
2.  La opci√≥n `pages` con el n√∫mero de p√°ginas que quieres adelantar.

üîµ **Espec√≠fico**: Usa esta funci√≥n cuando te enfrentes a una interfaz de "scroll infinito" o paginaci√≥n. Para cualquier otro tipo de datos, `prefetchQuery` (Concepto B) es suficiente.

---

## D - Patr√≥n 1: Precarga en Eventos de Usuario üü°

#### 1. **Introducci√≥n:**

Esta estrategia consiste en iniciar la precarga cuando el usuario realiza una acci√≥n que sugiere que _podr√≠a_ necesitar ciertos datos a continuaci√≥n, como pasar el rat√≥n por encima de un enlace o un bot√≥n.

#### 2. **Ejemplo:**

```tsx
function ShowDetailsButton() {
  const queryClient = useQueryClient();

  const prefetchDetails = () => {
    queryClient.prefetchQuery({
      queryKey: ['details'],
      queryFn: getDetailsData,
      // ¬°OJO! Esto es s√∫per importante aqu√≠.
      // Le decimos que los datos se consideran viejos despu√©s de 1 minuto.
      staleTime: 60000,
    });
  };

  return (
    <button onMouseEnter={prefetchDetails} onFocus={prefetchDetails} onClick={...}>
      Mostrar Detalles
    </button>
  );
}
```

**Explicaci√≥n del ejemplo:**
Cuando el usuario posa el cursor sobre el bot√≥n (`onMouseEnter`) o lo selecciona con el teclado (`onFocus`), se dispara la funci√≥n `prefetchDetails`. Esto inicia la carga de los datos de "detalles". Si el usuario finalmente hace clic, es muy probable que los datos ya est√©n listos y la secci√≥n de detalles aparezca al instante.

#### 3. **Desarrollo**:

La parte m√°s importante y que a menudo se olvida es el `staleTime`. ¬øPor qu√© es tan crucial aqu√≠? Porque `prefetchQuery` no har√° nada si considera que los datos en cach√© todav√≠a son "frescos". Al poner un `staleTime` (por ejemplo, de 1 minuto), te aseguras de que si el usuario vuelve a pasar el rat√≥n despu√©s de ese tiempo, los datos se actualizar√°n, garantizando que no vea informaci√≥n obsoleta.

üü° **Importante**: Este es un patr√≥n f√°cil de implementar y con un impacto muy positivo en la experiencia de usuario. Es una de esas "victorias f√°ciles" que hacen que tu aplicaci√≥n se sienta de alta calidad.

---

## E - Patr√≥n 2: Precarga en Componentes (Para Evitar "Cascadas") üü°

#### 1. **Introducci√≥n:**

A veces, un componente padre necesita datos, y solo cuando los tiene, renderiza un componente hijo que, a su vez, necesita _otros_ datos, creando una lenta "cascada de peticiones".

#### 2. **Ejemplo (El Problema):**

```tsx
// 1. El componente Article pide los datos del art√≠culo.
function Article({ id }) {
  const { data: articleData, isPending } = useQuery({
    queryKey: ["article", id],
    queryFn: getArticleById,
  });
  if (isPending) return "Cargando art√≠culo...";

  // 2. SOLO DESPU√âS de tener los datos, renderiza Comments.
  return <Comments id={id} />;
}

// 3. Y ahora, Comments empieza a pedir los datos de los comentarios.
function Comments({ id }) {
  const { data, isPending } = useQuery({
    queryKey: ["article-comments", id],
    queryFn: getArticleCommentsById,
  });
  // ...
}
```

**Explicaci√≥n del ejemplo (El Problema):**
Esto crea una secuencia de espera:

1.  `ESPERA` a que `getArticleById()` termine.
2.  `ESPERA` a que `getArticleCommentsById()` termine.

El tiempo total de carga es la suma de las dos esperas. ¬°Muy lento!

#### 3. **Desarrollo**:

El objetivo es "aplanar" esa cascada, es decir, hacer que ambas peticiones se inicien al mismo tiempo. La estrategia es iniciar la petici√≥n de los comentarios desde el componente padre (`Article`). Hay varias formas de hacerlo, y las veremos a continuaci√≥n como "soluciones" separadas.

üü° **Importante**: Identificar y solucionar las cascadas de peticiones es fundamental para el rendimiento de aplicaciones complejas. Es un problema muy com√∫n, y saber c√≥mo resolverlo te convertir√° en un mejor desarrollador.

---

## F - Soluci√≥n a la Cascada (Opci√≥n 1): Usar `useQuery` e ignorar el resultado üîµ

#### 1. **Introducci√≥n:**

Un truco sencillo para aplanar la cascada es llamar a `useQuery` para los datos del hijo directamente en el padre, pero sin usar su resultado, solo para que la petici√≥n se inicie antes.

#### 2. **Ejemplo (La Soluci√≥n):**

```tsx
function Article({ id }) {
  // Petici√≥n principal
  const { data: articleData, isPending } = useQuery({
    queryKey: ["article", id],
    queryFn: getArticleById,
  });

  // ¬°Aqu√≠ est√° el truco! Iniciamos la petici√≥n de comentarios aqu√≠.
  // No nos importa su resultado, solo queremos que empiece a cargar.
  useQuery({
    queryKey: ["article-comments", id],
    queryFn: getArticleCommentsById,
    // Optimizaci√≥n opcional: evita re-renders innecesarios en este componente.
    notifyOnChangeProps: [],
  });

  if (isPending) return "Cargando art√≠culo...";

  return <Comments id={id} />; // Comments encontrar√° los datos ya en cach√©.
}
```

**Explicaci√≥n del ejemplo:**
Ahora, las dos llamadas a `useQuery` se ejecutan en paralelo en cuanto el componente `Article` se monta. Cuando `Comments` se renderiza, su `useQuery` encuentra los datos de los comentarios ya en la cach√© (o en proceso de carga) y los muestra mucho m√°s r√°pido.

La cascada se aplana:

1.  `|> getArticleById()`
2.  `|> getArticleCommentsById()`

Ambas empiezan a la vez.

#### 3. **Desarrollo**:

Esta es una soluci√≥n r√°pida y efectiva. La opci√≥n `notifyOnChangeProps: []` es una peque√±a optimizaci√≥n que le dice a este `useQuery` de precarga: "Oye, no provoques un re-render del componente `Article` cuando termines de cargar o tus datos cambien". Es √∫til porque a `Article` no le importan los datos de los comentarios, solo quer√≠a iniciar la carga.

üîµ **Espec√≠fico**: Es una t√©cnica v√°lida y r√°pida. Sin embargo, existen hooks m√°s expl√≠citos como `usePrefetchQuery` (ver siguiente concepto) que pueden comunicar mejor tu intenci√≥n, especialmente cuando trabajas con Suspense.

---

## G - Soluci√≥n a la Cascada (Opci√≥n 2): `usePrefetchQuery` para Suspense üîµ

#### 1. **Introducci√≥n:**

Cuando usas Suspense de React, necesitas una forma de precargar datos sin que esa precarga _bloquee_ la renderizaci√≥n, y para eso existe el hook `usePrefetchQuery`.

#### 2. **Ejemplo:**

```tsx
// Componente contenedor que prepara los datos
function ArticleLayout({ id }) {
  // Inicia la precarga de comentarios. NO bloquea el renderizado.
  usePrefetchQuery({
    queryKey: ["article-comments", id],
    queryFn: getArticleCommentsById,
  });

  // Suspense mostrar√° "Cargando art√≠culo" mientras Article se carga.
  return (
    <Suspense fallback="Cargando art√≠culo...">
      <Article id={id} />
    </Suspense>
  );
}

// Componente que usa los datos principales con Suspense
function Article({ id }) {
  // Esta llamada S√ç suspende el componente hasta que los datos del art√≠culo est√©n listos.
  const { data: articleData } = useSuspenseQuery({
    queryKey: ["article", id],
    queryFn: getArticleById,
  });
  // ...
}
```

**Explicaci√≥n del ejemplo:**
`usePrefetchQuery` en `ArticleLayout` le da la se√±al a TanStack Query para que empiece a buscar los comentarios. Inmediatamente despu√©s, React intenta renderizar `<Article />`. `useSuspenseQuery` dentro de `Article` pausa la renderizaci√≥n y muestra el `fallback` de Suspense. Mientras el usuario ve "Cargando art√≠culo...", las dos peticiones (art√≠culo y comentarios) se est√°n ejecutando en paralelo.

#### 3. **Desarrollo**:

**¬øPor qu√© no usar `useQuery` aqu√≠?** Porque si lo usaras para la precarga, se ejecutar√≠a _despu√©s_ de que la promesa de `useSuspenseQuery` se resolviera, ¬°y volver√≠amos a la cascada!
**¬øPor qu√© no usar `useSuspenseQuery` para la precarga?** Porque bloquear√≠a el renderizado hasta que los comentarios estuvieran listos, y no queremos eso.

`usePrefetchQuery` es la herramienta perfecta para este escenario: inicia la carga, pero se aparta para no estorbar.

üîµ **Espec√≠fico**: Este es el hook que _debes_ usar para precargar datos en un componente que est√° por encima de un l√≠mite de Suspense. Es la forma can√≥nica de hacerlo bien.

---

## H - Soluci√≥n a la Cascada (Opci√≥n 3): Precarga dentro de otra `queryFn` üîµ

#### 1. **Introducci√≥n:**

Si dos tipos de datos est√°n tan √≠ntimamente ligados que siempre que pides uno, vas a necesitar el otro, puedes iniciar la precarga del segundo desde la propia funci√≥n de carga del primero.

#### 2. **Ejemplo:**

```tsx
const { data: articleData } = useQuery({
  queryKey: ["article", id],
  queryFn: async (...args) => {
    // 1. Inmediatamente, disparamos la precarga de los comentarios.
    queryClient.prefetchQuery({
      queryKey: ["article-comments", id],
      queryFn: getArticleCommentsById,
    });

    // 2. Mientras tanto, continuamos con la petici√≥n principal del art√≠culo.
    const article = await getArticleById(...args);
    return article;
  },
});
```

**Explicaci√≥n del ejemplo:**
En el momento en que `useQuery` llama a su `queryFn` para obtener el art√≠culo, lo primero que hacemos dentro de esa funci√≥n es usar `queryClient` para lanzar la precarga de los comentarios. No esperamos a que termine (`prefetchQuery` no se `await`-ea aqu√≠), simplemente la disparamos y seguimos con lo nuestro, que es obtener y devolver los datos del art√≠culo.

#### 3. **Desarrollo**:

Esta t√©cnica es ideal para datos fuertemente acoplados. La ventaja es que la l√≥gica de precarga vive junto a la petici√≥n de datos principal, lo que puede hacer el c√≥digo m√°s organizado. La desventaja es que acopla un poco m√°s tu l√≥gica de fetching.

üîµ **Espec√≠fico**: √ösalo cuando la relaci√≥n entre los datos es casi una regla de negocio ("cada vez que se muestra un art√≠culo, se muestran sus comentarios"). Para relaciones menos directas, los otros patrones son m√°s flexibles.

---

## I - Integraci√≥n con el Router: La estrategia a nivel de ruta üü°

#### 1. **Introducci√≥n:**

En lugar de gestionar la precarga dentro de los componentes, podemos hacerlo a un nivel superior: en la configuraci√≥n del router, definiendo qu√© datos necesita una ruta _antes_ de que se renderice.

#### 2. **Ejemplo (con TanStack Router):**

```tsx
const articleRoute = new Route({
  // ...
  // Define qu√© datos se necesitar√°n
  beforeLoad: () => ({
    articleQueryOptions: { queryKey: ["article"], queryFn: fetchArticle },
    commentsQueryOptions: { queryKey: ["comments"], queryFn: fetchComments },
  }),
  // El "cargador" de la ruta, donde ocurre la magia
  loader: async ({ context: { queryClient }, routeContext }) => {
    const { articleQueryOptions, commentsQueryOptions } = routeContext;

    // 1. Inicia la precarga de comentarios, PERO NO ESPERES (no hay await).
    // La ruta puede empezar a renderizar mientras esto se carga.
    queryClient.prefetchQuery(commentsQueryOptions);

    // 2. Inicia la precarga del art√≠culo Y ESPERA (s√≠ hay await).
    // La ruta NO se renderizar√° hasta que estos datos cr√≠ticos est√©n listos.
    await queryClient.prefetchQuery(articleQueryOptions);
  },
  // ...
});
```

**Explicaci√≥n del ejemplo:**
Este es un patr√≥n muy potente.

1.  En `beforeLoad`, declaramos las "recetas" para buscar los datos del art√≠culo y los comentarios.
2.  En `loader`, ejecutamos esas recetas.
    - Llamamos a `prefetchQuery` para los comentarios sin `await`. Esto significa: "Empieza a buscar esto, pero no me hagas esperar".
    - Llamamos a `prefetchQuery` para el art√≠culo con `await`. Esto significa: "No muestres la p√°gina hasta que tengas estos datos. Son indispensables".

El resultado es una experiencia de usuario fant√°stica: los datos cr√≠ticos se cargan bloqueando la navegaci√≥n (lo que suele ser r√°pido), y los datos secundarios se cargan en segundo plano mientras el usuario ya est√° viendo la p√°gina.

#### 3. **Desarrollo**:

Este enfoque centraliza la l√≥gica de obtenci√≥n de datos, desacopl√°ndola de tus componentes de UI. Es una forma muy robusta y escalable de construir aplicaciones, ya que previene las cascadas de peticiones a nivel de arquitectura. Aunque el ejemplo usa TanStack Router, el concepto se puede aplicar a otros routers como React Router.

üü° **Importante**: Para aplicaciones grandes y complejas, este es a menudo el mejor enfoque. Requiere un poco m√°s de configuraci√≥n inicial, pero te ahorra much√≠simos problemas de rendimiento a largo plazo.

---

## J - `setQueryData`: "Enga√±ando" a la cach√© con datos que ya tienes üü°

#### 1. **Introducci√≥n:**

A veces, ya tienes los datos que una query necesitar√≠a (quiz√°s vinieron en otra respuesta de la API o los creaste localmente) y solo quieres colocarlos en la cach√© para que est√©n disponibles al instante.

#### 2. **Ejemplo:**

```tsx
// Imagina que acabas de crear una nueva "tarea" y la API te la devuelve.
// La variable `newTodo` contiene el objeto de la nueva tarea.

// En lugar de volver a pedir toda la lista, la actualizamos manualmente.
queryClient.setQueryData(["todos"], (oldData) => [...oldData, newTodo]);
```

**Explicaci√≥n del ejemplo:**
Aqu√≠ no estamos haciendo una petici√≥n de red. Le estamos diciendo a TanStack Query: "Para la clave `['todos']`, toma los datos antiguos (`oldData`), y actual√≠zalos a√±adiendo este `newTodo` al final". Cualquier componente que est√© usando `useQuery` con la clave `['todos']` se re-renderizar√° autom√°ticamente con la lista actualizada.

#### 3. **Desarrollo**:

**Diferencia CLAVE con `prefetchQuery`:**

- `prefetchQuery`: Va a buscar datos a una fuente externa (API) y los pone en la cach√©. **Implica una petici√≥n as√≠ncrona.**
- `setQueryData`: Coloca datos que ya tienes _sincr√≥nicamente_ en la cach√©. **No hay petici√≥n de red.**

Es una herramienta incre√≠blemente √∫til para actualizaciones optimistas (fingir que una operaci√≥n tuvo √©xito al instante) o para "cebar" la cach√© con datos que obtuviste por otros medios.

üü° **Importante**: Dominar `setQueryData` te permite crear interacciones de usuario s√∫per fluidas, especialmente en operaciones de creaci√≥n, actualizaci√≥n o borrado (CRUD). Es una herramienta fundamental para la gesti√≥n manual de la cach√©.
