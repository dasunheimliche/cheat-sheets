## A - Prefetching: Pidiendo los datos antes de que el usuario los necesite 🟡

#### 1. **Introducción:**

El "prefetching" es la técnica mágica de cargar datos en segundo plano _antes_ de que se muestren en pantalla, para que cuando el usuario los necesite, ¡BAM!, ya estén ahí, haciendo que tu aplicación se sienta increíblemente rápida.

#### 2. **Ejemplo (Analogía):**

Imagina que vas a tu cafetería favorita. El barista, que ya te conoce, empieza a preparar tu café con leche y avellanas en cuanto te ve cruzar la puerta. Para cuando llegas al mostrador a pedir, tu café ya está listo. Eso, mi querido aprendiz, es _prefetching_. El barista se anticipó a tu petición.

#### 3. **Desarrollo**:

En el mundo de las aplicaciones, esto significa que podemos iniciar una petición a la API (ir a buscar los datos) basándonos en una señal de que el usuario _probablemente_ va a necesitar esa información. Algunas formas comunes de hacerlo, que veremos en detalle, son:

- Cuando el usuario pasa el ratón sobre un botón (`onMouseEnter`).
- Dentro de un componente que sabe que su componente hijo necesitará ciertos datos.
- Al definir las rutas de tu aplicación (por ejemplo, cuando el usuario navega a `/perfil`, empezamos a cargar los datos del perfil).

El objetivo final es simple: reducir o eliminar los tiempos de espera visibles para el usuario, creando una experiencia fluida y casi instantánea.

🟡 **Importante**: Esta no es una técnica básica, pero es una de las herramientas más poderosas que tienes para mejorar drásticamente el rendimiento percibido de tu aplicación. Entenderla te diferencia de un programador novato a uno que se preocupa de verdad por la experiencia del usuario.

---

## B - `prefetchQuery`: El "Ve a buscar esto" para tus datos 🟡

#### 1. **Introducción:**

Esta es la función principal que usarás para decirle a TanStack Query: "Oye, ¿podrías ir buscando estos datos y guardarlos por si los necesito luego? Gracias".

#### 2. **Ejemplo:**

```tsx
// Imagina que tienes un botón para ver una lista de "tareas pendientes" (todos)
const prefetchTodos = async () => {
  // Le decimos a queryClient que vaya buscando los datos con la clave ['todos']
  // y los guarde en la caché. No nos devuelve los datos, solo los guarda.
  await queryClient.prefetchQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos, // Esta es la función que realmente hace la llamada a la API
  });
};
```

**Explicación del ejemplo:**
Cuando se llama a `prefetchTodos`, TanStack Query ejecuta la función `fetchTodos` en segundo plano. Si la llamada tiene éxito, los datos resultantes se almacenan en la caché bajo la clave `['todos']`. Más tarde, si un componente usa `useQuery({ queryKey: ['todos'], ... })`, encontrará los datos ya listos y los mostrará al instante. ¡Cero espera para el usuario!

#### 3. **Desarrollo**:

Aquí van algunos detalles cruciales que te salvarán de futuros dolores de cabeza, te lo prometo:

- **No devuelve datos:** Esta función devuelve una promesa que se resuelve en `void` (nada). Su único trabajo es calentar la caché. Si necesitas los datos inmediatamente, debes usar `fetchQuery`.
- **No lanza errores:** Si la petición falla, `prefetchQuery` no explotará. Se queda calladita. La idea es que el `useQuery` que venga después lo intente de nuevo, lo que es un fallback bastante elegante. Si necesitas manejar errores, de nuevo, usa `fetchQuery`.
- **Respeta el `staleTime`:** Por defecto, si ya hay datos "frescos" en la caché para esa `queryKey`, no volverá a pedirlos. "Fresco" se define por el `staleTime`. Puedes pasar un `staleTime` específico para anular el comportamiento por defecto.
- **Se limpia con `gcTime`:** Si precargas algo y ningún componente lo usa, los datos se borrarán de la caché después del tiempo definido en `gcTime` (Garbage Collection Time o tiempo de recolección de basura).

🟡 **Importante**: `prefetchQuery` es tu herramienta de cabecera para la mayoría de escenarios de precarga. Es segura, eficiente y la base de casi todos los patrones que veremos a continuación.

---

## C - `prefetchInfiniteQuery`: Precargando datos que vienen por partes 🔵

#### 1. **Introducción:**

Es la versión de `prefetchQuery` diseñada específicamente para datos paginados, como un feed de noticias o una lista de productos con scroll infinito.

#### 2. **Ejemplo:**

```tsx
const prefetchProjects = async () => {
  await queryClient.prefetchInfiniteQuery({
    queryKey: ["projects"],
    queryFn: fetchProjects,
    initialPageParam: 0,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
    pages: 3, // ¡La clave está aquí! Precargamos las 3 primeras páginas.
  });
};
```

**Explicación del ejemplo:**
Este código no solo precarga la primera página de proyectos, sino que, gracias a la opción `pages: 3`, busca y guarda en caché las tres primeras páginas. Cuando el usuario llegue a la lista, no solo verá la primera página al instante, sino que las dos siguientes también cargarán de inmediato al hacer scroll.

#### 3. **Desarrollo**:

La principal diferencia con `prefetchQuery` es su capacidad para manejar múltiples páginas. Si no especificas la opción `pages`, por defecto solo precargará la primera página de resultados. Para precargar más, necesitas dos cosas:

1.  La función `getNextPageParam` para que sepa cómo encontrar la página siguiente.
2.  La opción `pages` con el número de páginas que quieres adelantar.

🔵 **Específico**: Usa esta función cuando te enfrentes a una interfaz de "scroll infinito" o paginación. Para cualquier otro tipo de datos, `prefetchQuery` (Concepto B) es suficiente.

---

## D - Patrón 1: Precarga en Eventos de Usuario 🟡

#### 1. **Introducción:**

Esta estrategia consiste en iniciar la precarga cuando el usuario realiza una acción que sugiere que _podría_ necesitar ciertos datos a continuación, como pasar el ratón por encima de un enlace o un botón.

#### 2. **Ejemplo:**

```tsx
function ShowDetailsButton() {
  const queryClient = useQueryClient();

  const prefetchDetails = () => {
    queryClient.prefetchQuery({
      queryKey: ['details'],
      queryFn: getDetailsData,
      // ¡OJO! Esto es súper importante aquí.
      // Le decimos que los datos se consideran viejos después de 1 minuto.
      staleTime: 60000,
    });
  };

  return (
    <button onMouseEnter={prefetchDetails} onFocus={prefetchDetails} onClick={...}>
      Mostrar Detalles
    </button>
  );
}
```

**Explicación del ejemplo:**
Cuando el usuario posa el cursor sobre el botón (`onMouseEnter`) o lo selecciona con el teclado (`onFocus`), se dispara la función `prefetchDetails`. Esto inicia la carga de los datos de "detalles". Si el usuario finalmente hace clic, es muy probable que los datos ya estén listos y la sección de detalles aparezca al instante.

#### 3. **Desarrollo**:

La parte más importante y que a menudo se olvida es el `staleTime`. ¿Por qué es tan crucial aquí? Porque `prefetchQuery` no hará nada si considera que los datos en caché todavía son "frescos". Al poner un `staleTime` (por ejemplo, de 1 minuto), te aseguras de que si el usuario vuelve a pasar el ratón después de ese tiempo, los datos se actualizarán, garantizando que no vea información obsoleta.

🟡 **Importante**: Este es un patrón fácil de implementar y con un impacto muy positivo en la experiencia de usuario. Es una de esas "victorias fáciles" que hacen que tu aplicación se sienta de alta calidad.

---

## E - Patrón 2: Precarga en Componentes (Para Evitar "Cascadas") 🟡

#### 1. **Introducción:**

A veces, un componente padre necesita datos, y solo cuando los tiene, renderiza un componente hijo que, a su vez, necesita _otros_ datos, creando una lenta "cascada de peticiones".

#### 2. **Ejemplo (El Problema):**

```tsx
// 1. El componente Article pide los datos del artículo.
function Article({ id }) {
  const { data: articleData, isPending } = useQuery({
    queryKey: ["article", id],
    queryFn: getArticleById,
  });
  if (isPending) return "Cargando artículo...";

  // 2. SOLO DESPUÉS de tener los datos, renderiza Comments.
  return <Comments id={id} />;
}

// 3. Y ahora, Comments empieza a pedir los datos de los comentarios.
function Comments({ id }) {
  const { data, isPending } = useQuery({
    queryKey: ["article-comments", id],
    queryFn: getArticleCommentsById,
  });
  // ...
}
```

**Explicación del ejemplo (El Problema):**
Esto crea una secuencia de espera:

1.  `ESPERA` a que `getArticleById()` termine.
2.  `ESPERA` a que `getArticleCommentsById()` termine.

El tiempo total de carga es la suma de las dos esperas. ¡Muy lento!

#### 3. **Desarrollo**:

El objetivo es "aplanar" esa cascada, es decir, hacer que ambas peticiones se inicien al mismo tiempo. La estrategia es iniciar la petición de los comentarios desde el componente padre (`Article`). Hay varias formas de hacerlo, y las veremos a continuación como "soluciones" separadas.

🟡 **Importante**: Identificar y solucionar las cascadas de peticiones es fundamental para el rendimiento de aplicaciones complejas. Es un problema muy común, y saber cómo resolverlo te convertirá en un mejor desarrollador.

---

## F - Solución a la Cascada (Opción 1): Usar `useQuery` e ignorar el resultado 🔵

#### 1. **Introducción:**

Un truco sencillo para aplanar la cascada es llamar a `useQuery` para los datos del hijo directamente en el padre, pero sin usar su resultado, solo para que la petición se inicie antes.

#### 2. **Ejemplo (La Solución):**

```tsx
function Article({ id }) {
  // Petición principal
  const { data: articleData, isPending } = useQuery({
    queryKey: ["article", id],
    queryFn: getArticleById,
  });

  // ¡Aquí está el truco! Iniciamos la petición de comentarios aquí.
  // No nos importa su resultado, solo queremos que empiece a cargar.
  useQuery({
    queryKey: ["article-comments", id],
    queryFn: getArticleCommentsById,
    // Optimización opcional: evita re-renders innecesarios en este componente.
    notifyOnChangeProps: [],
  });

  if (isPending) return "Cargando artículo...";

  return <Comments id={id} />; // Comments encontrará los datos ya en caché.
}
```

**Explicación del ejemplo:**
Ahora, las dos llamadas a `useQuery` se ejecutan en paralelo en cuanto el componente `Article` se monta. Cuando `Comments` se renderiza, su `useQuery` encuentra los datos de los comentarios ya en la caché (o en proceso de carga) y los muestra mucho más rápido.

La cascada se aplana:

1.  `|> getArticleById()`
2.  `|> getArticleCommentsById()`

Ambas empiezan a la vez.

#### 3. **Desarrollo**:

Esta es una solución rápida y efectiva. La opción `notifyOnChangeProps: []` es una pequeña optimización que le dice a este `useQuery` de precarga: "Oye, no provoques un re-render del componente `Article` cuando termines de cargar o tus datos cambien". Es útil porque a `Article` no le importan los datos de los comentarios, solo quería iniciar la carga.

🔵 **Específico**: Es una técnica válida y rápida. Sin embargo, existen hooks más explícitos como `usePrefetchQuery` (ver siguiente concepto) que pueden comunicar mejor tu intención, especialmente cuando trabajas con Suspense.

---

## G - Solución a la Cascada (Opción 2): `usePrefetchQuery` para Suspense 🔵

#### 1. **Introducción:**

Cuando usas Suspense de React, necesitas una forma de precargar datos sin que esa precarga _bloquee_ la renderización, y para eso existe el hook `usePrefetchQuery`.

#### 2. **Ejemplo:**

```tsx
// Componente contenedor que prepara los datos
function ArticleLayout({ id }) {
  // Inicia la precarga de comentarios. NO bloquea el renderizado.
  usePrefetchQuery({
    queryKey: ["article-comments", id],
    queryFn: getArticleCommentsById,
  });

  // Suspense mostrará "Cargando artículo" mientras Article se carga.
  return (
    <Suspense fallback="Cargando artículo...">
      <Article id={id} />
    </Suspense>
  );
}

// Componente que usa los datos principales con Suspense
function Article({ id }) {
  // Esta llamada SÍ suspende el componente hasta que los datos del artículo estén listos.
  const { data: articleData } = useSuspenseQuery({
    queryKey: ["article", id],
    queryFn: getArticleById,
  });
  // ...
}
```

**Explicación del ejemplo:**
`usePrefetchQuery` en `ArticleLayout` le da la señal a TanStack Query para que empiece a buscar los comentarios. Inmediatamente después, React intenta renderizar `<Article />`. `useSuspenseQuery` dentro de `Article` pausa la renderización y muestra el `fallback` de Suspense. Mientras el usuario ve "Cargando artículo...", las dos peticiones (artículo y comentarios) se están ejecutando en paralelo.

#### 3. **Desarrollo**:

**¿Por qué no usar `useQuery` aquí?** Porque si lo usaras para la precarga, se ejecutaría _después_ de que la promesa de `useSuspenseQuery` se resolviera, ¡y volveríamos a la cascada!
**¿Por qué no usar `useSuspenseQuery` para la precarga?** Porque bloquearía el renderizado hasta que los comentarios estuvieran listos, y no queremos eso.

`usePrefetchQuery` es la herramienta perfecta para este escenario: inicia la carga, pero se aparta para no estorbar.

🔵 **Específico**: Este es el hook que _debes_ usar para precargar datos en un componente que está por encima de un límite de Suspense. Es la forma canónica de hacerlo bien.

---

## H - Solución a la Cascada (Opción 3): Precarga dentro de otra `queryFn` 🔵

#### 1. **Introducción:**

Si dos tipos de datos están tan íntimamente ligados que siempre que pides uno, vas a necesitar el otro, puedes iniciar la precarga del segundo desde la propia función de carga del primero.

#### 2. **Ejemplo:**

```tsx
const { data: articleData } = useQuery({
  queryKey: ["article", id],
  queryFn: async (...args) => {
    // 1. Inmediatamente, disparamos la precarga de los comentarios.
    queryClient.prefetchQuery({
      queryKey: ["article-comments", id],
      queryFn: getArticleCommentsById,
    });

    // 2. Mientras tanto, continuamos con la petición principal del artículo.
    const article = await getArticleById(...args);
    return article;
  },
});
```

**Explicación del ejemplo:**
En el momento en que `useQuery` llama a su `queryFn` para obtener el artículo, lo primero que hacemos dentro de esa función es usar `queryClient` para lanzar la precarga de los comentarios. No esperamos a que termine (`prefetchQuery` no se `await`-ea aquí), simplemente la disparamos y seguimos con lo nuestro, que es obtener y devolver los datos del artículo.

#### 3. **Desarrollo**:

Esta técnica es ideal para datos fuertemente acoplados. La ventaja es que la lógica de precarga vive junto a la petición de datos principal, lo que puede hacer el código más organizado. La desventaja es que acopla un poco más tu lógica de fetching.

🔵 **Específico**: Úsalo cuando la relación entre los datos es casi una regla de negocio ("cada vez que se muestra un artículo, se muestran sus comentarios"). Para relaciones menos directas, los otros patrones son más flexibles.

---

## I - Integración con el Router: La estrategia a nivel de ruta 🟡

#### 1. **Introducción:**

En lugar de gestionar la precarga dentro de los componentes, podemos hacerlo a un nivel superior: en la configuración del router, definiendo qué datos necesita una ruta _antes_ de que se renderice.

#### 2. **Ejemplo (con TanStack Router):**

```tsx
const articleRoute = new Route({
  // ...
  // Define qué datos se necesitarán
  beforeLoad: () => ({
    articleQueryOptions: { queryKey: ["article"], queryFn: fetchArticle },
    commentsQueryOptions: { queryKey: ["comments"], queryFn: fetchComments },
  }),
  // El "cargador" de la ruta, donde ocurre la magia
  loader: async ({ context: { queryClient }, routeContext }) => {
    const { articleQueryOptions, commentsQueryOptions } = routeContext;

    // 1. Inicia la precarga de comentarios, PERO NO ESPERES (no hay await).
    // La ruta puede empezar a renderizar mientras esto se carga.
    queryClient.prefetchQuery(commentsQueryOptions);

    // 2. Inicia la precarga del artículo Y ESPERA (sí hay await).
    // La ruta NO se renderizará hasta que estos datos críticos estén listos.
    await queryClient.prefetchQuery(articleQueryOptions);
  },
  // ...
});
```

**Explicación del ejemplo:**
Este es un patrón muy potente.

1.  En `beforeLoad`, declaramos las "recetas" para buscar los datos del artículo y los comentarios.
2.  En `loader`, ejecutamos esas recetas.
    - Llamamos a `prefetchQuery` para los comentarios sin `await`. Esto significa: "Empieza a buscar esto, pero no me hagas esperar".
    - Llamamos a `prefetchQuery` para el artículo con `await`. Esto significa: "No muestres la página hasta que tengas estos datos. Son indispensables".

El resultado es una experiencia de usuario fantástica: los datos críticos se cargan bloqueando la navegación (lo que suele ser rápido), y los datos secundarios se cargan en segundo plano mientras el usuario ya está viendo la página.

#### 3. **Desarrollo**:

Este enfoque centraliza la lógica de obtención de datos, desacoplándola de tus componentes de UI. Es una forma muy robusta y escalable de construir aplicaciones, ya que previene las cascadas de peticiones a nivel de arquitectura. Aunque el ejemplo usa TanStack Router, el concepto se puede aplicar a otros routers como React Router.

🟡 **Importante**: Para aplicaciones grandes y complejas, este es a menudo el mejor enfoque. Requiere un poco más de configuración inicial, pero te ahorra muchísimos problemas de rendimiento a largo plazo.

---

## J - `setQueryData`: "Engañando" a la caché con datos que ya tienes 🟡

#### 1. **Introducción:**

A veces, ya tienes los datos que una query necesitaría (quizás vinieron en otra respuesta de la API o los creaste localmente) y solo quieres colocarlos en la caché para que estén disponibles al instante.

#### 2. **Ejemplo:**

```tsx
// Imagina que acabas de crear una nueva "tarea" y la API te la devuelve.
// La variable `newTodo` contiene el objeto de la nueva tarea.

// En lugar de volver a pedir toda la lista, la actualizamos manualmente.
queryClient.setQueryData(["todos"], (oldData) => [...oldData, newTodo]);
```

**Explicación del ejemplo:**
Aquí no estamos haciendo una petición de red. Le estamos diciendo a TanStack Query: "Para la clave `['todos']`, toma los datos antiguos (`oldData`), y actualízalos añadiendo este `newTodo` al final". Cualquier componente que esté usando `useQuery` con la clave `['todos']` se re-renderizará automáticamente con la lista actualizada.

#### 3. **Desarrollo**:

**Diferencia CLAVE con `prefetchQuery`:**

- `prefetchQuery`: Va a buscar datos a una fuente externa (API) y los pone en la caché. **Implica una petición asíncrona.**
- `setQueryData`: Coloca datos que ya tienes _sincrónicamente_ en la caché. **No hay petición de red.**

Es una herramienta increíblemente útil para actualizaciones optimistas (fingir que una operación tuvo éxito al instante) o para "cebar" la caché con datos que obtuviste por otros medios.

🟡 **Importante**: Dominar `setQueryData` te permite crear interacciones de usuario súper fluidas, especialmente en operaciones de creación, actualización o borrado (CRUD). Es una herramienta fundamental para la gestión manual de la caché.
