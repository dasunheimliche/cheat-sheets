### A - `queryFn`: Tu Mensajero Personal para Traer Datos üî¥

#### 1. **Introducci√≥n:**

La `queryFn` es, en esencia, la funci√≥n que se encarga de hacer el trabajo sucio: ir a buscar tus datos a donde sea que est√©n (una API, una base de datos, etc.) y tra√©rtelos de vuelta.

#### 2. **Ejemplo:**

Imagina que quieres mostrar el perfil de un usuario en tu aplicaci√≥n.

```tsx
// En tu componente, pides los datos del usuario con el ID "user-123"
const { data, isLoading } = useQuery({
  // 1. Una "etiqueta" √∫nica para esta b√∫squeda. Si pides esto mismo
  // en otro lugar, TanStack Query te dar√° los datos cacheados.
  queryKey: ["userProfile", "user-123"],

  // 2. ¬°Esta es tu queryFn! La funci√≥n que sabe C√ìMO buscar el perfil.
  queryFn: () => fetchUserProfile("user-123"),
});

// --- Y en otro archivo, podr√≠as tener esta funci√≥n ---

// Esta es la funci√≥n que realmente va a la API y trae los datos.
const fetchUserProfile = async (userId) => {
  // Va a la direcci√≥n de la API para buscar al usuario
  const response = await fetch(`https://api.example.com/users/${userId}`);

  // Si la API responde con un error (ej: no encontr√≥ al usuario),
  // lanzamos un error para que TanStack Query se entere.
  if (!response.ok) {
    throw new Error("¬°Ups! No pudimos encontrar a este usuario.");
  }

  // Si todo sali√≥ bien, devolvemos los datos del usuario en formato JSON.
  return response.json();
};
```

**Explicaci√≥n del ejemplo:**
Piensa en `useQuery` como el gerente de un restaurante.

1.  T√∫ le das una orden con una `queryKey` (la "etiqueta"): "Tr√°eme el perfil del usuario 123".
2.  El gerente (`useQuery`) le pasa la orden a un repartidor (`queryFn`).
3.  El repartidor (`fetchUserProfile`) va a la cocina (`la API`), recoge el pedido y se lo devuelve al gerente.
4.  Finalmente, el gerente te entrega los datos en la variable `data`. ¬°As√≠ de simple!

#### 3. **Desarrollo:**

La regla de oro de una `queryFn` es que **debe devolver una promesa**. No te asustes por la palabra "promesa", es solo un acuerdo: "Prometo que intentar√© buscar los datos. Cuando termine, te avisar√© si los encontr√© (resolve) o si algo sali√≥ mal (reject/throw error)".

Las funciones `async/await` que usamos hoy en d√≠a hacen esto de forma autom√°tica y muy legible. Puedes escribir tu `queryFn` de varias maneras, y todas son correctas. ¬°No dejes que esto te confunda!

- **Funci√≥n de flecha en l√≠nea:** `queryFn: () => fetchAPI('datos')` (Perfecto para tareas r√°pidas).
- **Funci√≥n `async` en l√≠nea:** `queryFn: async () => { const data = await fetchAPI(); return data; }` (√ötil si necesitas hacer algo antes de devolver los datos).
- **Referencia a una funci√≥n externa:** `queryFn: miFuncionDeBusqueda` (¬°La mejor opci√≥n para mantener tu c√≥digo limpio y ordenado!).

üî¥ **Fundamental**: Esta es la pieza m√°s importante de `useQuery`. Sin una `queryFn`, TanStack Query tiene la "etiqueta" (`queryKey`) pero no tiene ni idea de _c√≥mo_ o _d√≥nde_ buscar los datos. Es el motor del coche.

---

### B - Manejo de Errores: ¬°Gritando "Problema!" Cuando Algo Sale Mal üî¥

#### 1. **Introducci√≥n:**

Para que TanStack Query sepa que una b√∫squeda fall√≥, tu `queryFn` no puede quedarse callada; tiene que "lanzar un error" (`throw new Error`) para que todos se enteren.

#### 2. **Ejemplo:**

Imagina que intentas acceder a un panel de administraci√≥n, pero no tienes los permisos necesarios.

```tsx
const { data, error, isError } = useQuery({
  queryKey: ["admin-dashboard-stats"],
  queryFn: async () => {
    // Primero, comprobamos si el usuario tiene permiso.
    const hasPermission = await checkAdminPermissions();

    // Si no tiene permiso...
    if (!hasPermission) {
      // ¬°Aqu√≠ est√° la clave! Lanzamos un error con un mensaje claro.
      // Esto detiene la ejecuci√≥n y le avisa a TanStack Query del problema.
      throw new Error("Acceso denegado. No tienes permisos de administrador.");
    }

    // Si S√ç tiene permiso, continuamos y buscamos las estad√≠sticas.
    return fetchAdminStats();
  },
});

// En tu componente, puedes reaccionar a ese error:
if (isError) {
  // La variable 'error' contendr√° el objeto Error que lanzaste.
  return <div>¬°Error! {error.message}</div>; // Muestra "Acceso denegado..."
}
```

**Explicaci√≥n del ejemplo:**
Lanzar un error (`throw new Error(...)`) es como tirar de la palanca de emergencia en un tren. Todo se detiene. TanStack Query ve esa se√±al, frena la operaci√≥n y activa las luces de emergencia: pone la variable `isError` en `true` y guarda tu mensaje en la variable `error`. As√≠, puedes mostrarle al usuario un mensaje √∫til en lugar de una pantalla en blanco o un error cr√≠ptico.

#### 3. **Desarrollo:**

Si tu funci√≥n _no_ lanza un error y simplemente devuelve `null` o `undefined`, TanStack Query pensar√° que la b√∫squeda fue un **√©xito** y que los datos son, literalmente, `null`. Esto puede causar errores muy confusos en tu aplicaci√≥n.

**La regla es simple:**

- **Si todo va bien:** `return tusDatos;`
- **Si algo sale mal:** `throw new Error('Un mensaje que explique qu√© pas√≥');`

Tambi√©n puedes usar `return Promise.reject(new Error(...))`, que es otra forma de crear una promesa fallida, pero con `async/await`, usar `throw` es m√°s directo y com√∫n.

üî¥ **Fundamental**: Un mal manejo de errores es la causa #1 de dolores de cabeza en el desarrollo. Aprender a "gritar" cuando algo va mal es crucial para crear aplicaciones robustas y f√°ciles de depurar. Si no lo haces, tu app fallar√° en silencio y ni t√∫ ni tus usuarios sabr√°n por qu√©.

---

### C - El Caso `fetch` vs. `axios`: Cuando "OK" no Siempre Significa lo Mismo üü°

#### 1. **Introducci√≥n:**

No todas las herramientas para pedir datos se comportan igual ante un error del servidor (como un "404 No Encontrado"); `fetch` requiere que t√∫ lances el error manualmente, mientras que librer√≠as como `axios` lo hacen por ti.

#### 2. **Ejemplo:**

Imagina que tenemos dos mensajeros para ir a buscar un paquete a una direcci√≥n (`https://api.example.com/products/prod-999`). El paquete no existe.

**Mensajero 1: `fetch` (El Literal)**
Este mensajero solo considera un fallo si no puede llegar al edificio (error de red). Si llega y le dan una nota que dice "Paquete no encontrado", √©l simplemente te trae la nota. ¬°T√∫ tienes que leerla y dar la voz de alarma!

```tsx
// Con fetch, T√ö eres el responsable de "gritar" el error.
const { isError, error } = useQuery({
  queryKey: ["product-fetch", "prod-999"],
  queryFn: async () => {
    const response = await fetch("https://api.example.com/products/prod-999");

    // ¬°EL PASO CRUCIAL! Leemos la "nota" que nos trajo el mensajero.
    // Si no est√° "ok" (ej: es un error 404 o 500)...
    if (!response.ok) {
      // ...¬°LANZAMOS EL ERROR NOSOTROS MISMOS!
      throw new Error("Fetch dice: El producto no existe.");
    }
    return response.json();
  },
});
// Aqu√≠, isError ser√° 'true' gracias a nuestro 'throw'.
```

**Mensajero 2: `axios` (El Proactivo)**
Este mensajero es m√°s listo. Si llega y le dicen "Paquete no encontrado", √©l entiende que eso es un problema y vuelve gritando "¬°ERROR, NO LO ENCONTR√â!". No tienes que hacer nada extra.

```tsx
// Con axios, √©l "grita" el error por ti.
const { isError, error } = useQuery({
  queryKey: ["product-axios", "prod-999"],
  queryFn: async () => {
    // axios lanzar√° una excepci√≥n autom√°ticamente si el status es 4xx o 5xx.
    // TanStack Query atrapar√° ese error sin que hagamos nada m√°s.
    const response = await axios.get(
      "https://api.example.com/products/prod-999"
    );
    return response.data;
  },
});
// Aqu√≠, isError ser√° 'true' autom√°ticamente. No necesitamos un 'if'.
```

**Explicaci√≥n del ejemplo:**
La diferencia es clave: con `fetch`, el `if (!response.ok)` es tu red de seguridad obligatoria. Sin √©l, TanStack Query pensar√≠a que la petici√≥n fue un √©xito y `data` ser√≠a un objeto `Response` in√∫til, causando errores silenciosos y confusos. Con `axios`, esa red de seguridad ya viene incorporada.

#### 3. **Desarrollo:**

Esta diferencia de comportamiento es una de las "trampas" m√°s comunes para los principiantes.

- **Con `axios` (y `graphql-request`, etc.):** El `throw new Error` es **impl√≠cito** en caso de un error HTTP. La librer√≠a lo hace por ti. Tu c√≥digo es m√°s limpio.
- **Con `fetch`:** El `throw new Error` es **expl√≠cito** y tu responsabilidad. Debes comprobar el estado de la respuesta y lanzar el error si es necesario.

Saber esto te ahorra horas de depuraci√≥n pregunt√°ndote: "¬øPor qu√© mi `isError` no se activa si la API me est√° devolviendo un 404?". La respuesta casi siempre es: "Porque est√°s usando `fetch` y olvidaste el `if (!response.ok)`".

üü° **Importante**: Este es un conocimiento fundamental sobre las herramientas que usas para obtener datos. No es un concepto de TanStack Query en s√≠, pero es vital para usar la librer√≠a correctamente. Elegir una u otra herramienta tiene implicaciones directas en c√≥mo escribes tus `queryFn`.

### D - `queryKey`: Pasando Par√°metros a tu `queryFn` como un Profesional üü°

#### 1. **Introducci√≥n:**

Adem√°s de ser una etiqueta, la `queryKey` tambi√©n puede pasarle informaci√≥n √∫til a tu `queryFn`, permiti√©ndote crear funciones de b√∫squeda reutilizables y muy limpias.

#### 2. **Ejemplo:**

Imagina una lista de tareas que se puede filtrar por estado (`'pendiente'`, `'completada'`) y paginar.

```tsx
// En tu componente, defines los filtros actuales.
const [status, setStatus] = useState("pendiente");
const [page, setPage] = useState(1);

// La queryKey ahora incluye los filtros como un objeto.
const { data } = useQuery({
  queryKey: ["tasks", { status, page }], // ['tasks', { status: 'pendiente', page: 1 }]
  queryFn: fetchTasks, // ¬°Usamos una funci√≥n externa y limpia!
});

// --- Y en otro archivo, tu funci√≥n de b√∫squeda reutilizable ---

// La funci√≥n recibe un objeto "contexto" que incluye la queryKey.
async function fetchTasks({ queryKey }) {
  // ¬°Aqu√≠ est√° la magia! Descomponemos el array de la queryKey.
  // Usamos _key (con guion bajo) por convenci√≥n para decir "no usar√© esta parte".
  const [_key, filters] = queryKey; // _key = 'tasks', filters = { status, page }

  // Ahora usamos los filtros para construir la URL de la API.
  const url = `https://api.example.com/tasks?status=${filters.status}&page=${filters.page}`;
  console.log("Buscando en:", url); // "Buscando en: ...?status=pendiente&page=1"

  const response = await fetch(url);
  if (!response.ok) throw new Error("No se pudieron cargar las tareas");
  return response.json();
}
```

**Explicaci√≥n del ejemplo:**
¬°Esto es genial! En lugar de escribir una funci√≥n `queryFn` diferente para cada combinaci√≥n de filtros, creas una sola funci√≥n inteligente (`fetchTasks`). TanStack Query le pasa autom√°ticamente la `queryKey` a esa funci√≥n.

Dentro de `fetchTasks`, simplemente "desempacas" la `queryKey` para obtener los filtros que necesitas. Esto hace que tu funci√≥n `fetchTasks` sea:

1.  **Reutilizable:** La puedes usar en cualquier lugar que necesite buscar tareas.
2.  **Independiente:** No necesita saber nada sobre `useState` o el componente que la llam√≥.
3.  **F√°cil de probar:** Puedes probarla por separado pas√°ndole una `queryKey` falsa.

#### 3. **Desarrollo:**

Este patr√≥n es un salto cualitativo en la forma de organizar tu c√≥digo. Al principio, es tentador escribir todo dentro de `useQuery` con funciones de flecha: `queryFn: () => fetchTasks(status, page)`. Funciona, pero acopla tu l√≥gica de obtenci√≥n de datos directamente al estado de tu componente.

Al extraer la `queryFn` y dejar que reciba la `queryKey`, promueves un c√≥digo mucho m√°s modular y escalable, que es una de las mejores pr√°cticas en el desarrollo de software.

üü° **Importante**: Aunque no es estrictamente necesario para empezar, adoptar este patr√≥n te convertir√° en un desarrollador m√°s ordenado y eficiente. Es un paso clave para pasar de "hacer que funcione" a "hacerlo bien".

---

### E - `QueryFunctionContext`: La Caja de Herramientas de tu `queryFn` üîµ

#### 1. **Introducci√≥n:**

El `QueryFunctionContext` es simplemente el nombre oficial del objeto que TanStack Query le pasa a tu `queryFn`, el cual contiene no solo la `queryKey`, sino tambi√©n otras herramientas √∫tiles para casos m√°s avanzados.

#### 2. **Ejemplo:**

Imagina que quieres poder cancelar una b√∫squeda si el usuario navega a otra p√°gina, y tambi√©n quieres pasar informaci√≥n extra (metadatos) para registrar en la consola.

```tsx
// En tu componente, a√±ades una propiedad 'meta'.
useQuery({
  queryKey: ["user-activity", userId],
  queryFn: fetchUserActivity,
  // 'meta' es para pasar informaci√≥n extra que no afecta el cacheo.
  meta: {
    logMessage: `Iniciando b√∫squeda de actividad para el usuario ${userId}`,
  },
});

// --- Tu funci√≥n de b√∫squeda ahora usa m√°s herramientas del contexto ---

// Desestructuramos el contexto para sacar las herramientas que necesitamos.
async function fetchUserActivity({ queryKey, signal, meta }) {
  // 1. Usamos la queryKey como siempre.
  const [_key, userId] = queryKey;

  // 2. Usamos los metadatos.
  console.log(meta.logMessage);

  // 3. Usamos la 'signal' para la cancelaci√≥n.
  // Le pasamos esta "se√±al" a fetch. Si TanStack Query decide cancelar,
  // esta se√±al se activar√° y fetch detendr√° la petici√≥n de red.
  const response = await fetch(`https://api.example.com/activity/${userId}`, {
    signal, // ¬°Aqu√≠ se conecta la cancelaci√≥n!
  });

  if (!response.ok) throw new Error("Fall√≥ la b√∫squeda de actividad");
  return response.json();
}
```

**Explicaci√≥n del ejemplo:**
Piensa en el `QueryFunctionContext` como una caja de herramientas que el gerente (`useQuery`) le entrega al repartidor (`queryFn`).

- `queryKey`: Es la orden de pedido (lo que hay que buscar). ¬°La herramienta principal!
- `signal`: Es un walkie-talkie. Si el gerente necesita cancelar el pedido, te grita por el walkie-talkie y t√∫ te detienes. Esencial para la cancelaci√≥n de consultas.
- `meta`: Es una nota adhesiva que puedes pegar en la orden con instrucciones especiales ("Por favor, registrar esta b√∫squeda"). No cambia el pedido, pero da informaci√≥n adicional.

#### 3. **Desarrollo:**

El `QueryFunctionContext` contiene varias propiedades, pero en tu d√≠a a d√≠a, usar√°s `queryKey` el 95% del tiempo. Las otras son para situaciones m√°s espec√≠ficas:

- `queryKey`: La que ya amamos.
- `signal`: Para la [cancelaci√≥n de consultas](https://tanstack.com/query/latest/docs/framework/react/guides/query-cancellation). Muy √∫til para evitar peticiones de red innecesarias.
- `meta`: Para a√±adir informaci√≥n personalizada a tu consulta que no quieres que forme parte de la `queryKey` (porque si no, crear√≠a una nueva entrada en la cach√©).
- `pageParam` y `direction`: Espec√≠ficas para [Infinite Queries](https://tanstack.com/query/latest/docs/framework/react/guides/infinite-queries), para saber qu√© p√°gina de datos buscar.

No necesitas memorizar todo esto. Solo recuerda que si alguna vez necesitas hacer algo m√°s avanzado, como cancelar una petici√≥n, la herramienta probablemente ya exista dentro de este "contexto".

üîµ **Espec√≠fico**: Conocer el `QueryFunctionContext` a fondo es para situaciones particulares. Para la mayor√≠a de los casos, te bastar√° con saber que existe y que de ah√≠ puedes sacar la `queryKey`. Es bueno saber que tienes estas herramientas guardadas por si un d√≠a las necesitas.
