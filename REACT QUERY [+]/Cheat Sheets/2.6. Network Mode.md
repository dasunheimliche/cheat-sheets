## A - Network Mode: ¿Cómo debe actuar tu app sin internet? 🟡

#### 1. **Introducción:**

Esta opción es como darle instrucciones a un repartidor sobre qué hacer si llega a tu casa y no hay nadie: ¿debe esperar, debe dejar el paquete en la puerta o debe volver más tarde? El `networkMode` le dice a TanStack Query cómo comportarse con las peticiones de datos (queries) cuando el usuario no tiene conexión a internet.

#### 2. **Ejemplo:**

Puedes configurarlo para una query específica o para toda tu aplicación.

```javascript
import {
  useQuery,
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";

// Opción 1: Configurar para UNA SOLA query
function UserProfile() {
  const { data } = useQuery({
    queryKey: ["user"],
    queryFn: fetchUser,
    // ¡Aquí está la magia! Le decimos que sea insistente.
    networkMode: "always",
  });
  // ...
}

// Opción 2: Configurar para TODAS las queries de tu app (lo más común)
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // Todas las queries usarán 'online' por defecto, a menos que se indique lo contrario.
      networkMode: "online",
    },
  },
});

function App() {
  return (
    <QueryClientProvider client={queryClient}>{/* ... */}</QueryClientProvider>
  );
}
```

**Explicación del ejemplo:**
En el primer caso, solo la query `['user']` se comportará de una manera especial (`always`). En el segundo, establecemos un comportamiento por defecto (`online`) para cada `useQuery` que creemos en la aplicación, así no tenemos que repetirlo una y otra vez.

#### 3. **Desarrollo:**

Imagina que tu aplicación es un restaurante. Las "queries" son los pedidos que los clientes hacen a la cocina (el servidor). El `networkMode` es la política del restaurante sobre qué hacer si se corta la luz (se pierde la conexión a internet).

- **`online`**: "Solo cocinamos si hay luz". Es el modo por defecto y el más seguro para la mayoría de apps que dependen de una API externa.
- **`always`**: "Cocinamos sí o sí, aunque sea con velas". Útil si la "cocina" está dentro del mismo restaurante (ej: pides datos que ya están guardados en el navegador).
- **`offlineFirst`**: "Primero revisamos si tenemos platos ya listos y fríos. Si no, intentamos cocinar. Si no hay luz, esperamos". Ideal para apps que guardan datos para usarlos sin conexión (PWAs).

Elegir el modo correcto es fundamental para que tu app no se quede "colgada" o muestre errores extraños cuando la conexión del usuario falla.

🟡 **Importante**: Aunque `online` es el modo por defecto y funciona bien el 90% de las veces, entender los otros dos te da superpoderes para crear aplicaciones que funcionan de maravilla incluso en condiciones de red inestables, como en un metro o en una zona con mala cobertura.

---

## B - Network Mode: `online` 🔴

#### 1. **Introducción:**

Este es el modo por defecto, el "portero estricto": si no tienes una invitación (conexión a internet), no entras (la petición de datos no se ejecuta).

#### 2. **Ejemplo:**

No necesitas escribir nada, ¡ya viene activado por defecto!

```javascript
// Este código, por defecto, usa networkMode: 'online'
function ComponenteNormal() {
  const { data, status, fetchStatus } = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodosDesdeAPI,
  });

  // Imagina que el usuario abre la app en el metro y pierde la señal...
  // status será 'pending' (porque nunca hemos tenido datos)
  // fetchStatus será 'paused' (porque la petición está en pausa esperando conexión)

  if (status === "pending" && fetchStatus === "paused") {
    return <div>Buscando señal para cargar tus tareas... ¡Ten paciencia!</div>;
  }

  // ... resto del componente
}
```

**Explicación del ejemplo:**
Si un usuario entra a tu app por primera vez sin internet, la query `['todos']` no se disparará. Se quedará en un estado de "pausa". Tan pronto como el usuario recupere la conexión, TanStack Query reanudará la petición automáticamente. ¡No se cancela, solo espera pacientemente!

#### 3. **Desarrollo:**

Este modo es tu mejor amigo para cualquier aplicación que consuma una API externa. Su comportamiento es increíblemente inteligente:

1.  **¿Hay internet?** Se ejecuta la petición (`fetchStatus: 'fetching'`).
2.  **¿No hay internet?** La petición se pausa (`fetchStatus: 'paused'`). No falla, no da error, solo espera.
3.  **¿Se fue el internet a mitad de la petición?** ¡No hay problema! Los reintentos automáticos también se pausan.
4.  **¿Volvió el internet?** La petición o los reintentos continúan justo donde se quedaron.

🔴 **Fundamental**: Es el comportamiento por defecto porque es el más lógico y seguro para aplicaciones web estándar. Previene que tu app se llene de errores de red simplemente porque el usuario pasó por un túnel. ¡Es crucial que entiendas que **pausa** no es lo mismo que **fallo**!

---

## C - `fetchStatus`: El detective que te dice la verdad 🟡

#### 1. **Introducción:**

El `fetchStatus` te cuenta el chisme completo de lo que una query está haciendo _en este preciso instante_, a diferencia de `status` que te da una visión más general.

#### 2. **Ejemplo:**

¡Aquí es donde muchos principiantes caen! Mira la diferencia.

```javascript
function MiComponente() {
  const { status, fetchStatus, isPending, isFetching, isPaused } = useQuery({
    queryKey: ["posts"],
    queryFn: fetchPosts,
  });

  // CASO TRAMPA: El usuario no tiene internet al cargar la página.
  // isPending será `true` (porque no tenemos datos aún, está pendiente de tenerlos)
  // isFetching será `false` (porque NO se está ejecutando la petición)
  // isPaused será `true` (porque está en pausa por falta de red)
  // fetchStatus será `'paused'`

  // ¡NO HAGAS ESTO! Podrías mostrar un spinner infinito.
  if (isPending) {
    // return <Spinner /> // ¡MAL! Esto se mostraría aunque la app esté pausada.
  }

  // ¡HAZ ESTO! Es mucho más preciso.
  if (isFetching) {
    return <Spinner />; // Correcto, solo se muestra cuando de verdad está cargando.
  }
  if (isPaused) {
    return <div>Conexión perdida. Esperando a que vuelvas...</div>;
  }

  return <div>...Tus datos...</div>;
}
```

**Explicación del ejemplo:**
La confusión más grande es entre `status: 'pending'` y `fetchStatus: 'fetching'`.

- `status: 'pending'`: Significa "aún no tengo datos exitosos". Puede ser porque es la primera vez que carga O porque está recargando en segundo plano.
- `fetchStatus: 'fetching'`: Significa "AHORA MISMO estoy hablando con el servidor".

Si solo usas `isPending` para mostrar un spinner y el usuario no tiene internet, la query estará `pending` pero `paused`. ¡Tu spinner se quedará ahí para siempre! Usar `isFetching` es la forma correcta de saber si mostrar un indicador de carga.

#### 3. **Desarrollo:**

El `fetchStatus` tiene tres posibles valores que te lo dicen todo:

- `fetching`: La función `queryFn` se está ejecutando. Hay una petición en curso.
- `paused`: La petición se intentó hacer, pero se detuvo por falta de conexión (usando `networkMode: 'online'`).
- `idle`: La query no está haciendo absolutamente nada. Está tranquilita en su rincón.

Los booleanos `isFetching` y `isPaused` son atajos convenientes derivados de este estado.

🟡 **Importante**: Entender `fetchStatus` te separa de los novatos. Te permite crear interfaces de usuario que informan al usuario de manera precisa sobre lo que está pasando con la red, evitando frustraciones y spinners infinitos.

---

## D - Network Mode: `always` 🔵

#### 1. **Introducción:**

Este es el modo "optimista incansable": siempre intentará ejecutar la petición, ignorando por completo si el dispositivo está conectado a internet o no.

#### 2. **Ejemplo:**

Perfecto para cuando tu "fuente de datos" no es una API, sino algo local.

```javascript
import { useQuery } from "@tanstack/react-query";

// Imagina que guardaste el nombre de usuario en el almacenamiento local del navegador.
function getUsernameFromLocalStorage() {
  // Esta función NO necesita internet.
  const username = localStorage.getItem("username");
  if (!username) {
    // Si no hay nada, podemos simular un error.
    throw new Error(
      "Nombre de usuario no encontrado en el almacenamiento local."
    );
  }
  return username;
}

function WelcomeMessage() {
  const { data, error } = useQuery({
    queryKey: ["localUsername"],
    queryFn: getUsernameFromLocalStorage,
    // Le decimos: "inténtalo SIEMPRE, no me importa el estado de la red".
    networkMode: "always",
    // Los reintentos no se pausan, así que si falla, falla rápido.
    retry: 1,
  });

  if (error) return <div>Por favor, inicia sesión.</div>;

  return <h1>Bienvenido, {data}!</h1>;
}
```

**Explicación del ejemplo:**
La función `getUsernameFromLocalStorage` no hace una llamada `fetch` a un servidor, simplemente lee un dato del `localStorage` del navegador. Esta operación no depende de internet. Usar `networkMode: 'always'` aquí es perfecto, porque queremos que se ejecute sin importar el estado de la red. Si usáramos el modo `online` (por defecto) y el usuario no tuviera conexión, ¡la query se pausaría innecesariamente!

#### 3. **Desarrollo:**

Este modo cambia dos cosas importantes:

1.  **Las queries nunca se pausan.** Si la función falla (por ejemplo, porque el dato no existe en `localStorage`), irá directamente al estado de `error`. No se quedará esperando.
2.  **Los reintentos tampoco se pausan.** Si configuras reintentos, se ejecutarán uno tras otro, sin importar la conexión.
3.  **`refetchOnReconnect` se desactiva.** Como la conexión a internet es irrelevante para esta query, no tiene sentido que se vuelva a ejecutar cuando el usuario recupera la señal.

🔵 **Específico**: Usa este modo solo cuando estés seguro de que tu `queryFn` no necesita una conexión a internet activa. Es una herramienta de nicho pero increíblemente útil para gestionar estado local o datos del dispositivo con la potencia de TanStack Query.

---

## E - Network Mode: `offlineFirst` 🔵

#### 1. **Introducción:**

Este es el modo "estratega": primero intenta ejecutar la petición una vez (confiando en que un caché local, como un Service Worker, la intercepte) y, si ese primer intento falla, se rinde y se comporta como el modo `online` (pausa todo hasta que vuelva la conexión).

#### 2. **Ejemplo:**

El código es simple, pero la magia ocurre en la arquitectura de tu app (generalmente con un Service Worker, que no mostramos aquí para no complicar).

```javascript
// En tu componente React
function ArticleViewer({ id }) {
  const { data, isPaused } = useQuery({
    queryKey: ["article", id],
    queryFn: () => fetchArticle(id),
    // Le decimos: "Inténtalo una vez. Si fallas, espera a tener internet".
    networkMode: "offlineFirst",
  });

  if (isPaused) {
    return (
      <div>
        No pudimos cargar este artículo desde el caché. Se mostrará cuando
        recuperes la conexión.
      </div>
    );
  }

  return <article>{data}</article>;
}

// --- EN OTRO LUGAR (tu Service Worker) ---
// El Service Worker interceptaría la llamada a `fetchArticle(id)`.
// 1. Intenta buscar el artículo en su propio caché.
// 2. Si lo encuentra, lo devuelve. ¡Éxito! La query se completa sin usar la red.
// 3. Si NO lo encuentra, intenta ir a la red de verdad.
// 4. Si no hay internet, la petición de red falla.
// 5. TanStack Query ve el fallo y, como está en modo `offlineFirst`, PAUSA los reintentos.
```

**Explicación del ejemplo:**
Este modo es el corazón de las aplicaciones web progresivas (PWA) que funcionan sin conexión. El primer intento de `fetchArticle` podría ser resuelto por un Service Worker que ya tiene el artículo guardado. Si es así, ¡genial!, el usuario ve el contenido al instante, incluso sin internet. Si el artículo no está en el caché del Service Worker, este intentará buscarlo en la red. Si no hay conexión, la petición fallará, y `offlineFirst` se asegurará de que la query se pause elegantemente en lugar de mostrar un error.

#### 3. **Desarrollo:**

Es el punto medio perfecto entre `online` y `always`. Te da lo mejor de ambos mundos para un caso de uso muy concreto: aplicaciones diseñadas para funcionar sin conexión. Permite que tu app sirva contenido desde un caché local de forma instantánea, pero gestiona los fallos de red (cuando el contenido no está en caché) de la misma forma segura y predecible que el modo `online`.

🔵 **Específico**: Este es un modo avanzado. No lo necesitarás para una web sencilla, pero es absolutamente esencial si estás construyendo una PWA o cualquier aplicación que deba ofrecer una experiencia de usuario fluida sin conexión a internet.
