## A - Network Mode: 쮺칩mo debe actuar tu app sin internet? 游리

#### 1. **Introducci칩n:**

Esta opci칩n es como darle instrucciones a un repartidor sobre qu칠 hacer si llega a tu casa y no hay nadie: 쯗ebe esperar, debe dejar el paquete en la puerta o debe volver m치s tarde? El `networkMode` le dice a TanStack Query c칩mo comportarse con las peticiones de datos (queries) cuando el usuario no tiene conexi칩n a internet.

#### 2. **Ejemplo:**

Puedes configurarlo para una query espec칤fica o para toda tu aplicaci칩n.

```javascript
import {
  useQuery,
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";

// Opci칩n 1: Configurar para UNA SOLA query
function UserProfile() {
  const { data } = useQuery({
    queryKey: ["user"],
    queryFn: fetchUser,
    // 춰Aqu칤 est치 la magia! Le decimos que sea insistente.
    networkMode: "always",
  });
  // ...
}

// Opci칩n 2: Configurar para TODAS las queries de tu app (lo m치s com칰n)
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // Todas las queries usar치n 'online' por defecto, a menos que se indique lo contrario.
      networkMode: "online",
    },
  },
});

function App() {
  return (
    <QueryClientProvider client={queryClient}>{/* ... */}</QueryClientProvider>
  );
}
```

**Explicaci칩n del ejemplo:**
En el primer caso, solo la query `['user']` se comportar치 de una manera especial (`always`). En el segundo, establecemos un comportamiento por defecto (`online`) para cada `useQuery` que creemos en la aplicaci칩n, as칤 no tenemos que repetirlo una y otra vez.

#### 3. **Desarrollo:**

Imagina que tu aplicaci칩n es un restaurante. Las "queries" son los pedidos que los clientes hacen a la cocina (el servidor). El `networkMode` es la pol칤tica del restaurante sobre qu칠 hacer si se corta la luz (se pierde la conexi칩n a internet).

- **`online`**: "Solo cocinamos si hay luz". Es el modo por defecto y el m치s seguro para la mayor칤a de apps que dependen de una API externa.
- **`always`**: "Cocinamos s칤 o s칤, aunque sea con velas". 칔til si la "cocina" est치 dentro del mismo restaurante (ej: pides datos que ya est치n guardados en el navegador).
- **`offlineFirst`**: "Primero revisamos si tenemos platos ya listos y fr칤os. Si no, intentamos cocinar. Si no hay luz, esperamos". Ideal para apps que guardan datos para usarlos sin conexi칩n (PWAs).

Elegir el modo correcto es fundamental para que tu app no se quede "colgada" o muestre errores extra침os cuando la conexi칩n del usuario falla.

游리 **Importante**: Aunque `online` es el modo por defecto y funciona bien el 90% de las veces, entender los otros dos te da superpoderes para crear aplicaciones que funcionan de maravilla incluso en condiciones de red inestables, como en un metro o en una zona con mala cobertura.

---

## B - Network Mode: `online` 游댮

#### 1. **Introducci칩n:**

Este es el modo por defecto, el "portero estricto": si no tienes una invitaci칩n (conexi칩n a internet), no entras (la petici칩n de datos no se ejecuta).

#### 2. **Ejemplo:**

No necesitas escribir nada, 춰ya viene activado por defecto!

```javascript
// Este c칩digo, por defecto, usa networkMode: 'online'
function ComponenteNormal() {
  const { data, status, fetchStatus } = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodosDesdeAPI,
  });

  // Imagina que el usuario abre la app en el metro y pierde la se침al...
  // status ser치 'pending' (porque nunca hemos tenido datos)
  // fetchStatus ser치 'paused' (porque la petici칩n est치 en pausa esperando conexi칩n)

  if (status === "pending" && fetchStatus === "paused") {
    return <div>Buscando se침al para cargar tus tareas... 춰Ten paciencia!</div>;
  }

  // ... resto del componente
}
```

**Explicaci칩n del ejemplo:**
Si un usuario entra a tu app por primera vez sin internet, la query `['todos']` no se disparar치. Se quedar치 en un estado de "pausa". Tan pronto como el usuario recupere la conexi칩n, TanStack Query reanudar치 la petici칩n autom치ticamente. 춰No se cancela, solo espera pacientemente!

#### 3. **Desarrollo:**

Este modo es tu mejor amigo para cualquier aplicaci칩n que consuma una API externa. Su comportamiento es incre칤blemente inteligente:

1.  **쮿ay internet?** Se ejecuta la petici칩n (`fetchStatus: 'fetching'`).
2.  **쯅o hay internet?** La petici칩n se pausa (`fetchStatus: 'paused'`). No falla, no da error, solo espera.
3.  **쯉e fue el internet a mitad de la petici칩n?** 춰No hay problema! Los reintentos autom치ticos tambi칠n se pausan.
4.  **쯌olvi칩 el internet?** La petici칩n o los reintentos contin칰an justo donde se quedaron.

游댮 **Fundamental**: Es el comportamiento por defecto porque es el m치s l칩gico y seguro para aplicaciones web est치ndar. Previene que tu app se llene de errores de red simplemente porque el usuario pas칩 por un t칰nel. 춰Es crucial que entiendas que **pausa** no es lo mismo que **fallo**!

---

## C - `fetchStatus`: El detective que te dice la verdad 游리

#### 1. **Introducci칩n:**

El `fetchStatus` te cuenta el chisme completo de lo que una query est치 haciendo _en este preciso instante_, a diferencia de `status` que te da una visi칩n m치s general.

#### 2. **Ejemplo:**

춰Aqu칤 es donde muchos principiantes caen! Mira la diferencia.

```javascript
function MiComponente() {
  const { status, fetchStatus, isPending, isFetching, isPaused } = useQuery({
    queryKey: ["posts"],
    queryFn: fetchPosts,
  });

  // CASO TRAMPA: El usuario no tiene internet al cargar la p치gina.
  // isPending ser치 `true` (porque no tenemos datos a칰n, est치 pendiente de tenerlos)
  // isFetching ser치 `false` (porque NO se est치 ejecutando la petici칩n)
  // isPaused ser치 `true` (porque est치 en pausa por falta de red)
  // fetchStatus ser치 `'paused'`

  // 춰NO HAGAS ESTO! Podr칤as mostrar un spinner infinito.
  if (isPending) {
    // return <Spinner /> // 춰MAL! Esto se mostrar칤a aunque la app est칠 pausada.
  }

  // 춰HAZ ESTO! Es mucho m치s preciso.
  if (isFetching) {
    return <Spinner />; // Correcto, solo se muestra cuando de verdad est치 cargando.
  }
  if (isPaused) {
    return <div>Conexi칩n perdida. Esperando a que vuelvas...</div>;
  }

  return <div>...Tus datos...</div>;
}
```

**Explicaci칩n del ejemplo:**
La confusi칩n m치s grande es entre `status: 'pending'` y `fetchStatus: 'fetching'`.

- `status: 'pending'`: Significa "a칰n no tengo datos exitosos". Puede ser porque es la primera vez que carga O porque est치 recargando en segundo plano.
- `fetchStatus: 'fetching'`: Significa "AHORA MISMO estoy hablando con el servidor".

Si solo usas `isPending` para mostrar un spinner y el usuario no tiene internet, la query estar치 `pending` pero `paused`. 춰Tu spinner se quedar치 ah칤 para siempre! Usar `isFetching` es la forma correcta de saber si mostrar un indicador de carga.

#### 3. **Desarrollo:**

El `fetchStatus` tiene tres posibles valores que te lo dicen todo:

- `fetching`: La funci칩n `queryFn` se est치 ejecutando. Hay una petici칩n en curso.
- `paused`: La petici칩n se intent칩 hacer, pero se detuvo por falta de conexi칩n (usando `networkMode: 'online'`).
- `idle`: La query no est치 haciendo absolutamente nada. Est치 tranquilita en su rinc칩n.

Los booleanos `isFetching` y `isPaused` son atajos convenientes derivados de este estado.

游리 **Importante**: Entender `fetchStatus` te separa de los novatos. Te permite crear interfaces de usuario que informan al usuario de manera precisa sobre lo que est치 pasando con la red, evitando frustraciones y spinners infinitos.

---

## D - Network Mode: `always` 游댯

#### 1. **Introducci칩n:**

Este es el modo "optimista incansable": siempre intentar치 ejecutar la petici칩n, ignorando por completo si el dispositivo est치 conectado a internet o no.

#### 2. **Ejemplo:**

Perfecto para cuando tu "fuente de datos" no es una API, sino algo local.

```javascript
import { useQuery } from "@tanstack/react-query";

// Imagina que guardaste el nombre de usuario en el almacenamiento local del navegador.
function getUsernameFromLocalStorage() {
  // Esta funci칩n NO necesita internet.
  const username = localStorage.getItem("username");
  if (!username) {
    // Si no hay nada, podemos simular un error.
    throw new Error(
      "Nombre de usuario no encontrado en el almacenamiento local."
    );
  }
  return username;
}

function WelcomeMessage() {
  const { data, error } = useQuery({
    queryKey: ["localUsername"],
    queryFn: getUsernameFromLocalStorage,
    // Le decimos: "int칠ntalo SIEMPRE, no me importa el estado de la red".
    networkMode: "always",
    // Los reintentos no se pausan, as칤 que si falla, falla r치pido.
    retry: 1,
  });

  if (error) return <div>Por favor, inicia sesi칩n.</div>;

  return <h1>Bienvenido, {data}!</h1>;
}
```

**Explicaci칩n del ejemplo:**
La funci칩n `getUsernameFromLocalStorage` no hace una llamada `fetch` a un servidor, simplemente lee un dato del `localStorage` del navegador. Esta operaci칩n no depende de internet. Usar `networkMode: 'always'` aqu칤 es perfecto, porque queremos que se ejecute sin importar el estado de la red. Si us치ramos el modo `online` (por defecto) y el usuario no tuviera conexi칩n, 춰la query se pausar칤a innecesariamente!

#### 3. **Desarrollo:**

Este modo cambia dos cosas importantes:

1.  **Las queries nunca se pausan.** Si la funci칩n falla (por ejemplo, porque el dato no existe en `localStorage`), ir치 directamente al estado de `error`. No se quedar치 esperando.
2.  **Los reintentos tampoco se pausan.** Si configuras reintentos, se ejecutar치n uno tras otro, sin importar la conexi칩n.
3.  **`refetchOnReconnect` se desactiva.** Como la conexi칩n a internet es irrelevante para esta query, no tiene sentido que se vuelva a ejecutar cuando el usuario recupera la se침al.

游댯 **Espec칤fico**: Usa este modo solo cuando est칠s seguro de que tu `queryFn` no necesita una conexi칩n a internet activa. Es una herramienta de nicho pero incre칤blemente 칰til para gestionar estado local o datos del dispositivo con la potencia de TanStack Query.

---

## E - Network Mode: `offlineFirst` 游댯

#### 1. **Introducci칩n:**

Este es el modo "estratega": primero intenta ejecutar la petici칩n una vez (confiando en que un cach칠 local, como un Service Worker, la intercepte) y, si ese primer intento falla, se rinde y se comporta como el modo `online` (pausa todo hasta que vuelva la conexi칩n).

#### 2. **Ejemplo:**

El c칩digo es simple, pero la magia ocurre en la arquitectura de tu app (generalmente con un Service Worker, que no mostramos aqu칤 para no complicar).

```javascript
// En tu componente React
function ArticleViewer({ id }) {
  const { data, isPaused } = useQuery({
    queryKey: ["article", id],
    queryFn: () => fetchArticle(id),
    // Le decimos: "Int칠ntalo una vez. Si fallas, espera a tener internet".
    networkMode: "offlineFirst",
  });

  if (isPaused) {
    return (
      <div>
        No pudimos cargar este art칤culo desde el cach칠. Se mostrar치 cuando
        recuperes la conexi칩n.
      </div>
    );
  }

  return <article>{data}</article>;
}

// --- EN OTRO LUGAR (tu Service Worker) ---
// El Service Worker interceptar칤a la llamada a `fetchArticle(id)`.
// 1. Intenta buscar el art칤culo en su propio cach칠.
// 2. Si lo encuentra, lo devuelve. 춰칄xito! La query se completa sin usar la red.
// 3. Si NO lo encuentra, intenta ir a la red de verdad.
// 4. Si no hay internet, la petici칩n de red falla.
// 5. TanStack Query ve el fallo y, como est치 en modo `offlineFirst`, PAUSA los reintentos.
```

**Explicaci칩n del ejemplo:**
Este modo es el coraz칩n de las aplicaciones web progresivas (PWA) que funcionan sin conexi칩n. El primer intento de `fetchArticle` podr칤a ser resuelto por un Service Worker que ya tiene el art칤culo guardado. Si es as칤, 춰genial!, el usuario ve el contenido al instante, incluso sin internet. Si el art칤culo no est치 en el cach칠 del Service Worker, este intentar치 buscarlo en la red. Si no hay conexi칩n, la petici칩n fallar치, y `offlineFirst` se asegurar치 de que la query se pause elegantemente en lugar de mostrar un error.

#### 3. **Desarrollo:**

Es el punto medio perfecto entre `online` y `always`. Te da lo mejor de ambos mundos para un caso de uso muy concreto: aplicaciones dise침adas para funcionar sin conexi칩n. Permite que tu app sirva contenido desde un cach칠 local de forma instant치nea, pero gestiona los fallos de red (cuando el contenido no est치 en cach칠) de la misma forma segura y predecible que el modo `online`.

游댯 **Espec칤fico**: Este es un modo avanzado. No lo necesitar치s para una web sencilla, pero es absolutamente esencial si est치s construyendo una PWA o cualquier aplicaci칩n que deba ofrecer una experiencia de usuario fluida sin conexi칩n a internet.
