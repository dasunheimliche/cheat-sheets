## A - `enabled: false`: El Interruptor de tus Consultas 游리

#### 1. **Introducci칩n:**

Imagina que cada consulta (`useQuery`) es una l치mpara que se enciende sola al entrar a la habitaci칩n; con `enabled: false`, le pones un interruptor manual para encenderla solo cuando t칰 quieras.

#### 2. **Ejemplo:**

Piensa que tienes una lista de tareas (`Todos`) que NO quieres cargar al mostrar la p치gina. Solo quieres que se cargue cuando el usuario pulse un bot칩n.

```tsx
function Todos() {
  // Usamos useQuery, pero 춰ojo al 'enabled: false'!
  const {
    data, // Aqu칤 se guardar치n los datos cuando lleguen
    isError, // Ser치 'true' si algo sale mal
    isLoading, // Ser치 'true' solo la primera vez que se est칠 cargando
    refetch, // 춰Esta es la funci칩n m치gica para "encender la luz"!
    isFetching, // Ser치 'true' cada vez que se est칠 pidiendo datos
  } = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodoList, // La funci칩n que busca los datos
    enabled: false, // <-- 춰LA CLAVE! La consulta NO se ejecutar치 sola.
  });

  return (
    <div>
      {/* Este bot칩n llama a refetch() para iniciar la consulta manualmente */}
      <button onClick={() => refetch()}>Cargar Tareas</button>

      {/* El resto es l칩gica para mostrar los datos, un error, o un mensaje de carga */}
      {isLoading ? (
        <span>Cargando por primera vez...</span>
      ) : isError ? (
        <span>춰Oh no! Hubo un error.</span>
      ) : data ? (
        <ul>
          {data.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      ) : (
        <span>Pulsa el bot칩n para ver las tareas.</span>
      )}

      {/* Esto es 칰til para ver si se est치 recargando en segundo plano */}
      {isFetching ? "Buscando datos..." : null}
    </div>
  );
}
```

**Explicaci칩n del ejemplo:**
Al poner `enabled: false`, le estamos diciendo a TanStack Query: "Oye, s칠 que existes, pero qu칠date quieto. No hagas nada hasta que yo te avise". El componente se renderizar치, pero no habr치 ninguna petici칩n a la red. El "aviso" se lo damos con la funci칩n `refetch` que nos devuelve `useQuery`. Al hacer clic en el bot칩n "Cargar Tareas", ejecutamos `refetch()`, y es como si puls치ramos el interruptor: la consulta se activa y va a buscar los datos.

#### 3. **Desarrollo:**

Usar `enabled: false` es la forma m치s directa de tomar el control. Cuando lo haces, la consulta se queda en un estado de "pausa".

- **Si no hay datos en cach칠:** La consulta se inicia en estado `pending` (pendiente), pero `isFetching` (buscando) ser치 `false`. Est치 esperando, no buscando.
- **Si ya tiene datos en cach칠 de una ejecuci칩n anterior:** Se mostrar치n esos datos y el estado ser치 `success` (칠xito).
- **No se actualizar치 sola:** Ignorar치 las actualizaciones en segundo plano, los reintentos autom치ticos y las invalidaciones. Est치 completamente bajo tu control.

La principal raz칩n para usar esto es cuando la ejecuci칩n de una consulta depende de una acci칩n directa e imperativa del usuario, como hacer clic en un bot칩n.

游리 **Importante**: Este es un patr칩n fundamental para controlar el flujo de datos en aplicaciones interactivas. Es esencial para evitar peticiones innecesarias y dar al usuario el control sobre cu치ndo se carga la informaci칩n.

---

## B - "Lazy Queries": Consultas que Esperan una Se침al 游리

#### 1. **Introducci칩n:**

Esta no es una opci칩n nueva, sino un uso inteligent칤simo de `enabled`. Permite que una consulta se dispare autom치ticamente solo cuando se cumple una condici칩n (por ejemplo, cuando un usuario escribe algo en un buscador).

#### 2. **Ejemplo:**

Imagina un formulario con un filtro. No tiene sentido buscar nada hasta que el usuario haya escrito un t칠rmino de b칰squeda, 쯨erdad? 춰Ser칤a un desperdicio de recursos!

```tsx
function TodosConFiltro() {
  // 'filter' guardar치 lo que el usuario escriba. Empieza vac칤o.
  const [filter, setFilter] = React.useState("");

  const { data } = useQuery({
    // La queryKey ahora incluye el filtro para que sea 칰nica
    queryKey: ["todos", filter],
    queryFn: () => fetchTodos(filter), // La funci칩n de b칰squeda usa el filtro

    // ----> 춰AQU칈 EST츼 LA MAGIA! <----
    // 'enabled' ahora depende de si 'filter' tiene algo escrito.
    // !!filter convierte el string en un booleano:
    // !!'' (string vac칤o) -> false
    // !!'algo' (string con texto) -> true
    enabled: !!filter,
  });

  return (
    <div>
      {/* Este formulario actualiza el estado 'filter' */}
      <FiltersForm onApply={setFilter} />

      {/* La tabla solo se muestra si 'data' existe */}
      {data && <TodosTable data={data} />}
    </div>
  );
}
```

**Explicaci칩n del ejemplo:**
La consulta est치 "escuchando" el estado `filter`. Mientras `filter` est칠 vac칤o, `!!filter` es `false`, y la opci칩n `enabled` se mantiene en `false`. La consulta duerme. En el instante en que el usuario escribe algo y `filter` cambia a, por ejemplo, `"comprar leche"`, `!!filter` se convierte en `true`. Esto "despierta" a la consulta, que se ejecuta autom치ticamente con el nuevo filtro.

#### 3. **Desarrollo:**

Este patr칩n es la forma "declarativa" y elegante de manejar dependencias. En lugar de decir "춰Ejec칰tate AHORA!" (imperativo), le dices "Ejec칰tate _cuando_ esta condici칩n sea verdadera" (declarativo). La consulta reacciona a los cambios en tu aplicaci칩n.

**춰Cuidado con la confusi칩n!** El truco `!!valor` es muy com칰n en JavaScript. Simplemente convierte cualquier valor a su equivalente booleano. Un string vac칤o, el n칰mero 0, `null` o `undefined` se convierten en `false`. Cualquier otra cosa se convierte en `true`.

游리 **Importante**: Este es el pan de cada d칤a en aplicaciones complejas. Lo usar치s para b칰squedas, formularios dependientes, y cualquier situaci칩n donde una consulta solo tiene sentido despu칠s de que el usuario haya proporcionado cierta informaci칩n.

---

## C - `isLoading` vs. `isPending`: 쮼sperando o Cargando? 춰Que no te enga침en! 游리

#### 1. **Introducci칩n:**

Cuando usas consultas "perezosas" (`Lazy Queries`), es vital entender la diferencia entre `isPending` (la consulta no tiene datos) y `isLoading` (la consulta est치 buscando datos _por primera vez_).

#### 2. **Ejemplo:**

Pensemos en nuestra "Lazy Query" del punto anterior.

1.  **Al cargar la p치gina:**

    - El `filter` est치 vac칤o.
    - La consulta est치 deshabilitada (`enabled: false`).
    - `isPending` es `true` (porque, t칠cnicamente, no tiene datos).
    - `isLoading` es `false` (porque no est치 buscando nada, solo esperando).

2.  **El usuario escribe "comprar leche" y pulsa buscar:**
    - El `filter` ahora tiene valor.
    - La consulta se habilita (`enabled: true`).
    - `isPending` sigue siendo `true` (a칰n no han llegado los datos).
    - `isLoading` AHORA es `true` (춰est치 en plena b칰squeda por primera vez!).

**Explicaci칩n del ejemplo:**
Si intentas mostrar un spinner bas치ndote en `isPending`, 춰lo mostrar칤as desde el principio, incluso cuando la consulta est치 dormida! Ser칤a muy confuso para el usuario. `isLoading` es tu verdadero amigo para mostrar un indicador de carga inicial, porque solo se activa cuando la b칰squeda ha comenzado de verdad.

#### 3. **Desarrollo:**

La f칩rmula secreta es esta: `isLoading` es simplemente un atajo para `isPending && isFetching`.

- `isPending`: "No tengo datos finales todav칤a".
- `isFetching`: "Estoy activamente en una comunicaci칩n con el servidor AHORA MISMO".
- `isLoading`: "No tengo datos Y estoy busc치ndolos por primera vez".

Usa siempre `isLoading` para los spinners de carga inicial y `isFetching` para indicadores m치s sutiles que muestran cuando una consulta se est치 actualizando en segundo plano.

游리 **Importante**: Comprender esta distinci칩n te evitar치 errores l칩gicos y te permitir치 construir interfaces de usuario que comunican su estado de forma clara y precisa. Es una de esas "peque침as cosas" que marcan una gran diferencia.

---

## D - `skipToken`: La Opci칩n Segura para TypeScript 游댯

#### 1. **Introducci칩n:**

Si usas TypeScript, `skipToken` es una forma elegante de deshabilitar una consulta, asegurando que tu c칩digo siga siendo 100% seguro en cuanto a tipos.

#### 2. **Ejemplo:**

Volvamos al ejemplo del filtro, pero ahora con la seguridad de TypeScript.

```tsx
import { skipToken, useQuery } from "@tanstack/react-query";

function TodosConFiltroTS() {
  // El filtro puede ser un string o 'undefined'
  const [filter, setFilter] = React.useState<string | undefined>();

  const { data } = useQuery({
    queryKey: ["todos", filter],

    // ----> 춰LA MAGIA DE TYPESCRIPT! <----
    // Si 'filter' existe, le damos la funci칩n para buscar datos.
    // Si no, le pasamos 'skipToken'.
    // TanStack Query ve 'skipToken' y simplemente... no hace nada.
    queryFn: filter ? () => fetchTodos(filter) : skipToken,
  });

  return (
    <div>
      <FiltersForm onApply={setFilter} />
      {data && <TodosTable data={data} />}
    </div>
  );
}
```

**Explicaci칩n del ejemplo:**
Aqu칤, en lugar de usar la opci칩n `enabled`, movemos la l칩gica a `queryFn`. El operador ternario (`condicion ? valor_si_true : valor_si_false`) comprueba si `filter` tiene un valor. Si lo tiene, devuelve la funci칩n que busca los datos. Si no, devuelve `skipToken`. `skipToken` es una se침al especial que le dice a `useQuery`: "Cancela la misi칩n. No ejecutes nada". Esto evita que TypeScript se queje de que `fetchTodos` podr칤a recibir `undefined`, lo cual es genial.

#### 3. **Desarrollo:**

`skipToken` funciona de manera casi id칠ntica a `enabled: false`. La consulta no se ejecuta, no se actualiza en segundo plano, etc. Es la forma preferida en el ecosistema TypeScript para las "Lazy Queries".

**춰PERO, Y ESTE ES UN GRAN PERO!**
Hay una diferencia crucial que debes grabar a fuego en tu memoria: **`refetch` no funciona con `skipToken`**. Si tu l칩gica requiere un bot칩n para re-lanzar la consulta manualmente, no puedes usar `skipToken`.

游댯 **Espec칤fico**: Esta es la herramienta de elecci칩n si est치s en TypeScript y tu consulta se activa por un cambio de estado (como un filtro). Si necesitas un `refetch` manual, qu칠date con `enabled: false`.

---

## E - Duelo de Titanes: `enabled: false` vs. `skipToken` 游리

#### 1. **Introducci칩n:**

Aqu칤 tienes la gu칤a definitiva para que nunca m치s dudes sobre cu치l usar. Pi칠nsalo como elegir entre un destornillador manual y uno el칠ctrico: ambos aprietan tornillos, pero cada uno brilla en situaciones diferentes.

#### 2. **La Comparaci칩n Cara a Cara:**

| Caracter칤stica                 | `enabled: false`                                                                 | `skipToken`                                                                                       |
| :----------------------------- | :------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------ |
| **쮺칩mo funciona?**            | Una opci칩n booleana que "apaga" toda la consulta.                                | Un token especial que se pasa a `queryFn` para que no se ejecute.                                 |
| **Caso de uso principal**      | **Control manual.** Ideal para "ejecutar al hacer clic en un bot칩n".             | **Control reactivo.** Ideal para "ejecutar cuando un estado cambia".                              |
| **쮽unciona con `refetch()`?** | **S칤, perfectamente.** Es su compa침ero ideal.                                    | **No, en absoluto.** `refetch` no tendr치 efecto.                                                  |
| **Seguridad de Tipos (TS)**    | Buena, pero a veces requiere aserciones o validaciones extra.                    | **Excelente.** Es su raz칩n de ser. Evita errores de tipo de forma nativa.                         |
| **쮺u치ndo lo elijo?**          | Cuando necesites un bot칩n de "Cargar" o "Reintentar" que el usuario deba pulsar. | Cuando uses TypeScript y la consulta dependa de un estado que puede ser `undefined` al principio. |

#### 3. **La Trampa a Evitar (춰L칠elo dos veces!)**

La confusi칩n m치s grande y peligrosa es intentar usar `refetch` con `skipToken`. No es que funcione "a veces" o "de forma rara". Simplemente **NO FUNCIONA**.

- **쯅ecesitas un `refetch` manual?** Usa `enabled: false`. Fin de la discusi칩n.
- **쯊u prioridad es la m치xima seguridad de tipos en una consulta reactiva y no necesitas `refetch`?** Usa `skipToken`.

Elegir correctamente desde el principio te ahorrar치 horas de frustraci칩n y c칩digo confuso. 춰Conf칤a en m칤!

游리 **Importante**: Esta decisi칩n estrat칠gica define c칩mo interactuar치 tu componente con los datos. Entender esta tabla te convierte en un desarrollador m치s consciente y eficaz con TanStack Query.
