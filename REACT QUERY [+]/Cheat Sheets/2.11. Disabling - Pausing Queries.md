## A - `enabled: false`: El Interruptor de tus Consultas 🟡

#### 1. **Introducción:**

Imagina que cada consulta (`useQuery`) es una lámpara que se enciende sola al entrar a la habitación; con `enabled: false`, le pones un interruptor manual para encenderla solo cuando tú quieras.

#### 2. **Ejemplo:**

Piensa que tienes una lista de tareas (`Todos`) que NO quieres cargar al mostrar la página. Solo quieres que se cargue cuando el usuario pulse un botón.

```tsx
function Todos() {
  // Usamos useQuery, pero ¡ojo al 'enabled: false'!
  const {
    data, // Aquí se guardarán los datos cuando lleguen
    isError, // Será 'true' si algo sale mal
    isLoading, // Será 'true' solo la primera vez que se esté cargando
    refetch, // ¡Esta es la función mágica para "encender la luz"!
    isFetching, // Será 'true' cada vez que se esté pidiendo datos
  } = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodoList, // La función que busca los datos
    enabled: false, // <-- ¡LA CLAVE! La consulta NO se ejecutará sola.
  });

  return (
    <div>
      {/* Este botón llama a refetch() para iniciar la consulta manualmente */}
      <button onClick={() => refetch()}>Cargar Tareas</button>

      {/* El resto es lógica para mostrar los datos, un error, o un mensaje de carga */}
      {isLoading ? (
        <span>Cargando por primera vez...</span>
      ) : isError ? (
        <span>¡Oh no! Hubo un error.</span>
      ) : data ? (
        <ul>
          {data.map((todo) => (
            <li key={todo.id}>{todo.title}</li>
          ))}
        </ul>
      ) : (
        <span>Pulsa el botón para ver las tareas.</span>
      )}

      {/* Esto es útil para ver si se está recargando en segundo plano */}
      {isFetching ? "Buscando datos..." : null}
    </div>
  );
}
```

**Explicación del ejemplo:**
Al poner `enabled: false`, le estamos diciendo a TanStack Query: "Oye, sé que existes, pero quédate quieto. No hagas nada hasta que yo te avise". El componente se renderizará, pero no habrá ninguna petición a la red. El "aviso" se lo damos con la función `refetch` que nos devuelve `useQuery`. Al hacer clic en el botón "Cargar Tareas", ejecutamos `refetch()`, y es como si pulsáramos el interruptor: la consulta se activa y va a buscar los datos.

#### 3. **Desarrollo:**

Usar `enabled: false` es la forma más directa de tomar el control. Cuando lo haces, la consulta se queda en un estado de "pausa".

- **Si no hay datos en caché:** La consulta se inicia en estado `pending` (pendiente), pero `isFetching` (buscando) será `false`. Está esperando, no buscando.
- **Si ya tiene datos en caché de una ejecución anterior:** Se mostrarán esos datos y el estado será `success` (éxito).
- **No se actualizará sola:** Ignorará las actualizaciones en segundo plano, los reintentos automáticos y las invalidaciones. Está completamente bajo tu control.

La principal razón para usar esto es cuando la ejecución de una consulta depende de una acción directa e imperativa del usuario, como hacer clic en un botón.

🟡 **Importante**: Este es un patrón fundamental para controlar el flujo de datos en aplicaciones interactivas. Es esencial para evitar peticiones innecesarias y dar al usuario el control sobre cuándo se carga la información.

---

## B - "Lazy Queries": Consultas que Esperan una Señal 🟡

#### 1. **Introducción:**

Esta no es una opción nueva, sino un uso inteligentísimo de `enabled`. Permite que una consulta se dispare automáticamente solo cuando se cumple una condición (por ejemplo, cuando un usuario escribe algo en un buscador).

#### 2. **Ejemplo:**

Imagina un formulario con un filtro. No tiene sentido buscar nada hasta que el usuario haya escrito un término de búsqueda, ¿verdad? ¡Sería un desperdicio de recursos!

```tsx
function TodosConFiltro() {
  // 'filter' guardará lo que el usuario escriba. Empieza vacío.
  const [filter, setFilter] = React.useState("");

  const { data } = useQuery({
    // La queryKey ahora incluye el filtro para que sea única
    queryKey: ["todos", filter],
    queryFn: () => fetchTodos(filter), // La función de búsqueda usa el filtro

    // ----> ¡AQUÍ ESTÁ LA MAGIA! <----
    // 'enabled' ahora depende de si 'filter' tiene algo escrito.
    // !!filter convierte el string en un booleano:
    // !!'' (string vacío) -> false
    // !!'algo' (string con texto) -> true
    enabled: !!filter,
  });

  return (
    <div>
      {/* Este formulario actualiza el estado 'filter' */}
      <FiltersForm onApply={setFilter} />

      {/* La tabla solo se muestra si 'data' existe */}
      {data && <TodosTable data={data} />}
    </div>
  );
}
```

**Explicación del ejemplo:**
La consulta está "escuchando" el estado `filter`. Mientras `filter` esté vacío, `!!filter` es `false`, y la opción `enabled` se mantiene en `false`. La consulta duerme. En el instante en que el usuario escribe algo y `filter` cambia a, por ejemplo, `"comprar leche"`, `!!filter` se convierte en `true`. Esto "despierta" a la consulta, que se ejecuta automáticamente con el nuevo filtro.

#### 3. **Desarrollo:**

Este patrón es la forma "declarativa" y elegante de manejar dependencias. En lugar de decir "¡Ejecútate AHORA!" (imperativo), le dices "Ejecútate _cuando_ esta condición sea verdadera" (declarativo). La consulta reacciona a los cambios en tu aplicación.

**¡Cuidado con la confusión!** El truco `!!valor` es muy común en JavaScript. Simplemente convierte cualquier valor a su equivalente booleano. Un string vacío, el número 0, `null` o `undefined` se convierten en `false`. Cualquier otra cosa se convierte en `true`.

🟡 **Importante**: Este es el pan de cada día en aplicaciones complejas. Lo usarás para búsquedas, formularios dependientes, y cualquier situación donde una consulta solo tiene sentido después de que el usuario haya proporcionado cierta información.

---

## C - `isLoading` vs. `isPending`: ¿Esperando o Cargando? ¡Que no te engañen! 🟡

#### 1. **Introducción:**

Cuando usas consultas "perezosas" (`Lazy Queries`), es vital entender la diferencia entre `isPending` (la consulta no tiene datos) y `isLoading` (la consulta está buscando datos _por primera vez_).

#### 2. **Ejemplo:**

Pensemos en nuestra "Lazy Query" del punto anterior.

1.  **Al cargar la página:**

    - El `filter` está vacío.
    - La consulta está deshabilitada (`enabled: false`).
    - `isPending` es `true` (porque, técnicamente, no tiene datos).
    - `isLoading` es `false` (porque no está buscando nada, solo esperando).

2.  **El usuario escribe "comprar leche" y pulsa buscar:**
    - El `filter` ahora tiene valor.
    - La consulta se habilita (`enabled: true`).
    - `isPending` sigue siendo `true` (aún no han llegado los datos).
    - `isLoading` AHORA es `true` (¡está en plena búsqueda por primera vez!).

**Explicación del ejemplo:**
Si intentas mostrar un spinner basándote en `isPending`, ¡lo mostrarías desde el principio, incluso cuando la consulta está dormida! Sería muy confuso para el usuario. `isLoading` es tu verdadero amigo para mostrar un indicador de carga inicial, porque solo se activa cuando la búsqueda ha comenzado de verdad.

#### 3. **Desarrollo:**

La fórmula secreta es esta: `isLoading` es simplemente un atajo para `isPending && isFetching`.

- `isPending`: "No tengo datos finales todavía".
- `isFetching`: "Estoy activamente en una comunicación con el servidor AHORA MISMO".
- `isLoading`: "No tengo datos Y estoy buscándolos por primera vez".

Usa siempre `isLoading` para los spinners de carga inicial y `isFetching` para indicadores más sutiles que muestran cuando una consulta se está actualizando en segundo plano.

🟡 **Importante**: Comprender esta distinción te evitará errores lógicos y te permitirá construir interfaces de usuario que comunican su estado de forma clara y precisa. Es una de esas "pequeñas cosas" que marcan una gran diferencia.

---

## D - `skipToken`: La Opción Segura para TypeScript 🔵

#### 1. **Introducción:**

Si usas TypeScript, `skipToken` es una forma elegante de deshabilitar una consulta, asegurando que tu código siga siendo 100% seguro en cuanto a tipos.

#### 2. **Ejemplo:**

Volvamos al ejemplo del filtro, pero ahora con la seguridad de TypeScript.

```tsx
import { skipToken, useQuery } from "@tanstack/react-query";

function TodosConFiltroTS() {
  // El filtro puede ser un string o 'undefined'
  const [filter, setFilter] = React.useState<string | undefined>();

  const { data } = useQuery({
    queryKey: ["todos", filter],

    // ----> ¡LA MAGIA DE TYPESCRIPT! <----
    // Si 'filter' existe, le damos la función para buscar datos.
    // Si no, le pasamos 'skipToken'.
    // TanStack Query ve 'skipToken' y simplemente... no hace nada.
    queryFn: filter ? () => fetchTodos(filter) : skipToken,
  });

  return (
    <div>
      <FiltersForm onApply={setFilter} />
      {data && <TodosTable data={data} />}
    </div>
  );
}
```

**Explicación del ejemplo:**
Aquí, en lugar de usar la opción `enabled`, movemos la lógica a `queryFn`. El operador ternario (`condicion ? valor_si_true : valor_si_false`) comprueba si `filter` tiene un valor. Si lo tiene, devuelve la función que busca los datos. Si no, devuelve `skipToken`. `skipToken` es una señal especial que le dice a `useQuery`: "Cancela la misión. No ejecutes nada". Esto evita que TypeScript se queje de que `fetchTodos` podría recibir `undefined`, lo cual es genial.

#### 3. **Desarrollo:**

`skipToken` funciona de manera casi idéntica a `enabled: false`. La consulta no se ejecuta, no se actualiza en segundo plano, etc. Es la forma preferida en el ecosistema TypeScript para las "Lazy Queries".

**¡PERO, Y ESTE ES UN GRAN PERO!**
Hay una diferencia crucial que debes grabar a fuego en tu memoria: **`refetch` no funciona con `skipToken`**. Si tu lógica requiere un botón para re-lanzar la consulta manualmente, no puedes usar `skipToken`.

🔵 **Específico**: Esta es la herramienta de elección si estás en TypeScript y tu consulta se activa por un cambio de estado (como un filtro). Si necesitas un `refetch` manual, quédate con `enabled: false`.

---

## E - Duelo de Titanes: `enabled: false` vs. `skipToken` 🟡

#### 1. **Introducción:**

Aquí tienes la guía definitiva para que nunca más dudes sobre cuál usar. Piénsalo como elegir entre un destornillador manual y uno eléctrico: ambos aprietan tornillos, pero cada uno brilla en situaciones diferentes.

#### 2. **La Comparación Cara a Cara:**

| Característica                 | `enabled: false`                                                                 | `skipToken`                                                                                       |
| :----------------------------- | :------------------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------ |
| **¿Cómo funciona?**            | Una opción booleana que "apaga" toda la consulta.                                | Un token especial que se pasa a `queryFn` para que no se ejecute.                                 |
| **Caso de uso principal**      | **Control manual.** Ideal para "ejecutar al hacer clic en un botón".             | **Control reactivo.** Ideal para "ejecutar cuando un estado cambia".                              |
| **¿Funciona con `refetch()`?** | **Sí, perfectamente.** Es su compañero ideal.                                    | **No, en absoluto.** `refetch` no tendrá efecto.                                                  |
| **Seguridad de Tipos (TS)**    | Buena, pero a veces requiere aserciones o validaciones extra.                    | **Excelente.** Es su razón de ser. Evita errores de tipo de forma nativa.                         |
| **¿Cuándo lo elijo?**          | Cuando necesites un botón de "Cargar" o "Reintentar" que el usuario deba pulsar. | Cuando uses TypeScript y la consulta dependa de un estado que puede ser `undefined` al principio. |

#### 3. **La Trampa a Evitar (¡Léelo dos veces!)**

La confusión más grande y peligrosa es intentar usar `refetch` con `skipToken`. No es que funcione "a veces" o "de forma rara". Simplemente **NO FUNCIONA**.

- **¿Necesitas un `refetch` manual?** Usa `enabled: false`. Fin de la discusión.
- **¿Tu prioridad es la máxima seguridad de tipos en una consulta reactiva y no necesitas `refetch`?** Usa `skipToken`.

Elegir correctamente desde el principio te ahorrará horas de frustración y código confuso. ¡Confía en mí!

🟡 **Importante**: Esta decisión estratégica define cómo interactuará tu componente con los datos. Entender esta tabla te convierte en un desarrollador más consciente y eficaz con TanStack Query.
