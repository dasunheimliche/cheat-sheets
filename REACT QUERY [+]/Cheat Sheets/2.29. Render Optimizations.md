## A - `structural sharing`: Reutilizando las piezas del puzzle de tus datos üü°

#### 1. **Introducci√≥n:**

React Query es s√∫per listo y, para no hacerte trabajar de m√°s, reutiliza las partes de tus datos que no han cambiado entre una petici√≥n y otra.

#### 2. **Ejemplo:**

Imagina que pides los datos de un usuario y sus publicaciones.

**Petici√≥n 1 (Datos originales):**

```json
{
  "user": { "id": 1, "name": "Carlos", "status": "activo" },
  "posts": [
    { "id": 101, "title": "Mi primer post" },
    { "id": 102, "title": "Mi segundo post" }
  ]
}
```

Un minuto despu√©s, vuelves a pedir los datos. El usuario cambi√≥ su estado, pero sus posts son los mismos.

**Petici√≥n 2 (Nuevos datos):**

```json
{
  "user": { "id": 1, "name": "Carlos", "status": "ocupado" }, // <-- ¬°Esto cambi√≥!
  "posts": [
    // <-- ¬°Esto es id√©ntico!
    { "id": 101, "title": "Mi primer post" },
    { "id": 102, "title": "Mi segundo post" }
  ]
}
```

**Explicaci√≥n del ejemplo:**
React Query se da cuenta de que el objeto `user` ha cambiado, as√≠ que te da uno nuevo. Pero, ¬°y aqu√≠ est√° la magia!, ve que el array `posts` es _exactamente el mismo_. En lugar de crear un array nuevo en memoria, te devuelve una referencia al **mismo array original**.

**¬øY esto para qu√© sirve, te preguntar√°s?** Si tienes un componente que solo muestra los `posts`, React lo comparar√°, ver√° que el array es el mismo objeto de antes y decidir√°: "**No hay nada que hacer aqu√≠, no necesito re-dibujar este componente**". ¬°Te ahorra un re-render!

#### 3. **Desarrollo:**

Esta t√©cnica se llama "compartici√≥n estructural". Funciona de forma autom√°tica y silenciosa para datos compatibles con JSON (que es el 99% de los casos). Su √∫nico objetivo es mantener la "identidad referencial" (que el objeto en memoria sea el mismo) de las partes de tus datos que no cambian, lo cual es clave para que React pueda optimizar los re-renders.

üü° **Importante**: No tienes que hacer nada para que esto funcione, ¬°es un regalo de React Query! Pero es vital que sepas que existe para que entiendas por qu√© a veces tus componentes no se re-renderizan aunque los datos se hayan vuelto a pedir. Es una optimizaci√≥n, no un error.

---

## B - `Seguimiento de Propiedades`: React Query te esp√≠a (para bien) üî¥

#### 1. **Introducci√≥n:**

Tu componente solo se volver√° a dibujar si cambia el valor de una de las propiedades del hook `useQuery` que **realmente est√°s usando** en tu c√≥digo.

#### 2. **Ejemplo:**

Mira estos dos componentes. Parecen hacer lo mismo, pero uno es mucho m√°s eficiente.

```javascript
// ‚úÖ FORMA CORRECTA Y OPTIMIZADA
function NombreDeUsuario() {
  // Solo nos interesa 'data', as√≠ que solo lo "desestructuramos".
  const { data } = useQuery({ queryKey: ["user"], queryFn: fetchUser });

  // React Query sabe que solo te importa 'data'.
  // Si 'isFetching' o 'isStale' cambian, a este componente no le importa.
  // ¬°NO SE RE-RENDERIZAR√Å innecesariamente!
  return <div>{data?.name}</div>;
}

// ‚ùå ¬°CUIDADO! FORMA QUE ANULA LA OPTIMIZACI√ìN
function NombreDeUsuarioPocoOptimizado() {
  // Usamos el operador "rest" (...), que agrupa "el resto" de propiedades.
  const { data, ...rest } = useQuery({
    queryKey: ["user"],
    queryFn: fetchUser,
  });

  // ¬°ALERTA! Al hacer esto, le has dicho a React Query:
  // "Oye, me interesa 'data' Y TAMBI√âN todo lo que venga en 'rest'".
  // Ahora, si 'isFetching' cambia (que est√° dentro de 'rest'),
  // ¬°este componente S√ç SE RE-RENDERIZAR√Å!
  return <div>{data?.name}</div>;
}
```

**Explicaci√≥n del ejemplo:**
La clave es ser expl√≠cito. Si solo necesitas `data` y `error`, pide solo eso: `const { data, error } = useQuery(...)`. Al hacer esto, le das permiso a React Query para que ignore los cambios en todas las dem√°s propiedades (`isFetching`, `isLoading`, `isStale`, etc.), evitando que tu componente se redibuje por cambios que no le afectan visualmente.

Usar el operador `...rest` es como decirle "av√≠same de cualquier cambio en el resto de las cosas", lo cual es una forma segura de recibir notificaciones constantes y anular esta fant√°stica optimizaci√≥n.

#### 3. **Desarrollo:**

Esta maravilla funciona gracias a un objeto especial de JavaScript llamado `Proxy`. React Query envuelve su respuesta en un Proxy que "esp√≠a" a qu√© propiedades accedes. Si no accedes a una propiedad, asume que no te importa y no te notificar√° si cambia.

üî¥ **Fundamental**: Este es uno de los conceptos m√°s importantes para evitar re-renders innecesarios. **La regla de oro es: desestructura solo las propiedades que vayas a usar.** Por suerte, hay una regla de ESLint (`@tanstack/query/no-rest-destructuring`) que te gritar√° si cometes este error. ¬°Act√≠vala!

---

## C - `select`: Eligiendo solo la porci√≥n del pastel que te interesa üî¥

#### 1. **Introducci√≥n:**

Usa la opci√≥n `select` para transformar los datos que recibes y quedarte √∫nicamente con la pieza de informaci√≥n que tu componente necesita, ignorando todo lo dem√°s.

#### 2. **Ejemplo:**

Imagina que tienes una lista de tareas (`todos`) y un componente que solo debe mostrar **cu√°ntas** tareas hay en total.

```javascript
// Hook que trae TODAS las tareas desde el servidor.
// El servidor devuelve algo como: [{id:1, text:'Aprender React'}, {id:2, text:'Dominar Query'}]
const useTodos = (options) => {
  return useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos,
    ...options, // Pasamos las opciones extra aqu√≠
  });
};

// Componente que solo muestra el N√öMERO de tareas.
function ContadorDeTareas() {
  // Usamos nuestro hook 'useTodos' y le pasamos la opci√≥n 'select'.
  // Le decimos: "De todos los datos que recibas, solo me interesa su propiedad 'length'".
  const { data: numeroDeTareas } = useTodos({
    select: (todos) => todos.length,
  });

  return <h1>Tareas totales: {numeroDeTareas}</h1>;
}
```

**Explicaci√≥n del ejemplo:**
Supongamos que los datos de las tareas cambian porque editaste el texto de una de ellas (de 'Aprender React' a 'Aprender React AHORA'). Los datos completos han cambiado, s√≠. Pero, ¬øcambi√≥ el n√∫mero total de tareas? No, sigue siendo 2.

Como el componente `ContadorDeTareas` us√≥ `select` para suscribirse **√∫nicamente al resultado de `todos.length`**, React Query ve que el valor `2` no ha cambiado y, por lo tanto, **NO re-renderiza el componente**. ¬°Acabas de evitar un re-dibujo por un cambio que a este componente no le importaba en absoluto!

#### 3. **Desarrollo:**

La opci√≥n `select` es tu bistur√≠ de cirujano para la optimizaci√≥n. Te permite crear hooks muy espec√≠ficos a partir de una fuente de datos m√°s general. Es perfecta para:

1.  Extraer una peque√±a parte de un objeto grande.
2.  Transformar los datos (ej: filtrar, mapear, calcular un valor derivado).
3.  Evitar re-renders en componentes que solo dependen de esa peque√±a porci√≥n transformada.

üî¥ **Fundamental**: `select` es una de las herramientas de optimizaci√≥n manual m√°s potentes de React Query. Te permite construir una UI muy eficiente, donde cada pieza solo reacciona a los cambios que verdaderamente le conciernen.

---

## D - `Memoizaci√≥n de 'select'`: Evitando que tu selector trabaje de m√°s üü°

#### 1. **Introducci√≥n:**

Para que la optimizaci√≥n de `select` funcione a la perfecci√≥n, debes asegurarte de que la funci√≥n que le pasas no sea una funci√≥n "nueva" en cada renderizado del componente.

#### 2. **Ejemplo:**

Siguiendo con el contador de tareas, veamos la forma correcta e incorrecta de pasar la funci√≥n `select`.

```javascript
import { useCallback } from "react";

// ‚ùå FORMA INCORRECTA (pero muy com√∫n)
function ContadorDeTareasMalo() {
  const { data: numeroDeTareas } = useTodos({
    // ¬°Problema! Esta funci√≥n de flecha se crea de nuevo CADA VEZ
    // que el componente se renderiza. Para JavaScript, es una funci√≥n
    // completamente nueva, aunque haga lo mismo.
    select: (todos) => todos.length,
  });
  return <h1>...</h1>;
}

// ‚úÖ FORMA CORRECTA (Opci√≥n 1: Funci√≥n estable)
// La definimos fuera del componente, por lo que SIEMPRE es la misma funci√≥n.
const seleccionarNumeroDeTareas = (todos) => todos.length;

function ContadorDeTareasBueno() {
  const { data: numeroDeTareas } = useTodos({
    select: seleccionarNumeroDeTareas, // Siempre es la misma referencia
  });
  return <h1>...</h1>;
}

// ‚úÖ FORMA CORRECTA (Opci√≥n 2: useCallback)
// Si tu funci√≥n depende de props o estado, usa useCallback.
function ContadorDeTareasBuenoConCallback() {
  const { data: numeroDeTareas } = useTodos({
    // useCallback "memoriza" la funci√≥n y solo la crea de nuevo si
    // sus dependencias (el array vac√≠o en este caso) cambian.
    select: useCallback((todos) => todos.length, []),
  });
  return <h1>...</h1>;
}
```

**Explicaci√≥n del ejemplo:**
React Query vuelve a ejecutar la l√≥gica de `select` si ocurren dos cosas: 1) los datos cambian, o 2) **la propia funci√≥n `select` cambia**.

En el primer ejemplo (`ContadorDeTareasMalo`), cada vez que el componente se re-renderiza por cualquier motivo, se crea una nueva funci√≥n `(todos) => todos.length`. React Query la ve y piensa: "¬°Oh, me han dado una funci√≥n `select` diferente a la de antes! Mejor la ejecuto de nuevo por si acaso". Esto puede causar c√°lculos innecesarios.

Al definir la funci√≥n fuera del componente o al envolverla en `useCallback`, te aseguras de que la referencia a la funci√≥n sea **estable** (siempre la misma). As√≠, React Query solo la re-ejecutar√° cuando sea estrictamente necesario: cuando los datos de origen cambien.

#### 3. **Desarrollo:**

Esto tiene que ver con la "identidad referencial" de las funciones en JavaScript. Una funci√≥n definida "al vuelo" dentro de un componente es como una fotocopia nueva en cada render. `useCallback` o definirla fuera es como tener el documento original, siempre el mismo.

üü° **Importante**: Si tu funci√≥n `select` es simple y no depende de nada dentro de tu componente, def√≠nela fuera. Si depende de `props` o `state`, envu√©lvela en `useCallback`. Es un peque√±o paso extra que asegura que tu optimizaci√≥n con `select` sea robusta.
