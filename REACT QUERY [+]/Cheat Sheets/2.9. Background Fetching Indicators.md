## A - `isFetching`: El esp√≠a que te avisa si algo se est√° actualizando en secreto üü°

#### 1. **Introducci√≥n:**

Esta propiedad te permite mostrar un indicador de carga (como un "Refrescando...") _mientras_ los datos se actualizan en segundo plano, incluso cuando ya tienes datos "viejos" en pantalla.

#### 2. **Ejemplo:**

Imagina una lista de tareas. La primera vez que carga, ves "Loading...". Pero si vuelves a la ventana y React Query actualiza la lista autom√°ticamente, no quieres que todo desaparezca. En su lugar, muestras un sutil "Refreshing..." arriba.

```tsx
function Todos() {
  const {
    status,
    data: todos,
    error,
    isFetching, // ¬°Aqu√≠ est√° nuestro protagonista!
  } = useQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });

  // 1. Pantalla de carga INICIAL (cuando no hay NADA)
  if (status === "pending") {
    return <span>Loading...</span>;
  }

  // 2. Pantalla de ERROR (si algo sali√≥ muy mal)
  if (status === "error") {
    return <span>Error: {error.message}</span>;
  }

  // 3. Pantalla con DATOS (¬°√©xito!)
  return (
    <>
      {/* Este es el truco: muestra "Refreshing..." SOLO si hay una
          actualizaci√≥n en segundo plano. */}
      {isFetching ? <div>Refreshing...</div> : null}

      <div>
        {todos.map((todo) => (
          <Todo todo={todo} />
        ))}
      </div>
    </>
  );
}
```

**Explicaci√≥n del ejemplo:**
F√≠jate bien en la diferencia crucial:

- `status === 'pending'` se encarga de la **carga inicial**. Es cuando la pantalla est√° en blanco y esperas los datos por primera vez.
- `isFetching` se activa **tanto en la carga inicial como en las actualizaciones de fondo**. En el ejemplo, lo usamos para mostrar "Refreshing..." solo cuando ya tenemos datos (`status` es `'success'`) pero se est√° produciendo una nueva b√∫squeda silenciosa.

#### 3. **Desarrollo:**

Aqu√≠ viene la parte que confunde a todo el mundo, pero t√∫ no caer√°s en esa trampa. ¬°Me asegurar√© de ello!

**La Gran Diferencia: `status === 'pending'` vs. `isFetching`**

Pi√©nsalo as√≠:

- `status === 'pending'`: Est√°s montando una tienda por primera vez. La persiana est√° bajada y un cartel dice "Pr√≥xima Apertura". Nadie puede entrar ni ver nada. **Solo ocurre una vez, al principio, cuando no tienes datos.**
- `isFetching`: La tienda ya est√° abierta y funcionando (`status` es `'success'`). De repente, llega un repartidor por la puerta de atr√°s con nuevo stock. T√∫ sigues atendiendo a los clientes con la mercanc√≠a que ya tienes, pero pones un peque√±o cartelito en el mostrador que dice "Recibiendo nuevo inventario". Los clientes lo ven, saben que algo pasa, pero pueden seguir comprando. **`isFetching` ser√° `true` durante la "Pr√≥xima Apertura" Y tambi√©n cada vez que llegue el repartidor.**

En resumen:

| Propiedad              | ¬øCu√°ndo es `true`?                                                           | Analog√≠a de la tienda                                                    |
| ---------------------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| `status === 'pending'` | **Solo** en la primera carga, cuando no hay datos.                           | Cartel de "Pr√≥xima Apertura".                                            |
| `isFetching`           | En la primera carga **Y** en todas las actualizaciones silenciosas de fondo. | El cartel de "Pr√≥xima Apertura" Y el letrero de "Recibiendo inventario". |

Usar `isFetching` te da el poder de diferenciar entre "estoy esperando algo desde cero" y "estoy refrescando lo que ya tienes". ¬°Es clave para una buena experiencia de usuario!

üü° **Importante**: Esencial para crear interfaces de usuario que se sientan modernas y receptivas, informando al usuario de actividad en segundo plano sin bloquear la pantalla ni mostrar una pantalla de carga completa innecesariamente.

---

## B - `useIsFetching`: El vigilante global que te dice si _cualquier_ consulta se est√° actualizando üîµ

#### 1. **Introducci√≥n:**

Este hook es como un centinela en la torre m√°s alta de tu aplicaci√≥n; te avisa si _alguna_ consulta, en _cualquier_ parte, est√° en proceso de b√∫squeda de datos.

#### 2. **Ejemplo:**

Quieres mostrar una fina barra de carga en la parte superior de tu p√°gina (como en YouTube o Gmail) cada vez que la aplicaci√≥n est√° buscando datos, sin importar qu√© componente inici√≥ la b√∫squeda.

```tsx
import { useIsFetching } from "@tanstack/react-query";

// Este componente lo puedes poner en tu layout principal (App.js)
function GlobalLoadingIndicator() {
  // useIsFetching devuelve un N√öMERO (la cantidad de queries activas)
  const isFetching = useIsFetching();

  // Si es mayor que 0, significa que al menos una query est√° activa.
  return isFetching > 0 ? (
    <div
      style={{
        position: "fixed",
        top: 0,
        left: 0,
        width: "100%",
        background: "lightblue",
      }}
    >
      Cargando datos en segundo plano...
    </div>
  ) : null;
}
```

**Explicaci√≥n del ejemplo:**
`useIsFetching` no devuelve un simple `true` o `false`. ¬°No, no, es m√°s listo que eso! Devuelve un **n√∫mero**: la cantidad exacta de consultas que se est√°n ejecutando en toda tu aplicaci√≥n en ese instante. En el ejemplo, lo usamos de forma simple: si el n√∫mero es mayor que 0 (`isFetching > 0`), mostramos nuestro indicador global. Si es 0, no hay nada que mostrar.

#### 3. **Desarrollo:**

La belleza de `useIsFetching` es su simplicidad y su alcance global. No necesitas conectar cables ni pasar props por toda tu aplicaci√≥n. Simplemente lo pones en un componente de alto nivel (como tu `Layout` o `App`), y √©l solito se entera de todo lo que pasa por debajo.

**¬øPor qu√© devuelve un n√∫mero y no un booleano?**
¬°Excelente pregunta! Imagina que tienes dos componentes visibles que empiezan a buscar datos al mismo timepo. `useIsFetching` devolver√° `2`. Si uno termina, bajar√° a `1`. Cuando el √∫ltimo termine, volver√° a `0`. Esto te da un control m√°s granular si alguna vez lo necesitaras, aunque el 99% de las veces, como en el ejemplo, solo te importar√° si es "cero" o "no cero".

Es la herramienta perfecta para esos elementos de UI que no pertenecen a un componente espec√≠fico, sino a la experiencia general de la aplicaci√≥n.

üîµ **Espec√≠fico**: No lo usar√°s en cada componente (para eso tienes `isFetching` del concepto **A**), pero es la herramienta perfecta y elegant√≠sima para implementar indicadores de carga globales, como una barra de progreso en el encabezado de tu aplicaci√≥n.
