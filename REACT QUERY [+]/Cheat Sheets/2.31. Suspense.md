## A - Suspense con React Query: ¬°Adi√≥s a los `isLoading`! üü°

#### 1. **Introducci√≥n:**

Suspense te permite manejar los estados de carga de una forma mucho m√°s elegante y centralizada, mostrando una UI de "reserva" (fallback) mientras tus datos se est√°n cargando, en lugar de usar condicionales `isLoading` por todos lados.

#### 2. **Ejemplo:**

Imagina que tienes un componente que muestra una lista de tareas. Con Suspense, el c√≥digo se ve as√≠ de limpio:

```jsx
import { Suspense } from "react";
import { useSuspenseQuery } from "@tanstack/react-query";

// 1. Este componente pide los datos. ¬°F√≠jate que no hay `isLoading` ni `error`!
function TodoList() {
  const { data } = useSuspenseQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });

  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  );
}

// 2. Este es el componente principal que usa Suspense.
function App() {
  return (
    <div>
      <h1>Mis Tareas</h1>
      {/* 3. Aqu√≠ est√° la magia. */}
      <Suspense fallback={<div>üåÄ Cargando tareas...</div>}>
        <TodoList />
      </Suspense>
    </div>
  );
}
```

**Explicaci√≥n del ejemplo:**

1.  **`TodoList`**: Este componente usa `useSuspenseQuery`. Nota que solo extraemos `data`. No necesitamos `isLoading`, `isPending` o `error`. `useSuspenseQuery` es el "chivato": si los datos no est√°n listos, le avisa a React.
2.  **`App`**: Aqu√≠ es donde orquestamos todo.
3.  **`<Suspense>`**: Este es el componente de React que act√∫a como un guardia. "Escucha" si alg√∫n componente hijo (como `TodoList`) le avisa que est√° "suspendido" (cargando datos). Si es as√≠, en lugar de renderizar `TodoList`, muestra lo que le hayamos puesto en la prop `fallback` (en este caso, un simple div con "üåÄ Cargando tareas..."). Cuando `useSuspenseQuery` por fin tiene los datos, Suspense lo sabe y reemplaza el `fallback` por el componente `TodoList` ya renderizado con su informaci√≥n.

**¬°Una cosa menos de la que preocuparte!** Los errores se manejan de forma similar, pero con un componente llamado "Error Boundary", que act√∫a como una red de seguridad.

#### 3. **Desarrollo:**

Cuando usas los hooks dedicados para Suspense (`useSuspenseQuery`, `useSuspenseInfiniteQuery`, `useSuspenseQueries`), React Query cambia su comportamiento. En lugar de darte estados como `isLoading` para que t√∫ los gestiones manualmente con un `if`, simplemente "pausa" el renderizado del componente y le cede el control a React.

Esto tiene una ventaja enorme, sobre todo con TypeScript: como el componente solo se renderiza cuando los datos ya est√°n disponibles, ¬°puedes estar 100% seguro de que `data` no ser√° `undefined`! Se acabaron las comprobaciones `if (data) { ... }`.

**‚ö†Ô∏è ¬°Ojo al dato!** Esta forma de trabajar tiene dos implicaciones importantes:

- **No puedes desactivar una query condicionalmente**: El hook _debe_ ejecutarse siempre.
- **No existe `placeholderData`**: Para evitar que la UI se reemplace por el `fallback` en una actualizaci√≥n, debes envolver tus actualizaciones en `startTransition`, una herramienta de React para transiciones suaves.

üü° **Importante**: Suspense es un patr√≥n moderno y muy potente en React. Aunque puedes usar React Query perfectamente sin √©l, entenderlo te permitir√° escribir componentes m√°s limpios y declarativos, que es hacia donde se dirige el ecosistema de React.

---

## B - `throwOnError`: El Guardi√°n de Errores que Piensa en el Usuario üîµ

#### 1. **Introducci√≥n:**

Por defecto, `useSuspenseQuery` es listo y no lanza un error si ya tiene datos viejos (cacheados) para mostrar, priorizando la experiencia de usuario sobre mostrar una pantalla de error por un fallo en segundo plano.

#### 2. **Ejemplo:**

Esta es la regla que sigue React Query por defecto:

```javascript
// "Solo lanza un error si de verdad no tengo NADA de datos (`data` es undefined)"
throwOnError: (error, query) => typeof query.state.data === "undefined";
```

Si quieres que **SIEMPRE** se lance un error, incluso si hay datos viejos, tienes que hacerlo t√∫ mismo:

```jsx
import { useSuspenseQuery } from "@tanstack/react-query";

function ComponenteSensible() {
  const { data, error, isFetching } = useSuspenseQuery({ queryKey, queryFn });

  // Si hay un error Y no estamos intentando solucionarlo ahora mismo...
  if (error && !isFetching) {
    // ...¬°lanza el error para que lo atrape el Error Boundary!
    throw error;
  }

  // Si todo va bien, renderiza los datos (que podr√≠an ser viejos, pero es mejor que nada).
  return <div>{data.titulo}</div>;
}
```

**Explicaci√≥n del ejemplo:**

Imagina que entras a la app y los datos cargan bien. Luego, navegas por otras partes y vuelves. React Query intenta refrescar los datos en segundo plano, pero esta vez la API falla.

- **Comportamiento por defecto**: No ver√°s una pantalla de error. Seguir√°s viendo los datos de la primera vez (aunque est√©n "stale" o desactualizados), porque es mejor que romper la p√°gina.
- **Comportamiento forzado (nuestro ejemplo)**: El c√≥digo `if (error && !isFetching) { throw error }` dice: "No me importa si tienes datos viejos. Si hubo un error al refrescar, quiero que la app se rompa y muestre la pantalla de error". Esto puede ser √∫til en partes muy cr√≠ticas donde los datos deben ser siempre frescos.

#### 3. **Desarrollo:**

La filosof√≠a detr√°s de `throwOnError` es simple: **no molestar al usuario innecesariamente**. Un error en una recarga de datos en segundo plano (background refetch) a menudo es temporal. Mostrar una pantalla de error completa cuando ya tienes contenido visible en pantalla puede ser una experiencia frustrante. Por eso, React Query prefiere ser conservador. Si quieres un comportamiento m√°s agresivo con los errores, debes ser expl√≠cito y lanzarlos t√∫.

üîµ **Espec√≠fico**: Este es un concepto que necesitas entender bien si vas a implementar una estrategia de errores robusta con Suspense. No es algo que toques todos los d√≠as, pero cuando lo necesites, es crucial saber por qu√© funciona as√≠ y c√≥mo puedes cambiarlo.

---

## C - Reseteando Errores: El Bot√≥n de "Intentar de Nuevo" üü°

#### 1. **Introducci√≥n:**

Cuando una query falla y tu `ErrorBoundary` muestra un mensaje de error, necesitas una forma de decirle a React Query: "¬°Oye, quiero volver a intentar esa petici√≥n que fall√≥!". Para eso existen estas herramientas.

#### 2. **Comparativa: Las Dos Formas de Resetear**

Aqu√≠ es donde la cosa se pone interesante. Tienes dos herramientas que parecen similares, pero sirven para prop√≥sitos ligeramente distintos. ¬°Que no cunda el p√°nico, es m√°s f√°cil de lo que parece!

### **C.1 - `QueryErrorResetBoundary`: La "Zona de Reseteo"**

Piensa en esto como si dibujaras un c√≠rculo en el suelo y dijeras: "Cualquier error de query que ocurra **dentro de este c√≠rculo** se podr√° resetear con un bot√≥n especial".

**Ejemplo:**

```jsx
import { QueryErrorResetBoundary } from "@tanstack/react-query";
import { ErrorBoundary } from "react-error-boundary"; // Una librer√≠a popular para Error Boundaries

const App = () => (
  // 1. Dibujamos el c√≠rculo con QueryErrorResetBoundary
  <QueryErrorResetBoundary>
    {(
      { reset } // 2. Nos da una funci√≥n `reset`
    ) => (
      <ErrorBoundary
        onReset={reset} // 3. Le pasamos esa funci√≥n al ErrorBoundary
        fallbackRender={({ resetErrorBoundary }) => (
          <div>
            ¬°Houston, tenemos un problema!
            {/* 4. Este bot√≥n ahora resetea tanto el error en React como la query en React Query */}
            <button onClick={() => resetErrorBoundary()}>
              Intentar de nuevo
            </button>
          </div>
        )}
      >
        <MiComponenteConQuery />
      </ErrorBoundary>
    )}
  </QueryErrorResetBoundary>
);
```

**Explicaci√≥n del ejemplo:**

1.  `QueryErrorResetBoundary` envuelve la parte de tu app que quieres proteger.
2.  Provee una funci√≥n `reset` a sus hijos.
3.  Conectamos esa funci√≥n `reset` a la prop `onReset` de nuestro `ErrorBoundary`.
4.  Cuando el usuario hace clic en el bot√≥n, `resetErrorBoundary` llama a la funci√≥n `reset` que le pasamos, y ¬°voil√†! React Query sabe que debe reintentar las queries que fallaron dentro de ese `QueryErrorResetBoundary`.

### **C.2 - `useQueryErrorResetBoundary`: El "Control Remoto"**

Este hook es m√°s simple. No crea una nueva "zona", sino que te da un control remoto (`reset`) para la zona de reseteo m√°s cercana que encuentre por encima de √©l en el √°rbol de componentes.

**Ejemplo:**

```jsx
import { useQueryErrorResetBoundary } from '@tanstack/react-query';
import { ErrorBoundary } from 'react-error-boundary';

// Imagina que en un componente superior ya tienes un <QueryErrorResetBoundary>
const MiComponente = () => {
  // 1. Obtenemos el "control remoto" con el hook.
  const { reset } = useQueryErrorResetBoundary();

  return (
    <ErrorBoundary
      onReset={reset} // 2. Lo conectamos directamente.
      fallbackRender={/* ... igual que antes ... */}
    >
      <OtroComponenteConQuery />
    </ErrorBoundary>
  );
};
```

**Explicaci√≥n del ejemplo:**

1.  Llamamos al hook `useQueryErrorResetBoundary` y nos da la funci√≥n `reset`.
2.  La pasamos a `onReset`. Este `reset` buscar√° el `QueryErrorResetBoundary` m√°s cercano "hacia arriba" y lo activar√°. Si no encuentra ninguno, resetear√° los errores de forma global.

#### 3. **Desarrollo y Cu√°ndo Usar Cada Uno:**

- Usa **`<QueryErrorResetBoundary>`** cuando quieras **definir una nueva frontera o zona de reseteo**. Es perfecto para envolver "widgets" o secciones independientes de tu aplicaci√≥n.
- Usa **`useQueryErrorResetBoundary`** por **conveniencia** dentro de un componente que ya sabes que est√° dentro de una `QueryErrorResetBoundary`. Es m√°s limpio y directo.

üü° **Importante**: Si usas Suspense para manejar datos, manejar los errores y permitir que el usuario los resetee no es opcional, ¬°es una parte fundamental de una buena experiencia de usuario! Debes dominar al menos una de estas dos t√©cnicas.

---

## D - Fetch-on-render vs. Render-as-you-fetch: ¬øCu√°ndo Pides la Comida? üîµ

#### 1. **Introducci√≥n:**

Estos son dos patrones o estrategias sobre **cu√°ndo** empezar a cargar los datos, lo que tiene un gran impacto en la velocidad percibida de tu aplicaci√≥n.

#### 2. **Comparativa: Las Dos Estrategias**

Imagina que vas a un restaurante.

### **D.1 - Fetch-on-render (Pedir en la Mesa)**

Esta es la estrategia m√°s com√∫n y la que React Query con Suspense hace por defecto.

- **El Proceso:**
  1.  El usuario hace clic en un enlace.
  2.  React empieza a renderizar la nueva p√°gina (`on-render`).
  3.  Dentro del componente, `useSuspenseQuery` se ejecuta y se da cuenta de que necesita datos.
  4.  **AHORA** es cuando empieza a pedirlos a la API (`fetch`).
  5.  El usuario ve una pantalla de carga mientras espera.

Es como llegar al restaurante, sentarte en la mesa, mirar el men√∫ y **entonces** llamar al camarero para pedir. Es secuencial y funciona, pero hay un tiempo de espera inevitable.

### **D.2 - Render-as-you-fetch (Pedir de Camino al Restaurante)**

Esta es una estrategia m√°s avanzada y proactiva que hace que tu app se sienta instant√°nea.

- **El Proceso:**
  1.  El usuario hace clic en un enlace.
  2.  **INMEDIATAMENTE**, antes de empezar a renderizar la p√°gina, lanzas la petici√≥n a la API. Esto se hace a menudo con la funci√≥n `prefetchQuery` de React Query en el evento `onClick` o `onMouseEnter` del enlace.
  3.  **MIENTRAS** los datos se van cargando en segundo plano, React empieza a renderizar la nueva p√°gina (`as-you-fetch`).
  4.  Para cuando `useSuspenseQuery` se ejecuta, es muy probable que los datos ya est√©n en la cach√©, listos para ser mostrados.
  5.  El usuario no ve (o ve por muy poco tiempo) la pantalla de carga.

Es como usar la app del restaurante para pedir tu comida **mientras vas de camino**. Cuando llegas, ¬°tu pedido ya est√° casi listo en la mesa!

#### 3. **Desarrollo:**

React Query te da las herramientas para implementar ambas estrategias. "Fetch-on-render" es el comportamiento por defecto y no requiere configuraci√≥n extra. Para lograr "Render-as-you-fetch", que es el ideal de rendimiento, necesitas ser proactivo y usar t√©cnicas como el **prefetching** en los eventos del usuario.

üîµ **Espec√≠fico**: Este es un concepto de arquitectura y optimizaci√≥n de rendimiento. No es una funci√≥n que llamas, sino una forma de pensar sobre el flujo de datos. Entender esta diferencia es clave para construir aplicaciones web de alto rendimiento.

---

## E - Otras Funcionalidades Experimentales y de Servidor ‚ö™

#### 1. **Introducci√≥n:**

React Query tambi√©n explora el futuro de React, ofreciendo integraciones experimentales para funcionalidades de vanguardia como Streaming SSR y el hook `React.use`.

#### 2. **Conceptos (¬°Manejar con Cuidado!)**

### **E.1 - Suspense en el Servidor con Streaming (`@tanstack/react-query-next-experimental`)**

- **¬øQu√© es?** Una forma de usar `useSuspenseQuery` en un componente de cliente (`'use client'`) dentro de Next.js, pero que la petici√≥n se haga en el servidor. El servidor env√≠a la p√°gina sin los datos, y luego "chorrea" (stream) los datos al cliente a medida que est√°n listos.
- **¬øPara qu√© sirve?** Para que el usuario vea la estructura de la p√°gina s√∫per r√°pido, sin tener que esperar a que todas las peticiones de datos del servidor terminen. Mejora el "Time to First Byte" (TTFB).
- **¬øC√≥mo se usa?** Envolviendo tu app en un proveedor especial llamado `ReactQueryStreamedHydration`.
- **Clasificaci√≥n:** ‚ö™ **Raramente usado / Espec√≠fico**: Es experimental y solo para usuarios de Next.js que quieran estar a la √∫ltima en renderizado en servidor. No es para uso general en producci√≥n todav√≠a.

### **E.2 - `useQuery().promise` y `React.use()`**

- **¬øQu√© es?** Una forma alternativa de activar Suspense. En lugar de usar `useSuspenseQuery`, usas el `useQuery` normal y luego pasas su propiedad `.promise` al nuevo hook de React, `React.use()`.
- **¬øPara qu√© sirve?** Permite una composici√≥n m√°s flexible, ya que puedes crear la query en un componente padre y pasar el objeto de la query a un componente hijo, que es el que finalmente consume la promesa y suspende.
- **¬øC√≥mo se usa?**

  ```jsx
  // Componente Padre
  const query = useQuery({ queryKey: ["todos"], queryFn: fetchTodos });
  return <TodoList query={query} />;

  // Componente Hijo
  function TodoList({ query }) {
    // React.use() lee la promesa y suspende si no est√° resuelta.
    const data = React.use(query.promise);
    return <ul>...</ul>;
  }
  ```

- **Clasificaci√≥n:** ‚ö™ **Raramente usado / Espec√≠fico**: Tanto `React.use()` como esta integraci√≥n son experimentales. Es un vistazo al futuro de React, pero no algo que debas usar en tus proyectos del d√≠a a d√≠a... ¬°a√∫n!

#### 3. **Desarrollo:**

Estas funcionalidades muestran que React Query no solo es una librer√≠a robusta, sino que tambi√©n est√° en constante evoluci√≥n y alineada con las futuras APIs de React. Es bueno saber que existen para entender hacia d√≥nde va el ecosistema, pero para la mayor√≠a de los proyectos actuales, es mejor ce√±irse a las APIs estables como `useSuspenseQuery`.

‚ö™ **Raramente usado**: Se clasifican as√≠ porque son expl√≠citamente experimentales. Su API podr√≠a cambiar y no se recomiendan para aplicaciones en producci√≥n a menos que sepas exactamente lo que est√°s haciendo y est√©s dispuesto a asumir el riesgo.
