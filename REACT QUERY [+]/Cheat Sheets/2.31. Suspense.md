## A - Suspense con React Query: ¡Adiós a los `isLoading`! 🟡

#### 1. **Introducción:**

Suspense te permite manejar los estados de carga de una forma mucho más elegante y centralizada, mostrando una UI de "reserva" (fallback) mientras tus datos se están cargando, en lugar de usar condicionales `isLoading` por todos lados.

#### 2. **Ejemplo:**

Imagina que tienes un componente que muestra una lista de tareas. Con Suspense, el código se ve así de limpio:

```jsx
import { Suspense } from "react";
import { useSuspenseQuery } from "@tanstack/react-query";

// 1. Este componente pide los datos. ¡Fíjate que no hay `isLoading` ni `error`!
function TodoList() {
  const { data } = useSuspenseQuery({
    queryKey: ["todos"],
    queryFn: fetchTodos,
  });

  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  );
}

// 2. Este es el componente principal que usa Suspense.
function App() {
  return (
    <div>
      <h1>Mis Tareas</h1>
      {/* 3. Aquí está la magia. */}
      <Suspense fallback={<div>🌀 Cargando tareas...</div>}>
        <TodoList />
      </Suspense>
    </div>
  );
}
```

**Explicación del ejemplo:**

1.  **`TodoList`**: Este componente usa `useSuspenseQuery`. Nota que solo extraemos `data`. No necesitamos `isLoading`, `isPending` o `error`. `useSuspenseQuery` es el "chivato": si los datos no están listos, le avisa a React.
2.  **`App`**: Aquí es donde orquestamos todo.
3.  **`<Suspense>`**: Este es el componente de React que actúa como un guardia. "Escucha" si algún componente hijo (como `TodoList`) le avisa que está "suspendido" (cargando datos). Si es así, en lugar de renderizar `TodoList`, muestra lo que le hayamos puesto en la prop `fallback` (en este caso, un simple div con "🌀 Cargando tareas..."). Cuando `useSuspenseQuery` por fin tiene los datos, Suspense lo sabe y reemplaza el `fallback` por el componente `TodoList` ya renderizado con su información.

**¡Una cosa menos de la que preocuparte!** Los errores se manejan de forma similar, pero con un componente llamado "Error Boundary", que actúa como una red de seguridad.

#### 3. **Desarrollo:**

Cuando usas los hooks dedicados para Suspense (`useSuspenseQuery`, `useSuspenseInfiniteQuery`, `useSuspenseQueries`), React Query cambia su comportamiento. En lugar de darte estados como `isLoading` para que tú los gestiones manualmente con un `if`, simplemente "pausa" el renderizado del componente y le cede el control a React.

Esto tiene una ventaja enorme, sobre todo con TypeScript: como el componente solo se renderiza cuando los datos ya están disponibles, ¡puedes estar 100% seguro de que `data` no será `undefined`! Se acabaron las comprobaciones `if (data) { ... }`.

**⚠️ ¡Ojo al dato!** Esta forma de trabajar tiene dos implicaciones importantes:

- **No puedes desactivar una query condicionalmente**: El hook _debe_ ejecutarse siempre.
- **No existe `placeholderData`**: Para evitar que la UI se reemplace por el `fallback` en una actualización, debes envolver tus actualizaciones en `startTransition`, una herramienta de React para transiciones suaves.

🟡 **Importante**: Suspense es un patrón moderno y muy potente en React. Aunque puedes usar React Query perfectamente sin él, entenderlo te permitirá escribir componentes más limpios y declarativos, que es hacia donde se dirige el ecosistema de React.

---

## B - `throwOnError`: El Guardián de Errores que Piensa en el Usuario 🔵

#### 1. **Introducción:**

Por defecto, `useSuspenseQuery` es listo y no lanza un error si ya tiene datos viejos (cacheados) para mostrar, priorizando la experiencia de usuario sobre mostrar una pantalla de error por un fallo en segundo plano.

#### 2. **Ejemplo:**

Esta es la regla que sigue React Query por defecto:

```javascript
// "Solo lanza un error si de verdad no tengo NADA de datos (`data` es undefined)"
throwOnError: (error, query) => typeof query.state.data === "undefined";
```

Si quieres que **SIEMPRE** se lance un error, incluso si hay datos viejos, tienes que hacerlo tú mismo:

```jsx
import { useSuspenseQuery } from "@tanstack/react-query";

function ComponenteSensible() {
  const { data, error, isFetching } = useSuspenseQuery({ queryKey, queryFn });

  // Si hay un error Y no estamos intentando solucionarlo ahora mismo...
  if (error && !isFetching) {
    // ...¡lanza el error para que lo atrape el Error Boundary!
    throw error;
  }

  // Si todo va bien, renderiza los datos (que podrían ser viejos, pero es mejor que nada).
  return <div>{data.titulo}</div>;
}
```

**Explicación del ejemplo:**

Imagina que entras a la app y los datos cargan bien. Luego, navegas por otras partes y vuelves. React Query intenta refrescar los datos en segundo plano, pero esta vez la API falla.

- **Comportamiento por defecto**: No verás una pantalla de error. Seguirás viendo los datos de la primera vez (aunque estén "stale" o desactualizados), porque es mejor que romper la página.
- **Comportamiento forzado (nuestro ejemplo)**: El código `if (error && !isFetching) { throw error }` dice: "No me importa si tienes datos viejos. Si hubo un error al refrescar, quiero que la app se rompa y muestre la pantalla de error". Esto puede ser útil en partes muy críticas donde los datos deben ser siempre frescos.

#### 3. **Desarrollo:**

La filosofía detrás de `throwOnError` es simple: **no molestar al usuario innecesariamente**. Un error en una recarga de datos en segundo plano (background refetch) a menudo es temporal. Mostrar una pantalla de error completa cuando ya tienes contenido visible en pantalla puede ser una experiencia frustrante. Por eso, React Query prefiere ser conservador. Si quieres un comportamiento más agresivo con los errores, debes ser explícito y lanzarlos tú.

🔵 **Específico**: Este es un concepto que necesitas entender bien si vas a implementar una estrategia de errores robusta con Suspense. No es algo que toques todos los días, pero cuando lo necesites, es crucial saber por qué funciona así y cómo puedes cambiarlo.

---

## C - Reseteando Errores: El Botón de "Intentar de Nuevo" 🟡

#### 1. **Introducción:**

Cuando una query falla y tu `ErrorBoundary` muestra un mensaje de error, necesitas una forma de decirle a React Query: "¡Oye, quiero volver a intentar esa petición que falló!". Para eso existen estas herramientas.

#### 2. **Comparativa: Las Dos Formas de Resetear**

Aquí es donde la cosa se pone interesante. Tienes dos herramientas que parecen similares, pero sirven para propósitos ligeramente distintos. ¡Que no cunda el pánico, es más fácil de lo que parece!

### **C.1 - `QueryErrorResetBoundary`: La "Zona de Reseteo"**

Piensa en esto como si dibujaras un círculo en el suelo y dijeras: "Cualquier error de query que ocurra **dentro de este círculo** se podrá resetear con un botón especial".

**Ejemplo:**

```jsx
import { QueryErrorResetBoundary } from "@tanstack/react-query";
import { ErrorBoundary } from "react-error-boundary"; // Una librería popular para Error Boundaries

const App = () => (
  // 1. Dibujamos el círculo con QueryErrorResetBoundary
  <QueryErrorResetBoundary>
    {(
      { reset } // 2. Nos da una función `reset`
    ) => (
      <ErrorBoundary
        onReset={reset} // 3. Le pasamos esa función al ErrorBoundary
        fallbackRender={({ resetErrorBoundary }) => (
          <div>
            ¡Houston, tenemos un problema!
            {/* 4. Este botón ahora resetea tanto el error en React como la query en React Query */}
            <button onClick={() => resetErrorBoundary()}>
              Intentar de nuevo
            </button>
          </div>
        )}
      >
        <MiComponenteConQuery />
      </ErrorBoundary>
    )}
  </QueryErrorResetBoundary>
);
```

**Explicación del ejemplo:**

1.  `QueryErrorResetBoundary` envuelve la parte de tu app que quieres proteger.
2.  Provee una función `reset` a sus hijos.
3.  Conectamos esa función `reset` a la prop `onReset` de nuestro `ErrorBoundary`.
4.  Cuando el usuario hace clic en el botón, `resetErrorBoundary` llama a la función `reset` que le pasamos, y ¡voilà! React Query sabe que debe reintentar las queries que fallaron dentro de ese `QueryErrorResetBoundary`.

### **C.2 - `useQueryErrorResetBoundary`: El "Control Remoto"**

Este hook es más simple. No crea una nueva "zona", sino que te da un control remoto (`reset`) para la zona de reseteo más cercana que encuentre por encima de él en el árbol de componentes.

**Ejemplo:**

```jsx
import { useQueryErrorResetBoundary } from '@tanstack/react-query';
import { ErrorBoundary } from 'react-error-boundary';

// Imagina que en un componente superior ya tienes un <QueryErrorResetBoundary>
const MiComponente = () => {
  // 1. Obtenemos el "control remoto" con el hook.
  const { reset } = useQueryErrorResetBoundary();

  return (
    <ErrorBoundary
      onReset={reset} // 2. Lo conectamos directamente.
      fallbackRender={/* ... igual que antes ... */}
    >
      <OtroComponenteConQuery />
    </ErrorBoundary>
  );
};
```

**Explicación del ejemplo:**

1.  Llamamos al hook `useQueryErrorResetBoundary` y nos da la función `reset`.
2.  La pasamos a `onReset`. Este `reset` buscará el `QueryErrorResetBoundary` más cercano "hacia arriba" y lo activará. Si no encuentra ninguno, reseteará los errores de forma global.

#### 3. **Desarrollo y Cuándo Usar Cada Uno:**

- Usa **`<QueryErrorResetBoundary>`** cuando quieras **definir una nueva frontera o zona de reseteo**. Es perfecto para envolver "widgets" o secciones independientes de tu aplicación.
- Usa **`useQueryErrorResetBoundary`** por **conveniencia** dentro de un componente que ya sabes que está dentro de una `QueryErrorResetBoundary`. Es más limpio y directo.

🟡 **Importante**: Si usas Suspense para manejar datos, manejar los errores y permitir que el usuario los resetee no es opcional, ¡es una parte fundamental de una buena experiencia de usuario! Debes dominar al menos una de estas dos técnicas.

---

## D - Fetch-on-render vs. Render-as-you-fetch: ¿Cuándo Pides la Comida? 🔵

#### 1. **Introducción:**

Estos son dos patrones o estrategias sobre **cuándo** empezar a cargar los datos, lo que tiene un gran impacto en la velocidad percibida de tu aplicación.

#### 2. **Comparativa: Las Dos Estrategias**

Imagina que vas a un restaurante.

### **D.1 - Fetch-on-render (Pedir en la Mesa)**

Esta es la estrategia más común y la que React Query con Suspense hace por defecto.

- **El Proceso:**
  1.  El usuario hace clic en un enlace.
  2.  React empieza a renderizar la nueva página (`on-render`).
  3.  Dentro del componente, `useSuspenseQuery` se ejecuta y se da cuenta de que necesita datos.
  4.  **AHORA** es cuando empieza a pedirlos a la API (`fetch`).
  5.  El usuario ve una pantalla de carga mientras espera.

Es como llegar al restaurante, sentarte en la mesa, mirar el menú y **entonces** llamar al camarero para pedir. Es secuencial y funciona, pero hay un tiempo de espera inevitable.

### **D.2 - Render-as-you-fetch (Pedir de Camino al Restaurante)**

Esta es una estrategia más avanzada y proactiva que hace que tu app se sienta instantánea.

- **El Proceso:**
  1.  El usuario hace clic en un enlace.
  2.  **INMEDIATAMENTE**, antes de empezar a renderizar la página, lanzas la petición a la API. Esto se hace a menudo con la función `prefetchQuery` de React Query en el evento `onClick` o `onMouseEnter` del enlace.
  3.  **MIENTRAS** los datos se van cargando en segundo plano, React empieza a renderizar la nueva página (`as-you-fetch`).
  4.  Para cuando `useSuspenseQuery` se ejecuta, es muy probable que los datos ya estén en la caché, listos para ser mostrados.
  5.  El usuario no ve (o ve por muy poco tiempo) la pantalla de carga.

Es como usar la app del restaurante para pedir tu comida **mientras vas de camino**. Cuando llegas, ¡tu pedido ya está casi listo en la mesa!

#### 3. **Desarrollo:**

React Query te da las herramientas para implementar ambas estrategias. "Fetch-on-render" es el comportamiento por defecto y no requiere configuración extra. Para lograr "Render-as-you-fetch", que es el ideal de rendimiento, necesitas ser proactivo y usar técnicas como el **prefetching** en los eventos del usuario.

🔵 **Específico**: Este es un concepto de arquitectura y optimización de rendimiento. No es una función que llamas, sino una forma de pensar sobre el flujo de datos. Entender esta diferencia es clave para construir aplicaciones web de alto rendimiento.

---

## E - Otras Funcionalidades Experimentales y de Servidor ⚪

#### 1. **Introducción:**

React Query también explora el futuro de React, ofreciendo integraciones experimentales para funcionalidades de vanguardia como Streaming SSR y el hook `React.use`.

#### 2. **Conceptos (¡Manejar con Cuidado!)**

### **E.1 - Suspense en el Servidor con Streaming (`@tanstack/react-query-next-experimental`)**

- **¿Qué es?** Una forma de usar `useSuspenseQuery` en un componente de cliente (`'use client'`) dentro de Next.js, pero que la petición se haga en el servidor. El servidor envía la página sin los datos, y luego "chorrea" (stream) los datos al cliente a medida que están listos.
- **¿Para qué sirve?** Para que el usuario vea la estructura de la página súper rápido, sin tener que esperar a que todas las peticiones de datos del servidor terminen. Mejora el "Time to First Byte" (TTFB).
- **¿Cómo se usa?** Envolviendo tu app en un proveedor especial llamado `ReactQueryStreamedHydration`.
- **Clasificación:** ⚪ **Raramente usado / Específico**: Es experimental y solo para usuarios de Next.js que quieran estar a la última en renderizado en servidor. No es para uso general en producción todavía.

### **E.2 - `useQuery().promise` y `React.use()`**

- **¿Qué es?** Una forma alternativa de activar Suspense. En lugar de usar `useSuspenseQuery`, usas el `useQuery` normal y luego pasas su propiedad `.promise` al nuevo hook de React, `React.use()`.
- **¿Para qué sirve?** Permite una composición más flexible, ya que puedes crear la query en un componente padre y pasar el objeto de la query a un componente hijo, que es el que finalmente consume la promesa y suspende.
- **¿Cómo se usa?**

  ```jsx
  // Componente Padre
  const query = useQuery({ queryKey: ["todos"], queryFn: fetchTodos });
  return <TodoList query={query} />;

  // Componente Hijo
  function TodoList({ query }) {
    // React.use() lee la promesa y suspende si no está resuelta.
    const data = React.use(query.promise);
    return <ul>...</ul>;
  }
  ```

- **Clasificación:** ⚪ **Raramente usado / Específico**: Tanto `React.use()` como esta integración son experimentales. Es un vistazo al futuro de React, pero no algo que debas usar en tus proyectos del día a día... ¡aún!

#### 3. **Desarrollo:**

Estas funcionalidades muestran que React Query no solo es una librería robusta, sino que también está en constante evolución y alineada con las futuras APIs de React. Es bueno saber que existen para entender hacia dónde va el ecosistema, pero para la mayoría de los proyectos actuales, es mejor ceñirse a las APIs estables como `useSuspenseQuery`.

⚪ **Raramente usado**: Se clasifican así porque son explícitamente experimentales. Su API podría cambiar y no se recomiendan para aplicaciones en producción a menos que sepas exactamente lo que estás haciendo y estés dispuesto a asumir el riesgo.
