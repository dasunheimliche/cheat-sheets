## A - `invalidateQueries`: El Bot√≥n de "Refrescar" para tus Datos üî¥

#### 1. **Introducci√≥n:**

Esta es la herramienta m√°gica que usas para decirle a TanStack Query: "¬°Oye, esta informaci√≥n que tienes guardada ya no sirve, por favor, ve a buscar la versi√≥n m√°s reciente!".

#### 2. **Ejemplo:**

Imagina que tienes una lista de tareas (los famosos "todos") y el usuario acaba de a√±adir una nueva tarea llamada "Aprender TanStack Query". Justo despu√©s de que la nueva tarea se guarda en el servidor, quieres que la lista que se ve en pantalla se actualice.

```javascript
// Dentro de la funci√≥n que se ejecuta cuando el formulario de "a√±adir tarea" se env√≠a con √©xito...

// 1. Primero, obtenemos acceso al "cerebro" de TanStack Query
const queryClient = useQueryClient();

// ...l√≥gica para enviar la nueva tarea al servidor...

// 2. Una vez que el servidor confirma que la tarea se guard√≥,
// le decimos a TanStack Query que cualquier dato con la clave 'todos' est√° obsoleto.
queryClient.invalidateQueries({ queryKey: ["todos"] });
```

**Explicaci√≥n del ejemplo:**
Al llamar a `invalidateQueries({ queryKey: ['todos'] })`, no estamos borrando datos ni nada por el estilo. Simplemente estamos poniendo una "bandera roja" üö© en todas las consultas que comiencen con la clave `['todos']`. TanStack Query ve esa bandera y, si hay alg√∫n componente en tu app mostrando esos datos, autom√°ticamente ir√° a buscarlos de nuevo al servidor para tener la lista fresca y actualizada, incluyendo "Aprender TanStack Query".

#### 3. **Desarrollo**:

Pi√©nsalo as√≠: esperar a que los datos se vuelvan "viejos" por s√≠ solos (`staleTime`) est√° bien para informaci√≥n que no cambia muy a menudo. Pero cuando el _propio usuario_ hace un cambio (a√±adir, editar, borrar algo), t√∫ _sabes_ con un 100% de certeza que los datos que tienes en cach√© est√°n desactualizados. `invalidateQueries` es tu forma de actuar inmediatamente sobre ese conocimiento.

Cuando invalidas una consulta, ocurren dos cosas clave:

1.  **Se marca como `stale` (obsoleta):** Esto es como decirle "tu fecha de caducidad acaba de expirar, sin importar lo que dijera antes". Ignora cualquier `staleTime` que hubieras configurado.
2.  **Se vuelve a pedir (refetch):** Si la consulta est√° siendo usada en alg√∫n lugar de tu aplicaci√≥n en ese momento, se disparar√° una nueva petici√≥n en segundo plano para obtener los datos frescos.

La filosof√≠a de TanStack Query es: en lugar de que t√∫ intentes "adivinar" c√≥mo meter el nuevo dato en la lista que ya tienes (lo que puede ser complicado y propenso a errores), es m√°s f√°cil y seguro simplemente decirle a la librer√≠a: "los datos de la lista de tareas est√°n mal, tr√°elos de nuevo". Es un enfoque m√°s simple y robusto.

üî¥ **Fundamental**: Este es el pan de cada d√≠a cuando trabajas con datos que cambian (mutaciones). Si los usuarios pueden modificar datos en tu app, usar√°s `invalidateQueries` constantemente. Es una pieza central de la librer√≠a.

---

## B - `Query Matching`: C√≥mo Apuntar con Precisi√≥n L√°ser üéØ üü°

#### 1. **Introducci√≥n:**

`invalidateQueries` no es una herramienta de "todo o nada"; te permite ser incre√≠blemente espec√≠fico sobre _qu√©_ consultas quieres invalidar usando diferentes formas de "Query Matching" (coincidencia de consultas).

#### 2. **Desarrollo - Las 3 Formas Principales de Apuntar:**

Vamos a desglosar las formas m√°s comunes de usarlo, de la m√°s amplia a la m√°s espec√≠fica. Imagina que tus `queryKey` son como direcciones de carpetas en tu ordenador.

---

### B.1 - Coincidencia por Prefijo: La Red de Pesca üé£

Esto es como decir "invalida todo lo que est√© dentro de la carpeta `['todos']` y sus subcarpetas". Es la forma m√°s com√∫n y, a menudo, la m√°s √∫til.

**Ejemplo:**

```javascript
// Invalida CUALQUIER consulta cuya clave EMPIECE por ['todos']
queryClient.invalidateQueries({ queryKey: ["todos"] });

// --- Las siguientes consultas ser√≠an invalidadas por la l√≠nea de arriba ---

// 1. La lista general de tareas
useQuery({ queryKey: ["todos"], queryFn: fetchAllTodos });

// 2. La p√°gina 2 de la lista de tareas
useQuery({ queryKey: ["todos", { page: 2 }], queryFn: fetchTodosPage2 });

// 3. La lista de tareas completadas
useQuery({
  queryKey: ["todos", { status: "completed" }],
  queryFn: fetchCompletedTodos,
});
```

**Explicaci√≥n del ejemplo:**
Al usar `['todos']` como clave de invalidaci√≥n, est√°s lanzando una red amplia. No importa si la consulta era para la lista general, una p√°gina espec√≠fica o un filtro concreto. Si su "direcci√≥n" empieza por `['todos']`, ser√° marcada como obsoleta y se recargar√°.

üü° **Importante**: Usar√°s esta t√©cnica el 90% del tiempo. Cuando un usuario a√±ade o elimina una tarea, lo m√°s seguro es que quieras que _todas_ las vistas de tareas se actualicen para reflejar ese cambio, sin importar c√≥mo est√©n filtradas o paginadas.

---

### B.2 - Coincidencia Exacta: El Bistur√≠ del Cirujano üî™

A veces, la red de pesca es demasiado. Quieres invalidar _√∫nicamente_ una consulta espec√≠fica, sin tocar a sus "familiares". Para eso, a√±ades la opci√≥n `exact: true`.

**Ejemplo:**

```javascript
// Invalida SOLAMENTE la consulta cuya clave sea EXACTAMENTE ['todos']
queryClient.invalidateQueries({ queryKey: ["todos"], exact: true });

// --- ¬øQu√© pasa con nuestras consultas? ---

// 1. La lista general de tareas (clave: ['todos'])
//    ‚úÖ ¬°ESTA S√ç SE INVALIDA! Coincide perfectamente.
useQuery({ queryKey: ["todos"], queryFn: fetchAllTodos });

// 2. La p√°gina 2 de la lista de tareas (clave: ['todos', { page: 2 }])
//    ‚ùå ¬°ESTA NO SE INVALIDA! No es una coincidencia exacta.
useQuery({ queryKey: ["todos", { page: 2 }], queryFn: fetchTodosPage2 });
```

**Explicaci√≥n del ejemplo:**
Con `exact: true`, eres un francotirador. Solo la consulta cuya `queryKey` es id√©ntica, elemento por elemento, a `['todos']` ser√° invalidada. Cualquier otra consulta que tenga algo m√°s en su clave (como `{ page: 2 }`) ser√° ignorada.

üîµ **Espec√≠fico**: Esto es menos com√∫n, pero muy √∫til en escenarios concretos. Por ejemplo, si tienes una acci√≥n que solo afecta a un resumen general (la consulta `['todos']`) pero no deber√≠a provocar que se recarguen todas las listas paginadas o filtradas, que pueden ser peticiones m√°s "caras".

---

### B.3 - Coincidencia por Predicado: El Filtro Personalizado üïµÔ∏è‚Äç‚ôÇÔ∏è

Esta es la opci√≥n para el control total. En lugar de una clave, le pasas una funci√≥n (un "predicado") que decide, consulta por consulta, si debe ser invalidada o no.

**Ejemplo:**

Imagina que est√°s versionando tu API. Quieres invalidar todas las consultas de `todos` que se hicieron con una versi√≥n de API antigua (menor a la v10).

```javascript
// Invalida consultas seg√∫n una regla personalizada
queryClient.invalidateQueries({
  predicate: (query) => {
    // La regla es:
    // 1. ¬øEs una consulta de 'todos'?
    const isTodosQuery = query.queryKey[0] === "todos";
    // 2. ¬øTiene detalles de versi√≥n y esa versi√≥n es >= 10?
    const hasModernVersion = query.queryKey[1]?.version >= 10;

    // Invalida si es una consulta de 'todos' Y tiene una versi√≥n moderna.
    return isTodosQuery && hasModernVersion;
  },
});

// --- ¬øQu√© pasa con nuestras consultas? ---

// Consulta con versi√≥n 20 -> ‚úÖ ¬°SE INVALIDA! (cumple la regla)
useQuery({ queryKey: ["todos", { version: 20 }], queryFn: fetchTodos });

// Consulta con versi√≥n 5 -> ‚ùå ¬°NO SE INVALIDA! (no cumple la regla)
useQuery({ queryKey: ["todos", { version: 5 }], queryFn: fetchTodos });
```

**Explicaci√≥n del ejemplo:**
La funci√≥n `predicate` recibe cada consulta (`query`) que existe en la cach√©. T√∫ escribes la l√≥gica dentro. Si tu funci√≥n devuelve `true` para una consulta, se invalida. Si devuelve `false`, se ignora. En el ejemplo, solo invalidamos las que son de `todos` y cuya versi√≥n (almacenada en el segundo elemento de la clave) es 10 o superior.

üîµ **Espec√≠fico**: Esta es tu arma secreta para casos complejos. No la necesitar√°s todos los d√≠as, pero cuando te enfrentes a una l√≥gica de invalidaci√≥n realmente enrevesada, te alegrar√°s de saber que existe. Es el m√°ximo nivel de granularidad.
