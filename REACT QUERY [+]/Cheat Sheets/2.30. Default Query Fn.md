## A - Default Query Function: Tu "Mayordomo" de Datos Personal 🟡

#### 1. **Introducción:**

Imagina tener una única función "ayudante" que se encargue de todas tus peticiones de datos, para que no tengas que escribir la misma lógica de `axios.get` o `fetch` una y otra vez en cada componente.

#### 2. **Ejemplo:**

Pensemos en esto en dos partes: primero, la **configuración inicial** (que haces una sola vez) y segundo, el **uso diario** (que es súper simple).

```tsx
// --- PARTE 1: La Configuración (en tu archivo principal como App.jsx) ---

// 1. CREAMOS NUESTRO "MAYORDOMO" DE DATOS
// Esta función recibirá la "queryKey" y la usará para saber qué buscar.
const defaultQueryFn = async ({ queryKey }) => {
  // ¡Ojo aquí! queryKey es un array. Usamos el primer elemento
  // como la parte de la URL que cambia (ej: '/posts' o '/users').
  const endpoint = queryKey[0];
  const { data } = await axios.get(
    `https://jsonplaceholder.typicode.com${endpoint}`
  );
  return data;
};

// 2. LE DECIMOS A TANSTACK QUERY QUE USE NUESTRO MAYORDOMO
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // ¡Esta es la magia! Le asignamos nuestra función por defecto.
      queryFn: defaultQueryFn,
    },
  },
});

// 3. PROVEEMOS LA CONFIGURACIÓN A TODA LA APP
function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
    </QueryClientProvider>
  );
}

// --- PARTE 2: El Uso Diario (en cualquier componente) ---

// Ahora, para buscar posts, solo necesitas la "queryKey". ¡Nada de "queryFn"!
function Posts() {
  const { data, isFetching } = useQuery({ queryKey: ["/posts"] });
  // ... tu lógica para mostrar los posts
}

// Incluso para peticiones dinámicas, solo pasas la key y tus opciones.
function Post({ postId }) {
  const { data, isFetching } = useQuery({
    queryKey: [`/posts/${postId}`], // La key dinámica
    enabled: !!postId, // Puedes seguir usando otras opciones
  });
  // ... tu lógica para mostrar un solo post
}
```

**Explicación del ejemplo:**

- **Paso 1: El Mayordomo (`defaultQueryFn`)**: Creamos una función que sabe cómo hablar con nuestra API. Su única instrucción es: "Toma el primer elemento de la `queryKey` que te den (por ejemplo, `'/posts'`) y pégalo al final de la URL base de la API para hacer la petición".
- **Paso 2: La Configuración Central (`QueryClient`)**: Aquí es donde le "presentamos" nuestro mayordomo a TanStack Query. Le decimos: "Oye, a partir de ahora, si alguien usa `useQuery` y no me especifica una función para buscar datos (`queryFn`), por favor, usa este `defaultQueryFn` que te acabo de dar".
- **Paso 3: El Uso Simplificado (`useQuery`)**: ¡Esta es la recompensa! Ahora, en nuestros componentes, ya no necesitamos escribir la lógica de `axios` una y otra vez. Simplemente le decimos a `useQuery` _qué_ queremos con la `queryKey`, y él automáticamente usará nuestro "mayordomo" para ir a buscarlo. ¡Código más limpio y menos repetitivo!

#### 3. **Desarrollo**:

El propósito de una `Default Query Function` es aplicar el principio **DRY (Don't Repeat Yourself - No te repitas)**. En lugar de tener docenas de funciones `queryFn` esparcidas por tu aplicación que hacen casi lo mismo (llamar a un endpoint con `axios` o `fetch`), centralizas esa lógica en un solo lugar.

**Anticipando tus dudas (¡porque me obsesiona que lo entiendas todo!):**

- **"¿Y si una petición es diferente y no puede usar esa función por defecto?"**
  ¡Excelente pregunta! No hay problema. Si en un componente específico necesitas una lógica de fetching completamente distinta (quizás usa `POST`, o llama a otra API, o procesa los datos de forma rara), simplemente **puedes anular el comportamiento por defecto** escribiendo la `queryFn` directamente en ese `useQuery`, como lo harías normalmente. El `defaultQueryFn` solo actúa cuando _no_ proporcionas una `queryFn`.

  ```tsx
  // Este useQuery IGNORARÁ la función por defecto porque le damos una propia.
  const { data } = useQuery({
    queryKey: ["special-data"],
    queryFn: async () => {
      const response = await fetch("https://api.diferente.com/data");
      return response.json();
    },
  });
  ```

- **"¿Por qué `queryKey` es un array `['/posts']` y no solo un string `'posts'`?"**
  Porque las `queryKey` están diseñadas para ser descriptivas y únicas. El formato de array te permite añadir más detalles para identificar una query. Por ejemplo, `['/posts', 10]` podría ser la página 10 de los posts, y `['/posts', { category: 'react' }]` podría ser los posts de la categoría React. Nuestra función por defecto es simple y solo usa el primer elemento (`queryKey[0]`), pero esta estructura de array le da a TanStack Query un poder inmenso para gestionar el caché.

🟡 **Importante**: Esta técnica es altamente recomendada porque centraliza la lógica de fetching, haciendo tu código muchísimo más limpio, fácil de mantener y menos propenso a errores por copiar y pegar. Es una práctica estándar en aplicaciones de cualquier tamaño que hagan más de una o dos llamadas a una API.
