## A - Default Query Function: Tu "Mayordomo" de Datos Personal 

#### 1. **Introducci贸n:**

Imagina tener una 煤nica funci贸n "ayudante" que se encargue de todas tus peticiones de datos, para que no tengas que escribir la misma l贸gica de `axios.get` o `fetch` una y otra vez en cada componente.

#### 2. **Ejemplo:**

Pensemos en esto en dos partes: primero, la **configuraci贸n inicial** (que haces una sola vez) y segundo, el **uso diario** (que es s煤per simple).

```tsx
// --- PARTE 1: La Configuraci贸n (en tu archivo principal como App.jsx) ---

// 1. CREAMOS NUESTRO "MAYORDOMO" DE DATOS
// Esta funci贸n recibir谩 la "queryKey" y la usar谩 para saber qu茅 buscar.
const defaultQueryFn = async ({ queryKey }) => {
  // 隆Ojo aqu铆! queryKey es un array. Usamos el primer elemento
  // como la parte de la URL que cambia (ej: '/posts' o '/users').
  const endpoint = queryKey[0];
  const { data } = await axios.get(
    `https://jsonplaceholder.typicode.com${endpoint}`
  );
  return data;
};

// 2. LE DECIMOS A TANSTACK QUERY QUE USE NUESTRO MAYORDOMO
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // 隆Esta es la magia! Le asignamos nuestra funci贸n por defecto.
      queryFn: defaultQueryFn,
    },
  },
});

// 3. PROVEEMOS LA CONFIGURACIN A TODA LA APP
function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <YourApp />
    </QueryClientProvider>
  );
}

// --- PARTE 2: El Uso Diario (en cualquier componente) ---

// Ahora, para buscar posts, solo necesitas la "queryKey". 隆Nada de "queryFn"!
function Posts() {
  const { data, isFetching } = useQuery({ queryKey: ["/posts"] });
  // ... tu l贸gica para mostrar los posts
}

// Incluso para peticiones din谩micas, solo pasas la key y tus opciones.
function Post({ postId }) {
  const { data, isFetching } = useQuery({
    queryKey: [`/posts/${postId}`], // La key din谩mica
    enabled: !!postId, // Puedes seguir usando otras opciones
  });
  // ... tu l贸gica para mostrar un solo post
}
```

**Explicaci贸n del ejemplo:**

- **Paso 1: El Mayordomo (`defaultQueryFn`)**: Creamos una funci贸n que sabe c贸mo hablar con nuestra API. Su 煤nica instrucci贸n es: "Toma el primer elemento de la `queryKey` que te den (por ejemplo, `'/posts'`) y p茅galo al final de la URL base de la API para hacer la petici贸n".
- **Paso 2: La Configuraci贸n Central (`QueryClient`)**: Aqu铆 es donde le "presentamos" nuestro mayordomo a TanStack Query. Le decimos: "Oye, a partir de ahora, si alguien usa `useQuery` y no me especifica una funci贸n para buscar datos (`queryFn`), por favor, usa este `defaultQueryFn` que te acabo de dar".
- **Paso 3: El Uso Simplificado (`useQuery`)**: 隆Esta es la recompensa! Ahora, en nuestros componentes, ya no necesitamos escribir la l贸gica de `axios` una y otra vez. Simplemente le decimos a `useQuery` _qu茅_ queremos con la `queryKey`, y 茅l autom谩ticamente usar谩 nuestro "mayordomo" para ir a buscarlo. 隆C贸digo m谩s limpio y menos repetitivo!

#### 3. **Desarrollo**:

El prop贸sito de una `Default Query Function` es aplicar el principio **DRY (Don't Repeat Yourself - No te repitas)**. En lugar de tener docenas de funciones `queryFn` esparcidas por tu aplicaci贸n que hacen casi lo mismo (llamar a un endpoint con `axios` o `fetch`), centralizas esa l贸gica en un solo lugar.

**Anticipando tus dudas (隆porque me obsesiona que lo entiendas todo!):**

- **"驴Y si una petici贸n es diferente y no puede usar esa funci贸n por defecto?"**
  隆Excelente pregunta! No hay problema. Si en un componente espec铆fico necesitas una l贸gica de fetching completamente distinta (quiz谩s usa `POST`, o llama a otra API, o procesa los datos de forma rara), simplemente **puedes anular el comportamiento por defecto** escribiendo la `queryFn` directamente en ese `useQuery`, como lo har铆as normalmente. El `defaultQueryFn` solo act煤a cuando _no_ proporcionas una `queryFn`.

  ```tsx
  // Este useQuery IGNORAR la funci贸n por defecto porque le damos una propia.
  const { data } = useQuery({
    queryKey: ["special-data"],
    queryFn: async () => {
      const response = await fetch("https://api.diferente.com/data");
      return response.json();
    },
  });
  ```

- **"驴Por qu茅 `queryKey` es un array `['/posts']` y no solo un string `'posts'`?"**
  Porque las `queryKey` est谩n dise帽adas para ser descriptivas y 煤nicas. El formato de array te permite a帽adir m谩s detalles para identificar una query. Por ejemplo, `['/posts', 10]` podr铆a ser la p谩gina 10 de los posts, y `['/posts', { category: 'react' }]` podr铆a ser los posts de la categor铆a React. Nuestra funci贸n por defecto es simple y solo usa el primer elemento (`queryKey[0]`), pero esta estructura de array le da a TanStack Query un poder inmenso para gestionar el cach茅.

 **Importante**: Esta t茅cnica es altamente recomendada porque centraliza la l贸gica de fetching, haciendo tu c贸digo much铆simo m谩s limpio, f谩cil de mantener y menos propenso a errores por copiar y pegar. Es una pr谩ctica est谩ndar en aplicaciones de cualquier tama帽o que hagan m谩s de una o dos llamadas a una API.
