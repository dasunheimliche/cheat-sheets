## A - Batching (Loteo) de Actualizaciones de Estado

#### 1. **DefiniciÃ³n:**

Imagina que eres un camarero en un restaurante muy concurrido. ğŸ½ï¸ En lugar de correr a la cocina cada vez que un cliente pide algo, esperas a que te den toda la orden completa, Â¿verdad? Â¡Eso es batching! React hace algo parecido con las actualizaciones de estado. **Batching** es cuando React agrupa varias actualizaciones de estado en una sola "hornada" antes de volver a renderizar la pantalla. Esto hace que tu app sea mucho mÃ¡s rÃ¡pida y eficiente. ğŸš€

#### 2. **Ejemplo:**

Mira este botÃ³n que deberÃ­a sumar 3 al contador:

```jsx
import { useState } from "react";

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 1);
          setNumber(number + 1);
          setNumber(number + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

**Resultado al hacer clic (la primera vez):**

```
1
```

**ExplicaciÃ³n del ejemplo:**

Aunque llamamos `setNumber(number + 1)` tres veces, Â¡solo se incrementa una vez! Â¿Por quÃ©? ğŸ¤” Porque React hace **batching**. Cuando haces clic, React espera a que **todo el cÃ³digo dentro del `onClick` termine de ejecutarse** antes de procesar las actualizaciones de estado. En este caso, para cuando React procesa, todas las llamadas `setNumber` se han hecho, pero como `number` se mantiene `0` durante este evento (recuerda, Â¡es como una foto fija! ğŸ“¸), React bÃ¡sicamente ve esto:

```javascript
setNumber(0 + 1); // Intento 1: "Quiero que el estado sea 1"
setNumber(0 + 1); // Intento 2: "Quiero que el estado sea 1" (otra vez)
setNumber(0 + 1); // Intento 3: "Quiero que el estado sea 1" (otra vez)
```

Al final, React solo hace caso a la Ãºltima instrucciÃ³n efectiva y actualiza el estado a `1` **una sola vez** despuÃ©s de que el evento `onClick` termina. Â¡Es como si el camarero solo apuntara el Ãºltimo plato que le pediste! ğŸ˜…

#### 3. **Notas o advertencias:**

- **Velocidad y eficiencia:** El batching es genial porque hace que tu app sea mÃ¡s rÃ¡pida al evitar renderizados innecesarios. ğŸï¸
- **Eventos separados:** React solo hace batching dentro del mismo evento (como un `onClick`). Si tienes varios clics separados, no se agrupan. Cada clic se procesa por separado. ğŸ–±ï¸ğŸ–±ï¸ Â¡Cada clic es una "orden" diferente para nuestro camarero React!

---

## B - Actualizando el mismo estado varias veces (Â¡con funciones!)

#### 1. **DefiniciÃ³n:**

A veces, necesitas actualizar el mismo estado varias veces **dentro del mismo evento** y quieres que cada actualizaciÃ³n se tenga en cuenta. Para esto, en lugar de pasar el _nuevo valor_ directamente a `setNumber`, le pasas una **funciÃ³n**. Esta funciÃ³n recibe el valor de estado _anterior_ (el mÃ¡s reciente en la cola de actualizaciones) y devuelve el _nuevo valor_. Â¡Es como decirle a React: "Oye, haz esto con el estado actual"! ğŸ› ï¸

Estas funciones se llaman **funciones de actualizaciÃ³n** (o _updater functions_ en inglÃ©s).

#### 2. **Ejemplo:**

Ahora, mira este botÃ³n con funciones de actualizaciÃ³n:

```jsx
import { useState } from "react";

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber((n) => n + 1);
          setNumber((n) => n + 1);
          setNumber((n) => n + 1);
        }}
      >
        +3
      </button>
    </>
  );
}
```

**Resultado al hacer clic (la primera vez):**

```
3
```

**ExplicaciÃ³n del ejemplo:**

Â¡Ahora sÃ­ suma 3! ğŸ‰ Cuando usas `setNumber(n => n + 1)`, le estÃ¡s diciendo a React que en lugar de _reemplazar_ el estado directamente, quieres _aplicar una funciÃ³n_ al estado anterior.

AsÃ­ es como React procesa esto:

1.  `setNumber(n => n + 1)`: "AÃ±ade a la cola: 'funciÃ³n que incrementa en 1'". ğŸ“
2.  `setNumber(n => n + 1)`: "AÃ±ade a la cola: 'funciÃ³n que incrementa en 1'". ğŸ“
3.  `setNumber(n => n + 1)`: "AÃ±ade a la cola: 'funciÃ³n que incrementa en 1'". ğŸ“

Luego, durante el siguiente renderizado, React va procesando la cola de funciones una por una, usando el resultado de la anterior como entrada para la siguiente. Es como una cadena de montaje:

| ActualizaciÃ³n en cola | `n` (estado anterior) | Devuelve (nuevo estado) |
| --------------------- | --------------------- | ----------------------- |
| `n => n + 1`          | `0`                   | `0 + 1 = 1`             |
| `n => n + 1`          | `1`                   | `1 + 1 = 2`             |
| `n => n + 1`          | `2`                   | `2 + 1 = 3`             |

Finalmente, el estado se actualiza a `3`. Â¡Magia! âœ¨

#### 3. **Notas o advertencias:**

- **Estado consistente:** Las funciones de actualizaciÃ³n son sÃºper Ãºtiles cuando necesitas basar una actualizaciÃ³n de estado en el valor _anterior_ del estado, especialmente dentro del mismo evento. ğŸ¤
- **Funciones puras:** Â¡Ojo! Las funciones de actualizaciÃ³n deben ser **puras**. Esto significa que solo deben _calcular_ el nuevo estado y _devolverlo_. Â¡Nada de efectos secundarios raros dentro de ellas (como cambiar otros estados o hacer llamadas a APIs)! ğŸ™…â€â™€ï¸ En `Strict Mode`, React las ejecuta dos veces (y descarta el segundo resultado) para ayudarte a detectar si te has pasado de listo con los efectos secundarios. ğŸ•µï¸â€â™€ï¸

---

## C - Actualizar y luego Reemplazar (Â¿QuÃ© pasa?)

#### 1. **DefiniciÃ³n:**

Â¿QuÃ© ocurre si mezclas funciones de actualizaciÃ³n con reemplazos directos de estado? ğŸ¤” React procesa las actualizaciones en el orden en que las pones en tu cÃ³digo. Si primero usas un reemplazo directo y luego una funciÃ³n de actualizaciÃ³n, Â¡asÃ­ se procesarÃ¡n!

#### 2. **Ejemplo:**

```jsx
import { useState } from "react";

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5); // Reemplazo directo
          setNumber((n) => n + 1); // FunciÃ³n de actualizaciÃ³n
        }}
      >
        Aumentar el nÃºmero
      </button>
    </>
  );
}
```

**Resultado al hacer clic (la primera vez):**

```
6
```

**ExplicaciÃ³n del ejemplo:**

1.  `setNumber(number + 5)`: Como `number` es `0`, esto es `setNumber(5)`. React aÃ±ade a la cola: "Reemplazar con `5`". ğŸ“
2.  `setNumber(n => n + 1)`: React aÃ±ade a la cola: "FunciÃ³n que incrementa en 1". ğŸ“

Procesando la cola:

| ActualizaciÃ³n en cola | `n` (estado anterior) | Devuelve (nuevo estado) |
| --------------------- | --------------------- | ----------------------- |
| "Reemplazar con `5`"  | `0` (no se usa)       | `5`                     |
| `n => n + 1`          | `5`                   | `5 + 1 = 6`             |

El estado final es `6`. Â¡Primero reemplazamos con `5` y luego incrementamos en `1`! ğŸ¤¯

#### 3. **Notas o advertencias:**

- `setState(valor)` es como `setState(n => valor)` (Â¡pero `n` no se usa!). Es otra forma de ver los reemplazos directos. ğŸ˜‰

---

## D - Reemplazar y luego Actualizar (Â¡Otro giro!)

#### 1. **DefiniciÃ³n:**

Â¿Y si lo hacemos al revÃ©s? Primero una funciÃ³n de actualizaciÃ³n y luego un reemplazo directo. Â¡Veamos quÃ© pasa!

#### 2. **Ejemplo:**

```jsx
import { useState } from "react";

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button
        onClick={() => {
          setNumber(number + 5); // Reemplazo directo
          setNumber((n) => n + 1); // FunciÃ³n de actualizaciÃ³n
          setNumber(42); // Reemplazo directo (Â¡otra vez!)
        }}
      >
        Aumentar el nÃºmero
      </button>
    </>
  );
}
```

**Resultado al hacer clic (la primera vez):**

```
42
```

**ExplicaciÃ³n del ejemplo:**

1.  `setNumber(number + 5)`: `setNumber(5)`. Cola: "Reemplazar con `5`". ğŸ“
2.  `setNumber(n => n + 1)`: Cola: "FunciÃ³n que incrementa en 1". ğŸ“
3.  `setNumber(42)`: Cola: "Reemplazar con `42`". ğŸ“

Procesando la cola:

| ActualizaciÃ³n en cola | `n` (estado anterior) | Devuelve (nuevo estado) |
| --------------------- | --------------------- | ----------------------- |
| "Reemplazar con `5`"  | `0` (no se usa)       | `5`                     |
| `n => n + 1`          | `5`                   | `5 + 1 = 6`             |
| "Reemplazar con `42`" | `6` (no se usa)       | `42`                    |

Â¡El estado final es `42`! El Ãºltimo reemplazo directo **siempre gana**. Es como si React dijera: "Ah, al final querÃ­as que fuera 42, Â¡pues 42 serÃ¡!". ğŸ˜…

#### 3. **Resumen rÃ¡pido:**

- **FunciÃ³n de actualizaciÃ³n:** Se aÃ±ade a la cola para ser procesada secuencialmente.
- **Cualquier otro valor (reemplazo directo):** AÃ±ade "reemplazar con [valor]" a la cola, **ignorando** cualquier reemplazo directo anterior en la cola. Â¡Pero las funciones de actualizaciÃ³n que ya estaban en la cola **sÃ­** se procesan antes del reemplazo final! ğŸ¤¯

---

## E - Convenciones de Nombres para Funciones de ActualizaciÃ³n

#### 1. **DefiniciÃ³n:**

Cuando usas funciones de actualizaciÃ³n, es buena prÃ¡ctica nombrar el argumento de la funciÃ³n (que representa el estado anterior) de forma que sea fÃ¡cil de entender. Â¡AsÃ­ tu cÃ³digo es mÃ¡s legible! ğŸ¤“

#### 2. **Ejemplos:**

- Si tu estado es `enabled`, puedes usar `e` o `enabled` o `prevEnabled`:

  ```javascript
  setEnabled((e) => !e);
  setEnabled((enabled) => !enabled);
  setEnabled((prevEnabled) => !prevEnabled);
  ```

- Para `lastName`, puedes usar `ln`:

  ```javascript
  setLastName((ln) => ln.reverse());
  ```

- Para `friendCount`, puedes usar `fc`:

  ```javascript
  setFriendCount((fc) => fc * 2);
  ```

**ExplicaciÃ³n de los ejemplos:**

Usar nombres cortos como la primera letra o abreviaturas es comÃºn para que el cÃ³digo no sea demasiado verboso, pero tambiÃ©n puedes usar nombres mÃ¡s largos si prefieres que sea mÃ¡s explÃ­cito. Â¡Lo importante es que sea claro para ti y para otros que lean tu cÃ³digo! ğŸ‘
