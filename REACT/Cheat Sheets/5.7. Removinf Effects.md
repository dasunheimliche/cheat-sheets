## A - Dependencias de los Effects: Â¡Deben Coincidir con el CÃ³digo! ğŸ¤

#### 1. **Definicion:**

Cuando usas `useEffect`, tienes que decirle a React quÃ© valores reactivos (como `props` o `state`) usa tu Effect. Â¡Es como decirle a React quÃ© cosas debe vigilar para saber cuÃ¡ndo volver a ejecutar tu Effect! Si tu Effect usa `roomId`, Â¡debe estar en la lista de dependencias! ğŸ“

#### 2. **Ejemplo:**

**CÃ³digo INcorrecto (Â¡Linter te avisarÃ¡!):**

```jsx
import { useState, useEffect } from "react";
import { createConnection } from "./chat.js";

const serverUrl = "https://localhost:1234";

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // ğŸ”´ Â¡Error! Falta roomId como dependencia

  return <h1>Welcome to the {roomId} room!</h1>;
}
```

**CÃ³digo CORRECTO (Â¡Linter feliz!):**

```jsx
import { useState, useEffect } from "react";
import { createConnection } from "./chat.js";

const serverUrl = "https://localhost:1234";

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // âœ… Â¡roomId ahora es dependencia!

  return <h1>Welcome to the {roomId} room!</h1>;
}
```

**ExplicaciÃ³n del ejemplo:**
En el cÃ³digo incorrecto, olvidamos decirle a React que el Effect usa `roomId`. Â¡El linter (tu amigo que te ayuda a no meter la pata) te avisarÃ¡! En el cÃ³digo correcto, aÃ±adimos `roomId` como dependencia. Ahora, si `roomId` cambia, Â¡React volverÃ¡ a ejecutar el Effect para que todo estÃ© sincronizado! ğŸ”„

#### 3. **Notas o advertencias:**

- **El linter es tu amigo:** Â¡Hazle caso! Te evita muchos dolores de cabeza. ğŸ¤•
- **Reactividad es la clave:** Los Effects "reaccionan" a los valores reactivos. Si tu Effect usa un valor reactivo, Â¡debe ser una dependencia! ğŸ”‘

---

## B - Quitar una Dependencia: Â¡PruÃ©bale a React que NO es Necesaria! ğŸ¤”

#### 1. **Definicion:**

No puedes simplemente "decidir" quÃ© dependencias poner o quitar. Para quitar una dependencia, tienes que cambiar tu cÃ³digo para que ese valor **ya no sea reactivo** para tu Effect. Â¡Es como convencer a React de que ese valor ya no importa para este Effect! ğŸ¤·â€â™‚ï¸

#### 2. **Ejemplo:**

**CÃ³digo con dependencia reactiva:**

```jsx
function ChatRoom({ roomId }) {
  // roomId es reactivo (prop)
  useEffect(() => {
    // ... usa roomId ...
  }, [roomId]); // âœ… roomId es dependencia
}
```

**CÃ³digo SIN dependencia reactiva (roomId fuera del componente):**

```jsx
const roomId = "music"; // roomId ya NO es reactivo (constante)

function ChatRoom() {
  useEffect(() => {
    // ... usa roomId ...
  }, []); // âœ… Â¡Ahora [] funciona! roomId no es reactivo
}
```

![image](https://react.dev/images/docs/diagrams/effects_removing_dependency_not_reactive.webp)

**ExplicaciÃ³n del ejemplo:**
En el primer ejemplo, `roomId` es una prop, Â¡asÃ­ que es reactiva! Si cambia, el Effect debe re-ejecutarse. En el segundo ejemplo, movimos `roomId` fuera del componente y lo hicimos una constante. Â¡Ahora ya no es reactivo! Como el Effect ya no usa un valor reactivo, Â¡podemos usar `[]` como dependencias! ğŸ‰

#### 3. **Notas o advertencias:**

- **Cambia el cÃ³digo, cambia las dependencias:** Si quieres menos dependencias, Â¡cambia tu cÃ³digo para que el Effect no las necesite! ğŸ› ï¸
- **No puedes "elegir" dependencias:** Las dependencias son un reflejo de tu cÃ³digo, Â¡no al revÃ©s! ğŸ–¼ï¸

---

## C - Cambiar las Dependencias: Â¡Cambia Primero el CÃ³digo! ğŸ”„

#### 1. **Definicion:**

Si no te gustan las dependencias de tu Effect, Â¡no intentes "forzar" la lista de dependencias! En lugar de eso, **cambia el cÃ³digo de tu Effect o cÃ³mo declaras tus valores reactivos**. Luego, deja que el linter te guÃ­e para ajustar las dependencias. Â¡Es un proceso de "ida y vuelta"! ğŸ”„

#### 2. **Proceso:**

1.  **Cambia el cÃ³digo:** Modifica tu Effect o cÃ³mo declaras tus variables reactivas. âœï¸
2.  **Ajusta las dependencias:** Sigue las sugerencias del linter para que las dependencias **coincidan con el cÃ³digo modificado**. ğŸ‘‚
3.  **Â¿No te gusta la lista?:** Vuelve al paso 1 y Â¡cambia el cÃ³digo de nuevo! â†©ï¸

**ExplicaciÃ³n del proceso:**
Piensa en las dependencias como una descripciÃ³n de lo que tu Effect estÃ¡ usando. No las "eliges", Â¡las descubres a travÃ©s de tu cÃ³digo! Si quieres cambiar la descripciÃ³n (las dependencias), Â¡tienes que cambiar lo que estÃ¡s describiendo (el cÃ³digo)! ğŸ¨

#### 3. **Notas o advertencias:**

- **Piensa en "ecuaciones":** A veces es como resolver una ecuaciÃ³n. Tienes un objetivo (menos dependencias) y necesitas encontrar el cÃ³digo que lo cumpla. ğŸ§®
- **Recetas comunes:** Â¡No te preocupes! Hay "recetas" o patrones comunes para ayudarte a reducir las dependencias. Â¡Las veremos mÃ¡s adelante! ğŸ§‘â€ğŸ³

---

## D - Â¡PELIGRO! ğŸš¨ Evita Suprimir el Linter de Dependencias

#### 1. **Definicion:**

Si ves un cÃ³digo como este, Â¡CORRE! ğŸƒâ€â™€ï¸ğŸƒâ€â™‚ï¸ Suprimir el linter de dependencias es **muy peligroso** y puede causar **bugs muy difÃ­ciles de encontrar**. Â¡Es como mentirle a React sobre de quÃ© depende tu Effect! ğŸ¤¥

```jsx
useEffect(() => {
  // ... cÃ³digo ...
  // ğŸ”´ Â¡MAL! Â¡EVITA ESTO! ğŸ”´
  // eslint-ignore-next-line react-hooks/exhaustive-deps
}, []);
```

#### 2. **Ejemplo de BUG (Timer Roto):**

```jsx
import { useState, useEffect } from "react";

export default function Timer() {
  const [count, setCount] = useState(0);
  const [increment, setIncrement] = useState(1);

  function onTick() {
    setCount(count + increment);
  }

  useEffect(() => {
    const id = setInterval(onTick, 1000);
    return () => clearInterval(id);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []); // ğŸ”´ Â¡LINTER SUPRIMIDO! Â¡PROBLEMAS!

  return (
    <>
      <h1>
        Counter: {count} <button onClick={() => setCount(0)}>Reset</button>
      </h1>
      <hr />
      <p>Every second, increment by: ... </p>
    </>
  );
}
```

**ExplicaciÃ³n del ejemplo:**
En este ejemplo, querÃ­an que el timer solo se iniciara "al montar" el componente, asÃ­ que usaron `[]` y suprimieron el linter. Â¡Pero esto causa un bug! El `increment` siempre se queda con su valor inicial (1), Â¡incluso si intentas cambiarlo con los botones! ğŸ› Esto pasa porque el Effect usa una versiÃ³n "vieja" de `onTick`.

#### 3. **Notas o advertencias:**

- **Bugs INESPERADOS:** Suprimir el linter lleva a bugs muy raros y difÃ­ciles de depurar. ğŸ‘»
- **Siempre hay una MEJOR soluciÃ³n:** Â¡En lugar de suprimir el linter, usa las tÃ©cnicas que te enseÃ±aremos! ğŸ’ª
- **Â¡Linter = Error de CompilaciÃ³n!:** Piensa en los errores del linter de dependencias como errores de compilaciÃ³n. Â¡No los ignores! ğŸ›‘

---

## E - Removiendo Dependencias Innecesarias: Â¡A Limpiar se ha Dicho! ğŸ§¹

#### 1. **Definicion:**

A veces, las dependencias hacen que tu Effect se ejecute **demasiado a menudo**, Â¡o incluso entren en un **bucle infinito**! ğŸ˜µâ€ğŸ’« Necesitamos aprender a identificar y eliminar dependencias que no son realmente necesarias.

#### 2. **Situaciones Comunes:**

- **Re-ejecutar partes diferentes:** Quieres que diferentes partes de tu Effect se ejecuten bajo diferentes condiciones. ğŸ­
- **Leer el valor MÃS RECIENTE:** Solo quieres leer el valor actual de una dependencia, Â¡pero no "reaccionar" a cada cambio! ğŸ‘ï¸
- **Dependencia cambia SIN QUERER:** Una dependencia cambia demasiado a menudo sin que realmente quieras que el Effect se re-ejecute (Â¡culpa de objetos y funciones!). ğŸ¤¦â€â™€ï¸

#### 3. **Preguntas Clave:**

Para encontrar la soluciÃ³n correcta, Â¡hazte estas preguntas sobre tu Effect! ğŸ‘‡

- Â¿DeberÃ­a este cÃ³digo estar en un **manejador de eventos**? ğŸ–±ï¸
- Â¿Mi Effect estÃ¡ haciendo **varias cosas no relacionadas**? ğŸ‘¯
- Â¿Estoy leyendo **state para calcular el siguiente state**? â•
- Â¿Quiero **leer un valor sin "reaccionar"** a sus cambios? ğŸ§˜
- Â¿AlgÃºn valor reactivo **cambia sin querer**? ğŸ«¨

Â¡Vamos a ver soluciones para cada una de estas preguntas! ğŸ•µï¸â€â™€ï¸

---

## F - Â¿DeberÃ­a este CÃ³digo Moverse a un Manejador de Eventos? ğŸ–±ï¸

#### 1. **Definicion:**

Si el cÃ³digo de tu Effect se ejecuta en respuesta a una **acciÃ³n especÃ­fica del usuario** (como un clic o un envÃ­o de formulario), Â¡probablemente deberÃ­a estar en un **manejador de eventos** en lugar de un Effect! Los Effects son para **sincronizaciÃ³n**, los manejadores de eventos para **interacciones**. ğŸ¤

#### 2. **Ejemplo (Formulario de Registro):**

**CÃ³digo INcorrecto (Effect para evento):**

```jsx
function Form() {
  const [submitted, setSubmitted] = useState(false);
  const theme = useContext(ThemeContext);

  useEffect(() => {
    if (submitted) {
      // ğŸ”´ Â¡MAL! LÃ³gica de evento en Effect
      post("/api/register");
      showNotification("Â¡Registro exitoso!", theme);
    }
  }, [submitted, theme]); // âš ï¸ Â¡Dependencia theme causa re-ejecuciones innecesarias!

  function handleSubmit() {
    setSubmitted(true);
  }
  // ...
}
```

**CÃ³digo CORRECTO (Manejador de evento):**

```jsx
function Form() {
  const theme = useContext(ThemeContext);

  function handleSubmit() {
    // âœ… Â¡BIEN! LÃ³gica de evento en manejador
    post("/api/register");
    showNotification("Â¡Registro exitoso!", theme);
  }
  // ...
}
```

**ExplicaciÃ³n del ejemplo:**
En el cÃ³digo incorrecto, usamos un Effect que "reacciona" a `submitted` para enviar el formulario y mostrar la notificaciÃ³n. Â¡Pero esto causa un bug! Si cambias el tema despuÃ©s de enviar el formulario, Â¡la notificaciÃ³n se mostrarÃ¡ de nuevo! ğŸ˜± En el cÃ³digo correcto, movemos la lÃ³gica al `handleSubmit`. Â¡Ahora solo se ejecuta cuando se envÃ­a el formulario, como debe ser! ğŸ‰

#### 3. **Notas o advertencias:**

- **Effects para SincronizaciÃ³n:** Usa Effects para mantener cosas sincronizadas con valores reactivos. ğŸ”„
- **Manejadores para Interacciones:** Usa manejadores de eventos para responder a acciones del usuario. ğŸ–±ï¸
- **Elimina Effects Innecesarios:** A veces, Â¡simplemente no necesitas un Effect! PregÃºntate si realmente estÃ¡s sincronizando algo. ğŸ¤”

---

## G - Â¿Tu Effect EstÃ¡ Haciendo Varias Cosas No Relacionadas? ğŸ‘¯

#### 1. **Definicion:**

Si tu Effect estÃ¡ sincronizando **dos o mÃ¡s cosas que no tienen nada que ver entre sÃ­**, Â¡divÃ­delo en **Effects separados**! Cada Effect debe encargarse de **una sola tarea de sincronizaciÃ³n**. Â¡Es como separar la ropa blanca de la de color! ğŸ§º

#### 2. **Ejemplo (Formulario de EnvÃ­o - Ciudades y Ãreas):**

**CÃ³digo INcorrecto (Un Effect para todo):**

```jsx
function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);

  useEffect(() => {
    let ignore = false;

    fetch(`/api/cities?country=${country}`) // Fetch ciudades por paÃ­s
      .then(...)
      .then(json => { if (!ignore) setCities(json); });

    if (city) { // ğŸ”´ Â¡MAL! Un Effect sincroniza dos cosas
      fetch(`/api/areas?city=${city}`) // Fetch Ã¡reas por ciudad
        .then(...)
        .then(json => { if (!ignore) setAreas(json); });
    }

    return () => { ignore = true; };
  }, [country, city]); // âš ï¸ Â¡Dependencia 'city' re-ejecuta fetch de ciudades innecesariamente!

  // ...
}
```

**CÃ³digo CORRECTO (Effects Separados):**

```jsx
function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);

  useEffect(() => { // âœ… Effect 1: Sincroniza ciudades con paÃ­s
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(...)
      .then(json => { if (!ignore) setCities(json); });
    return () => { ignore = true; };
  }, [country]);

  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);

  useEffect(() => { // âœ… Effect 2: Sincroniza Ã¡reas con ciudad
    if (city) {
      let ignore = false;
      fetch(`/api/areas?city=${city}`)
        .then(...)
        .then(json => { if (!ignore) setAreas(json); });
      return () => { ignore = true; };
    }
  }, [city]);

  // ...
}
```

**ExplicaciÃ³n del ejemplo:**
En el cÃ³digo incorrecto, un solo Effect intenta sincronizar tanto las ciudades (con el paÃ­s) como las Ã¡reas (con la ciudad). Â¡Esto causa problemas! Cuando cambias la ciudad, el Effect se re-ejecuta y vuelve a cargar la lista de ciudades, Â¡innecesariamente! ğŸ¤¦â€â™€ï¸ En el cÃ³digo correcto, dividimos la lÃ³gica en dos Effects separados. Â¡Ahora cada Effect se encarga de una sola sincronizaciÃ³n y solo se re-ejecuta cuando es necesario! ğŸ‰

#### 3. **Notas o advertencias:**

- **Un Effect = Una SincronizaciÃ³n:** Cada Effect debe representar un proceso de sincronizaciÃ³n independiente. ğŸ¯
- **Independencia:** Si eliminar un Effect no rompe la lÃ³gica del otro, Â¡es buena seÃ±al de que deberÃ­an estar separados! ğŸ¤
- **Hooks Personalizados:** Si tienes lÃ³gica repetitiva, Â¡puedes extraerla a un Hook personalizado para reutilizarla! â™»ï¸

---

## ==H - Â¿EstÃ¡s Leyendo State para Calcular el Siguiente State? â•==

#### 1. **Definicion:**

Si dentro de tu Effect estÃ¡s leyendo el valor actual de un `state` para **calcular el nuevo valor de ese mismo `state`**, Â¡puedes evitar que el Effect dependa del `state` usando la **funciÃ³n de actualizaciÃ³n** de `setState`! Â¡Es como usar la "versiÃ³n anterior" del state para calcular la "versiÃ³n nueva"! ğŸ”„

#### 2. **Ejemplo (Chat - AÃ±adir Mensajes):**

**CÃ³digo INcorrecto (Dependencia innecesaria de `messages`):**

```jsx
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on("message", (receivedMessage) => {
      setMessages([...messages, receivedMessage]); // ğŸ”´ Â¡MAL! Lee 'messages' para actualizarlo
    });
    return () => connection.disconnect();
  }, [roomId, messages]); // âš ï¸ Â¡Dependencia 'messages' re-conecta el chat con cada mensaje!

  // ...
}
```

**CÃ³digo CORRECTO (FunciÃ³n de actualizaciÃ³n):**

```jsx
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on("message", (receivedMessage) => {
      setMessages((msgs) => [...msgs, receivedMessage]); // âœ… Â¡BIEN! Usa funciÃ³n de actualizaciÃ³n
    });
    return () => connection.disconnect();
  }, [roomId]); // âœ… Â¡Ya no depende de 'messages'!

  // ...
}
```

**ExplicaciÃ³n del ejemplo:**
En el cÃ³digo incorrecto, leemos `messages` dentro del Effect para crear un nuevo array con el nuevo mensaje. Â¡Esto hace que `messages` sea una dependencia! Y cada vez que recibimos un mensaje, el Effect se re-ejecuta y Â¡re-conecta el chat! ğŸ˜± En el cÃ³digo correcto, usamos la funciÃ³n de actualizaciÃ³n `msgs => [...msgs, receivedMessage]`. Â¡Ahora el Effect ya no necesita leer `messages`! React se encarga de pasar el valor actual de `messages` a la funciÃ³n de actualizaciÃ³n. ğŸ‰

#### 3. **Notas o advertencias:**

- **FunciÃ³n de ActualizaciÃ³n = No Dependencia:** Usar la funciÃ³n de actualizaciÃ³n de `setState` te permite actualizar el state basado en su valor anterior **sin que el Effect dependa del state**. ğŸª„
- **Cola de Actualizaciones:** React pone tu funciÃ³n de actualizaciÃ³n en una "cola" y la ejecutarÃ¡ en el prÃ³ximo render. â³

---

## ==I - Â¿Quieres Leer un Valor Sin "Reaccionar" a Sus Cambios? (Effect Events) ğŸ§˜==

#### 1. **Definicion:**

A veces, quieres **leer un valor** dentro de tu Effect (como un prop o un state), pero **no quieres que el Effect se re-ejecute cada vez que ese valor cambia**. Para esto, Â¡puedes usar **Effect Events**! Los Effect Events te permiten separar la parte "reactiva" de tu Effect (las dependencias) de la parte "no reactiva" (la lectura de valores). ğŸ§˜

#### 2. **Ejemplo (Chat - Sonido Muteado):**

**CÃ³digo INcorrecto (Dependencia innecesaria de `isMuted`):**

```jsx
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  const [isMuted, setIsMuted] = useState(false);

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on("message", (receivedMessage) => {
      setMessages((msgs) => [...msgs, receivedMessage]);
      if (!isMuted) {
        // ğŸ”´ Â¡MAL! Lee 'isMuted' directamente
        playSound();
      }
    });
    return () => connection.disconnect();
  }, [roomId, isMuted]); // âš ï¸ Â¡Dependencia 'isMuted' re-conecta el chat al mutear/desmutear!

  // ...
}
```

**CÃ³digo CORRECTO (Effect Event):**

```jsx
import { useState, useEffect, useEffectEvent } from "react";

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  const [isMuted, setIsMuted] = useState(false);

  const onMessage = useEffectEvent((receivedMessage) => {
    // âœ… Effect Event
    setMessages((msgs) => [...msgs, receivedMessage]);
    if (!isMuted) {
      // âœ… Â¡BIEN! Lee 'isMuted' dentro del Effect Event
      playSound();
    }
  });

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on("message", (receivedMessage) => {
      onMessage(receivedMessage); // âœ… Llama al Effect Event
    });
    return () => connection.disconnect();
  }, [roomId]); // âœ… Â¡Ya no depende de 'isMuted'!

  // ...
}
```

**ExplicaciÃ³n del ejemplo:**
En el cÃ³digo incorrecto, leemos `isMuted` directamente dentro del Effect para decidir si reproducir el sonido. Â¡Esto hace que `isMuted` sea una dependencia! Y cada vez que muteamos/desmuteamos, el Effect se re-ejecuta y Â¡re-conecta el chat! ğŸ˜± En el cÃ³digo correcto, movemos la lÃ³gica que usa `isMuted` a un **Effect Event** llamado `onMessage`. Ahora, el Effect principal solo depende de `roomId` y llama a `onMessage` cuando recibe un mensaje. Â¡`isMuted` ya no es una dependencia del Effect principal! ğŸ‰

#### 3. **Notas o advertencias:**

- **Effect Events = No Reactivos:** Los Effect Events **no son reactivos**. Leen los valores **mÃ¡s recientes** cuando se ejecutan, pero **no hacen que el Effect principal se re-ejecute** si esos valores cambian. ğŸ§˜
- **Separa LÃ³gica Reactiva y No Reactiva:** Usa Effect Events para separar la lÃ³gica que debe "reaccionar" a las dependencias de la lÃ³gica que solo necesita leer valores puntualmente. ğŸ­

---

## ==J - Envolviendo un Manejador de Eventos de las Props (Effect Events) ğŸ==

#### 1. **Definicion:**

Un caso comÃºn donde los Effect Events son muy Ãºtiles es cuando tu componente recibe un **manejador de eventos como prop**. Si usas este manejador directamente en un Effect, Â¡puede causar re-ejecuciones innecesarias si el componente padre pasa una funciÃ³n diferente en cada render! Para evitar esto, Â¡envuelve la llamada al manejador de eventos en un **Effect Event**! ğŸ

#### 2. **Ejemplo (Chat - Prop `onReceiveMessage`):**

**CÃ³digo INcorrecto (Dependencia innecesaria de `onReceiveMessage`):**

```jsx
function ChatRoom({ roomId, onReceiveMessage }) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on("message", (receivedMessage) => {
      onReceiveMessage(receivedMessage); // ğŸ”´ Â¡MAL! Llama a prop directamente
    });
    return () => connection.disconnect();
  }, [roomId, onReceiveMessage]); // âš ï¸ Â¡Dependencia 'onReceiveMessage' re-conecta el chat con cada re-render del padre!

  // ...
}
```

**CÃ³digo CORRECTO (Effect Event):**

```jsx
import { useState, useEffect, useEffectEvent } from "react";

function ChatRoom({ roomId, onReceiveMessage }) {
  const [messages, setMessages] = useState([]);

  const onMessage = useEffectEvent((receivedMessage) => {
    // âœ… Effect Event
    onReceiveMessage(receivedMessage); // âœ… Â¡BIEN! Llama a prop dentro del Effect Event
  });

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on("message", (receivedMessage) => {
      onMessage(receivedMessage); // âœ… Llama al Effect Event
    });
    return () => connection.disconnect();
  }, [roomId]); // âœ… Â¡Ya no depende de 'onReceiveMessage'!

  // ...
}
```

**ExplicaciÃ³n del ejemplo:**
En el cÃ³digo incorrecto, llamamos a `onReceiveMessage` directamente dentro del Effect. Â¡Esto hace que `onReceiveMessage` sea una dependencia! Si el componente padre re-renderiza y pasa una **nueva funciÃ³n** `onReceiveMessage` (aunque haga lo mismo), Â¡el Effect se re-ejecutarÃ¡ y re-conectarÃ¡ el chat! ğŸ˜± En el cÃ³digo correcto, envolvemos la llamada a `onReceiveMessage` en un **Effect Event** llamado `onMessage`. Â¡Ahora el Effect principal ya no depende de `onReceiveMessage`! ğŸ‰

#### 3. **Notas o advertencias:**

- **Props FunciÃ³n = Nueva FunciÃ³n en Cada Render:** Si el padre re-renderiza, Â¡es probable que la funciÃ³n que pasa como prop sea una **nueva funciÃ³n** aunque haga lo mismo! ğŸ”„
- **Effect Events AÃSLAN:** Los Effect Events aÃ­slan tu Effect de los cambios en las funciones que vienen como props. ğŸ›¡ï¸

---

## ==K - Separando CÃ³digo Reactivo y No Reactivo (Effect Events) ğŸ­==

#### 1. **Definicion:**

Los Effect Events son geniales para **separar la lÃ³gica reactiva** (que debe reaccionar a las dependencias) de la **lÃ³gica no reactiva** (que solo necesita leer valores puntualmente) dentro de un mismo Effect. Â¡Es como tener dos "capas" de lÃ³gica en tu Effect! ğŸ­

#### 2. **Ejemplo (Chat - Log de Visitas con Contador de Notificaciones):**

```jsx
function Chat({ roomId, notificationCount }) {
  const onVisit = useEffectEvent((visitedRoomId) => {
    // âœ… Effect Event
    logVisit(visitedRoomId, notificationCount); // âœ… Lee 'notificationCount' dentro del Effect Event
  });

  useEffect(() => {
    onVisit(roomId); // âœ… Llama al Effect Event
  }, [roomId]); // âœ… Solo depende de 'roomId' (reactivo)

  // ...
}
```

**ExplicaciÃ³n del ejemplo:**
Queremos registrar una visita cada vez que `roomId` cambia. TambiÃ©n queremos incluir el `notificationCount` en el log, Â¡pero **no queremos que un cambio en `notificationCount` registre una visita extra**! Usamos un Effect Event `onVisit`. El Effect principal solo depende de `roomId` (la parte reactiva). Dentro de `onVisit` (la parte no reactiva), leemos `notificationCount`. Â¡AsÃ­, solo se registra una visita cuando `roomId` cambia, y `notificationCount` se lee con su valor mÃ¡s reciente en ese momento! ğŸ‰

#### 3. **Notas o advertencias:**

- **Control Fino de Reactividad:** Los Effect Events te dan un control muy preciso sobre quÃ© partes de tu Effect son reactivas y cuÃ¡les no. ğŸ¯
- **Lee Valores Recientes:** Dentro de un Effect Event, siempre leerÃ¡s los valores **mÃ¡s recientes** de props y state, Â¡sin hacer que el Effect principal se re-ejecute! ğŸ‘ï¸

---

## L - Â¿AlgÃºn Valor Reactivo Cambia Sin Querer? (Objetos y Funciones) ğŸ«¨

#### 1. **Definicion:**

Â¡Cuidado con los **objetos y funciones** como dependencias de tus Effects! âš ï¸ En JavaScript, **cada nuevo objeto o funciÃ³n que creas es diferente de todos los demÃ¡s**, Â¡incluso si tienen el mismo contenido! Esto puede hacer que tus Effects se re-ejecuten **mÃ¡s a menudo de lo que esperas**, Â¡sin que realmente haya un cambio "real" desde el punto de vista del usuario! ğŸ˜µâ€ğŸ’«

#### 2. **Ejemplo (Chat - Objeto `options`):**

```jsx
function ChatRoom({ roomId }) {
  const [message, setMessage] = useState("");

  const options = {
    // ğŸ”´ Â¡PROBLEMA! Objeto creado en cada render
    serverUrl: serverUrl,
    roomId: roomId,
  };

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]); // âš ï¸ Â¡Dependencia 'options' re-conecta el chat con cada letra que escribes!

  // ...
}
```

**ExplicaciÃ³n del ejemplo:**
En este ejemplo, creamos un objeto `options` en cada render del componente. Aunque el contenido de `options` sea el mismo (a menos que `roomId` cambie), Â¡React ve que es un **nuevo objeto** en cada render! Como el Effect depende de `options`, Â¡se re-ejecuta con cada re-render! Â¡Incluso cuando solo escribes en el input de mensaje! ğŸ˜±

#### 3. **Notas o advertencias:**

- **Identidad de Objetos y Funciones:** En JavaScript, los objetos y funciones se comparan por **identidad**, no por contenido. ğŸª
- **Re-renders Innecesarios:** Las dependencias de objetos y funciones pueden causar que tus Effects se re-sincronicen mÃ¡s de lo necesario. ğŸ¤¦â€â™€ï¸
- **Â¡Evita Objetos y Funciones como Dependencias!** Siempre que sea posible, intenta evitar tener objetos y funciones directamente como dependencias de tus Effects. Â¡Busca alternativas! ğŸ”

---

## M - Mueve Objetos y Funciones EstÃ¡ticas Fuera de Tu Componente ğŸ“¦

#### 1. **Definicion:**

Si tienes un **objeto o funciÃ³n que no depende de ningÃºn prop o state** (es "estÃ¡tico"), Â¡mÃºvelo **fuera de la definiciÃ³n de tu componente**! Esto le "prueba" al linter que ya no es un valor reactivo y, por lo tanto, Â¡no necesita ser una dependencia! ğŸ“¦

#### 2. **Ejemplo (Chat - `options` EstÃ¡tico):**

**CÃ³digo INcorrecto (Objeto `options` dentro del componente):**

```jsx
function ChatRoom() {
  const options = {
    // ğŸ”´ Â¡PROBLEMA! Objeto dentro del componente
    serverUrl: "https://localhost:1234",
    roomId: "music",
  };

  useEffect(() => {
    // ... usa options ...
  }, [options]); // âš ï¸ Â¡Dependencia 'options' causa re-ejecuciones innecesarias!
}
```

**CÃ³digo CORRECTO (Objeto `options` fuera del componente):**

```jsx
const options = {
  // âœ… Â¡BIEN! Objeto fuera del componente (estÃ¡tico)
  serverUrl: "https://localhost:1234",
  roomId: "music",
};

function ChatRoom() {
  useEffect(() => {
    // ... usa options ...
  }, []); // âœ… Â¡Ahora [] funciona! 'options' no es reactivo
}
```

**ExplicaciÃ³n del ejemplo:**
En el cÃ³digo incorrecto, `options` se crea dentro del componente, Â¡asÃ­ que es reactivo! En el cÃ³digo correcto, movimos `options` fuera del componente. Â¡Ahora es una constante **estÃ¡tica**! Como no depende de nada reactivo, Â¡ya no necesita ser una dependencia del Effect! ğŸ‰

#### 3. **Notas o advertencias:**

- **EstÃ¡tico = No Reactivo:** Los valores declarados fuera del componente **no son reactivos**. No cambian con los re-renders. ğŸ§˜
- **OptimizaciÃ³n:** Mover valores estÃ¡ticos fuera del componente ayuda a **optimizar** tus Effects y evitar re-ejecuciones innecesarias. ğŸš€

---

## N - Mueve Objetos y Funciones DinÃ¡micas Dentro de Tu Effect â¡ï¸

#### 1. **Definicion:**

Si necesitas crear un **objeto o funciÃ³n que sÃ­ depende de valores reactivos** (como props o state), Â¡mueve la **creaciÃ³n de ese objeto o funciÃ³n dentro del cÃ³digo de tu Effect**! De esta manera, el objeto o funciÃ³n en sÃ­ **no se convierte en una dependencia** del Effect. Â¡Es como "encapsular" la creaciÃ³n del valor dentro del Effect! â¡ï¸

#### 2. **Ejemplo (Chat - `options` DinÃ¡mico):**

**CÃ³digo INcorrecto (Objeto `options` fuera del Effect):**

```jsx
function ChatRoom({ roomId }) {
  const options = {
    // ğŸ”´ Â¡PROBLEMA! Objeto fuera del Effect
    serverUrl: serverUrl,
    roomId: roomId,
  };

  useEffect(() => {
    // ... usa options ...
  }, [options]); // âš ï¸ Â¡Dependencia 'options' causa re-ejecuciones innecesarias!
}
```

**CÃ³digo CORRECTO (Objeto `options` dentro del Effect):**

```jsx
function ChatRoom({ roomId }) {
  useEffect(() => {
    const options = {
      // âœ… Â¡BIEN! Objeto dentro del Effect (dinÃ¡mico)
      serverUrl: serverUrl,
      roomId: roomId,
    };
    // ... usa options ...
  }, [roomId]); // âœ… Â¡Ahora solo depende de 'roomId'!
}
```

**ExplicaciÃ³n del ejemplo:**
En el cÃ³digo incorrecto, `options` se crea fuera del Effect, Â¡y se convierte en una dependencia! En el cÃ³digo correcto, movimos la creaciÃ³n de `options` **dentro del Effect**. Ahora, `options` ya no es una dependencia del Effect. El Effect solo depende de `roomId`, que es un valor primitivo (string), Â¡y los valores primitivos no causan re-ejecuciones innecesarias como los objetos! ğŸ‰

#### 3. **Notas o advertencias:**

- **Objeto/FunciÃ³n Interna = No Dependencia:** Los objetos y funciones creados **dentro** de un Effect **no son dependencias** de ese Effect. ğŸ›¡ï¸
- **Valores Primitivos Seguros:** Depender de **valores primitivos** (nÃºmeros, strings, booleanos) es mucho mÃ¡s seguro que depender de objetos y funciones, Â¡ya que los primitivos se comparan por **valor** y no por **identidad**! ğŸ’

---

## ==O - Lee Valores Primitivos de Objetos ğŸ‘“==

#### 1. **Definicion:**

En lugar de depender **directamente de un objeto** como dependencia de tu Effect, Â¡intenta **extraer los valores primitivos** que necesitas del objeto **fuera del Effect** y depender de esos valores primitivos! Es como "desglosar" el objeto en sus partes mÃ¡s importantes y solo depender de esas partes. ğŸ‘“

#### 2. **Ejemplo (Chat - Prop `options` Objeto):**

**CÃ³digo INcorrecto (Dependencia del objeto `options`):**

```jsx
function ChatRoom({ options }) {
  // prop 'options' es un objeto
  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]); // âš ï¸ Â¡Dependencia 'options' causa re-ejecuciones innecesarias!
}
```

**CÃ³digo CORRECTO (Dependencia de valores primitivos):**

```jsx
function ChatRoom({ options }) {
  // prop 'options' es un objeto
  const { roomId, serverUrl } = options; // âœ… Extrae valores primitivos

  useEffect(() => {
    const connection = createConnection({
      // âœ… Crea un nuevo objeto DENTRO del Effect
      roomId: roomId,
      serverUrl: serverUrl,
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]); // âœ… Â¡Ahora depende de valores primitivos!
}
```

**ExplicaciÃ³n del ejemplo:**
En el cÃ³digo incorrecto, el Effect depende directamente del objeto `options`. Si el componente padre re-renderiza y pasa un **nuevo objeto `options`** (aunque tenga el mismo contenido), Â¡el Effect se re-ejecutarÃ¡! ğŸ˜± En el cÃ³digo correcto, **extraemos `roomId` y `serverUrl` del objeto `options` fuera del Effect**. Luego, **creamos un nuevo objeto** dentro del Effect con esos valores. Â¡Ahora el Effect solo depende de `roomId` y `serverUrl`, que son valores primitivos! ğŸ‰

#### 3. **Notas o advertencias:**

- **Dependencias ExplÃ­citas:** Depender de valores primitivos hace que sea **muy claro** de quÃ© informaciÃ³n depende realmente tu Effect. ğŸ¯
- **Menos Re-renders Innecesarios:** Al evitar depender de objetos directamente, reduces la posibilidad de re-renders innecesarios causados por la creaciÃ³n de nuevos objetos en cada render del padre. ğŸš€

---

## ==P - Calcula Valores Primitivos de Funciones ğŸ§®==

#### 1. **Definicion:**

Similar a los objetos, si recibes una **funciÃ³n como prop** que devuelve un objeto, Â¡en lugar de depender de la funciÃ³n en sÃ­, **llama a la funciÃ³n fuera del Effect** para obtener los **valores primitivos** que necesitas y depende de esos valores primitivos! Â¡Es como "ejecutar" la funciÃ³n para obtener sus "ingredientes" primitivos y solo depender de los ingredientes! ğŸ§®

#### 2. **Ejemplo (Chat - Prop `getOptions` FunciÃ³n):**

**CÃ³digo INcorrecto (Dependencia de la funciÃ³n `getOptions`):**

```jsx
function ChatRoom({ getOptions }) {
  // prop 'getOptions' es una funciÃ³n
  useEffect(() => {
    const options = getOptions();
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [getOptions]); // âš ï¸ Â¡Dependencia 'getOptions' causa re-ejecuciones innecesarias!
}
```

**CÃ³digo CORRECTO (Dependencia de valores primitivos calculados):**

```jsx
function ChatRoom({ getOptions }) {
  // prop 'getOptions' es una funciÃ³n
  const { roomId, serverUrl } = getOptions(); // âœ… Llama a la funciÃ³n FUERA del Effect y extrae valores primitivos

  useEffect(() => {
    const connection = createConnection({
      // âœ… Crea un nuevo objeto DENTRO del Effect
      roomId: roomId,
      serverUrl: serverUrl,
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]); // âœ… Â¡Ahora depende de valores primitivos!
}
```

**ExplicaciÃ³n del ejemplo:**
En el cÃ³digo incorrecto, el Effect depende directamente de la funciÃ³n `getOptions`. Si el componente padre re-renderiza y pasa una **nueva funciÃ³n `getOptions`** (aunque haga lo mismo), Â¡el Effect se re-ejecutarÃ¡! ğŸ˜± En el cÃ³digo correcto, **llamamos a `getOptions()` fuera del Effect** y extraemos `roomId` y `serverUrl` del objeto que devuelve. Luego, **creamos un nuevo objeto** dentro del Effect con esos valores. Â¡Ahora el Effect solo depende de `roomId` y `serverUrl`, valores primitivos! ğŸ‰

#### 3. **Notas o advertencias:**

- **Funciones Puras:** Esto funciona bien con **funciones puras**, ya que es seguro llamarlas durante el renderizado. ğŸ˜‡
- **Manejadores de Eventos NO:** Si la funciÃ³n es un **manejador de eventos** y no quieres que sus cambios re-sincronicen tu Effect, Â¡usa **Effect Events** en su lugar! ğŸ (Como vimos en la secciÃ³n J).
