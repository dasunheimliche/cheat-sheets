## A - Custom Hooks: Â¡Comparte LÃ³gica entre Componentes! ğŸ¤

#### 1. **Definicion:**

Imagina que quieres usar la misma lÃ³gica (como saber si el usuario estÃ¡ online) en varios componentes. Â¡Un **Custom Hook** es como una funciÃ³n mÃ¡gica que encapsula esa lÃ³gica reutilizable! Es como crear tus propios Hooks personalizados, Â¡ademÃ¡s de los que ya vienen con React como `useState` y `useEffect`! ğŸ§™â€â™‚ï¸

#### 2. **Ejemplo:**

**LÃ³gica duplicada (Â¡Feo! ğŸ˜–):**

```jsx
function StatusBar() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    /* ... lÃ³gica online ... */
  }, []);
  return <h1>{isOnline ? "âœ… Online" : "âŒ Desconectado"}</h1>;
}

function SaveButton() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    /* ... MISMA lÃ³gica online ... */
  }, []);
  return <button disabled={!isOnline}>...</button>;
}
```

**Usando un Custom Hook (Â¡Limpio y reutilizable! âœ¨):**

```jsx
// useOnlineStatus.js (Â¡Nuestro Custom Hook!)
function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    /* ... lÃ³gica online ... */
  }, []);
  return isOnline;
}

// StatusBar.js y SaveButton.js (Â¡Componentes mÃ¡s limpios!)
function StatusBar() {
  const isOnline = useOnlineStatus(); // âœ… Â¡Usamos nuestro Custom Hook!
  return <h1>{isOnline ? "âœ… Online" : "âŒ Desconectado"}</h1>;
}

function SaveButton() {
  const isOnline = useOnlineStatus(); // âœ… Â¡Reutilizamos el mismo Custom Hook!
  return <button disabled={!isOnline}>...</button>;
}
```

**ExplicaciÃ³n del ejemplo:**
Antes, tenÃ­amos la misma lÃ³gica para detectar el estado online/offline duplicada en `StatusBar` y `SaveButton`. Â¡QuÃ© rollo! ğŸ˜« Creamos un Custom Hook `useOnlineStatus` y movimos esa lÃ³gica ahÃ­. Ahora, ambos componentes **usan** `useOnlineStatus` para obtener el estado online, Â¡sin repetir cÃ³digo! ğŸ‰

#### 3. **Notas o advertencias:**

- **ReutilizaciÃ³n = Menos CÃ³digo = Menos Bugs:** Â¡Reutilizar lÃ³gica con Custom Hooks hace tu cÃ³digo mÃ¡s fÃ¡cil de mantener y menos propenso a errores! ğŸ›â¡ï¸âœ…
- **Componentes Describen QUÃ‰, No CÃ“MO:** Los Custom Hooks permiten que tus componentes se enfoquen en **quÃ©** quieren hacer (usar el estado online), no en **cÃ³mo** hacerlo (suscribirse a eventos del navegador). ğŸ¯

---

## B - Extraer un Custom Hook: Â¡De Componente a Hook! âœ‚ï¸

#### 1. **Definicion:**

Para crear un Custom Hook, simplemente **toma la lÃ³gica repetida de tus componentes (state y Effects)** y **mÃºvela a una funciÃ³n separada**. Â¡Esta funciÃ³n se convierte en tu Custom Hook! No olvides que el nombre debe empezar por `use`. âœ‚ï¸â¡ï¸ğŸ§™â€â™‚ï¸

#### 2. **Pasos:**

1.  **Identifica la lÃ³gica repetida:** Busca state y Effects que se repiten en varios componentes. ğŸ”
2.  **Crea una funciÃ³n `use[Nombre]`:** Dale un nombre descriptivo que empiece por `use` (ej: `useOnlineStatus`, `useFormInput`). âœï¸
3.  **Mueve la lÃ³gica al Hook:** Corta y pega el state y los Effects repetidos dentro de tu nueva funciÃ³n Hook. âœ‚ï¸â¡ï¸ğŸ“¦
4.  **Retorna lo que necesiten los componentes:** El Hook debe retornar los valores (state, funciones) que los componentes necesitan usar. ğŸ“¤
5.  **Usa el Hook en los componentes:** En lugar de repetir la lÃ³gica, llama a tu Custom Hook en cada componente. ğŸ“

**Ejemplo (Extrayendo `useOnlineStatus`):**

**Antes (Componente con lÃ³gica online):**

```jsx
function StatusBar() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    /* ... lÃ³gica online ... */
  }, []);
  // ...
}
```

**DespuÃ©s (Custom Hook `useOnlineStatus`):**

```jsx
// useOnlineStatus.js
function useOnlineStatus() {
  // âœ… Creamos el Custom Hook
  const [isOnline, setIsOnline] = useState(true); // âœ… Movemos el state
  useEffect(() => {
    /* ... lÃ³gica online ... */
  }, []); // âœ… Movemos el Effect
  return isOnline; // âœ… Retornamos el estado 'isOnline'
}

// StatusBar.js (Componente usando el Hook)
function StatusBar() {
  const isOnline = useOnlineStatus(); // âœ… Usamos el Custom Hook
  // ...
}
```

**ExplicaciÃ³n del ejemplo:**
Tomamos el `useState` y el `useEffect` de `StatusBar` y los movimos a la funciÃ³n `useOnlineStatus`. Â¡Ahora `useOnlineStatus` es nuestro Custom Hook! Retornamos `isOnline` para que `StatusBar` pueda usarlo. Â¡Magia! âœ¨

#### 3. **Notas o advertencias:**

- **Nombre `use[Nombre]`:** Â¡IMPRESCINDIBLE! React necesita que los nombres de los Custom Hooks empiecen por `use` para que funcionen correctamente. âš ï¸
- **Retorna Valores Ãštiles:** Piensa quÃ© necesitan tus componentes del Hook y asegÃºrate de retornarlo. ğŸ

---

## C - Nombres de Hooks: Â¡Siempre Empiezan con `use`! ğŸ·ï¸

#### 1. **Definicion:**

Â¡Regla de ORO! ğŸŒŸ **Todos los nombres de Hooks (tanto los de React como los Custom Hooks) deben empezar con `use` seguido de una letra mayÃºscula.** Esto le dice a React (y a otros desarrolladores) que esa funciÃ³n es un Hook y sigue las reglas de los Hooks. Â¡Es como una etiqueta que identifica a los Hooks! ğŸ·ï¸

#### 2. **Convenciones de Nombres:**

1.  **Componentes:** Nombres **con mayÃºscula inicial** (ej: `StatusBar`, `SaveButton`). Retornan JSX.
2.  **Hooks:** Nombres **empiezan con `use` y mayÃºscula despuÃ©s** (ej: `useState`, `useEffect`, `useOnlineStatus`). Pueden retornar cualquier valor.

**Ejemplos:**

- âœ… `useState` (Hook de React)
- âœ… `useEffect` (Hook de React)
- âœ… `useContext` (Hook de React)
- âœ… `useOnlineStatus` (Custom Hook)
- âœ… `useFormInput` (Custom Hook)
- âŒ `onlineStatus` (Â¡Falta `use`!)
- âŒ `UseOnlineStatus` (Â¡`U` de `Use` debe ser minÃºscula!)
- âŒ `getOnlineStatus` (Â¡Empieza por `get`, no por `use`!)

**Linter te ayuda:** Si tu linter estÃ¡ configurado para React, Â¡te avisarÃ¡ si no sigues esta convenciÃ³n de nombres! ğŸ‘®â€â™‚ï¸

**Ejemplo de Error de Linter (si renombras `useOnlineStatus` a `getOnlineStatus`):**

```jsx
function getOnlineStatus() {
  // ğŸ”´ Â¡MAL NOMBRE! No empieza por 'use'
  const [isOnline, setIsOnline] = useState(true); // ğŸ”´ Â¡ERROR! No puedes usar Hooks aquÃ­
  useEffect(() => {
    /* ... */
  }, []); // ğŸ”´ Â¡ERROR! No puedes usar Hooks aquÃ­
  return isOnline;
}
```

**ExplicaciÃ³n del ejemplo:**
Si renombras `useOnlineStatus` a `getOnlineStatus`, el linter te dirÃ¡ que **no puedes usar `useState` o `useEffect` dentro de `getOnlineStatus`**. Â¡Solo las funciones que empiezan por `use` (Hooks) pueden llamar a otros Hooks! ğŸš¨

#### 3. **Notas o advertencias:**

- **ConvenciÃ³n = Regla:** Â¡No es solo una sugerencia! Es una **regla** que debes seguir para que React funcione correctamente y tu cÃ³digo sea comprensible. âš ï¸
- **Linter te Protege:** El linter te ayuda a recordar esta regla y evitar errores. Â¡ConfÃ­a en Ã©l! ğŸ›¡ï¸

---

## D - Custom Hooks: Â¡Comparten LÃ³gica, NO Estado! ğŸ­

#### 1. **Definicion:**

Â¡OJO! ğŸ‘€ Los Custom Hooks te permiten **compartir la lÃ³gica con estado** (la forma en que el estado se actualiza, los Effects, etc.), **pero NO el estado en sÃ­**. Cada vez que llamas a un Custom Hook en un componente, Â¡obtienes una **instancia INDEPENDIENTE** del estado! No es que el estado se comparta entre componentes. Â¡Es como si cada componente tuviera su propia "copia" de la lÃ³gica y el estado del Hook! ğŸ­

#### 2. **Ejemplo (Formulario con `useFormInput`):**

```jsx
// useFormInput.js
function useFormInput(initialValue) {
  const [value, setValue] = useState(initialValue);
  // ...
  return { value, onChange: handleChange };
}

// Form.js
function Form() {
  const firstNameProps = useFormInput("Mary"); // ğŸ“ Â¡Llamada 1 a useFormInput!
  const lastNameProps = useFormInput("Poppins"); // ğŸ“ Â¡Llamada 2 a useFormInput!

  return (
    <>
      <label>
        First name: <input {...firstNameProps} />
      </label>
      <label>
        Last name: <input {...lastNameProps} />
      </label>
      <p>
        <b>
          Good morning, {firstNameProps.value} {lastNameProps.value}.
        </b>
      </p>
    </>
  );
}
```

**ExplicaciÃ³n del ejemplo:**
En `Form`, llamamos a `useFormInput` **dos veces**: una para `firstName` y otra para `lastName`. Â¡Cada llamada crea su **propio** `value` state! Cambiar el `firstName` **NO afecta** al `lastName`, Â¡porque son estados independientes! Los Custom Hooks **reutilizan la lÃ³gica**, pero **no comparten el estado entre diferentes llamadas**. ğŸ‘¯â€â™€ï¸â¡ï¸ğŸ‘¤ğŸ‘¤

#### 3. **Notas o advertencias:**

- **Instancias Independientes:** Cada llamada a un Custom Hook crea una nueva instancia de su estado y Effects. ğŸ‘¤
- **Compartir ESTADO = Levantar el Estado:** Si necesitas que el **estado SÃ se comparta** entre componentes, necesitas "levantar el estado" al componente padre y pasarlo como props. â¬†ï¸

---

## E - Pasar Valores Reactivos entre Hooks: Â¡Como Efectos en Cadena! ğŸ”—

#### 1. **Definicion:**

Los Custom Hooks se **re-ejecutan en cada re-render** del componente que los usa, Â¡igual que el cÃ³digo dentro de un componente! Esto significa que siempre reciben los **Ãºltimos props y state** del componente. Puedes **pasar valores reactivos (props, state) como argumentos a tus Custom Hooks**, y el Hook "reaccionarÃ¡" a esos cambios, Â¡igual que un Effect! Es como conectar Hooks en "cadena". ğŸ”—

#### 2. **Ejemplo (Chat con `useChatRoom`):**

```jsx
// useChatRoom.js
function useChatRoom({ serverUrl, roomId }) {
  // âœ… Recibe props como argumentos
  useEffect(() => {
    // ... usa serverUrl y roomId ...
  }, [roomId, serverUrl]); // âœ… Dependencias del Effect
}

// ChatRoom.js
function ChatRoom({ roomId }) {
  const [serverUrl, setServerUrl] = useState("https://localhost:1234");

  useChatRoom({
    // âœ… Pasa state y prop como argumentos al Custom Hook
    roomId: roomId,
    serverUrl: serverUrl,
  });

  // ...
}
```

**ExplicaciÃ³n del ejemplo:**
`useChatRoom` recibe `serverUrl` y `roomId` como argumentos. Dentro de `useChatRoom`, el `useEffect` depende de `roomId` y `serverUrl`. Cuando `ChatRoom` re-renderiza (porque `serverUrl` o `roomId` cambian), **se vuelve a llamar a `useChatRoom` con los nuevos valores**. Â¡El `useEffect` dentro de `useChatRoom` "reacciona" a estos cambios y se re-ejecuta! ğŸ”„

#### 3. **Notas o advertencias:**

- **Hooks se Re-renderizan con Componentes:** Piensa en el cÃ³digo dentro de un Custom Hook como parte del cuerpo de tu componente. Se re-ejecuta en cada render. ğŸ”„
- **Encadenamiento de Hooks:** Puedes "encadenar" Hooks, pasando la salida de un Hook como entrada a otro. Â¡Es como efectos de audio o video en cadena! ğŸ¶ğŸ¬

---

## F - Pasar Manejadores de Eventos a Custom Hooks: Â¡PersonalizaciÃ³n! ğŸ

#### 1. **Definicion:**

Puedes hacer que tus Custom Hooks sean **mÃ¡s flexibles y personalizables** permitiendo que los componentes les pasen **manejadores de eventos como argumentos**. Por ejemplo, en `useChatRoom`, podrÃ­as permitir que el componente defina **quÃ© hacer cuando se recibe un nuevo mensaje**. Â¡Es como darle "ganchos" a tu Hook para que los componentes puedan "colgar" su propia lÃ³gica! ğŸ

#### 2. **Ejemplo (Chat con `onReceiveMessage` personalizable):**

```jsx
// useChatRoom.js
function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {
  // âœ… Recibe onReceiveMessage
  useEffect(() => {
    connection.on("message", (msg) => {
      onReceiveMessage(msg); // âœ… Llama al manejador de eventos pasado como argumento
    });
  }, [roomId, serverUrl, onReceiveMessage]); // âš ï¸ Â¡Dependencia de onReceiveMessage! (Mejorable con Effect Event)
}

// ChatRoom.js
function ChatRoom({ roomId }) {
  useChatRoom({
    roomId: roomId,
    serverUrl: serverUrl,
    onReceiveMessage(msg) {
      // âœ… Pasa un manejador de eventos personalizado
      showNotification("Nuevo mensaje: " + msg);
    },
  });
  // ...
}
```

**ExplicaciÃ³n del ejemplo:**
Ahora `useChatRoom` recibe `onReceiveMessage` como argumento. `ChatRoom` le pasa su propia funciÃ³n `onReceiveMessage` que muestra una notificaciÃ³n. Dentro de `useChatRoom`, cuando se recibe un mensaje, **se llama a la funciÃ³n `onReceiveMessage` que le pasÃ³ el componente**. Â¡AsÃ­, `ChatRoom` personaliza el comportamiento de `useChatRoom`! ğŸ‰

**Mejora con Effect Event:** La dependencia `onReceiveMessage` en `useEffect` puede causar re-conexiones innecesarias. Â¡Podemos usar `useEffectEvent` para eliminarla! (Ver secciÃ³n anterior de Cheat Sheet sobre Effect Dependencies).

```jsx
import { useEffect, useEffectEvent } from "react";

function useChatRoom({ serverUrl, roomId, onReceiveMessage }) {
  const onMessageEvent = useEffectEvent(onReceiveMessage); // âœ… Effect Event

  useEffect(() => {
    connection.on("message", (msg) => {
      onMessageEvent(msg); // âœ… Llama al Effect Event
    });
  }, [roomId, serverUrl]); // âœ… Â¡Ya no depende de onReceiveMessage!
}
```

#### 3. **Notas o advertencias:**

- **Flexibilidad y ReutilizaciÃ³n:** Permitir pasar manejadores de eventos hace que tus Custom Hooks sean mÃ¡s **reutilizables y adaptables** a diferentes componentes. ğŸ¤¸â€â™€ï¸
- **Effect Events para Manejadores:** Si pasas manejadores de eventos a Custom Hooks, considera usar `useEffectEvent` para evitar dependencias innecesarias y re-ejecuciones. ğŸâ¡ï¸ğŸ§˜

---

## G - Â¿CuÃ¡ndo Usar Custom Hooks? Â¡No Para Todo! ğŸ¤”

#### 1. **Definicion:**

Â¡No te emociones demasiado! ğŸ˜œ **No necesitas crear un Custom Hook para cada pequeÃ±a repeticiÃ³n de cÃ³digo.** A veces, un poco de duplicaciÃ³n estÃ¡ bien. Los Custom Hooks son mÃ¡s Ãºtiles para **lÃ³gica compleja y reutilizable**, especialmente la que involucra Effects. Â¡Ãšsalos con sabidurÃ­a! ğŸ¦‰

#### 2. **CuÃ¡ndo SÃ usar Custom Hooks:**

- **LÃ³gica de Effects Compleja:** Cuando tienes Effects que son largos, difÃ­ciles de entender o que se repiten en varios componentes. ğŸ˜µâ€ğŸ’«â¡ï¸ğŸ§™â€â™‚ï¸
- **SincronizaciÃ³n con Sistemas Externos:** Effects que se conectan a APIs, websockets, timers, etc. ğŸŒ
- **ReutilizaciÃ³n de LÃ³gica con Estado:** Cuando quieres reutilizar lÃ³gica que involucra `useState` y `useEffect` en diferentes componentes. ğŸ‘¯â€â™€ï¸
- **CÃ³digo MÃ¡s Declarativo:** Para que tus componentes se enfoquen en **quÃ©** hacen, no en **cÃ³mo** lo hacen. ğŸ¯
- **AbstracciÃ³n de ImplementaciÃ³n:** Para "esconder" los detalles "sucios" de cÃ³mo interactÃºas con sistemas externos. ğŸ™ˆ

**Ejemplo (Extrayendo `useData` para fetching):**

**Antes (Fetching repetido en componentes):**

```jsx
function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  useEffect(() => {
    /* ... fetch cities ... */
  }, [country]);

  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);
  useEffect(() => {
    /* ... fetch areas ... */
  }, [city]);
  // ...
}
```

**DespuÃ©s (Custom Hook `useData` para fetching):**

```jsx
// useData.js
function useData(url) {
  const [data, setData] = useState(null);
  useEffect(() => {
    /* ... fetch data from url ... */
  }, [url]);
  return data;
}

// ShippingForm.js
function ShippingForm({ country }) {
  const cities = useData(`/api/cities?country=${country}`); // âœ… Usa useData para cities
  const [city, setCity] = useState(null);
  const areas = useData(city ? `/api/areas?city=${city}` : null); // âœ… Usa useData para areas
  // ...
}
```

**ExplicaciÃ³n del ejemplo:**
En lugar de repetir la lÃ³gica de fetching en `ShippingForm`, creamos un Custom Hook `useData` que encapsula esa lÃ³gica. Ahora, `ShippingForm` usa `useData` para obtener tanto las ciudades como las Ã¡reas, Â¡de forma mucho mÃ¡s limpia y reutilizable! âœ¨

#### 3. **Notas o advertencias:**

- **No Exageres:** No conviertas cada funciÃ³n pequeÃ±a en un Custom Hook. Empieza por la lÃ³gica mÃ¡s compleja y repetitiva. ğŸ§˜
- **Claridad y PropÃ³sito:** Un buen Custom Hook tiene un **nombre claro** y un **propÃ³sito bien definido**. Si te cuesta nombrar tu Hook, Â¡quizÃ¡s no estÃ© listo para ser extraÃ­do! ğŸ¤”

---

## H - Hooks Customizados: Â¡EnfÃ³cate en Casos de Uso Concretos! ğŸ¯

#### 1. **Definicion:**

Cuando crees Custom Hooks, **enfÃ³cate en casos de uso concretos y de alto nivel**. El nombre de tu Hook debe ser **claro y descriptivo**, incluso para alguien que no sea programador. Evita crear Hooks demasiado genÃ©ricos o abstractos que sean solo "wrappers" convenientes para `useEffect`. Â¡Un buen Custom Hook hace que el cÃ³digo que lo usa sea mÃ¡s **declarativo y fÃ¡cil de entender**! ğŸ¯

#### 2. **Ejemplos de Nombres de Custom Hooks:**

**Buenos Nombres (Casos de Uso Concretos):**

- âœ… `useData(url)` (Obtiene datos de una URL)
- âœ… `useImpressionLog(eventName, extraData)` (Registra una impresiÃ³n en analytics)
- âœ… `useChatRoom(options)` (Conecta a una sala de chat)
- âœ… `useMediaQuery(query)` (Verifica si se cumple una media query)
- âœ… `useSocket(url)` (Conecta a un WebSocket)
- âœ… `useIntersectionObserver(ref, options)` (Observa la intersecciÃ³n de un elemento)

**Malos Nombres (Demasiado Abstractos o "Lifecycle"):**

- âŒ `useMount(fn)` (Ejecuta una funciÃ³n solo al montar el componente - Â¡Demasiado "lifecycle"!)
- âŒ `useEffectOnce(fn)` (Ejecuta un Effect solo una vez - Â¡Wrapper de `useEffect`!)
- âŒ `useUpdateEffect(fn)` (Ejecuta un Effect solo en actualizaciones - Â¡Otro wrapper!)
- âŒ `useGenericEffect(options)` (Â¡Demasiado genÃ©rico! No describe el propÃ³sito)

**Ejemplo de Hook "lifecycle" `useMount` (Â¡EVITAR! ğŸ”´):**

```jsx
// ğŸ”´ Â¡MAL! Hook "lifecycle" useMount
function useMount(fn) {
  useEffect(() => {
    fn();
  }, []); // ğŸ”´ Â¡Problema! No reacciona a cambios de props/state
}

function ChatRoom({ roomId }) {
  useMount(() => {
    // ğŸ”´ Â¡MAL USO!
    // ... lÃ³gica de conexiÃ³n al chat ...
  });
  // ...
}
```

**ExplicaciÃ³n del ejemplo:**
`useMount` intenta ser un "wrapper" para ejecutar cÃ³digo solo "al montar" el componente. Â¡Pero esto es un **anti-patrÃ³n**! Los Hooks "lifecycle" como `useMount` son **demasiado abstractos** y **no encajan bien con el paradigma de React**. AdemÃ¡s, Â¡pueden ocultar errores! (Como no reaccionar a cambios de props/state). Es mejor usar `useEffect` directamente y enfocarse en el **propÃ³sito** de tu Effect, no en su "lifecycle". ğŸ¯

#### 3. **Notas o advertencias:**

- **Nombres Descriptivos = CÃ³digo Declarativo:** Un buen nombre de Custom Hook hace que el cÃ³digo que lo usa sea mÃ¡s **declarativo y fÃ¡cil de entender**. ğŸ“–
- **Evita Abstracciones Innecesarias:** No crees Custom Hooks solo por crear abstracciones. Ãšsalos para **resolver problemas concretos** y hacer tu cÃ³digo mÃ¡s claro y reutilizable. ğŸ§˜

---

## I - Custom Hooks: Â¡Migra a Mejores Patrones! ğŸš€

#### 1. **Definicion:**

Los Effects son como "vÃ­as de escape" para interactuar con sistemas externos. Pero el objetivo de React es **reducir al mÃ­nimo el uso de Effects**, proporcionando soluciones mÃ¡s especÃ­ficas para problemas comunes. Los Custom Hooks te ayudan a **encapsular tus Effects** y facilitan la **migraciÃ³n a mejores patrones** cuando React ofrece nuevas APIs. Â¡Es como preparar tu cÃ³digo para el futuro! ğŸš€

#### 2. **Ejemplo (Migrando `useOnlineStatus` a `useSyncExternalStore`):**

**`useOnlineStatus` original (con `useState` y `useEffect`):**

```jsx
function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);
  useEffect(() => {
    /* ... lÃ³gica online ... */
  }, []);
  return isOnline;
}
```

**`useOnlineStatus` mejorado (con `useSyncExternalStore`):**

```jsx
import { useSyncExternalStore } from "react";

function subscribe(callback) {
  /* ... lÃ³gica de suscripciÃ³n a eventos online/offline ... */
}

function useOnlineStatus() {
  return useSyncExternalStore(
    subscribe,
    () => navigator.onLine, // âœ… Obtiene valor inicial del cliente
    () => true // âœ… Obtiene valor inicial del servidor
  );
}
```

**Componentes NO CAMBIAN:**

```jsx
function StatusBar() {
  const isOnline = useOnlineStatus(); // âœ… Â¡Sigue funcionando igual!
  // ...
}

function SaveButton() {
  const isOnline = useOnlineStatus(); // âœ… Â¡Sigue funcionando igual!
  // ...
}
```

**ExplicaciÃ³n del ejemplo:**
`useOnlineStatus` original tenÃ­a algunos problemas (ej: valor inicial incorrecto en ciertas situaciones). React 18 introdujo `useSyncExternalStore`, una API **mejor y mÃ¡s robusta** para sincronizar con fuentes de datos externas. **Migramos `useOnlineStatus` para usar `useSyncExternalStore`, Â¡pero los componentes que usaban `useOnlineStatus` NO NECESITARON CAMBIAR!** Los Custom Hooks **encapsulan la implementaciÃ³n**, permitiendo actualizaciones sin afectar el resto de la app. ğŸ‰

#### 3. **Notas o advertencias:**

- **EncapsulaciÃ³n = Flexibilidad:** Encapsular Effects en Custom Hooks te da **flexibilidad** para cambiar la implementaciÃ³n interna sin romper el cÃ³digo que usa el Hook. ğŸ›¡ï¸
- **Preparado para el Futuro de React:** Usar Custom Hooks te ayuda a **mantener tu cÃ³digo actualizado** y aprovechar las nuevas APIs de React mÃ¡s fÃ¡cilmente. ğŸš€
- **Design System de Hooks:** Piensa en crear un "design system" de Custom Hooks para tu app, encapsulando patrones comunes y facilitando la evoluciÃ³n del cÃ³digo. ğŸ—ï¸

---

## J - Â¡Hay MÃ¡s de Una Forma de Hacerlo! (Ejemplo AnimaciÃ³n Fade-In) ğŸ­

#### 1. **Definicion:**

No hay una "Ãºnica forma correcta" de extraer lÃ³gica en Custom Hooks. A veces, puedes tener **varias opciones** y la mejor dependerÃ¡ de tu caso especÃ­fico y preferencias. Incluso para una tarea simple como una animaciÃ³n fade-in, Â¡puedes usar diferentes enfoques! Lo importante es **elegir el que haga tu cÃ³digo mÃ¡s claro, mantenible y eficiente**. ğŸ­

#### 2. **Ejemplos de Enfoques para Fade-In:**

1.  **`useFadeIn` con `requestAnimationFrame` (LÃ³gica en el Hook):**

    ```jsx
    function useFadeIn(ref, duration) {
      useEffect(() => {
        /* ... lÃ³gica de animaciÃ³n con requestAnimationFrame ... */
      }, [ref, duration]);
    }
    ```

2.  **`useFadeIn` y `useAnimationLoop` (Hooks en Cadena):**

    ```jsx
    function useAnimationLoop(isRunning, drawFrame) {
      /* ... Hook para loop de animaciÃ³n ... */
    }

    function useFadeIn(ref, duration) {
      useAnimationLoop(isRunning, (timePassed) => {
        /* ... lÃ³gica fade-in dentro del loop ... */
      });
    }
    ```

3.  **`useFadeIn` con Clase `FadeInAnimation` (LÃ³gica en Clase Externa):**

    ```jsx
    // animation.js (Clase JavaScript)
    class FadeInAnimation {
      /* ... lÃ³gica de animaciÃ³n en una clase ... */
    }

    function useFadeIn(ref, duration) {
      useEffect(() => {
        const animation = new FadeInAnimation(ref.current);
        animation.start(duration);
        return () => animation.stop();
      }, [ref, duration]);
    }
    ```

4.  **Â¡Sin Hook! Â¡AnimaciÃ³n con CSS! (SoluciÃ³n MÃ¡s Simple y Eficiente):**

```css
.welcome {
    animation: fadeIn 1000ms;
}

@keyframes fadeIn {
    0% { opacity: 0; }
    100% { opacity: 1; }
}
```

```jsx
function Welcome() {
    return <h1 className="welcome">Welcome</h1>; // âœ… Â¡AnimaciÃ³n con CSS!
}
```

**ExplicaciÃ³n de los ejemplos:**
Vemos diferentes formas de implementar fade-in. Desde un Hook que lo hace todo (`useFadeIn` 1), hasta dividir la lÃ³gica en Hooks mÃ¡s pequeÃ±os (`useFadeIn` y `useAnimationLoop` 2), usar una clase externa (3), Â¡o incluso **no usar JavaScript y hacerlo solo con CSS** (4)! **CSS Animations son la soluciÃ³n mÃ¡s simple y eficiente para este caso.** A veces, Â¡la mejor soluciÃ³n es la mÃ¡s simple y no necesita JavaScript ni Hooks! ğŸ§˜

#### 3. **Notas o advertencias:**

- **Elige la Mejor OpciÃ³n para Tu Caso:** Considera la complejidad, reutilizaciÃ³n, rendimiento y claridad de cada enfoque. No siempre hay una "respuesta correcta" Ãºnica. ğŸ¤”
- **Simplicidad Primero:** Â¡Empieza por la soluciÃ³n mÃ¡s simple! A veces, no necesitas un Hook complejo cuando una soluciÃ³n mÃ¡s sencilla (como CSS) es suficiente. ğŸ§˜â€â™€ï¸
- **Refactoriza y Experimenta:** No tengas miedo de refactorizar y experimentar con diferentes enfoques para encontrar el que mejor se adapte a tus necesidades. ğŸ› ï¸
