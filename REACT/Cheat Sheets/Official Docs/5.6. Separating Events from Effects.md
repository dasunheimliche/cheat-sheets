## A - Eventos vs. Efectos en React

#### 1. **DefiniciÃ³n:**

- **Eventos (Event Handlers):** Son funciones que **responden a acciones especÃ­ficas del usuario**, como clics, cambios en inputs, etc. Piensa en ellos como "reacciones manuales" a lo que el usuario hace. Solo se ejecutan cuando ocurre la interacciÃ³n definida.
- **Efectos (Effects):** Son funciones que **mantienen tu componente sincronizado con el exterior**. Se ejecutan automÃ¡ticamente despuÃ©s de cada renderizado (o cuando cambian ciertas dependencias) para asegurar que tu componente estÃ© "al dÃ­a" con el mundo que lo rodea. Son como "reacciones automÃ¡ticas" a los cambios en los datos o en el entorno.

#### 2. **Ejemplo:**

Imagina un componente para un chat:

```jsx
import { useState, useEffect } from "react";

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState("");

  // ğŸ’¬ Evento: Enviar mensaje al hacer clic en "Enviar"
  function handleSendClick() {
    sendMessage(message);
  }

  // ğŸ”Œ Efecto: Conectar al chat room cuando cambia 'roomId'
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect(); // Desconectar al desmontar o al cambiar 'roomId'
  }, [roomId]);

  return (
    <>
      <input value={message} onChange={(e) => setMessage(e.target.value)} />
      <button onClick={handleSendClick}>Enviar</button>
    </>
  );
}
```

**ExplicaciÃ³n del ejemplo:**

- **`handleSendClick` (Evento):** Solo se ejecuta **cuando el usuario hace clic en el botÃ³n "Enviar"**. Enviar un mensaje es una acciÃ³n _especÃ­fica_ del usuario.
- **`useEffect` (Efecto):** Se ejecuta **cada vez que `roomId` cambia**. La conexiÃ³n al chat debe _sincronizarse_ con el `roomId` actual, sin importar _por quÃ©_ o _cÃ³mo_ cambiÃ³. Incluso si `roomId` no cambia, el efecto se ejecuta al menos una vez al inicio para establecer la conexiÃ³n inicial.

#### 3. **Notas o advertencias:**

- **PregÃºntate el "por quÃ©":** Para decidir si usar un evento o un efecto, piensa en **por quÃ©** necesitas que se ejecute ese cÃ³digo. Â¿Es por una acciÃ³n _especÃ­fica_ del usuario (evento)? Â¿Es para mantener la _sincronizaciÃ³n_ con algo (efecto)?
- **Reactividad:** Los efectos son reactivos, los eventos no. Esto lo veremos con mÃ¡s detalle en el siguiente punto.

---

## B - Valores Reactivos y LÃ³gica Reactiva

#### 1. **DefiniciÃ³n:**

- **Valores Reactivos:** Son las `props`, el `state`, y las variables que declaras **dentro del cuerpo de tu componente**. Estos valores pueden cambiar y provocar que React vuelva a renderizar el componente. En el ejemplo anterior, `roomId` y `message` son reactivos. `serverUrl` no lo es porque estÃ¡ fuera del componente y no cambia con el renderizado.
- **LÃ³gica Reactiva:** Es la lÃ³gica que **reacciona a los cambios en los valores reactivos**. Los **Efectos** son reactivos. Si un efecto usa un valor reactivo, y ese valor cambia, el efecto se vuelve a ejecutar.
- **LÃ³gica No Reactiva:** Es la lÃ³gica que **no reacciona automÃ¡ticamente a los cambios en los valores reactivos**. Los **Eventos** son no reactivos. Aunque un evento use un valor reactivo, el evento solo se ejecuta cuando se produce la interacciÃ³n, no cuando el valor reactivo cambia por sÃ­ solo.

#### 2. **Ejemplo:**

Volvamos al ejemplo del chat:

```jsx
function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  function handleSendClick() {
    // LÃ³gica NO reactiva: solo se ejecuta al hacer clic
    sendMessage(message);
  }

  useEffect(() => {
    // LÃ³gica REACTIVA: se ejecuta y re-ejecuta si roomId cambia
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // âœ… 'roomId' es una dependencia reactiva
```

**ExplicaciÃ³n del ejemplo:**

- **`sendMessage(message)` en `handleSendClick`:** Esta lÃ­nea es **no reactiva**. Cambiar el valor de `message` (mientras el usuario escribe) **no deberÃ­a enviar el mensaje automÃ¡ticamente**. Solo se envÃ­a cuando el usuario _manualmente_ hace clic en "Enviar".
- **`createConnection(serverUrl, roomId)` en `useEffect`:** Esta lÃ­nea es **reactiva**. Si `roomId` cambia (por ejemplo, el usuario elige otra sala), **queremos que la conexiÃ³n se actualice automÃ¡ticamente** a la nueva sala. Por eso, `roomId` se pone como dependencia del `useEffect`.

#### 3. **Notas o advertencias:**

- **Dependencias de los Efectos:** React te pide que declares como **dependencias** todos los valores reactivos que uses dentro de un `useEffect`. Esto le permite a React saber cuÃ¡ndo debe volver a ejecutar el efecto (cuando alguna dependencia cambia). Si olvidas una dependencia, Â¡React te avisarÃ¡! ğŸš¨

---

## C - Extraer LÃ³gica No Reactiva de los Efectos con Effect Events

#### 1. **El Problema:**

A veces, dentro de un efecto reactivo, necesitas ejecutar cÃ³digo que **no quieres que sea reactivo**. Imagina que quieres mostrar una notificaciÃ³n cuando te conectas al chat, y quieres que la notificaciÃ³n tenga el tema (claro/oscuro) actual:

```jsx
function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('Â¡Conectado!', theme); // ğŸ¨ Queremos usar 'theme' pero NO hacerlo reactivo
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, theme]); // ğŸ”´ Problema: 'theme' como dependencia hace que se reconecte al cambiar el tema
```

**Problema:** `theme` es un valor reactivo. Si lo pones como dependencia del `useEffect`, la conexiÃ³n al chat se **volverÃ¡ a establecer cada vez que cambies el tema**, Â¡y eso no es lo que queremos! Solo queremos que la conexiÃ³n se restablezca cuando cambie `roomId`.

#### 2. **La SoluciÃ³n: Effect Events**

==React (en su versiÃ³n experimental) nos da una herramienta genial: `useEffectEvent`. Un **Effect Event** te permite extraer una parte de la lÃ³gica de tu efecto y hacerla **no reactiva**.==

```jsx
import { useEffect, experimental_useEffectEvent as useEffectEvent } from 'react';

function ChatRoom({ roomId, theme }) {
  // âœ¨ Creamos un Effect Event para la notificaciÃ³n
  const onConnected = useEffectEvent(() => {
    showNotification('Â¡Conectado!', theme); // âœ… 'theme' se usa aquÃ­, pero NO hace que el efecto se re-ejecute al cambiar
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected(); // ğŸš€ Llamamos al Effect Event desde el efecto
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // âœ… Â¡Solo 'roomId' como dependencia!
```

**ExplicaciÃ³n:**

- **`useEffectEvent(() => { ... })`:** Crea un Effect Event llamado `onConnected`. La lÃ³gica dentro de `onConnected` **no es reactiva**. Puede usar `theme` sin que `theme` se convierta en una dependencia del `useEffect` principal.
- **`onConnected()` dentro del `useEffect`:** Llamamos al Effect Event desde dentro del efecto. El efecto sigue siendo reactivo a `roomId`, pero la notificaciÃ³n (y el uso de `theme`) dentro de `onConnected` ya no lo es.

#### 3. **DefiniciÃ³n de Effect Events:**

- Son como "event handlers" dentro de los efectos.
- La lÃ³gica dentro de un Effect Event **no es reactiva**.
- Siempre "ven" los **valores mÃ¡s recientes** de props y state cuando se ejecutan.
- Se usan para separar la lÃ³gica no reactiva de la lÃ³gica reactiva dentro de un efecto.

---

## D - Leer las Ãšltimas Props y State con Effect Events

#### 1. **Caso de Uso: Registrar Visitas a PÃ¡ginas**

Imagina que quieres registrar las visitas a las pÃ¡ginas de tu sitio web. Tienes un componente `Page` que recibe la `url` de la pÃ¡gina actual. TambiÃ©n quieres incluir el nÃºmero de items en el carrito de compras en cada registro de visita.

```jsx
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  useEffect(() => {
    logVisit(url, numberOfItems); // ğŸ›’ Queremos 'numberOfItems' pero NO reactivo a cambios en el carrito
  }, [url]); // ğŸ”´ Problema: React te pide aÃ±adir 'numberOfItems' como dependencia
```

**Problema:** React te pide que aÃ±adas `numberOfItems` como dependencia del `useEffect`. Pero **no queremos que `logVisit` se ejecute cada vez que cambia el nÃºmero de items en el carrito**. Solo queremos registrar la visita cuando la `url` de la pÃ¡gina cambia. La visita a la pÃ¡gina es el "evento", no los cambios en el carrito.

#### 2. **SoluciÃ³n con Effect Events:**

```jsx
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  // âœ¨ Effect Event para registrar la visita
  const onVisit = useEffectEvent((visitedUrl) => {
    logVisit(visitedUrl, numberOfItems); // âœ… 'numberOfItems' se usa aquÃ­ sin hacerlo reactivo
  });

  useEffect(() => {
    onVisit(url); // ğŸš€ Llamamos al Effect Event desde el efecto
  }, [url]); // âœ… Â¡Solo 'url' como dependencia!
```

**ExplicaciÃ³n:**

- **`useEffectEvent((visitedUrl) => { ... })`:** Crea un Effect Event `onVisit` que recibe `visitedUrl` como argumento. Dentro de `onVisit`, usamos `numberOfItems` (del scope del componente) sin que sea una dependencia.
- **`onVisit(url)` dentro del `useEffect`:** Llamamos a `onVisit` desde el efecto, pasando la `url` actual. El efecto sigue siendo reactivo a `url`, pero `logVisit` dentro de `onVisit` no reacciona a los cambios en `numberOfItems`.

#### 3. **Nota Importante: Pasar Argumentos al Effect Event**

Es mejor pasar `url` como argumento a `onVisit` (`onVisit(url)`) en lugar de leer `url` directamente dentro de `onVisit`. Esto hace mÃ¡s explÃ­cito que la visita a una pÃ¡gina con una `url` diferente es un "evento" distinto. AdemÃ¡s, ayuda a que el linter te avise si accidentalmente eliminas `url` de las dependencias del `useEffect`.

```jsx
const onVisit = useEffectEvent((visitedUrl) => {
  // âœ… Mejor: 'visitedUrl' como argumento
  logVisit(visitedUrl, numberOfItems);
});
useEffect(() => {
  onVisit(url);
}, [url]);
```

**Notas o advertencias:**

- **Claridad:** Pasar argumentos a los Effect Events hace que tu cÃ³digo sea mÃ¡s claro y fÃ¡cil de entender.
- **Seguridad:** Ayuda a prevenir errores y a que el linter te proteja.

---

## ==E - Limitaciones de los Effect Events==

#### 1. **Restricciones de Uso:**

Los Effect Events tienen limitaciones importantes:

- **Solo se llaman desde dentro de Efectos:** No puedes llamar a un Effect Event desde un event handler, desde fuera de un componente React, etc. Su propÃ³sito es especÃ­fico para usarse _dentro_ de los efectos.
- **No se pasan a otros componentes o Hooks:** No puedes pasar un Effect Event como prop a otro componente, ni como callback a un Hook personalizado. Deben declararse y usarse localmente dentro del mismo componente donde se define el efecto.

#### 2. **Ejemplo de Uso Incorrecto y Correcto:**

**âŒ Incorrecto: Pasar un Effect Event a un Hook personalizado**

```jsx
function Timer() {
  const [count, setCount] = useState(0);
  const onTick = useEffectEvent(() => {
    setCount(count + 1);
  });
  useTimer(onTick, 1000); // ğŸ”´ Â¡MAL! No pasar Effect Events
  return <h1>{count}</h1>;
}

function useTimer(callback, delay) {
  // Hook personalizado
  useEffect(() => {
    const id = setInterval(() => {
      callback();
    }, delay);
    return () => clearInterval(id);
  }, [delay, callback]); // ğŸ”´ Necesitas 'callback' como dependencia (Â¡y esto causa problemas!)
}
```

**âœ… Correcto: Declarar el Effect Event localmente en el Hook**

```jsx
function Timer() {
  const [count, setCount] = useState(0);
  useTimer(() => {
    // âœ… Callback directamente en el Hook
    setCount(count + 1);
  }, 1000);
  return <h1>{count}</h1>;
}

function useTimer(callback, delay) {
  // Hook personalizado
  const onTick = useEffectEvent(() => {
    // âœ¨ Effect Event DENTRO del Hook
    callback();
  });
  useEffect(() => {
    const id = setInterval(() => {
      onTick(); // âœ… Â¡Bien! Llamada local al Effect Event
    }, delay);
    return () => clearInterval(id);
  }, [delay]); // âœ… Â¡No necesitas 'onTick' como dependencia!
}
```

**ExplicaciÃ³n:**

- **Incorrecto:** Pasar `onTick` a `useTimer` obliga a que `useTimer` tenga `callback` como dependencia, lo cual puede causar re-ejecuciones innecesarias del efecto dentro de `useTimer`.
- **Correcto:** Declarar `onTick` _dentro_ de `useTimer` y llamarlo localmente evita el problema de las dependencias innecesarias y mantiene el Effect Event dentro del Ã¡mbito de su efecto.

**Notas o advertencias:**

- **Localidad:** Los Effect Events son "piezas" no reactivas de tu cÃ³digo de efecto. Deben vivir cerca del efecto que los usa.
- **Simplicidad:** Si te encuentras pasando un Effect Event, probablemente haya una mejor manera de estructurar tu cÃ³digo.

---

## F - Â¿Por QuÃ© NO Suprimir el Linter de Dependencias?

#### 1. **Problemas de Suprimir el Linter:**

A veces, para evitar que React te pida dependencias en un `useEffect`, podrÃ­as sentirte tentado a **suprimir el linter** (la herramienta que te avisa de las dependencias faltantes). **Â¡NO LO HAGAS!** ğŸ™…â€â™‚ï¸

```jsx
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;
  useEffect(() => {
    logVisit(url, numberOfItems);
    // ğŸ”´ Â¡EVITA suprimir el linter asÃ­!
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [url]);
  // ...
}
```

**Problemas de suprimir el linter:**

- **Pierdes las advertencias de React:** React ya no te avisarÃ¡ si olvidas una dependencia importante. Esto puede llevar a errores difÃ­ciles de detectar.
- **Valores "Stale" (Obsoletos):** Si suprimes el linter, tu efecto podrÃ­a usar **valores antiguos** de props o state, en lugar de los valores mÃ¡s recientes. Esto causa comportamientos inesperados y bugs.

**CÃ³digo con el bug (por suprimir el linter):**

```jsx
function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  function handleMove(e) {
    if (canMove) {
      // ğŸ”´ 'canMove' SIEMPRE es 'true' (valor inicial)
      setPosition({ x: e.clientX, y: e.clientY });
    }
  }

  useEffect(() => {
    window.addEventListener("pointermove", handleMove);
    return () => window.removeEventListener("pointermove", handleMove);
    // eslint-disable-next-line react-hooks/exhaustive-deps // ğŸ”´ Â¡SUPRIMIDO!
  }, []);

  // ...
}
```

**SoluciÃ³n: No suprimir el linter y usar Effect Events (si es necesario):**

Usando `useEffectEvent`, evitamos suprimir el linter y el cÃ³digo funciona correctamente:

```jsx
function App() {
  // ...
  const onMove = useEffectEvent((e) => {
    // âœ¨ Effect Event
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  });

  useEffect(() => {
    window.addEventListener("pointermove", onMove);
    return () => window.removeEventListener("pointermove", onMove);
  }, []); // âœ… Â¡Sin dependencias!
  // ...
}
```

#### 3. **Alternativas a Suprimir el Linter:**

- **Effect Events:** Como hemos visto, son una excelente manera de manejar lÃ³gica no reactiva dentro de efectos.
- **Otras tÃ©cnicas:** Existen otras formas de "eliminar" dependencias de efectos de manera segura (sin suprimir el linter), como usar `useRef` o actualizar funciones fuera del renderizado. Pero los Effect Events son una soluciÃ³n muy Ãºtil y limpia para muchos casos.

**Notas o advertencias:**

- **Â¡Nunca mientas a React!** Suprimir el linter es como mentirle a React sobre las dependencias de tus efectos. Siempre termina mal. ğŸ˜…
- **ConfÃ­a en el linter:** El linter de React estÃ¡ ahÃ­ para ayudarte a escribir cÃ³digo correcto y evitar errores comunes. Â¡Hazle caso! ğŸ‘
