## A - Eventos vs. Efectos en React

#### 1. **Definici√≥n:**

- **Eventos (Event Handlers):** Son funciones que **responden a acciones espec√≠ficas del usuario**, como clics, cambios en inputs, etc. Piensa en ellos como "reacciones manuales" a lo que el usuario hace. Solo se ejecutan cuando ocurre la interacci√≥n definida.
- **Efectos (Effects):** Son funciones que **mantienen tu componente sincronizado con el exterior**. Se ejecutan autom√°ticamente despu√©s de cada renderizado (o cuando cambian ciertas dependencias) para asegurar que tu componente est√© "al d√≠a" con el mundo que lo rodea. Son como "reacciones autom√°ticas" a los cambios en los datos o en el entorno.

#### 2. **Ejemplo:**

Imagina un componente para un chat:

```jsx
import { useState, useEffect } from "react";

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState("");

  // üí¨ Evento: Enviar mensaje al hacer clic en "Enviar"
  function handleSendClick() {
    sendMessage(message);
  }

  // üîå Efecto: Conectar al chat room cuando cambia 'roomId'
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect(); // Desconectar al desmontar o al cambiar 'roomId'
  }, [roomId]);

  return (
    <>
      <input value={message} onChange={(e) => setMessage(e.target.value)} />
      <button onClick={handleSendClick}>Enviar</button>
    </>
  );
}
```

**Explicaci√≥n del ejemplo:**

- **`handleSendClick` (Evento):** Solo se ejecuta **cuando el usuario hace clic en el bot√≥n "Enviar"**. Enviar un mensaje es una acci√≥n _espec√≠fica_ del usuario.
- **`useEffect` (Efecto):** Se ejecuta **cada vez que `roomId` cambia**. La conexi√≥n al chat debe _sincronizarse_ con el `roomId` actual, sin importar _por qu√©_ o _c√≥mo_ cambi√≥. Incluso si `roomId` no cambia, el efecto se ejecuta al menos una vez al inicio para establecer la conexi√≥n inicial.

#### 3. **Notas o advertencias:**

- **Preg√∫ntate el "por qu√©":** Para decidir si usar un evento o un efecto, piensa en **por qu√©** necesitas que se ejecute ese c√≥digo. ¬øEs por una acci√≥n _espec√≠fica_ del usuario (evento)? ¬øEs para mantener la _sincronizaci√≥n_ con algo (efecto)?
- **Reactividad:** Los efectos son reactivos, los eventos no. Esto lo veremos con m√°s detalle en el siguiente punto.

---

## B - Valores Reactivos y L√≥gica Reactiva

#### 1. **Definici√≥n:**

- **Valores Reactivos:** Son las `props`, el `state`, y las variables que declaras **dentro del cuerpo de tu componente**. Estos valores pueden cambiar y provocar que React vuelva a renderizar el componente. En el ejemplo anterior, `roomId` y `message` son reactivos. `serverUrl` no lo es porque est√° fuera del componente y no cambia con el renderizado.
- **L√≥gica Reactiva:** Es la l√≥gica que **reacciona a los cambios en los valores reactivos**. Los **Efectos** son reactivos. Si un efecto usa un valor reactivo, y ese valor cambia, el efecto se vuelve a ejecutar.
- **L√≥gica No Reactiva:** Es la l√≥gica que **no reacciona autom√°ticamente a los cambios en los valores reactivos**. Los **Eventos** son no reactivos. Aunque un evento use un valor reactivo, el evento solo se ejecuta cuando se produce la interacci√≥n, no cuando el valor reactivo cambia por s√≠ solo.

#### 2. **Ejemplo:**

Volvamos al ejemplo del chat:

```jsx
function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  function handleSendClick() {
    // L√≥gica NO reactiva: solo se ejecuta al hacer clic
    sendMessage(message);
  }

  useEffect(() => {
    // L√≥gica REACTIVA: se ejecuta y re-ejecuta si roomId cambia
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ 'roomId' es una dependencia reactiva
```

**Explicaci√≥n del ejemplo:**

- **`sendMessage(message)` en `handleSendClick`:** Esta l√≠nea es **no reactiva**. Cambiar el valor de `message` (mientras el usuario escribe) **no deber√≠a enviar el mensaje autom√°ticamente**. Solo se env√≠a cuando el usuario _manualmente_ hace clic en "Enviar".
- **`createConnection(serverUrl, roomId)` en `useEffect`:** Esta l√≠nea es **reactiva**. Si `roomId` cambia (por ejemplo, el usuario elige otra sala), **queremos que la conexi√≥n se actualice autom√°ticamente** a la nueva sala. Por eso, `roomId` se pone como dependencia del `useEffect`.

#### 3. **Notas o advertencias:**

- **Dependencias de los Efectos:** React te pide que declares como **dependencias** todos los valores reactivos que uses dentro de un `useEffect`. Esto le permite a React saber cu√°ndo debe volver a ejecutar el efecto (cuando alguna dependencia cambia). Si olvidas una dependencia, ¬°React te avisar√°! üö®

---

## C - Extraer L√≥gica No Reactiva de los Efectos con Effect Events

#### 1. **El Problema:**

A veces, dentro de un efecto reactivo, necesitas ejecutar c√≥digo que **no quieres que sea reactivo**. Imagina que quieres mostrar una notificaci√≥n cuando te conectas al chat, y quieres que la notificaci√≥n tenga el tema (claro/oscuro) actual:

```jsx
function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('¬°Conectado!', theme); // üé® Queremos usar 'theme' pero NO hacerlo reactivo
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, theme]); // üî¥ Problema: 'theme' como dependencia hace que se reconecte al cambiar el tema
```

**Problema:** `theme` es un valor reactivo. Si lo pones como dependencia del `useEffect`, la conexi√≥n al chat se **volver√° a establecer cada vez que cambies el tema**, ¬°y eso no es lo que queremos! Solo queremos que la conexi√≥n se restablezca cuando cambie `roomId`.

#### 2. **La Soluci√≥n: Effect Events**

==React (en su versi√≥n experimental) nos da una herramienta genial: `useEffectEvent`. Un **Effect Event** te permite extraer una parte de la l√≥gica de tu efecto y hacerla **no reactiva**.==

```jsx
import { useEffect, experimental_useEffectEvent as useEffectEvent } from 'react';

function ChatRoom({ roomId, theme }) {
  // ‚ú® Creamos un Effect Event para la notificaci√≥n
  const onConnected = useEffectEvent(() => {
    showNotification('¬°Conectado!', theme); // ‚úÖ 'theme' se usa aqu√≠, pero NO hace que el efecto se re-ejecute al cambiar
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected(); // üöÄ Llamamos al Effect Event desde el efecto
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ ¬°Solo 'roomId' como dependencia!
```

**Explicaci√≥n:**

- **`useEffectEvent(() => { ... })`:** Crea un Effect Event llamado `onConnected`. La l√≥gica dentro de `onConnected` **no es reactiva**. Puede usar `theme` sin que `theme` se convierta en una dependencia del `useEffect` principal.
- **`onConnected()` dentro del `useEffect`:** Llamamos al Effect Event desde dentro del efecto. El efecto sigue siendo reactivo a `roomId`, pero la notificaci√≥n (y el uso de `theme`) dentro de `onConnected` ya no lo es.

#### 3. **Definici√≥n de Effect Events:**

- Son como "event handlers" dentro de los efectos.
- La l√≥gica dentro de un Effect Event **no es reactiva**.
- Siempre "ven" los **valores m√°s recientes** de props y state cuando se ejecutan.
- Se usan para separar la l√≥gica no reactiva de la l√≥gica reactiva dentro de un efecto.

---

## D - Leer las √öltimas Props y State con Effect Events

#### 1. **Caso de Uso: Registrar Visitas a P√°ginas**

Imagina que quieres registrar las visitas a las p√°ginas de tu sitio web. Tienes un componente `Page` que recibe la `url` de la p√°gina actual. Tambi√©n quieres incluir el n√∫mero de items en el carrito de compras en cada registro de visita.

```jsx
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  useEffect(() => {
    logVisit(url, numberOfItems); // üõí Queremos 'numberOfItems' pero NO reactivo a cambios en el carrito
  }, [url]); // üî¥ Problema: React te pide a√±adir 'numberOfItems' como dependencia
```

**Problema:** React te pide que a√±adas `numberOfItems` como dependencia del `useEffect`. Pero **no queremos que `logVisit` se ejecute cada vez que cambia el n√∫mero de items en el carrito**. Solo queremos registrar la visita cuando la `url` de la p√°gina cambia. La visita a la p√°gina es el "evento", no los cambios en el carrito.

#### 2. **Soluci√≥n con Effect Events:**

```jsx
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  // ‚ú® Effect Event para registrar la visita
  const onVisit = useEffectEvent((visitedUrl) => {
    logVisit(visitedUrl, numberOfItems); // ‚úÖ 'numberOfItems' se usa aqu√≠ sin hacerlo reactivo
  });

  useEffect(() => {
    onVisit(url); // üöÄ Llamamos al Effect Event desde el efecto
  }, [url]); // ‚úÖ ¬°Solo 'url' como dependencia!
```

**Explicaci√≥n:**

- **`useEffectEvent((visitedUrl) => { ... })`:** Crea un Effect Event `onVisit` que recibe `visitedUrl` como argumento. Dentro de `onVisit`, usamos `numberOfItems` (del scope del componente) sin que sea una dependencia.
- **`onVisit(url)` dentro del `useEffect`:** Llamamos a `onVisit` desde el efecto, pasando la `url` actual. El efecto sigue siendo reactivo a `url`, pero `logVisit` dentro de `onVisit` no reacciona a los cambios en `numberOfItems`.

#### 3. **Nota Importante: Pasar Argumentos al Effect Event**

Es mejor pasar `url` como argumento a `onVisit` (`onVisit(url)`) en lugar de leer `url` directamente dentro de `onVisit`. Esto hace m√°s expl√≠cito que la visita a una p√°gina con una `url` diferente es un "evento" distinto. Adem√°s, ayuda a que el linter te avise si accidentalmente eliminas `url` de las dependencias del `useEffect`.

```jsx
const onVisit = useEffectEvent((visitedUrl) => {
  // ‚úÖ Mejor: 'visitedUrl' como argumento
  logVisit(visitedUrl, numberOfItems);
});
useEffect(() => {
  onVisit(url);
}, [url]);
```

**Notas o advertencias:**

- **Claridad:** Pasar argumentos a los Effect Events hace que tu c√≥digo sea m√°s claro y f√°cil de entender.
- **Seguridad:** Ayuda a prevenir errores y a que el linter te proteja.

---

## ==E - Limitaciones de los Effect Events==

#### 1. **Restricciones de Uso:**

Los Effect Events tienen limitaciones importantes:

- **Solo se llaman desde dentro de Efectos:** No puedes llamar a un Effect Event desde un event handler, desde fuera de un componente React, etc. Su prop√≥sito es espec√≠fico para usarse _dentro_ de los efectos.
- **No se pasan a otros componentes o Hooks:** No puedes pasar un Effect Event como prop a otro componente, ni como callback a un Hook personalizado. Deben declararse y usarse localmente dentro del mismo componente donde se define el efecto.

#### 2. **Ejemplo de Uso Incorrecto y Correcto:**

**‚ùå Incorrecto: Pasar un Effect Event a un Hook personalizado**

```jsx
function Timer() {
  const [count, setCount] = useState(0);
  const onTick = useEffectEvent(() => {
    setCount(count + 1);
  });
  useTimer(onTick, 1000); // üî¥ ¬°MAL! No pasar Effect Events
  return <h1>{count}</h1>;
}

function useTimer(callback, delay) {
  // Hook personalizado
  useEffect(() => {
    const id = setInterval(() => {
      callback();
    }, delay);
    return () => clearInterval(id);
  }, [delay, callback]); // üî¥ Necesitas 'callback' como dependencia (¬°y esto causa problemas!)
}
```

**‚úÖ Correcto: Declarar el Effect Event localmente en el Hook**

```jsx
function Timer() {
  const [count, setCount] = useState(0);
  useTimer(() => {
    // ‚úÖ Callback directamente en el Hook
    setCount(count + 1);
  }, 1000);
  return <h1>{count}</h1>;
}

function useTimer(callback, delay) {
  // Hook personalizado
  const onTick = useEffectEvent(() => {
    // ‚ú® Effect Event DENTRO del Hook
    callback();
  });
  useEffect(() => {
    const id = setInterval(() => {
      onTick(); // ‚úÖ ¬°Bien! Llamada local al Effect Event
    }, delay);
    return () => clearInterval(id);
  }, [delay]); // ‚úÖ ¬°No necesitas 'onTick' como dependencia!
}
```

**Explicaci√≥n:**

- **Incorrecto:** Pasar `onTick` a `useTimer` obliga a que `useTimer` tenga `callback` como dependencia, lo cual puede causar re-ejecuciones innecesarias del efecto dentro de `useTimer`.
- **Correcto:** Declarar `onTick` _dentro_ de `useTimer` y llamarlo localmente evita el problema de las dependencias innecesarias y mantiene el Effect Event dentro del √°mbito de su efecto.

**Notas o advertencias:**

- **Localidad:** Los Effect Events son "piezas" no reactivas de tu c√≥digo de efecto. Deben vivir cerca del efecto que los usa.
- **Simplicidad:** Si te encuentras pasando un Effect Event, probablemente haya una mejor manera de estructurar tu c√≥digo.

---

## F - ¬øPor Qu√© NO Suprimir el Linter de Dependencias?

#### 1. **Problemas de Suprimir el Linter:**

A veces, para evitar que React te pida dependencias en un `useEffect`, podr√≠as sentirte tentado a **suprimir el linter** (la herramienta que te avisa de las dependencias faltantes). **¬°NO LO HAGAS!** üôÖ‚Äç‚ôÇÔ∏è

```jsx
function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;
  useEffect(() => {
    logVisit(url, numberOfItems);
    // üî¥ ¬°EVITA suprimir el linter as√≠!
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [url]);
  // ...
}
```

**Problemas de suprimir el linter:**

- **Pierdes las advertencias de React:** React ya no te avisar√° si olvidas una dependencia importante. Esto puede llevar a errores dif√≠ciles de detectar.
- **Valores "Stale" (Obsoletos):** Si suprimes el linter, tu efecto podr√≠a usar **valores antiguos** de props o state, en lugar de los valores m√°s recientes. Esto causa comportamientos inesperados y bugs.

**C√≥digo con el bug (por suprimir el linter):**

```jsx
function App() {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [canMove, setCanMove] = useState(true);

  function handleMove(e) {
    if (canMove) {
      // üî¥ 'canMove' SIEMPRE es 'true' (valor inicial)
      setPosition({ x: e.clientX, y: e.clientY });
    }
  }

  useEffect(() => {
    window.addEventListener("pointermove", handleMove);
    return () => window.removeEventListener("pointermove", handleMove);
    // eslint-disable-next-line react-hooks/exhaustive-deps // üî¥ ¬°SUPRIMIDO!
  }, []);

  // ...
}
```

**Soluci√≥n: No suprimir el linter y usar Effect Events (si es necesario):**

Usando `useEffectEvent`, evitamos suprimir el linter y el c√≥digo funciona correctamente:

```jsx
function App() {
  // ...
  const onMove = useEffectEvent((e) => {
    // ‚ú® Effect Event
    if (canMove) {
      setPosition({ x: e.clientX, y: e.clientY });
    }
  });

  useEffect(() => {
    window.addEventListener("pointermove", onMove);
    return () => window.removeEventListener("pointermove", onMove);
  }, []); // ‚úÖ ¬°Sin dependencias!
  // ...
}
```

#### 3. **Alternativas a Suprimir el Linter:**

- **Effect Events:** Como hemos visto, son una excelente manera de manejar l√≥gica no reactiva dentro de efectos.
- **Otras t√©cnicas:** Existen otras formas de "eliminar" dependencias de efectos de manera segura (sin suprimir el linter), como usar `useRef` o actualizar funciones fuera del renderizado. Pero los Effect Events son una soluci√≥n muy √∫til y limpia para muchos casos.

**Notas o advertencias:**

- **¬°Nunca mientas a React!** Suprimir el linter es como mentirle a React sobre las dependencias de tus efectos. Siempre termina mal. üòÖ
- **Conf√≠a en el linter:** El linter de React est√° ah√≠ para ayudarte a escribir c√≥digo correcto y evitar errores comunes. ¬°Hazle caso! üëç
