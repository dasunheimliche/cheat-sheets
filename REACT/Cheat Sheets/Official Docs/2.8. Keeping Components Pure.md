## A - Pureza: Componentes como FÃ³rmulas

#### 1. **DefiniciÃ³n:**

En el mundo de la programaciÃ³n, una **funciÃ³n pura** es como un matemÃ¡tico ordenado:

- **Se centra en lo suyo:** No cambia nada fuera de su propio "espacio de trabajo". No modifica variables o cosas que ya existÃ­an antes de que la llamaras.
- **Misma entrada, misma salida:** Si le das la misma informaciÃ³n de entrada, siempre te darÃ¡ el mismo resultado. Â¡Siempre!

Piensa en una fÃ³rmula matemÃ¡tica sencilla: `y = 2 * x`.

- Si `x = 2`, entonces `y = 4`. **Siempre.**
- Si `x = 3`, entonces `y = 6`. **Siempre.**

No importa si es lunes, viernes o si estÃ¡ lloviendo. Si `x` es 3, `y` siempre serÃ¡ 6. Â¡Eso es pureza!

En React, queremos que nuestros **componentes sean como estas fÃ³rmulas puras**. Un componente puro de React, dadas las mismas "entradas" (props), siempre debe retornar el mismo JSX (la "salida").

#### 2. **Ejemplo:**

```jsx
function Recipe({ drinkers }) {
  return (
    <ol>
      <li>Hervir {drinkers} tazas de agua.</li>
      <li>
        AÃ±adir {drinkers} cucharadas de tÃ© y {0.5 * drinkers} cucharadas de
        especias.
      </li>
      <li>
        AÃ±adir {0.5 * drinkers} tazas de leche a hervir y azÃºcar al gusto.
      </li>
    </ol>
  );
}

export default function App() {
  return (
    <section>
      <h1>Receta de Chai Especiado</h1>
      <h2>Para dos</h2>
      <Recipe drinkers={2} />
      <h2>Para una reuniÃ³n</h2>
      <Recipe drinkers={4} />
    </section>
  );
}
```

**ExplicaciÃ³n del ejemplo:**

El componente `Recipe` es **puro**. Â¿Por quÃ©?

- **Entrada:** Recibe una "entrada" a travÃ©s de la prop `drinkers` (nÃºmero de personas).
- **Salida:** Retorna JSX que muestra los ingredientes y cantidades para la receta, basados en el nÃºmero de `drinkers`.
- **Pureza:** Si siempre le pasas `drinkers={2}`, siempre te darÃ¡ JSX con "2 tazas de agua", "2 cucharadas de tÃ©", etc. Si siempre le pasas `drinkers={4}`, siempre te darÃ¡ JSX con "4 tazas de agua", "4 cucharadas de tÃ©", etc. **Misma entrada, misma salida. Siempre.**

Â¡Es como una receta de cocina! Si sigues los pasos (el cÃ³digo del componente) con los mismos ingredientes (props), siempre obtendrÃ¡s el mismo plato (JSX). ğŸ²

#### 3. **Notas o advertencias:**

- Pensar en componentes como fÃ³rmulas matemÃ¡ticas o recetas es una buena forma de entender la pureza.
- La pureza hace que tus componentes sean **predecibles** y **fÃ¡ciles de probar**. Sabes exactamente quÃ© esperar con ciertas entradas.
- React estÃ¡ diseÃ±ado para funcionar mejor con componentes puros. Aprovecha la pureza para optimizar el rendimiento y hacer que tu app sea mÃ¡s robusta.

---

## B - Efectos Secundarios: Consecuencias (no) deseadas

#### 1. **DefiniciÃ³n:**

El proceso de "renderizado" de React (cuando React llama a tus componentes para obtener el JSX) **siempre debe ser puro**. Esto significa que tus componentes solo deben **retornar** JSX, y **no deben cambiar** nada que exista fuera de ellos mismos mientras se renderizan. Cambiar cosas "por fuera" se llama **efecto secundario** (o "side effect" en inglÃ©s).

Imagina un cocinero que, mientras prepara un plato (renderiza JSX), decide cambiar la receta original o usar ingredientes de otro plato sin avisar (modifica variables externas). Â¡SerÃ­a un caos! ğŸ¤¯

Los efectos secundarios durante el renderizado hacen que tus componentes sean **impuros** e **impredecibles**.

#### 2. **Ejemplo:**

```jsx
let guest = 0; // âš ï¸ Variable global fuera del componente

function Cup() {
  guest = guest + 1; // âŒ Efecto secundario: Â¡modifica la variable global!
  return <h2>Taza de tÃ© para el invitado #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```

**ExplicaciÃ³n del ejemplo:**

Este componente `Cup` es **impuro**. Â¿Por quÃ©?

- **Variable global `guest`:** Se declara una variable `guest` _fuera_ del componente.
- **Efecto secundario:** Dentro del componente `Cup`, se **modifica** el valor de la variable global `guest` (`guest = guest + 1;`). Â¡Esto es un efecto secundario durante el renderizado!
- **Impredecibilidad:** Cada vez que se renderiza `<Cup />`, el valor de `guest` cambia. Si renderizas `<TeaSet />`, verÃ¡s "Taza de tÃ© para el invitado #2", "Taza de tÃ© para el invitado #4", "Taza de tÃ© para el invitado #6" en lugar de 1, 2, 3. Â¡El resultado depende de cuÃ¡ntas veces se renderice el componente y en quÃ© orden! Â¡No es predecible!

Volviendo a la fÃ³rmula `y = 2 * x`, ahora, incluso si `x = 2`, Â¡no podemos confiar en que `y = 4`! PodrÃ­a ser cualquier cosa dependiendo de "efectos secundarios" ocultos. Â¡Pesadilla! ğŸ˜±

**SoluciÃ³n: Pasar `guest` como prop:**

```jsx
function Cup({ guest }) {
  // âœ… Recibe 'guest' como prop
  return <h2>Taza de tÃ© para el invitado #{guest}</h2>; // âœ… Usa la prop 'guest'
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} /> {/* âœ… Pasa 'guest=1' como prop */}
      <Cup guest={2} /> {/* âœ… Pasa 'guest=2' como prop */}
      <Cup guest={3} /> {/* âœ… Pasa 'guest=3' como prop */}
    </>
  );
}
```

Ahora el componente `Cup` es **puro**. El JSX que retorna solo depende de la prop `guest`. Â¡Predecible y sin efectos secundarios! ğŸ‰

#### 3. **Notas o advertencias:**

- **Evita los efectos secundarios durante el renderizado.** No modifiques variables globales, no llames a funciones que cambien cosas fuera del componente, etc.
- Los componentes deben ser como "cajas negras" que solo reciben entradas (props) y retornan salidas (JSX), sin afectar nada mÃ¡s.
- React no te obliga a escribir componentes puros, pero hacerlo te traerÃ¡ muchos beneficios a largo plazo.

---

## C - MutaciÃ³n Local: El PequeÃ±o Secreto de tu Componente

#### 1. **DefiniciÃ³n:**

Hablamos de que los componentes puros no deben "mutar" (cambiar) variables u objetos que existÃ­an _antes_ de que se renderizaran. Pero, Â¿quÃ© pasa con las variables y objetos que **creas dentro del componente mientras se renderiza**? Â¿Puedes modificarlos?

Â¡SÃ­! EstÃ¡ **perfectamente bien** modificar variables y objetos que **acabas de crear** dentro del componente durante el renderizado. Esto se llama **mutaciÃ³n local**. Es como un pequeÃ±o secreto que tu componente guarda para sÃ­ mismo. ğŸ¤«

#### 2. **Ejemplo:**

```jsx
function Cup({ guest }) {
  return <h2>Taza de tÃ© para el invitado #{guest}</h2>;
}

export default function TeaGathering() {
  let cups = []; // âœ… Crea un array 'cups' *dentro* del componente
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />); // âœ… Modifica 'cups' (push) *localmente*
  }
  return cups; // âœ… Retorna el array 'cups'
}
```

**ExplicaciÃ³n del ejemplo:**

En `TeaGathering`:

- **`let cups = [];`:** Se crea un array vacÃ­o `cups` **dentro** de la funciÃ³n `TeaGathering`. Este array es "local" al componente.
- **`cups.push(...)`:** Dentro del bucle `for`, se aÃ±aden elementos `<Cup />` al array `cups` usando `push()`. Â¡Esto es una mutaciÃ³n! Pero es una **mutaciÃ³n local**, porque `cups` se creÃ³ dentro de `TeaGathering`.
- **`return cups;`:** Se retorna el array `cups`.

**Â¿Por quÃ© estÃ¡ bien la mutaciÃ³n local?**

Porque la variable `cups` y el array `[]` se crearon **durante este mismo renderizado**, dentro de `TeaGathering`. **NingÃºn cÃ³digo fuera de `TeaGathering` sabe que esto pasÃ³.** Es como si el componente estuviera usando un "bloc de notas" privado para hacer cÃ¡lculos durante el renderizado. Â¡Nadie mÃ¡s se entera! ğŸ˜‰

Si `cups` o `[]` se hubieran creado _fuera_ de `TeaGathering`, Â¡serÃ­a un problema! EstarÃ­as modificando un objeto _preexistente_, lo cual serÃ­a un efecto secundario impuro.

#### 3. **Notas o advertencias:**

- La mutaciÃ³n local es una excepciÃ³n a la regla de pureza, pero es una excepciÃ³n **controlada** y **segura**.
- Puedes usar variables (`let`), arrays (`[]`), objetos (`{}`) y modificarlos _localmente_ dentro de tu componente mientras se renderiza.
- AsegÃºrate de que estas variables y objetos se creen **dentro del componente** y no sean accesibles desde fuera.

---

## D - Â¿DÃ³nde SÃ puedes causar Efectos Secundarios?

#### 1. **DefiniciÃ³n:**

Si los componentes puros no deben tener efectos secundarios durante el renderizado, Â¿entonces dÃ³nde podemos hacer cosas como actualizar la pantalla, iniciar animaciones, cambiar datos, etc.? Â¡Para eso estÃ¡n los **manejadores de eventos** y, como Ãºltimo recurso, `useEffect`!

Los **efectos secundarios** son necesarios para que tu app haga cosas "en el mundo real". Pero deben ocurrir **"al margen"** del renderizado, no _durante_ Ã©l.

#### 2. **Manejadores de Eventos:**

Los **manejadores de eventos** (event handlers) son funciones que React ejecuta **cuando ocurre algo**, como un clic de botÃ³n, un cambio en un input, etc. Aunque los definas _dentro_ de tu componente, **no se ejecutan durante el renderizado**. Se ejecutan _despuÃ©s_, en respuesta a una acciÃ³n del usuario.

**Ejemplo:**

```jsx
import { useState } from "react";

export default function Counter() {
  const [count, setCount] = useState(0); // âœ… 'useState' *fuera* del renderizado

  function handleClick() {
    // âœ… Manejador de evento
    setCount(count + 1); // âœ… Efecto secundario: actualiza el estado *fuera* del renderizado
  }

  return (
    <button onClick={handleClick}>
      {" "}
      {/* âœ… Asocia el manejador al evento 'onClick' */}
      Contador: {count}
    </button>
  );
}
```

**ExplicaciÃ³n:**

- **`useState(0)`:** `useState` se llama _fuera_ del renderizado (en la "fase de inicializaciÃ³n" del componente). `useState` es una funciÃ³n especial de React que te permite tener "estado" en tus componentes.
- **`handleClick()`:** Esta es un **manejador de evento**. Se define _dentro_ del componente, pero **no se ejecuta durante el renderizado inicial**. Solo se ejecuta cuando el usuario hace **clic** en el botÃ³n.
- **`setCount(count + 1)`:** Dentro de `handleClick`, se llama a `setCount` para **actualizar el estado** `count`. **Actualizar el estado es un efecto secundario.** Pero estÃ¡ bien, porque ocurre _dentro_ de un manejador de evento, **no durante el renderizado**.

**En resumen:** Los manejadores de eventos son el lugar **principal** para poner tus efectos secundarios en React.

#### 3. **`useEffect` (Ãšltimo Recurso):**

Si no encuentras un manejador de evento adecuado para tu efecto secundario, puedes usar `useEffect`. `useEffect` es un "gancho" (hook) de React que te permite ejecutar cÃ³digo **despuÃ©s de que React haya renderizado** el componente y actualizado el DOM.

**Ejemplo (Â¡solo para ilustrar, no es la mejor prÃ¡ctica en este caso!):**

```jsx
import { useEffect, useState } from "react";

export default function TitleUpdater() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    // âœ… 'useEffect' para efectos secundarios *despuÃ©s* del renderizado
    document.title = `Contador: ${count}`; // âœ… Efecto secundario: cambia el tÃ­tulo de la pÃ¡gina
  }, [count]); // âœ… Dependencia: ejecuta el efecto cuando 'count' cambie

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <>
      <button onClick={handleClick}>Incrementar contador</button>
      <p>Contador: {count}</p>
    </>
  );
}
```

**ExplicaciÃ³n:**

- **`useEffect(() => { ... }, [count]);`:** `useEffect` recibe dos argumentos:
  - Una **funciÃ³n** (el primer argumento) que contiene el cÃ³digo del efecto secundario. En este caso, `document.title = ...` (cambiar el tÃ­tulo de la pÃ¡gina).
  - Un **array de dependencias** (el segundo argumento, `[count]`). React ejecutarÃ¡ la funciÃ³n del efecto secundario **despuÃ©s del renderizado inicial y cada vez que alguna de las dependencias en el array cambie** (en este caso, cuando `count` cambie).
- **`document.title = ...`:** Cambiar el tÃ­tulo de la pÃ¡gina es un **efecto secundario**. Con `useEffect`, lo ejecutamos _despuÃ©s_ del renderizado, no durante Ã©l.

**`useEffect` es como un "aviso" a React:** "Oye, React, despuÃ©s de que termines de renderizar este componente y actualizar la pantalla, ejecuta este cÃ³digo (el efecto secundario)".

**Â¡Importante!** `useEffect` debe ser tu **Ãºltimo recurso** para efectos secundarios. Siempre que sea posible, intenta usar **manejadores de eventos** para la lÃ³gica interactiva. `useEffect` es mÃ¡s para cosas que necesitan ocurrir _despuÃ©s_ del renderizado, como sincronizar con APIs externas, animaciones complejas, etc.

#### 4. **Notas o advertencias:**

- Los **manejadores de eventos** son el lugar principal para los efectos secundarios en React (actualizar estado, llamar a APIs, etc.).
- `useEffect` es para efectos secundarios que necesitan ocurrir **despuÃ©s** del renderizado y la actualizaciÃ³n del DOM. Ãšsalo con moderaciÃ³n.
- Intenta expresar la lÃ³gica de tu app principalmente con **renderizado puro** (componentes que solo retornan JSX basados en props y estado). Te sorprenderÃ¡ lo lejos que puedes llegar solo con renderizado puro. ğŸ˜‰

---

## E - Â¿Por quÃ© React se Preocupa por la Pureza?

#### 1. **Beneficios de la Pureza:**

Escribir componentes puros requiere prÃ¡ctica y disciplina, Â¡pero los beneficios son enormes!

- **Renderizado en el servidor (SSR):** Los componentes puros pueden ejecutarse en diferentes entornos, Â¡incluso en el servidor! Como siempre dan la misma salida para las mismas entradas, un componente puede servir a muchas peticiones de usuarios en el servidor. Esto mejora el rendimiento y el SEO de tu app.
- **OptimizaciÃ³n del rendimiento (memoizaciÃ³n):** React puede **saltarse el renderizado** de componentes puros si sus entradas (props) no han cambiado. Como sabemos que un componente puro siempre darÃ¡ el mismo resultado con las mismas entradas, es seguro "recordar" (memorizar) el resultado anterior y reutilizarlo si las entradas no cambian. Â¡Esto acelera tu app!
- **Renderizado interrumpible:** Si los datos cambian mientras React estÃ¡ renderizando un Ã¡rbol de componentes profundo, React puede **reiniciar el renderizado** sin perder tiempo en terminar un renderizado que ya estÃ¡ desactualizado. La pureza hace que sea seguro detener el cÃ¡lculo en cualquier momento y volver a empezar. Â¡Mejora la experiencia de usuario en apps complejas!

En resumen, la pureza es un **principio fundamental** en React. Todas las nuevas funcionalidades de React se basan en la pureza para ofrecerte una mejor experiencia de desarrollo y un mejor rendimiento en tus apps.

#### 2. **Modo Estricto (`StrictMode`): Detectando Componentes Impuros**

React ofrece un "Modo Estricto" (`<React.StrictMode>`) que puedes activar en tu app **durante el desarrollo**. El Modo Estricto **llama a la funciÃ³n de cada componente dos veces** en cada renderizado.

**Â¿Por quÃ© dos veces?** Para **detectar componentes que rompen las reglas de pureza**. Si un componente es impuro y modifica variables externas o tiene efectos secundarios durante el renderizado, al llamarlo dos veces, Â¡es muy probable que se note el problema! VerÃ¡s resultados inesperados o errores.

**Ejemplo (con el componente `Cup` impuro anterior):**

Si envuelves `<TeaSet />` en `<React.StrictMode>`:

```jsx
import React from "react"; // âœ… Importa React

// ... (componente Cup impuro de antes) ...

export default function App() {
  return (
    <React.StrictMode>
      {" "}
      {/* âœ… Activa el Modo Estricto */}
      <TeaSet />
    </React.StrictMode>
  );
}
```

VerÃ¡s que el componente `Cup` impuro ahora muestra "Taza de tÃ© para el invitado #2", "Taza de tÃ© para el invitado #4", "Taza de tÃ© para el invitado #6" en lugar de 1, 2, 3. Â¡El Modo Estricto ha "desenmascarado" la impureza!

**Componentes puros, Â¡sin problemas en Modo Estricto!**

El componente `Cup` puro (que recibe `guest` como prop) funciona perfectamente incluso en Modo Estricto. Llamarlo dos veces no cambia nada, porque es puro. **Misma entrada, misma salida, siempre.**

**Â¡Importante!** El Modo Estricto **solo funciona en desarrollo**. No afecta al rendimiento de tu app en producciÃ³n (cuando la subes a internet para los usuarios). Es una herramienta para ayudarte a escribir mejor cÃ³digo durante el desarrollo.

#### 3. **Notas o advertencias:**

- Activa `<React.StrictMode>` en tu app **durante el desarrollo** para detectar componentes impuros y otros posibles problemas. Muchos frameworks de React lo activan por defecto.
- El Modo Estricto no te "arregla" los componentes impuros, solo te ayuda a **identificarlos**. Luego, Â¡tÃº tienes que corregirlos!
- Escribir componentes puros puede requerir un cambio de mentalidad al principio, pero a la larga, te ahorrarÃ¡ muchos dolores de cabeza y te permitirÃ¡ aprovechar al mÃ¡ximo el poder de React. ğŸ’ª
