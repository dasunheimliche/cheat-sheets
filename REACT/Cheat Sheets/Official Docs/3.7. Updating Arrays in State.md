## A - Arrays Inmutables en React

#### 1. **DefiniciÃ³n:**

En React, cuando guardas un array en el estado, Â¡debes tratarlo como si fuera de "solo lectura"! Aunque en JavaScript los arrays son mutables (puedes cambiarlos directamente), en React **no debemos mutar los arrays en el estado**. En lugar de cambiar el array original, siempre crearemos **nuevos arrays** con los cambios. Â¡Es como trabajar con copias de seguridad!

#### 2. **Ejemplo:**

**MutaciÃ³n de array (Â¡MAL!):**

```javascript
let frutas = ["manzana", "plÃ¡tano"];
frutas.push("naranja"); // âŒ Â¡Mutando el array original!
console.log(frutas); // Output: ['manzana', 'plÃ¡tano', 'naranja']
```

**Inmutabilidad de array (Â¡BIEN!):**

```javascript
let frutas = ["manzana", "plÃ¡tano"];
let nuevasFrutas = frutas.concat(["naranja"]); // âœ… Â¡Creando un nuevo array!
console.log(frutas); // Output: ['manzana', 'plÃ¡tano'] (Â¡Original intacto!)
console.log(nuevasFrutas); // Output: ['manzana', 'plÃ¡tano', 'naranja'] (Â¡Nuevo array con cambio!)
```

**ExplicaciÃ³n del ejemplo:**
En el ejemplo de mutaciÃ³n, usamos `push()` para aÃ±adir 'naranja' directamente al array `frutas`. En el ejemplo inmutable, usamos `concat()` que **no cambia** `frutas`, sino que **devuelve un nuevo array** (`nuevasFrutas`) con el elemento aÃ±adido. Â¡AsÃ­ mantenemos el array original sin cambios!

#### 3. **Notas o advertencias:**

- MÃ©todos como `push()`, `pop()`, `shift()`, `unshift()`, `splice()`, `sort()`, y `reverse()` **mutan** el array original. Â¡EvÃ­talos en React!
- Usa mÃ©todos que **devuelven nuevos arrays** como `concat()`, `slice()`, `filter()`, `map()`, y el _spread syntax_ (`...`) para mantener la inmutabilidad.

---

## B - AÃ±adiendo Elementos a un Array

#### 1. **DefiniciÃ³n:**

Para aÃ±adir elementos a un array en el estado de React de forma inmutable, en lugar de usar `push()` o `unshift()`, usaremos `concat()` o el _spread syntax_ (`...`). Â¡Son como "pegamento" inmutable para arrays!

#### 2. **Ejemplo:**

**Usando `push()` (Â¡MAL!):**

```jsx
import { useState } from "react";

export default function ListaArtistasMala() {
  const [artistas, setArtistas] = useState([]);
  const [nombre, setNombre] = useState("");

  return (
    <>
      <input value={nombre} onChange={(e) => setNombre(e.target.value)} />
      <button
        onClick={() => {
          artistas.push({ name: nombre }); // âŒ Â¡Mutando 'artistas' directamente!
        }}
      >
        AÃ±adir
      </button>
      <ul>
        {artistas.map((artista) => (
          <li key={artista.name}>{artista.name}</li>
        ))}
      </ul>
    </>
  );
}
```

**Usando _spread syntax_ (Â¡BIEN!):**

```jsx
import { useState } from "react";

let nextId = 0;

export default function ListaArtistasBuena() {
  const [artistas, setArtistas] = useState([]);
  const [nombre, setNombre] = useState("");

  return (
    <>
      <input value={nombre} onChange={(e) => setNombre(e.target.value)} />
      <button
        onClick={() => {
          setArtistas([
            // âœ… Â¡Creando un nuevo array con spread syntax!
            ...artistas,
            { id: nextId++, name: nombre },
          ]);
        }}
      >
        AÃ±adir
      </button>
      <ul>
        {artistas.map((artista) => (
          <li key={artista.id}>{artista.name}</li>
        ))}
      </ul>
    </>
  );
}
```

**ExplicaciÃ³n del ejemplo:**
En el ejemplo "malo", `artistas.push()` muta el array `artistas` directamente. En el ejemplo "bueno", `[...artistas, { id: nextId++, name: nombre }]` crea un **nuevo array**: primero copia todos los elementos de `artistas` con `...artistas`, y luego aÃ±ade el nuevo objeto al final. `setArtistas()` actualiza el estado con este nuevo array.

#### 3. **Notas o advertencias:**

- `concat()` tambiÃ©n funciona: `setArtistas(artistas.concat([{ id: nextId++, name: nombre }]))`.
- Para aÃ±adir al **principio** del array con _spread syntax_: `setArtistas([{ id: nextId++, name: nombre }, ...artistas])`. Â¡Como un sÃ¡ndwich al revÃ©s! ğŸ¥ª

---

## C - Eliminando Elementos de un Array

#### 1. **DefiniciÃ³n:**

Para eliminar elementos de un array inmutablemente, usaremos `filter()`. `filter()` crea un **nuevo array** con solo los elementos que "pasen" una condiciÃ³n. Â¡Es como un portero de discoteca que solo deja pasar a los que cumplen los requisitos! ğŸšª

#### 2. **Ejemplo:**

**Usando `splice()` (Â¡MAL!):**

```jsx
// ... (cÃ³digo inicial similar al ejemplo anterior) ...
<button
  onClick={() => {
    artistas.splice(indexAEliminar, 1); // âŒ Â¡Mutando 'artistas' con splice!
  }}
>
  Eliminar
</button>
```

**Usando `filter()` (Â¡BIEN!):**

```jsx
import { useState } from "react";

let initialArtists = [
  { id: 0, name: "Marta Colvin Andrade" },
  { id: 1, name: "Lamidi Olonade Fakeye" },
  { id: 2, name: "Louise Nevelson" },
];

export default function ListaArtistasEliminar() {
  const [artistas, setArtistas] = useState(initialArtists);

  return (
    <>
      <ul>
        {artistas.map((artista) => (
          <li key={artista.id}>
            {artista.name}
            <button
              onClick={() => {
                setArtistas(
                  // âœ… Â¡Usando filter para crear un nuevo array!
                  artistas.filter((a) => a.id !== artista.id)
                );
              }}
            >
              Eliminar
            </button>
          </li>
        ))}
      </ul>
    </>
  );
}
```

**ExplicaciÃ³n del ejemplo:**
`artistas.filter(a => a.id !== artista.id)` crea un **nuevo array** que contiene solo los artistas cuyo `id` **no es igual** al `id` del artista que queremos eliminar. `filter()` **no modifica** el array `artistas` original.

#### 3. **Notas o advertencias:**

- `filter()` es muy flexible. Puedes usar cualquier condiciÃ³n dentro de `filter(elemento => condiciÃ³n)` para decidir quÃ© elementos mantener en el nuevo array.
- `slice()` tambiÃ©n puede usarse para eliminar rangos de elementos, pero `filter()` suele ser mÃ¡s claro para eliminar elementos especÃ­ficos basados en propiedades.

---

## D - Transformando Arrays

#### 1. **DefiniciÃ³n:**

Si quieres cambiar _algunos_ o _todos_ los elementos de un array, usa `map()`. `map()` crea un **nuevo array** aplicando una funciÃ³n a cada elemento del array original. Â¡Es como una fÃ¡brica que transforma cada pieza de una materia prima en un producto diferente! ğŸ­

#### 2. **Ejemplo:**

**TransformaciÃ³n con bucle `for` mutando (Â¡MUY LARGO Y COMPLICADO!):**

```javascript
// ... (cÃ³digo con bucle for mutando un array - Â¡no recomendado!) ...
```

**TransformaciÃ³n con `map()` (Â¡CLARO Y SENCILLO!):**

```jsx
import { useState } from "react";

let initialShapes = [
  { id: 0, type: "circle", x: 50, y: 100 },
  { id: 1, type: "square", x: 150, y: 100 },
  { id: 2, type: "circle", x: 250, y: 100 },
];

export default function EditorDeFormas() {
  const [formas, setFormas] = useState(initialShapes);

  function handleClick() {
    const nuevasFormas = formas.map((forma) => {
      // âœ… Â¡Usando map para transformar!
      if (forma.type === "square") {
        return forma; // Dejar cuadrados sin cambios
      } else {
        return { ...forma, y: forma.y + 50 }; // Mover cÃ­rculos 50px abajo
      }
    });
    setFormas(nuevasFormas);
  }

  return (
    <>
      <button onClick={handleClick}>Mover cÃ­rculos abajo!</button>
      {formas.map((forma) => (
        <div
          key={forma.id}
          style={{
            position: "absolute",
            background: "lightblue",
            border: "1px solid black",
            borderRadius: forma.type === "circle" ? "50%" : "0%",
            width: 20,
            height: 20,
            transform: `translate(${forma.x}px, ${forma.y}px)`,
          }}
        />
      ))}
    </>
  );
}
```

**ExplicaciÃ³n del ejemplo:**
`formas.map(forma => { ... })` itera sobre cada `forma` en el array `formas`. La funciÃ³n dentro de `map()` decide quÃ© hacer con cada `forma`: si es un cuadrado, la devuelve sin cambios; si es un cÃ­rculo, devuelve un **nuevo objeto** (copia con _spread syntax_) con la `y` incrementada en 50. `map()` devuelve un **nuevo array** `nuevasFormas` con las formas transformadas.

#### 3. **Notas o advertencias:**

- `map()` es ideal para aplicar la misma transformaciÃ³n (o transformaciones diferentes basadas en condiciones) a _cada_ elemento de un array y obtener un nuevo array transformado.
- Recuerda: `map()` siempre devuelve un **nuevo array** de la misma longitud que el original.

---

## E - Reemplazando Elementos en un Array

#### 1. **DefiniciÃ³n:**

Reemplazar un elemento en un array inmutablemente tambiÃ©n se hace con `map()`. Dentro de `map()`, usaremos el **Ã­ndice** del elemento para decidir si lo reemplazamos o lo dejamos como estÃ¡. Â¡Es como un robot que revisa cada caja en una cinta transportadora y reemplaza las que estÃ¡n defectuosas! ğŸ¤–ğŸ“¦

#### 2. **Ejemplo:**

**Usando asignaciÃ³n directa mutando (Â¡MAL!):**

```javascript
// ... (cÃ³digo con asignaciÃ³n directa como counters[index] = nuevoValor - Â¡no recomendado!) ...
```

**Usando `map()` con Ã­ndice (Â¡BIEN!):**

```jsx
import { useState } from "react";

let initialCounters = [0, 0, 0];

export default function ListaContadores() {
  const [contadores, setContadores] = useState(initialCounters);

  function handleIncrementarClick(index) {
    const nuevosContadores = contadores.map((contador, i) => {
      // âœ… map con Ã­ndice 'i'
      if (i === index) {
        // Si el Ã­ndice actual 'i' es el que queremos cambiar...
        return contador + 1; // ...incrementa el contador
      } else {
        return contador; // ...si no, deja el contador sin cambios
      }
    });
    setContadores(nuevosContadores);
  }

  return (
    <ul>
      {contadores.map((contador, i) => (
        <li key={i}>
          {contador}
          <button onClick={() => handleIncrementarClick(i)}>+1</button>
        </li>
      ))}
    </ul>
  );
}
```

**ExplicaciÃ³n del ejemplo:**
`contadores.map((contador, i) => { ... })` usa el segundo argumento de `map()`, `i`, que es el **Ã­ndice** del elemento actual. Si `i` coincide con el `index` del contador que queremos incrementar, devolvemos `contador + 1`. Si no, devolvemos el `contador` sin cambios. `map()` crea un **nuevo array** `nuevosContadores` con el contador reemplazado (o no).

#### 3. **Notas o advertencias:**

- El segundo argumento de la funciÃ³n `map()` es siempre el **Ã­ndice** del elemento actual. Â¡Muy Ãºtil para reemplazar elementos en posiciones especÃ­ficas!
- Recuerda que `map()` siempre itera sobre _todos_ los elementos del array, aunque solo modifiques uno.

---

## F - Insertando Elementos en un Array

#### 1. **DefiniciÃ³n:**

Para insertar un elemento en una posiciÃ³n especÃ­fica (que no sea al principio o al final) de un array inmutablemente, combinaremos `slice()` y el _spread syntax_ (`...`). `slice()` corta un "trozo" del array, y el _spread syntax_ "pega" los trozos con el nuevo elemento en medio. Â¡Es como un cirujano que hace una incisiÃ³n precisa para insertar algo y luego vuelve a unir! ğŸ”ªğŸ’‰

#### 2. **Ejemplo:**

**Usando `splice()` (Â¡MAL!):**

```javascript
// ... (cÃ³digo usando splice para insertar - Â¡no recomendado!) ...
```

**Usando `slice()` y _spread syntax_ (Â¡BIEN!):**

```jsx
import { useState } from "react";

let nextId = 3;
const initialArtists = [
  { id: 0, name: "Marta Colvin Andrade" },
  { id: 1, name: "Lamidi Olonade Fakeye" },
  { id: 2, name: "Louise Nevelson" },
];

export default function ListaArtistasInsertar() {
  const [nombre, setNombre] = useState("");
  const [artistas, setArtistas] = useState(initialArtists);

  function handleClick() {
    const indiceDeInsercion = 1; // Â¡Inserta en el Ã­ndice 1!
    const nuevosArtistas = [
      // 1. Trozo del array *antes* del Ã­ndice de inserciÃ³n:
      ...artistas.slice(0, indiceDeInsercion),
      // 2. Nuevo elemento a insertar:
      { id: nextId++, name: nombre },
      // 3. Trozo del array *despuÃ©s* del Ã­ndice de inserciÃ³n:
      ...artistas.slice(indiceDeInsercion),
    ];
    setArtistas(nuevosArtistas);
    setNombre("");
  }

  return (
    <>
      <input value={nombre} onChange={(e) => setNombre(e.target.value)} />
      <button onClick={handleClick}>Insertar en Ã­ndice 1</button>
      <ul>
        {artistas.map((artista) => (
          <li key={artista.id}>{artista.name}</li>
        ))}
      </ul>
    </>
  );
}
```

**ExplicaciÃ³n del ejemplo:**
`artistas.slice(0, indiceDeInsercion)` crea un **nuevo array** con los elementos desde el inicio de `artistas` hasta (pero sin incluir) `indiceDeInsercion`. `artistas.slice(indiceDeInsercion)` crea otro **nuevo array** con los elementos desde `indiceDeInsercion` hasta el final de `artistas`. Luego, `[..., ..., ...]` crea un **nuevo array** final que combina estos trozos con el nuevo artista en medio.

#### 3. **Notas o advertencias:**

- `slice(inicio, fin)` **no incluye** el elemento en el Ã­ndice `fin`.
- `indiceDeInsercion` puede ser cualquier Ã­ndice vÃ¡lido dentro del array (o incluso `array.length` para aÃ±adir al final, aunque para eso es mÃ¡s simple usar solo _spread syntax_ como vimos antes).

---

## G - Otros Cambios en Arrays (Ordenar, Invertir)

#### 1. **DefiniciÃ³n:**

MÃ©todos como `reverse()` y `sort()` **mutan** el array original. Para usarlos inmutablemente, primero haremos una **copia** del array (con _spread syntax_ `[...]`) y luego aplicaremos `reverse()` o `sort()` a la **copia**. Â¡Es como hacer un doble de acciÃ³n para que el array original no se lastime! ğŸ¬ğŸ‘¯

#### 2. **Ejemplo:**

**Usando `reverse()` y `sort()` directamente (Â¡MUTACIÃ“N!):**

```javascript
// ... (cÃ³digo usando reverse() o sort() directamente en el estado - Â¡no recomendado!) ...
```

**Copiando primero con _spread syntax_ y luego `reverse()` (Â¡INMUTABLE!):**

```jsx
import { useState } from "react";

const listaInicial = [
  { id: 0, title: "Big Bellies" },
  { id: 1, title: "Lunar Landscape" },
  { id: 2, title: "Terracotta Army" },
];

export default function ListaReversible() {
  const [lista, setLista] = useState(listaInicial);

  function handleClick() {
    const nuevaLista = [...lista]; // âœ… Â¡Copiando el array con spread syntax!
    nuevaLista.reverse(); // âœ… Â¡reverse() en la *copia*!
    setLista(nuevaLista);
  }

  return (
    <>
      <button onClick={handleClick}>Invertir</button>
      <ul>
        {lista.map((obra) => (
          <li key={obra.id}>{obra.title}</li>
        ))}
      </ul>
    </>
  );
}
```

**ExplicaciÃ³n del ejemplo:**
`const nuevaLista = [...lista];` crea una **copia superficial** del array `lista`. `nuevaLista.reverse();` **muta** el array `nuevaLista` (la copia), pero **no toca** el array `lista` original en el estado. Luego, `setLista(nuevaLista)` actualiza el estado con la copia invertida.

#### 3. **Notas o advertencias:**

- Este patrÃ³n de "copiar, modificar copia, actualizar estado con copia" funciona para `reverse()`, `sort()`, y cualquier otro mÃ©todo mutante que quieras usar inmutablemente.
- Recuerda: incluso despuÃ©s de copiar el array, **no puedes mutar directamente los objetos _dentro_ del array** si ya estaban en el estado original. La copia del array es superficial, Â¡los objetos dentro siguen siendo los mismos! (Veremos cÃ³mo manejar esto en la siguiente secciÃ³n).

---

## H - Actualizando Objetos Dentro de Arrays

#### 1. **DefiniciÃ³n:**

Cuando tienes arrays de objetos en el estado, actualizar una propiedad de un objeto dentro del array es un poco mÃ¡s complejo. Necesitamos hacer copias en **cada nivel**: copiar el array, y luego copiar el objeto que queremos modificar dentro del array. Â¡Es como una muÃ±eca rusa de copias! ğŸ

#### 2. **Ejemplo:**

**MutaciÃ³n incorrecta de objeto dentro de array (Â¡PROBLEMAS!):**

```jsx
// ... (cÃ³digo con mutaciÃ³n incorrecta que causa que dos listas compartan estado - Â¡bug!) ...
```

**ActualizaciÃ³n correcta e inmutable de objeto dentro de array (Â¡BIEN!):**

```jsx
import { useState } from "react";

let nextId = 3;
const listaInicial = [
  { id: 0, title: "Big Bellies", seen: false },
  { id: 1, title: "Lunar Landscape", seen: false },
  { id: 2, title: "Terracotta Army", seen: true },
];

export default function ListaDeDeseos() {
  const [miLista, setMiLista] = useState(listaInicial);

  function handleToggleMiLista(idObra, visto) {
    setMiLista(
      miLista.map((obra) => {
        // âœ… map para iterar sobre el array
        if (obra.id === idObra) {
          return { ...obra, seen: visto }; // âœ… spread syntax para copiar *objeto* y cambiar 'seen'
        } else {
          return obra; // Dejar objetos no modificados sin cambios
        }
      })
    );
  }

  return (
    <>
      <ul>
        {miLista.map((obra) => (
          <li key={obra.id}>
            <label>
              <input
                type="checkbox"
                checked={obra.seen}
                onChange={(e) => handleToggleMiLista(obra.id, e.target.checked)}
              />
              {obra.title}
            </label>
          </li>
        ))}
      </ul>
    </>
  );
}
```

**ExplicaciÃ³n del ejemplo:**
`miLista.map(obra => { ... })` itera sobre el array `miLista`. Si `obra.id` coincide con el `idObra` que queremos actualizar, `{ ...obra, seen: visto }` crea un **nuevo objeto** copiando las propiedades de `obra` con _spread syntax_ y luego sobrescribiendo `seen` con el nuevo valor `visto`. Si no coincide el `id`, simplemente devolvemos `obra` sin cambios. `map()` devuelve un **nuevo array** `nuevaLista` con el objeto actualizado (o no).

#### 3. **Notas o advertencias:**

- Para actualizar objetos dentro de arrays, necesitas usar `map()` para crear un **nuevo array**, y dentro de `map()`, usar _spread syntax_ (`...`) para crear **nuevos objetos** cuando necesites modificar alguno.
- Recuerda: Â¡copia el array, y copia tambiÃ©n el objeto que modificas dentro del array!

---

## I - Simplificando Actualizaciones de Arrays con Immer

#### 1. **DefiniciÃ³n:**

Si actualizar arrays anidados inmutablemente se vuelve muy repetitivo, Â¡Immer viene al rescate! Al igual que con los objetos, Immer te permite escribir cÃ³digo como si **mutaras** los arrays directamente, pero por debajo, Immer se encarga de hacer todas las copias inmutables necesarias. Â¡Es como tener un asistente mÃ¡gico que hace el trabajo duro de la inmutabilidad por ti! âœ¨ğŸ§™â€â™‚ï¸

#### 2. **Ejemplo:**

**ActualizaciÃ³n anidada "manual" (Â¡MUCHO CÃ“DIGO!):**

```javascript
// ... (cÃ³digo de actualizaciÃ³n anidada manual con map y spread syntax - largo y repetitivo) ...
```

**ActualizaciÃ³n con Immer (Â¡MÃS SIMPLE Y CLARO!):**

```jsx
import { useImmer } from "use-immer";

// ... (cÃ³digo inicial similar al ejemplo anterior ListaDeDeseos) ...
export default function ListaDeDeseosImmer() {
  const [miLista, updateMiLista] = useImmer(listaInicial); // âœ… useImmer en lugar de useState

  function handleToggleMiLista(idObra, visto) {
    updateMiLista((draft) => {
      // âœ… updateMiLista y funciÃ³n 'draft'
      const obra = draft.find((a) => a.id === idObra);
      obra.seen = visto; // âœï¸ Â¡MutaciÃ³n directa en 'draft'!
    }); // âœ¨ Immer se encarga de la inmutabilidad
  }

  // ... (resto del componente igual) ...
}
```

**Para usar Immer con arrays:**

1.  Instala: `npm install use-immer`
2.  Importa: `import { useImmer } from 'use-immer'`
3.  Reemplaza `useState` con `useImmer`: `const [miLista, updateMiLista] = useImmer(listaInicial);`
4.  Usa `updateMiLista(draft => { ... })` para actualizar el estado. Â¡Dentro de `draft => { ... }`, puedes mutar `draft` como si fuera un array normal!

**ExplicaciÃ³n del ejemplo:**
Con `useImmer`, obtienes `updateMiLista` en lugar de `setMiLista`. Dentro de `updateMiLista(draft => { ... })`, `draft` es un "borrador" mutable del array. Puedes usar mÃ©todos mutantes como `obra.seen = visto` o incluso `draft.push(...)`, `draft.pop()`, etc. Immer registra tus cambios en `draft` y, al final, devuelve un **nuevo estado inmutable** con tus modificaciones.

#### 3. **Notas o advertencias:**

- Immer simplifica mucho el cÃ³digo de actualizaciÃ³n de arrays, especialmente cuando tienes arrays anidados o arrays de objetos complejos.
- Hace que el cÃ³digo sea mÃ¡s legible y menos propenso a errores, ya que te permite escribir de forma mÃ¡s "natural" (mutando) sin romper la inmutabilidad.
- Si te sientes abrumado por las copias manuales con `map()` y _spread syntax_, Â¡Immer es una excelente opciÃ³n!
