## A - Event Handlers en React

#### 1. **Definici√≥n:**

En React, un **event handler** es simplemente una funci√≥n que t√∫ creas para que se ejecute cuando ocurre algo en la interfaz de usuario, como un clic en un bot√≥n, el rat√≥n pasando por encima de un elemento, o cuando alguien escribe en un campo de texto. React te permite "escuchar" estos eventos y reaccionar a ellos con tu c√≥digo. ¬°Es como darle superpoderes a tu interfaz! ‚ú®

#### 2. **Ejemplo:**

```jsx
export default function Button() {
  function handleClick() {
    alert("¬°Me has clickeado! üéâ");
  }

  return <button onClick={handleClick}>¬°Haz clic aqu√≠!</button>;
}
```

**Explicaci√≥n del ejemplo:**
Aqu√≠ creamos un bot√≥n. `onClick={handleClick}` le dice a React: "Oye, cuando alguien haga clic en este bot√≥n, ejecuta la funci√≥n `handleClick`". La funci√≥n `handleClick` simplemente muestra una alerta en la pantalla. ¬°As√≠ de f√°cil!

#### 3. **Notas o advertencias:**

- Los event handlers se suelen definir **dentro** de tus componentes.
- Por convenci√≥n, sus nombres empiezan con `handle` seguido del nombre del evento (ej: `handleClick`, `handleMouseEnter`).
- Puedes definirlos de dos formas:
  - **Funci√≥n separada:** `function handleClick() { ... }` y luego `onClick={handleClick}`
  - **Funci√≥n en l√≠nea (inline):** `onClick={() => { ... }}` (usando _arrow functions_ para que sea m√°s corto).

---

## B - Pasar Funciones, No Llamarlas (¬°Cuidado con los par√©ntesis! ‚ö†Ô∏è)

#### 1. **Definici√≥n:**

Cuando asignas un event handler, tienes que **pasar la funci√≥n en s√≠**, no el resultado de _llamar_ a la funci√≥n. Es una diferencia sutil pero crucial. Piensa que le est√°s dando una instrucci√≥n a React: "Aqu√≠ tienes la funci√≥n, ejec√∫tala _t√∫_ cuando pase el evento".

#### 2. **Ejemplo:**

```jsx
// ‚úÖ Correcto: Pasamos la funci√≥n handleClick
<button onClick={handleClick}>Haz clic</button>

// ‚ùå Incorrecto: Llamamos a handleClick inmediatamente
<button onClick={handleClick()}>Haz clic</button>

// ‚úÖ Correcto (inline): Pasamos una funci√≥n an√≥nima
<button onClick={() => alert('¬°Clic!')}>Haz clic</button>

// ‚ùå Incorrecto (inline): alert('¬°Clic!') se ejecuta al renderizar, no al hacer clic
<button onClick={alert('¬°Clic!')}>Haz clic</button>
```

**Explicaci√≥n del ejemplo:**
En los ejemplos **incorrectos**, al usar `handleClick()` o `alert('¬°Clic!')` dentro de `onClick`, est√°s ejecutando esas funciones **inmediatamente** cuando React dibuja el componente en la pantalla, ¬°no cuando el usuario hace clic! Lo que queremos es que React _recuerde_ la funci√≥n y la ejecute solo cuando ocurra el evento.

#### 3. **Notas o advertencias:**

- **Sin par√©ntesis `()` para pasar la funci√≥n:** `onClick={handleClick}` (le pasas la receta de la funci√≥n).
- **Con par√©ntesis `()` para llamar a la funci√≥n:** `handleClick()` (ejecutas la receta _ahora mismo_).
- Si usas funciones en l√≠nea, aseg√∫rate de usar `() => { ... }` para crear una funci√≥n an√≥nima que se ejecutar√° _despu√©s_, cuando ocurra el evento.

---

## C - Event Handlers y Props: ¬°Trabajo en Equipo! ü§ù

#### 1. **Definici√≥n:**

Los event handlers, al estar dentro de un componente, tienen acceso a las **props** de ese componente. Esto significa que puedes usar informaci√≥n que le pasas al componente (las props) dentro de la funci√≥n que se ejecuta cuando ocurre un evento. ¬°Es como si el bot√≥n supiera cosas sobre s√≠ mismo! ü§ì

#### 2. **Ejemplo:**

```jsx
function AlertButton({ message, children }) {
  return <button onClick={() => alert(message)}>{children}</button>;
}

export default function Toolbar() {
  return (
    <div>
      <AlertButton message="¬°Reproduciendo pel√≠cula! üé¨">
        Ver Pel√≠cula
      </AlertButton>
      <AlertButton message="¬°Subiendo imagen! üñºÔ∏è">Subir Imagen</AlertButton>
    </div>
  );
}
```

**Explicaci√≥n del ejemplo:**
`AlertButton` recibe dos props: `message` (el mensaje que mostrar√° la alerta) y `children` (el texto del bot√≥n). Dentro del `onClick`, usamos `alert(message)` para mostrar el mensaje que se le pas√≥ como prop. `Toolbar` usa `AlertButton` dos veces, cada vez con un mensaje diferente. ¬°As√≠, cada bot√≥n muestra un mensaje distinto al ser clickeado!

#### 3. **Notas o advertencias:**

- Las props hacen que tus componentes sean **reutilizables y configurables**. Puedes cambiar el comportamiento de un event handler simplemente cambiando las props que le pasas al componente.

---

## D - Event Handlers como Props: ¬°Delegando Tareas! ü´±üèº‚Äçü´≤üèΩ

#### 1. **Definici√≥n:**

A veces, quieres que el componente **padre** decida qu√© debe hacer un componente **hijo** cuando ocurre un evento. Para esto, puedes pasar un event handler como una **prop** al componente hijo. Es como si el padre le dijera al hijo: "Cuando te hagan clic, usa _esta_ funci√≥n que te doy".

#### 2. **Ejemplo:**

```jsx
function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

function PlayButton({ movieName }) {
  function handlePlayClick() {
    alert(`¬°Reproduciendo ${movieName}! üçø`);
  }
  return <Button onClick={handlePlayClick}>Reproducir "{movieName}"</Button>;
}

function UploadButton() {
  return (
    <Button onClick={() => alert("¬°Subiendo imagen! üöÄ")}>Subir Imagen</Button>
  );
}

export default function Toolbar() {
  return (
    <div>
      <PlayButton movieName="El Viaje de Chihiro" />
      <UploadButton />
    </div>
  );
}
```

**Explicaci√≥n del ejemplo:**
Aqu√≠, `Button` es un componente gen√©rico de bot√≥n. `PlayButton` y `UploadButton` son m√°s espec√≠ficos.

- `PlayButton` define `handlePlayClick` y se la pasa como prop `onClick` a `Button`.
- `UploadButton` define una funci√≥n en l√≠nea y se la pasa como prop `onClick` a `Button`.
- `Toolbar` usa `PlayButton` y `UploadButton`. El comportamiento espec√≠fico de "reproducir" o "subir" se define en `PlayButton` y `UploadButton`, y se delega al componente `Button` a trav√©s de la prop `onClick`.

#### 3. **Notas o advertencias:**

- Este patr√≥n es muy com√∫n en React para crear componentes **reutilizables y personalizables**. El componente `Button` no sabe _qu√©_ va a hacer `onClick`, solo sabe que tiene que ejecutar _alguna_ funci√≥n cuando se haga clic.
- Es la base de los **design systems**, donde tienes componentes de UI b√°sicos (como `Button`) que se pueden usar en diferentes contextos con comportamientos distintos.

---

## E - Nombres de Props para Event Handlers: ¬°Convenciones Amigables! üè∑Ô∏è

#### 1. **Definici√≥n:**

Para los componentes **nativos** de HTML (como `<button>`, `<div>`, `<span>`, etc.), React usa los nombres de eventos est√°ndar del navegador (como `onClick`, `onMouseOver`, `onSubmit`). Pero cuando creas **tus propios componentes**, ¬°puedes nombrar las props de los event handlers como quieras!

#### 2. **Ejemplo:**

```jsx
function Button({ onSmash, children }) {
  // Prop 'onSmash' en lugar de 'onClick'
  return (
    <button onClick={onSmash}>
      {" "}
      {/* Pero el <button> nativo sigue usando 'onClick' */}
      {children}
    </button>
  );
}

export default function App() {
  return (
    <div>
      <Button onSmash={() => alert("¬°Reproduciendo! üé¨")}>Ver Pel√≠cula</Button>
      <Button onSmash={() => alert("¬°Subiendo! üñºÔ∏è")}>Subir Imagen</Button>
    </div>
  );
}
```

**Explicaci√≥n del ejemplo:**
Aqu√≠, el componente `Button` recibe una prop llamada `onSmash` en lugar de `onClick`. Dentro de `Button`, seguimos usando `onClick` en el `<button>` nativo, pero lo conectamos a la prop `onSmash`. ¬°Funciona igual!

#### 3. **Notas o advertencias:**

- **Convenci√≥n:** Para tus componentes, es buena pr√°ctica que los nombres de las props para event handlers empiecen con `on` seguido de una letra may√∫scula (ej: `onPlayMovie`, `onItemSelect`, `onSubmitForm`). Esto hace que tu c√≥digo sea m√°s f√°cil de entender para otros desarrolladores (¬°y para ti en el futuro!).
- Puedes usar nombres de props que describan la **acci√≥n espec√≠fica** que ocurre en tu aplicaci√≥n (ej: `onPlayMovie`, `onUploadImage`) en lugar de solo el evento gen√©rico (como `onClick`). Esto hace que el c√≥digo sea m√°s claro y flexible.

---

## F - Propagaci√≥n de Eventos (Event Propagation): ¬°Como Burbujas! ü´ß

#### 1. **Definici√≥n:**

Cuando ocurre un evento en un elemento (por ejemplo, un clic en un bot√≥n), ese evento no solo se dispara en ese elemento, sino que tambi√©n "sube" por el √°rbol de componentes hasta llegar a los componentes padres. Esto se llama **propagaci√≥n de eventos** o **event bubbling**. Es como si el evento fuera una burbuja que sube desde el elemento que lo origin√≥ hasta la cima.

#### 2. **Ejemplo:**

```jsx
export default function Toolbar() {
  return (
    <div
      className="Toolbar"
      onClick={() => {
        alert("¬°Clic en la barra de herramientas! üß∞");
      }}
    >
      <button onClick={() => alert("¬°Reproduciendo! üé¨")}>Ver Pel√≠cula</button>
      <button onClick={() => alert("¬°Subiendo! üñºÔ∏è")}>Subir Imagen</button>
    </div>
  );
}
```

**Explicaci√≥n del ejemplo:**
Si haces clic en uno de los botones, ver√°s **dos** alertas: primero la del bot√≥n ("¬°Reproduciendo!" o "¬°Subiendo!") y luego la de la `div` contenedora ("¬°Clic en la barra de herramientas!"). Esto pasa porque el evento de clic primero se dispara en el bot√≥n, y luego "sube" hasta la `div` padre, disparando tambi√©n su `onClick`. Si haces clic directamente en la barra de herramientas (fuera de los botones), solo ver√°s la alerta de la `div`.

#### 3. **Notas o advertencias:**

- **Todos los eventos en React se propagan** (hacen _bubbling_) **excepto `onScroll`**, que solo funciona en el elemento al que se lo asignas.
- La propagaci√≥n de eventos puede ser √∫til para manejar eventos en un nivel superior y evitar tener que asignar el mismo event handler a muchos elementos hijos. Pero a veces, ¬°puede que no quieras que el evento se propague! Para eso, existe...

---

## G - Detener la Propagaci√≥n (Stopping Propagation): ¬°Rompiendo la Burbuja! üí•

#### 1. **Definici√≥n:**

A veces, quieres que un evento se maneje solo en el elemento que lo origin√≥, y **no quieres que se propague** a los componentes padres. Para esto, puedes usar `e.stopPropagation()` dentro del event handler. `e` es el **objeto de evento**, que se pasa autom√°ticamente a tu event handler. Llamar a `e.stopPropagation()` es como pinchar la burbuja del evento para que no siga subiendo.

#### 2. **Ejemplo:**

```jsx
function Button({ onClick, children }) {
  return (
    <button
      onClick={(e) => {
        e.stopPropagation(); // ¬°Detenemos la propagaci√≥n!
        onClick(); // Ejecutamos el onClick que nos pasaron como prop
      }}
    >
      {children}
    </button>
  );
}

export default function Toolbar() {
  return (
    <div
      className="Toolbar"
      onClick={() => {
        alert("¬°Clic en la barra de herramientas! üß∞");
      }}
    >
      <Button onClick={() => alert("¬°Reproduciendo! üé¨")}>Ver Pel√≠cula</Button>
      <Button onClick={() => alert("¬°Subiendo! üñºÔ∏è")}>Subir Imagen</Button>
    </div>
  );
}
```

**Explicaci√≥n del ejemplo:**
Ahora, si haces clic en un bot√≥n, solo ver√°s **una** alerta: la del bot√≥n ("¬°Reproduciendo!" o "¬°Subiendo!"). La alerta de la `div` contenedora ya no aparece. Esto es porque `e.stopPropagation()` dentro del `onClick` del componente `Button` evita que el evento de clic se propague hacia arriba.

#### 3. **Notas o advertencias:**

- `e.stopPropagation()` es √∫til cuando quieres un control m√°s preciso sobre c√≥mo se manejan los eventos y evitar comportamientos inesperados debido a la propagaci√≥n.
- √ösalo con **cuidado**. Detener la propagaci√≥n puede hacer que tu c√≥digo sea m√°s dif√≠cil de entender si se usa en exceso. A veces, es mejor usar otros patrones (como pasar handlers como props, que veremos a continuaci√≥n) en lugar de depender demasiado de `stopPropagation()`.

---

## H - Capture Phase Events (Fase de Captura): ¬°Esp√≠as de Eventos! üïµÔ∏è‚Äç‚ôÄÔ∏è (Avanzado)

#### 1. **Definici√≥n:**

En casos muy raros, podr√≠as necesitar "capturar" todos los eventos que ocurren en los elementos hijos, **incluso si detienen la propagaci√≥n**. Para esto, puedes usar la **fase de captura** de eventos. En lugar de `onClick`, usas `onClickCapture`. Los event handlers `onClickCapture` se ejecutan **antes** que los event handlers `onClick` normales, durante la fase de "captura" del evento.

#### 2. **Ejemplo:**

```jsx
<div
  onClickCapture={() => {
    alert("¬°Captura primero! üé£");
  }}
>
  <button onClick={(e) => e.stopPropagation()}>Bot√≥n 1</button>
  <button onClick={(e) => e.stopPropagation()}>Bot√≥n 2</button>
</div>
```

**Explicaci√≥n del ejemplo:**
Si haces clic en cualquiera de los botones, primero ver√°s la alerta "¬°Captura primero! üé£" (del `onClickCapture` en la `div`), y luego **no ver√°s ninguna otra alerta** de los botones, porque detienen la propagaci√≥n. El `onClickCapture` de la `div` se ejecuta **siempre primero**, incluso si los hijos detienen la propagaci√≥n.

#### 3. **Notas o advertencias:**

- **Muy poco com√∫n en el c√≥digo de aplicaciones normales.** La fase de captura es m√°s √∫til para bibliotecas o frameworks que necesitan un control muy bajo nivel sobre los eventos (como routers o herramientas de an√°lisis).
- **No te preocupes demasiado por esto al principio.** Es un concepto avanzado que probablemente no necesites usar en tus primeros proyectos de React.

---

## I - Handlers como Alternativa a la Propagaci√≥n: ¬°Control Total! üïπÔ∏è

#### 1. **Definici√≥n:**

En lugar de depender de la propagaci√≥n de eventos y de `e.stopPropagation()`, a veces es m√°s claro y controlable pasar event handlers como props y hacer que el componente hijo **ejecute el handler del padre expl√≠citamente**. Esto te da m√°s control sobre el flujo de los eventos y hace que el c√≥digo sea m√°s f√°cil de seguir.

#### 2. **Ejemplo:**

```jsx
function Button({ onClick, children }) {
  return (
    <button
      onClick={(e) => {
        // No usamos e.stopPropagation()
        // Podemos hacer cosas ANTES de llamar al onClick del padre
        console.log("¬°Bot√≥n clickeado!");
        onClick(); // ¬°Llamamos al onClick del padre EXPLICITAMENTE!
        // Podemos hacer cosas DESPU√âS de llamar al onClick del padre
      }}
    >
      {children}
    </button>
  );
}

export default function Toolbar() {
  return (
    <div className="Toolbar">
      <Button onClick={() => alert("¬°Reproduciendo! üé¨")}>Ver Pel√≠cula</Button>
      <Button onClick={() => alert("¬°Subiendo! üñºÔ∏è")}>Subir Imagen</Button>
    </div>
  );
}
```

**Explicaci√≥n del ejemplo:**
En este ejemplo, el componente `Button` **no detiene la propagaci√≥n**. En su lugar, dentro de su `onClick`, primero hace algo (`console.log('¬°Bot√≥n clickeado!')`) y luego **llama expl√≠citamente** a la funci√≥n `onClick` que le pasaron como prop (`onClick()`). Esto permite que el componente padre controle qu√© pasa cuando se hace clic en el bot√≥n, pero tambi√©n permite que el componente hijo a√±ada su propio comportamiento.

#### 3. **Notas o advertencias:**

- Este patr√≥n es m√°s **expl√≠cito** que la propagaci√≥n. Es m√°s f√°cil ver exactamente qu√© funciones se ejecutan y en qu√© orden.
- Puede ser m√°s **verboso** que la propagaci√≥n, pero a menudo hace que el c√≥digo sea m√°s **mantenible** y menos propenso a errores inesperados.
- Si te encuentras con problemas para entender por qu√© se est√°n ejecutando ciertos event handlers debido a la propagaci√≥n, ¬°prueba este enfoque!

---

## J - Prevenir el Comportamiento por Defecto (Prevent Default Behavior): ¬°Controlando el Navegador! üõë

#### 1. **Definici√≥n:**

Algunos eventos del navegador tienen un **comportamiento por defecto** asociado. Por ejemplo, cuando haces clic en un bot√≥n dentro de un `<form>`, el formulario se env√≠a y la p√°gina se recarga por defecto. A veces, quieres **prevenir** este comportamiento por defecto. Para esto, usas `e.preventDefault()` en el objeto de evento.

#### 2. **Ejemplo:**

```jsx
export default function Signup() {
  return (
    <form
      onSubmit={(e) => {
        e.preventDefault(); // ¬°Prevenimos la recarga de la p√°gina!
        alert("¬°Enviando formulario! ‚úâÔ∏è");
      }}
    >
      <input />
      <button>Enviar</button>
    </form>
  );
}
```

**Explicaci√≥n del ejemplo:**
Normalmente, al hacer clic en "Enviar", el formulario se enviar√≠a y la p√°gina se recargar√≠a. Pero al usar `e.preventDefault()` dentro del `onSubmit` del `<form>`, **evitamos la recarga de la p√°gina**. En su lugar, solo se muestra la alerta "¬°Enviando formulario! ‚úâÔ∏è".

#### 3. **Notas o advertencias:**

- `e.preventDefault()` y `e.stopPropagation()` son **cosas diferentes** y no relacionadas:
  - `e.stopPropagation()`: Detiene la propagaci√≥n del evento a los componentes padres.
  - `e.preventDefault()`: Previene el comportamiento por defecto del navegador para ciertos eventos.
- `e.preventDefault()` es √∫til para controlar el comportamiento de formularios, enlaces, men√∫s contextuales, etc., y personalizar la interacci√≥n del usuario.

---

## K - ¬øSide Effects en Event Handlers? ¬°Absolutamente S√ç! ‚úÖ

#### 1. **Definici√≥n:**

Los **side effects** (efectos secundarios) son acciones que **cambian algo fuera del componente**, como actualizar el estado, hacer una llamada a una API, cambiar el DOM directamente, etc. A diferencia de las funciones de renderizado (que deben ser "puras" y no tener side effects), los **event handlers son el lugar perfecto para los side effects** en React.

#### 2. **Ejemplo:**

```jsx
import { useState } from "react";

export default function CounterButton() {
  const [count, setCount] = useState(0); // Estado para el contador

  function handleClick() {
    setCount(count + 1); // Side effect: ¬°Actualizamos el estado!
  }

  return <button onClick={handleClick}>Contador: {count}</button>;
}
```

**Explicaci√≥n del ejemplo:**
Aqu√≠, `handleClick` es un event handler. Dentro de `handleClick`, usamos `setCount(count + 1)` para **actualizar el estado** `count`. Actualizar el estado es un side effect. ¬°Est√° totalmente bien y es lo que se espera que hagas en un event handler!

#### 3. **Notas o advertencias:**

- Los event handlers son el **punto de entrada principal** para interactuar con el usuario y **actualizar la interfaz de usuario** en respuesta a esas interacciones.
- En el pr√≥ximo tema, aprender√°s m√°s sobre el **estado (state)** en React, que es la forma principal de almacenar y actualizar informaci√≥n en tus componentes, ¬°y que se usa mucho dentro de los event handlers!
