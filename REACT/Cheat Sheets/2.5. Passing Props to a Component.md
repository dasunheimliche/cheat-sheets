## A - Â¿QuÃ© son las "Props"?

#### 1. **DefiniciÃ³n:**

Las **"props"** (abreviatura de "properties" o propiedades) son como **atributos personalizados** que puedes pasar a tus componentes React. Son la manera principal en que un componente **padre** le envÃ­a informaciÃ³n a un componente **hijo**. Imagina que estÃ¡s armando un mueble de IKEA: las "props" son como las instrucciones y las piezas que necesitas para ensamblar cada parte. Â¡Cada componente hijo recibe las "props" que necesita para funcionar correctamente! ğŸ› ï¸

#### 2. **Ejemplo AnalÃ³gico:**

**Piensa en una funciÃ³n en JavaScript:**

```javascript
function saludar(nombre) {
  return "Â¡Hola, " + nombre + "!";
}

saludar("Ana"); // "Ana" es el "argumento" que le pasamos a la funciÃ³n
```

**En React, los componentes son como funciones, y las "props" son como los "argumentos" que les pasamos:**

```jsx
function SaludoComponente(props) {
  // 'props' es como el 'nombre' en la funciÃ³n de arriba
  return <h1>Â¡Hola, {props.nombre}!</h1>; // Usamos props.nombre para mostrar el nombre
}

<SaludoComponente nombre="Carlos" />; // "nombre='Carlos'" es la "prop" que le pasamos al componente
```

**ExplicaciÃ³n del ejemplo**:
AsÃ­ como le pasamos un "argumento" (`"Ana"`) a la funciÃ³n `saludar()`, le pasamos una "prop" (`nombre="Carlos"`) al componente `SaludoComponente`. Las "props" permiten **configurar y personalizar** cÃ³mo se renderiza un componente hijo desde su componente padre. Â¡Flexibilidad al mÃ¡ximo! ğŸ’ª

## B - Props Familiares (HTML) vs. Props Personalizadas (React)

#### 1. **DefiniciÃ³n:**

Ya conoces "props" de HTML, como `className`, `src`, `alt`, `width`, `height` para la etiqueta `<img>`. Estas son **props predefinidas** que HTML entiende. En React, **tambiÃ©n puedes crear tus propias "props" personalizadas** para tus componentes. Â¡Es como si pudieras inventar nuevos atributos HTML solo para tus componentes React! ğŸ¤¯

#### 2. **Ejemplo:**

**Props HTML familiares en un componente `Avatar`:**

```jsx
function Avatar() {
  return (
    <img
      className="avatar" // prop 'className' (HTML)
      src="https://i.imgur.com/1bX5QH6.jpg" // prop 'src' (HTML)
      alt="Lin Lanying" // prop 'alt' (HTML)
      width={100} // prop 'width' (HTML)
      height={100} // prop 'height' (HTML)
    />
  );
}
```

**Props personalizadas en un componente `Avatar`:**

```jsx
function Avatar(props) {
  // Â¡'props' contendrÃ¡ nuestras props personalizadas!
  return (
    <img
      className="avatar"
      src={props.imagenSrc} // Â¡Usamos la prop personalizada 'imagenSrc'!
      alt={props.nombreAlt} // Â¡Usamos la prop personalizada 'nombreAlt'!
      width={props.tamanio} // Â¡Usamos la prop personalizada 'tamanio'!
      height={props.tamanio} // Â¡Usamos la prop personalizada 'tamanio'!
    />
  );
}

<Avatar
  imagenSrc="url-de-imagen.jpg"
  nombreAlt="Texto alternativo"
  tamanio={50}
/>;
// 'imagenSrc', 'nombreAlt', 'tamanio' son props personalizadas que inventamos
```

**ExplicaciÃ³n del ejemplo**:

- **Props HTML familiares:** `className`, `src`, `alt`, `width`, `height` son props que ya existen en HTML y React las entiende igual.
- **Props personalizadas:** `imagenSrc`, `nombreAlt`, `tamanio` son props que **nosotros inventamos** para nuestro componente `Avatar`. Â¡Podemos nombrarlas como queramos! Lo importante es que el componente hijo (`Avatar`) sepa cÃ³mo usar esas props que le pasamos desde el padre. Â¡TÃº defines las reglas del juego! ğŸ®

## C - Paso 1: Pasar Props a un Componente Hijo

#### 1. **DefiniciÃ³n:**

Para pasar props de un componente padre a un hijo, es como darle atributos HTML a la etiqueta del componente hijo **en el JSX del padre**. Simplemente escribes el nombre de la prop que quieres pasar, seguido de un signo igual `=` y el valor que quieres darle a esa prop.

#### 2. **Ejemplo:**

**Componente `Profile` (padre) pasando props a `Avatar` (hijo):**

```jsx
export default function Profile() {
  return (
    <Avatar
      person={{ name: "Lin Lanying", imageId: "1bX5QH6" }} // Prop 'person' (objeto)
      size={100} // Prop 'size' (nÃºmero)
    />
  );
}
```

**ExplicaciÃ³n del ejemplo**:

- **`<Avatar ... />`**: Dentro del `return` del componente `Profile`, usamos el componente `Avatar` como una etiqueta JSX.
- **`person={{ name: 'Lin Lanying', imageId: '1bX5QH6' }}`**: Le pasamos una prop llamada `person`. El valor de esta prop es un **objeto JavaScript** con informaciÃ³n sobre una persona. Â¡FÃ­jate en las **dobles llaves `{{ }}`**! La primera llave abre el "modo JavaScript" en JSX, y la segunda llave define un objeto literal de JavaScript.
- **`size={100}`**: Le pasamos otra prop llamada `size`. El valor de esta prop es el **nÃºmero** `100`. Â¡Usamos llaves `{}` para pasar un valor JavaScript (en este caso, un nÃºmero)!

**Â¡Ahora el componente `Avatar` recibirÃ¡ las props `person` y `size` desde `Profile`!** Es como si `Profile` le estuviera diciendo a `Avatar`: "AquÃ­ tienes informaciÃ³n sobre una persona y el tamaÃ±o que quiero que uses para mostrar su avatar". ğŸ—£ï¸â¡ï¸ğŸ

## D - Paso 2: Leer Props en un Componente Hijo

#### 1. **DefiniciÃ³n:**

Para que un componente hijo pueda **usar** las props que le pasaste desde el padre, necesita **"leerlas" o "recibirlas"**. Esto se hace en la **definiciÃ³n de la funciÃ³n del componente hijo**, usando **destructuring** (desestructuraciÃ³n) de JavaScript. Es como abrir el regalo que te dieron y ver quÃ© hay dentro. ğŸ â¡ï¸ ğŸ‘€

#### 2. **Ejemplo:**

**Componente `Avatar` (hijo) leyendo las props `person` y `size`:**

```jsx
function Avatar({ person, size }) {
  // ğŸ‘ˆ Â¡Recibimos las props 'person' y 'size' aquÃ­!
  return (
    <img
      className="avatar"
      src={`https://i.imgur.com/${person.imageId}.jpg`} // Usamos person.imageId
      alt={person.name} // Usamos person.name
      width={size} // Usamos la prop 'size'
      height={size} // Usamos la prop 'size'
    />
  );
}
```

**ExplicaciÃ³n del ejemplo**:

- **`function Avatar({ person, size }) { ... }`**: En la definiciÃ³n de la funciÃ³n `Avatar`, usamos **destructuring** (`{ person, size }`) dentro de los parÃ©ntesis. Esto le dice a JavaScript: "Espero recibir un objeto (las props) como argumento. De ese objeto, quiero extraer las propiedades `person` y `size` y guardarlas en variables con esos mismos nombres (`person` y `size`) para poder usarlas dentro de la funciÃ³n `Avatar`".
- **`src={`...${person.imageId}...`}`**: Usamos `person.imageId` para construir la URL de la imagen. Accedemos a la propiedad `imageId` del objeto `person` que recibimos como prop.
- **`alt={person.name}`**: Usamos `person.name` para el texto alternativo de la imagen.
- **`width={size}` y `height={size}`**: Usamos la prop `size` para establecer el ancho y el alto de la imagen.

**Â¡Ahora el componente `Avatar` puede usar la informaciÃ³n de las props `person` y `size` para renderizarse de forma personalizada!** Cada vez que el componente padre `Profile` renderice `Avatar` con diferentes props, Â¡`Avatar` se mostrarÃ¡ de manera diferente! Â¡Componentes configurables y reutilizables! âš™ï¸

**Ejemplo completo con `Profile` y `Avatar`:**

App.jsutils.js

App.js

```jsx
import { getImageUrl } from "./utils.js"; // FunciÃ³n auxiliar (no relevante para props)

function Avatar({ person, size }) {
  // Avatar recibe props 'person' y 'size'
  return (
    <img
      className="avatar"
      src={getImageUrl(person)} // Usa funciÃ³n auxiliar y prop 'person'
      alt={person.name} // Usa prop 'person'
      width={size} // Usa prop 'size'
      height={size} // Usa prop 'size'
    />
  );
}

export default function Profile() {
  return (
    <div>
      <Avatar // Primer Avatar con props diferentes
        size={100}
        person={{
          name: "Katsuko Saruhashi",
          imageId: "YfeOqp2",
        }}
      />
      <Avatar // Segundo Avatar con props diferentes
        size={80}
        person={{
          name: "Aklilu Lemma",
          imageId: "OKS67lh",
        }}
      />
      <Avatar // Tercer Avatar con props diferentes
        size={50}
        person={{
          name: "Lin Lanying",
          imageId: "1bX5QH6",
        }}
      />
    </div>
  );
}
```

**ExplicaciÃ³n del ejemplo**:
El componente `Profile` renderiza **tres componentes `Avatar`**, Â¡pero cada uno con **props diferentes**! Esto demuestra el poder de las props: **reutilizar el mismo componente (`Avatar`) para mostrar diferentes cosas, simplemente cambiando las props que le pasamos**. Â¡Un componente, mÃºltiples configuraciones! ğŸ­

**Imagen de los Avatars renderizados con diferentes props:**

(En este caso, no hay una imagen especÃ­fica en el texto, pero imagina tres avatares de diferentes tamaÃ±os y con nombres diferentes).

## E - Especificando un Valor por Defecto para una Prop

#### 1. **DefiniciÃ³n:**

A veces, quieres que una prop tenga un **valor predeterminado** si no se le pasa ningÃºn valor desde el componente padre. Puedes hacer esto directamente en la **desestructuraciÃ³n de las props** en el componente hijo, usando el signo igual `=` seguido del valor por defecto. Es como decir: "Si no me das este regalo, Â¡ya tengo uno de repuesto!". ğŸ â¡ï¸ ğŸ (por defecto)

#### 2. **Ejemplo:**

**Componente `Avatar` con un valor por defecto para la prop `size`:**

```jsx
function Avatar({ person, size = 100 }) {
  // ğŸ‘ˆ Valor por defecto 'size = 100'
  return (
    <img
      className="avatar"
      src={`https://i.imgur.com/${person.imageId}.jpg`}
      alt={person.name}
      width={size} // 'size' usarÃ¡ 100 si no se pasa la prop
      height={size} // 'size' usarÃ¡ 100 si no se pasa la prop
    />
  );
}

<Avatar person={{ name: "Hedy Lamarr", imageId: "xyz789" }} />;
// Â¡No pasamos la prop 'size'! 'Avatar' usarÃ¡ el valor por defecto: 100
```

**ExplicaciÃ³n del ejemplo**:

- **`function Avatar({ person, size = 100 }) { ... }`**: En la desestructuraciÃ³n de props, ponemos `size = 100`. Esto significa: "Si la prop `size` no se pasa desde el padre, o si se pasa como `undefined`, entonces usa el valor `100` como valor por defecto para `size`".
- **`<Avatar person={{ ... }} />`**: AquÃ­, **no pasamos la prop `size`** al componente `Avatar`. Como resultado, `Avatar` usarÃ¡ el valor por defecto `100` para `size`.

**Â¡Los valores por defecto hacen que tus componentes sean mÃ¡s robustos y fÃ¡ciles de usar!** Si olvidas pasar una prop opcional, el componente seguirÃ¡ funcionando con un valor sensato. Â¡Componentes a prueba de olvidos! ğŸ›¡ï¸

**Importante:** El valor por defecto **solo se usa si la prop estÃ¡ ausente o es `undefined`**. Si pasas `size={null}` o `size={0}`, **no se usarÃ¡ el valor por defecto**. `null` y `0` son valores vÃ¡lidos, Â¡no valores ausentes!

## F - Reenviando Props con la Sintaxis Spread `...props`

#### 1. **DefiniciÃ³n:**

A veces, un componente padre solo sirve como un "contenedor" o "intermediario" y simplemente quiere **pasar todas las props que recibe a su componente hijo, sin modificarlas**. En estos casos, puedes usar la **sintaxis spread `...props`** para reenviar todas las props de forma concisa. Es como decir: "Toma todos los regalos que me dieron a mÃ­ y pÃ¡salos directamente al siguiente componente". ğŸâ¡ï¸ğŸâ¡ï¸ğŸ

#### 2. **Ejemplo:**

**Componente `ProfileCard` (padre) reenviando todas las props a `Avatar` (hijo):**

```jsx
function ProfileCard(props) {
  // Recibimos todas las props en 'props'
  return (
    <div className="card">
      <Avatar {...props} /> // ğŸ‘ˆ Â¡Reenviamos TODAS las props a Avatar con{" "}
      {...props}!
    </div>
  );
}

<ProfileCard
  person={{ name: "Ada Lovelace", imageId: "abc123" }}
  size={80}
  isSepia={true}
/>;
// 'ProfileCard' recibe 'person', 'size', 'isSepia' y las reenvÃ­a a 'Avatar'
```

**ExplicaciÃ³n del ejemplo**:

- **`function ProfileCard(props) { ... }`**: El componente `ProfileCard` recibe todas las props en un objeto llamado `props`.
- **`<Avatar {...props} />`**: Dentro de `ProfileCard`, usamos `<Avatar {...props} />`. La sintaxis **`{...props}`** es la **sintaxis spread de JSX**. Le dice a React: "Toma todas las propiedades que estÃ¡n dentro del objeto `props` y pÃ¡salas como props individuales al componente `Avatar`".

**Â¡Es como si `ProfileCard` fuera transparente en tÃ©rminos de props!** Recibe props y las pasa directamente a `Avatar` sin hacer nada mÃ¡s con ellas. Ãštil para componentes contenedores simples. ğŸ“¦â¡ï¸ğŸ“¦

**Â¡Usa la sintaxis spread con moderaciÃ³n!** Si la usas en todos lados, puede ser seÃ±al de que algo no estÃ¡ bien en la estructura de tus componentes. A menudo, es mejor dividir los componentes y usar la prop `children` (que veremos a continuaciÃ³n) en lugar de reenviar todas las props indiscriminadamente. Â¡No abuses del spread! âš ï¸

## G - Pasando JSX como `children`

#### 1. **DefiniciÃ³n:**

AdemÃ¡s de pasar props con valores simples (strings, nÃºmeros, objetos), tambiÃ©n puedes pasar **JSX (markup)** como una prop especial llamada **`children`**. Esto te permite "envolver" componentes con otros componentes y pasarles contenido dinÃ¡mico. Es como si un componente padre le diera a su hijo un "hueco" que el padre puede "llenar" con cualquier cosa que quiera renderizar dentro del hijo. ğŸ•³ï¸ â¡ï¸ ğŸ§©

#### 2. **Ejemplo:**

**Componente `Card` (contenedor) que recibe JSX como `children`:**

App.jsAvatar.jsutils.js

App.js

```jsx
import Avatar from "./Avatar.js"; // Importamos el componente Avatar

function Card({ children }) {
  // ğŸ‘ˆ Â¡Recibimos la prop 'children'!
  return (
    <div className="card">
      {children} // ğŸ‘ˆ Â¡Renderizamos la prop 'children' aquÃ­!
    </div>
  );
}

export default function Profile() {
  return (
    <Card>
      {" "}
      {/* Componente Card como contenedor */}
      <Avatar // Â¡JSX que pasamos como 'children' a Card!
        size={100}
        person={{
          name: "Katsuko Saruhashi",
          imageId: "YfeOqp2",
        }}
      />
    </Card>
  );
}
```

**ExplicaciÃ³n del ejemplo**:

- **`function Card({ children }) { ... }`**: El componente `Card` recibe una prop especial llamada `children`. **React automÃ¡ticamente asigna cualquier JSX que pongas _entre_ las etiquetas de apertura y cierre de `<Card>` a esta prop `children`**.
- **`<div className="card">{children}</div>`**: Dentro del `return` de `Card`, renderizamos `{children}` dentro de un `<div>` con la clase "card". Esto significa que **cualquier JSX que se pase como `children` se renderizarÃ¡ _dentro_ de este `<div>`**.
- **`<Card><Avatar ... /></Card>`**: En el componente `Profile`, usamos `<Card>` como un "contenedor" y ponemos el componente `<Avatar>` **dentro** de `<Card>`. Â¡Este `<Avatar>` se convierte en la prop `children` del componente `Card`!

**Â¡Ahora el componente `Card` puede "envolver" cualquier contenido que le pasemos como `children`!** Puedes poner texto, otros componentes, Â¡lo que quieras dentro de `<Card>` y `Card` lo renderizarÃ¡ dentro de su estructura. SÃºper flexible para crear layouts y componentes contenedores reutilizables. ğŸ + ğŸ“¦ = ğŸ¤©

**Ejemplo de `Card` envolviendo texto:**

```jsx
<Card>
  <h1>Â¡Hola!</h1>
  <p>Este es un pÃ¡rrafo dentro de la Card.</p>
</Card>
```

**Imagen ilustrativa de la prop `children`:**

![image](https://react.dev/images/docs/illustrations/i_children-prop.png)
_Componente `Card` con un "hueco" para la prop `children`, que puede ser llenado con diferentes piezas JSX como texto o `Avatar`._

## H - CÃ³mo Cambian las Props con el Tiempo

#### 1. **DefiniciÃ³n:**

Las props **no son estÃ¡ticas**, Â¡pueden **cambiar con el tiempo**! Un componente puede recibir **diferentes props en diferentes momentos**, dependiendo de cÃ³mo cambien los datos en su componente padre o en la aplicaciÃ³n. Imagina que las props son como el estado del mundo exterior que influye en cÃ³mo se muestra un componente. â³ğŸ”„

#### 2. **Ejemplo:**

**Componente `Clock` que recibe props `color` y `time` que cambian:**

Clock.js

Clock.js

```jsx
export default function Clock({ color, time }) {
  // Recibe props 'color' y 'time'
  return (
    <h1 style={{ color: color }}>
      {" "}
      // Usa la prop 'color' para el estilo
      {time} // Usa la prop 'time' para mostrar la hora
    </h1>
  );
}
```

**ExplicaciÃ³n del ejemplo**:

- **`Clock({ color, time })`**: El componente `Clock` recibe dos props: `color` y `time`.
- **`<h1 style={{ color: color }}>{time}</h1>`**: Usa la prop `color` para establecer el color del texto del `<h1>` y la prop `time` para mostrar la hora.

**En el ejemplo interactivo del texto original, la prop `time` cambia cada segundo, y la prop `color` cambia cuando seleccionas un color diferente.** Esto muestra que las props pueden ser **dinÃ¡micas** y reflejar los datos actuales de la aplicaciÃ³n.

Â¡Importante! Las props son **inmutables**. Esto significa que **no puedes cambiar las props _dentro_ del propio componente hijo**. Cuando un componente necesita "cambiar sus props" (por ejemplo, en respuesta a una interacciÃ³n del usuario), lo que realmente sucede es que **el componente padre le pasa _nuevas props_ al componente hijo**. El componente hijo recibe un _nuevo objeto de props_ con los valores actualizados. Â¡No intentes "modificar" las props directamente! Para eso, React tiene otro concepto llamado **"state" (estado)**, que veremos mÃ¡s adelante. Las props fluyen en una sola direcciÃ³n: \*\*de padre a hijo. â¡ï¸

**En resumen: Las props son la forma en que los componentes padres le dan informaciÃ³n a los componentes hijos. Son como "regalos" que configuran y personalizan cÃ³mo se renderizan los componentes. Â¡Dominar las props es fundamental para construir interfaces React dinÃ¡micas y reutilizables!** Sigue practicando y experimentando con props, Â¡y te convertirÃ¡s en un maestro de la comunicaciÃ³n entre componentes! Â¡Cualquier duda, ya sabes dÃ³nde preguntar! Â¡A programar con props! ğŸš€ğŸğŸ’ª
