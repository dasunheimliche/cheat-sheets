## A - Evita `useEffect` para transformar datos al renderizar

#### 1. **Definicion:**

No necesitas un `useEffect` para preparar datos antes de mostrarlos en tu interfaz. Si solo quieres cambiar c√≥mo se ven los datos (filtrar una lista, formatear texto, etc.) ¬°hazlo directamente en el renderizado!

#### 2. **Ejemplo:**

```jsx
function ListaTareas({ tareas, filtro }) {
  const [nuevaTarea, setNuevaTarea] = useState("");

  // ‚ùå Mal: Usar Effect para filtrar (innecesario y lento)
  const [tareasVisibles, setTareasVisibles] = useState([]);
  useEffect(() => {
    setTareasVisibles(filtrarTareas(tareas, filtro));
  }, [tareas, filtro]);

  // ‚úÖ Bien: Filtrar directamente en el renderizado (simple y r√°pido)
  const tareasVisibles = filtrarTareas(tareas, filtro);

  return <>{/* ... JSX ... */}</>;
}

function filtrarTareas(tareas, filtro) {
  // ... l√≥gica para filtrar tareas ...
  return tareasFiltradas;
}
```

**Explicaci√≥n del ejemplo:**
En el ejemplo incorrecto, usamos `useEffect` para actualizar `tareasVisibles` cada vez que `tareas` o `filtro` cambian. ¬°Esto es un rodeo innecesario! La versi√≥n correcta calcula `tareasVisibles` directamente al renderizar. React se encarga de recalcularlo eficientemente cuando `tareas` o `filtro` cambian. ¬°Menos c√≥digo, m√°s r√°pido!

#### 3. **Notas o advertencias:**

- **Rendimiento:** Usar `useEffect` para esto causa renders extra innecesarios. ¬°Ev√≠talos!
- **Simplicidad:** Calcular los datos directamente hace tu c√≥digo m√°s f√°cil de leer y entender.

## B - `useMemo` para c√°lculos costosos

#### 1. **Definicion:**

Si tienes una funci√≥n que tarda en ejecutarse (por ejemplo, filtrar una lista muy grande), usa `useMemo` para guardar el resultado y reutilizarlo si las entradas no cambian. ¬°As√≠ evitas recalcular lo mismo una y otra vez!

#### 2. **Ejemplo:**

```jsx
import { useMemo, useState } from "react";

function ListaTareas({ tareas, filtro }) {
  const [nuevaTarea, setNuevaTarea] = useState("");

  // ‚úÖ Bien: useMemo para optimizar el filtrado
  const tareasVisibles = useMemo(() => {
    console.log("Filtrando tareas..."); // Para ver cu√°ndo se ejecuta
    return filtrarTareas(tareas, filtro);
  }, [tareas, filtro]); // ¬°Solo se recalcula si tareas o filtro cambian!

  return <>{/* ... JSX ... */}</>;
}

function filtrarTareas(tareas, filtro) {
  // ... l√≥gica costosa para filtrar tareas ...
  return tareasFiltradas;
}
```

**Explicaci√≥n del ejemplo:**
Con `useMemo`, la funci√≥n `filtrarTareas` solo se ejecuta cuando `tareas` o `filtro` cambian. Si no cambian, `useMemo` devuelve el resultado guardado de la vez anterior. ¬°Mucho m√°s eficiente si `filtrarTareas` es lenta!

#### 3. **Notas o advertencias:**

- **¬øCu√°ndo usar `useMemo`?** Solo si el c√°lculo es realmente lento. Para la mayor√≠a de las cosas, ¬°no lo necesitas!
- **Pureza:** La funci√≥n dentro de `useMemo` debe ser "pura", es decir, no debe tener efectos secundarios (como modificar variables fuera de su √°mbito).

## C - Reinicia el estado con `key` al cambiar props

#### 1. **Definicion:**

Si quieres que un componente y **todo su estado interno** se reinicien por completo cuando cambia una prop importante (como un `userId`), usa la prop `key`. React tratar√° al componente como si fuera uno nuevo.

#### 2. **Ejemplo:**

```jsx
function PaginaPerfil({ userId }) {
  return (
    <PerfilUsuario
      userId={userId}
      key={userId} // üîë ¬°La clave m√°gica!
    />
  );
}

function PerfilUsuario({ userId }) {
  const [comentario, setComentario] = useState(""); // üìù Estado que se reinicia con la key

  return (
    <div>
      <h2>Perfil de usuario {userId}</h2>
      <textarea
        value={comentario}
        onChange={(e) => setComentario(e.target.value)}
        placeholder="Escribe un comentario..."
      />
      {/* ... m√°s contenido del perfil ... */}
    </div>
  );
}
```

**Explicaci√≥n del ejemplo:**
Cuando `userId` cambia en `PaginaPerfil`, la prop `key` en `<PerfilUsuario key={userId} />` tambi√©n cambia. React detecta esto y **destruye** el `<PerfilUsuario>` anterior y crea uno **nuevo** desde cero. ¬°El estado `comentario` se reinicia autom√°ticamente!

#### 3. **Notas o advertencias:**

- **Reinicio total:** `key` reinicia **todo** el estado del componente y sus hijos. √ösalo cuando realmente quieras un "nuevo comienzo".
- **Alternativa a `useEffect`:** Evita usar `useEffect` para resetear el estado manualmente al cambiar props. ¬°`key` es m√°s limpio y eficiente!

## ==D - Ajustar parte del estado al cambiar props (¬°con cuidado!)==

#### 1. **Definicion:**

A veces, solo necesitas cambiar **parte** del estado cuando una prop cambia. Puedes hacerlo **directamente durante el renderizado**, pero ¬°con precauci√≥n! Es mejor buscar alternativas como calcular todo en el renderizado o usar `key`.

#### 2. **Ejemplo:**

```jsx
function ListaItems({ items }) {
  const [estaReversa, setEstaReversa] = useState(false);
  const [seleccion, setSeleccion] = useState(null);

  // ‚ö†Ô∏è  Ajuste de estado en renderizado (con cuidado)
  const [itemsAnteriores, setItemsAnteriores] = useState(items);
  if (items !== itemsAnteriores) {
    setItemsAnteriores(items);
    setSeleccion(null); // Resetea la selecci√≥n al cambiar items
  }

  return <>{/* ... JSX ... */}</>;
}
```

**Explicaci√≥n del ejemplo:**
Aqu√≠, comparamos `items` con `itemsAnteriores` en cada renderizado. Si `items` es diferente, actualizamos `itemsAnteriores` y reseteamos `seleccion`. Esto se hace **durante el renderizado**. React vuelve a renderizar el componente **inmediatamente** despu√©s de este ajuste.

#### 3. **Notas o advertencias:**

- **¬°√ösalo con moderaci√≥n!** Hacer esto complica el flujo de datos. Preg√∫ntate si puedes calcular `seleccion` directamente o usar `key` en su lugar.
- **Solo el mismo componente:** Solo puedes actualizar el estado del **mismo** componente durante el renderizado. Intentar actualizar el estado de otro componente causar√° un error.
- **Condici√≥n necesaria:** La condici√≥n `items !== itemsAnteriores` es crucial para evitar bucles infinitos de renderizado.

## E - Comparte l√≥gica entre manejadores de eventos (¬°funciones!)

#### 1. **Definicion:**

Si tienes l√≥gica que se repite en varios manejadores de eventos (como `onClick` de botones), ¬°no uses `useEffect` para esto! Simplemente **crea una funci√≥n** y ll√°mala desde todos los manejadores de eventos que la necesiten.

#### 2. **Ejemplo:**

```jsx
function PaginaProducto({ producto, agregarAlCarrito }) {
  // ‚úÖ Bien: L√≥gica compartida en una funci√≥n
  function comprarProducto() {
    agregarAlCarrito(producto);
    mostrarNotificacion(`¬°${producto.nombre} a√±adido al carrito!`);
  }

  function handleClickComprar() {
    comprarProducto();
  }

  function handleClickPagar() {
    comprarProducto();
    navegarA("/pagar");
  }

  return (
    <>{/* ... JSX con botones handleClickComprar y handleClickPagar ... */}</>
  );
}

function mostrarNotificacion(mensaje) {
  alert(mensaje); //  Simplemente para el ejemplo
}
function navegarA(ruta) {
  console.log("Navegando a:", ruta); // Simplemente para el ejemplo
}
```

**Explicaci√≥n del ejemplo:**
En lugar de un `useEffect` complicado, creamos la funci√≥n `comprarProducto()` que contiene la l√≥gica com√∫n. `handleClickComprar` y `handleClickPagar` simplemente llaman a `comprarProducto()`. ¬°Mucho m√°s limpio y f√°cil de entender!

#### 3. **Notas o advertencias:**

- **Eventos vs. Efectos:** `useEffect` es para l√≥gica que se ejecuta **porque el componente se muestra**. Los manejadores de eventos son para l√≥gica que se ejecuta **porque el usuario interact√∫a**. ¬°No los mezcles innecesariamente!
- **Reutilizaci√≥n:** Las funciones son la forma natural de reutilizar l√≥gica en JavaScript y React. ¬°√ösalas!

## F - Peticiones POST: Eventos para acciones del usuario, Efectos para inicializaci√≥n

#### 1. **Definicion:**

- **Peticiones POST por acciones del usuario (botones, formularios):** ¬°Van en los **manejadores de eventos**! El usuario inicia la acci√≥n.
- **Peticiones POST que deben ocurrir cuando el componente se muestra (an√°lisis, inicializaci√≥n):** Pueden ir en `useEffect`.

#### 2. **Ejemplo:**

```jsx
function FormularioRegistro() {
  const [nombre, setNombre] = useState("");
  const [apellido, setApellido] = useState("");

  // ‚úÖ Bien: Anal√≠tica al mostrar el formulario (useEffect)
  useEffect(() => {
    enviarPost("/api/analitica", { evento: "formulario_visto" });
  }, []); // [] para que se ejecute solo al montar

  function handleSubmit(evento) {
    evento.preventDefault();
    // ‚úÖ Bien: Registro al hacer clic en "Enviar" (manejador de evento)
    enviarPost("/api/registrar", { nombre, apellido });
  }

  return (
    <form onSubmit={handleSubmit}>
      {/* ... campos del formulario ... */}
      <button type="submit">Enviar</button>
    </form>
  );
}

function enviarPost(url, datos) {
  console.log("Enviando POST a", url, "con datos:", datos); // Simplemente para el ejemplo
  // ... c√≥digo real para fetch o axios ...
}
```

**Explicaci√≥n del ejemplo:**
La petici√≥n de anal√≠tica (`/api/analitica`) se env√≠a en un `useEffect` porque queremos registrar que el formulario se ha **mostrado**. La petici√≥n de registro (`/api/registrar`) se env√≠a en `handleSubmit` porque queremos registrar al usuario **cuando hace clic en "Enviar"**. ¬°L√≥gica clara y separada!

#### 3. **Notas o advertencias:**

- **Causa y efecto:** Piensa en **por qu√©** se debe ejecutar la petici√≥n POST. ¬øEs por la interacci√≥n del usuario o porque el componente est√° en pantalla?
- **Consistencia:** Mantener esta distinci√≥n hace que tu c√≥digo sea m√°s predecible y f√°cil de mantener.

## G - Evita cadenas de `useEffect` para c√°lculos dependientes

#### 1. **Definicion:**

Si tienes varios `useEffect` que se activan en cadena, actualizando el estado uno tras otro, ¬°detente! Esto es ineficiente y complicado. Intenta calcular todo lo posible **en un solo lugar**, idealmente en el **manejador de eventos** que inicia la cadena de cambios.

#### 2. **Ejemplo:**

```jsx
function JuegoDeCartas() {
  const [carta, setCarta] = useState(null);
  const [cartasDoradas, setCartasDoradas] = useState(0);
  const [ronda, setRonda] = useState(1);

  // ‚ùå Mal: Cadena de Effects (ineficiente y confuso)
  useEffect(() => {
    if (carta !== null && carta.esDorada) {
      setCartasDoradas((c) => c + 1);
    }
  }, [carta]);

  useEffect(() => {
    if (cartasDoradas > 3) {
      setRonda((r) => r + 1);
      setCartasDoradas(0);
    }
  }, [cartasDoradas]);

  // ‚úÖ Bien: Calcula todo en el manejador de eventos
  function handleColocarCarta(nuevaCarta) {
    setCarta(nuevaCarta);
    if (nuevaCarta.esDorada) {
      let nuevasCartasDoradas = cartasDoradas + 1;
      if (nuevasCartasDoradas > 3) {
        setRonda(ronda + 1);
        nuevasCartasDoradas = 0;
      }
      setCartasDoradas(nuevasCartasDoradas);
    }
  }

  return <>{/* ... JSX ... */}</>;
}
```

**Explicaci√≥n del ejemplo:**
La versi√≥n incorrecta usa una cadena de `useEffect` para actualizar `cartasDoradas` y `ronda`. La versi√≥n correcta calcula **todos** los cambios de estado dentro de `handleColocarCarta`. ¬°Un solo lugar para entender la l√≥gica, m√°s eficiente y menos propenso a errores!

#### 3. **Notas o advertencias:**

- **Rendimiento:** Las cadenas de `useEffect` causan m√∫ltiples renders innecesarios.
- **Fragilidad:** Son dif√≠ciles de mantener y modificar a medida que el c√≥digo crece.
- **Simplicidad:** Centralizar la l√≥gica en manejadores de eventos hace que el flujo de datos sea m√°s claro.

## ==H - Inicializaci√≥n de la aplicaci√≥n: Fuera de `useEffect` (o con cuidado)==

#### 1. **Definicion:**

L√≥gica que solo debe ejecutarse **una vez al inicio de la aplicaci√≥n** (cargar datos iniciales, verificar autenticaci√≥n, etc.) **No** la pongas directamente en un `useEffect` sin m√°s. Puede ejecutarse dos veces en desarrollo (StrictMode).

#### 2. **Ejemplo:**

```jsx
// ‚ùå Mal: Effect simple para inicializaci√≥n (puede ejecutarse dos veces)
function App() {
  useEffect(() => {
    cargarDatosIniciales();
    verificarTokenAutenticacion();
  }, []);

  // ‚úÖ Mejor: Variable global para asegurar ejecuci√≥n √∫nica
  let inicializado = false;
  useEffect(() => {
    if (!inicializado) {
      inicializado = true;
      cargarDatosIniciales();
      verificarTokenAutenticacion();
    }
  }, []);

  // ‚úÖ A√∫n mejor: Inicializaci√≥n fuera del componente (antes del renderizado)
  if (typeof window !== "undefined" && !window.appInicializado) {
    window.appInicializado = true;
    verificarTokenAutenticacion();
    cargarDatosIniciales();
  }

  function App() {
    // ... resto del componente App ...
  }

  return <App />; // Renderiza App despu√©s de la inicializaci√≥n
}

function cargarDatosIniciales() {
  console.log("Cargando datos iniciales...");
}

function verificarTokenAutenticacion() {
  console.log("Verificando token de autenticaci√≥n...");
}
```

**Explicaci√≥n del ejemplo:**
La primera versi√≥n (incorrecta) puede ejecutar la inicializaci√≥n dos veces en desarrollo. La segunda versi√≥n usa una variable `inicializado` para asegurar que solo se ejecute una vez. La tercera versi√≥n (a√∫n mejor) mueve la inicializaci√≥n **fuera** del componente, ejecut√°ndola **antes** de que React empiece a renderizar.

#### 3. **Notas o advertencias:**

- **StrictMode:** React ejecuta los Effects dos veces en desarrollo con StrictMode para detectar errores. Esto puede ser un problema para la inicializaci√≥n.
- **Ejecuci√≥n √∫nica:** Aseg√∫rate de que la l√≥gica de inicializaci√≥n solo se ejecute una vez por carga de la aplicaci√≥n, no por montaje del componente.
- **Inicializaci√≥n temprana:** Si es posible, inicializa fuera de los componentes para evitar problemas con el ciclo de vida de React.

## I - Notificar al componente padre sobre cambios de estado: Handlers, no Effects

#### 1. **Definicion:**

Si un componente hijo necesita informar a su componente padre cuando su estado interno cambia, **no uses `useEffect` para llamar a una funci√≥n `onChange` del padre**. Actualiza el estado del hijo **y** llama a `onChange` **directamente en el manejador de eventos** que causa el cambio de estado.

#### 2. **Ejemplo:**

```jsx
function Toggle({ onChange }) {
  const [estaActivado, setEstaActivado] = useState(false);

  // ‚ùå Mal: onChange en Effect (demasiado tarde, render doble)
  useEffect(() => {
    onChange(estaActivado);
  }, [estaActivado, onChange]);

  // ‚úÖ Bien: onChange en el manejador de eventos (r√°pido, un solo render)
  function actualizarToggle(nuevoEstado) {
    setEstaActivado(nuevoEstado);
    onChange(nuevoEstado); // ¬°Llama a onChange aqu√≠ mismo!
  }

  function handleClick() {
    actualizarToggle(!estaActivado);
  }

  return (
    <button onClick={handleClick}>
      {estaActivado ? "Activado" : "Desactivado"}
    </button>
  );
}

function ComponentePadre() {
  const [togglePadre, setTogglePadre] = useState(false);
  return (
    <div>
      <p>Toggle del padre: {togglePadre ? "Activado" : "Desactivado"}</p>
      <Toggle onChange={setTogglePadre} />
    </div>
  );
}
```

**Explicaci√≥n del ejemplo:**
En la versi√≥n incorrecta, `onChange` se llama en un `useEffect` **despu√©s** de que el estado `estaActivado` se actualiza y el componente se renderiza. La versi√≥n correcta llama a `onChange` **directamente** en `actualizarToggle`, junto con `setEstaActivado`. ¬°Todo ocurre en el mismo evento, m√°s eficiente!

#### 3. **Notas o advertencias:**

- **Flujo de datos:** Mant√©n el flujo de datos claro. Los eventos del hijo informan al padre **directamente** en el momento en que ocurren.
- **Rendimiento:** Evita renders dobles innecesarios llamando a `onChange` en un `useEffect`.

## J - Pasar datos al padre: ¬°El padre los busca y los pasa al hijo!

#### 1. **Definicion:**

En React, los datos fluyen **de padre a hijo (props)**. Si un componente hijo necesita "pasar datos al padre", **no uses `useEffect` para llamar a una funci√≥n del padre y "enviarle" los datos**. En su lugar, haz que el **componente padre busque los datos** y se los **pase al hijo como props**.

#### 2. **Ejemplo:**

```jsx
function ComponentePadre() {
  const datosAPI = useMiAPI(); // ‚úÖ El padre busca los datos

  return <ComponenteHijo datos={datosAPI} />; // ‚úÖ Y se los pasa al hijo como prop
}

function ComponenteHijo({ datos }) {
  // ‚úÖ El hijo recibe los datos como prop
  return (
    <div>
      {datos ? <p>Datos del hijo: {datos.valor}</p> : <p>Cargando datos...</p>}
    </div>
  );
}

function useMiAPI() {
  const [datos, setDatos] = useState(null);
  useEffect(() => {
    // Simulaci√≥n de petici√≥n a la API
    setTimeout(() => {
      setDatos({ valor: "¬°Datos desde la API!" });
    }, 1000);
  }, []);
  return datos;
}
```

**Explicaci√≥n del ejemplo:**
En lugar de que el hijo "env√≠e" datos al padre, el `ComponentePadre` usa `useMiAPI()` para buscar los datos **√©l mismo** y luego se los pasa al `ComponenteHijo` como la prop `datos`. ¬°Flujo de datos unidireccional y claro!

#### 3. **Notas o advertencias:**

- **Flujo unidireccional:** React se basa en el flujo de datos de padre a hijo. Mant√©n este patr√≥n para un c√≥digo m√°s f√°cil de entender y depurar.
- **Inversi√≥n de control:** El padre controla los datos y decide qu√© props pasar a sus hijos.

## ==K - Suscribirse a un "store" externo: `useSyncExternalStore` (¬°mejor que `useEffect`!)==

#### 1. **Definicion:**

Si necesitas que tu componente reaccione a cambios en datos **fuera de React** (API del navegador, librer√≠as externas), **no uses `useEffect` directamente para suscribirte**. React tiene un Hook espec√≠fico para esto: `useSyncExternalStore`. ¬°Es m√°s eficiente y menos propenso a errores!

#### 2. **Ejemplo:**

```jsx
import { useSyncExternalStore } from "react";

function useEstadoOnline() {
  // ‚úÖ Bien: useSyncExternalStore para suscribirse al estado online del navegador
  return useSyncExternalStore(
    subscribe, // Funci√≥n para suscribirse
    () => navigator.onLine, // Funci√≥n para obtener el valor actual (cliente)
    () => true // Funci√≥n para obtener el valor inicial (servidor)
  );
}

function IndicadorChat() {
  const estaOnline = useEstadoOnline();
  return <div>Estado: {estaOnline ? "Online" : "Offline"}</div>;
}

function subscribe(callback) {
  window.addEventListener("online", callback);
  window.addEventListener("offline", callback);
  return () => {
    window.removeEventListener("online", callback);
    window.removeEventListener("offline", callback);
  };
}
```

**Explicaci√≥n del ejemplo:**
`useEstadoOnline` usa `useSyncExternalStore` para suscribirse a los eventos `online` y `offline` del navegador. `useSyncExternalStore` se encarga de la suscripci√≥n y de actualizar el componente de forma eficiente cuando el estado online cambia. ¬°C√≥digo m√°s limpio y optimizado para este caso!

#### 3. **Notas o advertencias:**

- **Datos externos:** `useSyncExternalStore` es ideal para sincronizarte con fuentes de datos que React no controla directamente.
- **Rendimiento:** `useSyncExternalStore` est√° optimizado para este tipo de suscripciones y es m√°s eficiente que hacerlo manualmente con `useEffect`.
- **Abstracci√≥n:** Crea Hooks personalizados como `useEstadoOnline` para reutilizar la l√≥gica de suscripci√≥n en varios componentes.

## ==L - "Fetching" de datos: `useEffect` s√≠, ¬°pero con limpieza y cuidado!==

#### 1. **Definicion:**

Para buscar datos de una API cuando un componente se muestra, **`useEffect` es apropiado**. Pero ¬°ojo! Necesitas manejar las "race conditions" (respuestas fuera de orden) y considerar estrategias m√°s avanzadas como frameworks o Hooks personalizados para un "fetching" m√°s robusto.

#### 2. **Ejemplo:**

```jsx
import { useState, useEffect } from "react";

function ResultadosBusqueda({ query }) {
  const [resultados, setResultados] = useState([]);
  const [pagina, setPagina] = useState(1);

  useEffect(() => {
    let ignorar = false; // üö© Bandera para evitar "race conditions"

    async function buscar() {
      const json = await buscarResultados(query, pagina);
      if (!ignorar) {
        // ‚úÖ Solo actualiza si no se ha "ignorado" esta petici√≥n
        setResultados(json);
      }
    }

    buscar();

    return () => {
      ignorar = true; // üßπ Funci√≥n de limpieza: marca para ignorar peticiones antiguas
    };
  }, [query, pagina]);

  function handleSiguientePaginaClick() {
    setPagina(pagina + 1);
  }

  return (
    <div>
      {/* ... JSX para mostrar resultados y bot√≥n handleSiguientePaginaClick ... */}
    </div>
  );
}

async function buscarResultados(query, pagina) {
  console.log("Buscando resultados para:", query, "pagina:", pagina); // Simulaci√≥n de petici√≥n
  await new Promise((resolve) => setTimeout(resolve, 500)); // Simula latencia de red
  return [{ id: 1, titulo: `Resultado para "${query}" pagina ${pagina}` }]; // Datos simulados
}
```

**Explicaci√≥n del ejemplo:**
Este `useEffect` busca resultados de b√∫squeda cuando `query` o `pagina` cambian. La clave aqu√≠ es la variable `ignorar` y la funci√≥n de limpieza (`return () => { ignorar = true; };`). Esto asegura que solo se procese la **√∫ltima** respuesta de la API y se ignoren las respuestas "viejas" que lleguen despu√©s (evitando "race conditions").

#### 3. **Notas o advertencias:**

- **"Race conditions":** ¬°Son un problema com√∫n al hacer "fetching" en Effects! La funci√≥n de limpieza es esencial para prevenirlas.
- **Frameworks y Hooks:** Para aplicaciones grandes, considera usar frameworks que ofrecen soluciones de "fetching" m√°s completas (cache, SSR, etc.) o crear Hooks personalizados para encapsular la l√≥gica de "fetching".
- **No es un evento:** El "fetching" en `useEffect` no se dispara por un evento del usuario directamente, sino porque el componente **est√° visible y necesita sincronizarse con datos externos**.
