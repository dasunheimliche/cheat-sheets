## A - Proxy Inverso con NGINX

#### 1. **Definición:**

Un **proxy inverso** es como un portero para tus servidores. En lugar de que los clientes (como tu navegador web) hablen directamente con el servidor que tiene la información que buscan, hablan con NGINX. NGINX recibe la petición, se la pasa al servidor correcto (el "back-end"), y cuando el servidor responde, NGINX le devuelve la respuesta al cliente. ¡Todo esto sin que el cliente sepa quién está trabajando realmente!

#### 2. **Ejemplo Básico:**

```nginx
events {

}

http {

    include /etc/nginx/mime.types;

    server {
        listen 80;
        server_name nginx.test;

        location / {
                proxy_pass "https://nginx.org/";
        }
    }
}
```

**Explicación del ejemplo:**

- **`listen 80;`**: NGINX escucha en el puerto 80 (el puerto estándar para HTTP).
- **`server_name nginx.test;`**: Este bloque de configuración se aplica a las peticiones que llegan al nombre de dominio `nginx.test`.
- **`location / { ... }`**: Configuración para todas las peticiones que lleguen a la raíz (`/`) de `nginx.test`.
- **`proxy_pass "https://nginx.org/";`**: ¡Aquí está la magia! Cualquier petición a `nginx.test` se enviará a `https://nginx.org/`. La respuesta de `nginx.org` se devolverá al cliente como si viniera de `nginx.test`.

**Para que este ejemplo funcione en tu máquina:**

1.  Asegúrate de tener NGINX instalado y configurado.
2.  Añade la siguiente línea a tu archivo `hosts` (normalmente en `/etc/hosts` en Linux/macOS o `C:\Windows\System32\drivers\etc\hosts` en Windows):

    ```
    192.168.20.20   nginx.test
    ```

    _(Asegúrate de usar la IP de tu servidor NGINX si es diferente de `192.168.20.20`)_

3.  Visita `http://nginx.test` en tu navegador. ¡Verás la página de `nginx.org`!

#### 3. **Notas o advertencias:**

- El cliente piensa que está hablando con tu servidor (`nginx.test`), pero en realidad está viendo contenido de otro sitio (`nginx.org`).
- Este es un ejemplo muy básico. Los proxies inversos se usan para muchas cosas más útiles, como balanceo de carga, seguridad y servir aplicaciones web.

---

## B - Proxy Inverso para Node.js

#### 1. **Definición:**

Puedes usar NGINX como proxy inverso para aplicaciones Node.js. Esto es genial porque Node.js es muy bueno para la lógica de tu aplicación, pero NGINX es un campeón sirviendo contenido estático y manejando conexiones web de manera eficiente.

#### 2. **Ejemplo:**

**Configuración de NGINX:**

```nginx
events {

}

http {
    listen 80;
    server_name nginx-handbook.test;

    location / {
        proxy_pass http://localhost:3000;
    }
}
```

**Código de Node.js (ejemplo `app.js`):**

```javascript
const express = require("express");
const app = express();
const port = 3000;

app.get("/", (req, res) => {
  res.json({
    status: "success",
    message: "You're reading The NGINX Handbook!",
  });
});

app.listen(port, () => {
  console.log(`Example app listening at http://localhost:${port}`);
});
```

**Explicación del ejemplo:**

1.  **Aplicación Node.js:** Tenemos una aplicación sencilla en Node.js que corre en `http://localhost:3000` y responde con un JSON.
2.  **`proxy_pass http://localhost:3000;`**: NGINX recibe las peticiones en `nginx-handbook.test` y las reenvía a la aplicación Node.js que está corriendo localmente en el puerto 3000.
3.  Cuando la aplicación Node.js responde, NGINX devuelve esa respuesta al cliente.

**Para probarlo:**

1.  Asegúrate de tener Node.js instalado.
2.  Crea un archivo `app.js` con el código de ejemplo y ejecuta `node app.js` o usa `pm2 start app.js` (si tienes PM2 instalado, ver punto siguiente).
3.  **Opcional pero recomendado:** Instala PM2 (`sudo npm install -g pm2`) para gestionar tu aplicación Node.js en segundo plano. Inicia la app con `pm2 start app.js`.
4.  Configura NGINX con el bloque `server` de arriba.
5.  Añade `192.168.20.20   nginx-handbook.test` a tu archivo `hosts`.
6.  Visita `http://nginx-handbook.test` en tu navegador o usa `curl http://nginx-handbook.test`. Deberías ver la respuesta JSON de tu aplicación Node.js.

#### 3. **Notas o advertencias:**

- Este ejemplo muestra cómo NGINX puede servir como "fachada" para tu aplicación Node.js.
- En un escenario real, podrías tener varias aplicaciones Node.js y NGINX las dirigiría a la correcta según el dominio o la ruta.

---

## C - WebSockets con Node.js y Proxy Inverso

#### 1. **Definición:**

Si tu aplicación Node.js usa WebSockets (para comunicación en tiempo real), necesitas una configuración especial en NGINX para que el proxy inverso funcione correctamente con WebSockets.

#### 2. **Ejemplo:**

```nginx
events {

}

http {
    listen 80;
    server_name nginx-handbook.test;

    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
    }
}
```

**Explicación del ejemplo:**

- **`proxy_http_version 1.1;`**: WebSocket requiere HTTP 1.1 o superior. Por defecto, `proxy_pass` usa HTTP 1.0, así que lo cambiamos a 1.1.
- **`proxy_set_header Upgrade $http_upgrade;`**: Le dice a NGINX que pase la cabecera `Upgrade` del cliente al servidor back-end. Esta cabecera es esencial para el "handshake" de WebSocket.
- **`proxy_set_header Connection 'upgrade';`**: Similar a `Upgrade`, esta cabecera `Connection` también es necesaria para establecer la conexión WebSocket.

**En resumen:** Estas directivas aseguran que la "petición de mejora" (upgrade request) de WebSocket del cliente llegue correctamente a tu aplicación Node.js a través de NGINX.

#### 3. **Notas o advertencias:**

- Si tu aplicación usa WebSockets y no configuras esto, ¡no funcionará!
- Estas directivas son muy comunes para aplicaciones Node.js que usan WebSockets detrás de un proxy inverso NGINX.

---

## D - Proxy Inverso para PHP con FastCGI

#### 1. **Definición:**

Para aplicaciones PHP, en lugar de usar HTTP entre NGINX y PHP, se usa **FastCGI** (a través de **PHP-FPM**). FastCGI es un protocolo más eficiente y seguro para comunicar NGINX con procesos PHP.

#### 2. **Ejemplo:**

```nginx
events {

}

http {

      include /etc/nginx/mime.types;

      server {

          listen 80;
          server_name nginx-handbook.test;
          root /srv/nginx-handbook-projects/php-demo;

          index index.php;

          location / {
              try_files $uri $uri/ =404;
          }

          location ~ \.php$ {
              fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;
              fastcgi_param REQUEST_METHOD $request_method;
              fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
      }
   }
}
```

**Explicación del ejemplo:**

- **`root /srv/nginx-handbook-projects/php-demo;`**: Define el directorio raíz donde están los archivos PHP de tu aplicación.
- **`index index.php;`**: Indica que si se pide el directorio raíz, se debe servir `index.php`.
- **`location / { try_files $uri $uri/ =404; }`**: Intenta servir el archivo o directorio que se pide directamente. Si no existe, devuelve un error 404.
- **`location ~ \.php$ { ... }`**: ¡Aquí está la configuración para PHP! Esta sección se aplica a todos los archivos que terminan en `.php`.
  - **`fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;`**: En lugar de `proxy_pass`, usamos `fastcgi_pass` para indicar que vamos a comunicarnos con un servicio FastCGI. `unix:/var/run/php/php7.4-fpm.sock` es la dirección del socket Unix donde escucha PHP-FPM (FastCGI Process Manager).
  - **`fastcgi_param REQUEST_METHOD $request_method;`**: Pasa el método HTTP (GET, POST, etc.) a PHP-FPM.
  - **`fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;`**: Pasa la ruta completa del archivo PHP que se debe ejecutar.

**Para probarlo:**

1.  Asegúrate de tener PHP y PHP-FPM instalados (`sudo apt install php-fpm -y` en sistemas Debian/Ubuntu).
2.  Crea un directorio `/srv/nginx-handbook-projects/php-demo` y pon un archivo `index.php` dentro con este contenido de ejemplo:

    ```php
    <?php
    header('Content-Type: application/json');
    echo json_encode(["status" => "success", "message" => "You're reading The NGINX Handbook!"]);
    ?>
    ```

3.  Configura NGINX con el bloque `server` de arriba.
4.  Añade `192.168.20.20   nginx-handbook.test` a tu archivo `hosts`.
5.  Visita `http://nginx-handbook.test` en tu navegador o usa `curl http://nginx-handbook.test`. Deberías ver la respuesta JSON de tu script PHP.

#### 3. **Notas o advertencias:**

- PHP-FPM es esencial para ejecutar PHP con NGINX de manera eficiente.
- `fastcgi_pass` puede usar un socket Unix (como en el ejemplo) o una dirección IP y puerto (`fastcgi_pass localhost:9000;`). El socket Unix suele ser más seguro y rápido si PHP-FPM y NGINX están en el mismo servidor.

---

## E - Problemas de Permisos con PHP-FPM

#### 1. **Definición:**

A veces, al configurar PHP con FastCGI, puedes encontrarte con errores de "Permission denied". Esto suele ocurrir porque el usuario que ejecuta NGINX no tiene permiso para acceder al socket de PHP-FPM.

#### 2. **Ejemplo de Error y Solución:**

**Error en el log de NGINX (`/var/log/nginx/error.log`):**

```
2021/04/24 17:15:17 [crit] 17691#17691: *21 connect() to unix:/var/run/php/php7.4-fpm.sock failed (13: Permission denied) while connecting to upstream, client: 192.168.20.20, server: nginx-handbook.test, request: "GET / HTTP/1.1", upstream: "fastcgi://unix:/var/run/php/php7.4-fpm.sock:", host: "nginx-handbook.test"
```

**Solución: Cambiar el usuario de NGINX:**

Añade la directiva `user www-data;` al principio de tu archivo de configuración de NGINX (fuera de los bloques `http`, `server`, etc.):

```nginx
user www-data;

events {

}

http {
    # ... el resto de tu configuración ...
}
```

**Explicación:**

1.  **Usuario de NGINX:** Por defecto, NGINX puede ejecutarse con un usuario como `nobody` o `nginx`.
2.  **Usuario de PHP-FPM:** PHP-FPM suele ejecutarse con el usuario `www-data`.
3.  **Problema de permisos:** Si NGINX se ejecuta con un usuario diferente a `www-data`, podría no tener permiso para conectarse al socket de PHP-FPM, que pertenece a `www-data`.
4.  **Solución `user www-data;`**: Al poner `user www-data;` en la configuración de NGINX, le decimos a NGINX que ejecute sus procesos worker (los que realmente hacen el trabajo) con el usuario `www-data`. Ahora, NGINX y PHP-FPM se ejecutan con el mismo usuario (o al menos NGINX tiene los mismos permisos), y el problema de "Permission denied" se soluciona.

**Para verificar los usuarios:**

- **Procesos de NGINX:** `ps aux | grep nginx`
- **Procesos de PHP-FPM:** `ps aux | grep php-fpm`

#### 3. **Notas o advertencias:**

- Verificar los logs de error de NGINX es crucial para diagnosticar problemas.
- Asegurarte de que los usuarios de NGINX y PHP-FPM estén correctamente configurados es importante para la seguridad y el funcionamiento.

---

## F - El archivo `fastcgi_params`

#### 1. **Definición:**

Para que FastCGI funcione correctamente con PHP, NGINX necesita pasarle mucha información (parámetros) a PHP-FPM. En lugar de escribir todos estos parámetros manualmente, NGINX proporciona un archivo de configuración predefinido llamado `fastcgi_params` que contiene los parámetros más comunes.

#### 2. **Ejemplo:**

**Contenido de `/etc/nginx/fastcgi_params` (ejemplo parcial):**

```
fastcgi_param  QUERY_STRING       $query_string;
fastcgi_param  REQUEST_METHOD     $request_method;
fastcgi_param  CONTENT_TYPE       $content_type;
fastcgi_param  CONTENT_LENGTH     $content_length;
fastcgi_param  SCRIPT_NAME        $fastcgi_script_name;
# ... más parámetros ...
```

**Cómo usar `fastcgi_params` en tu configuración de NGINX:**

En lugar de escribir `fastcgi_param REQUEST_METHOD ...`, etc., simplemente incluye el archivo `fastcgi_params` en tu bloque `location ~ \.php$`:

```nginx
location ~ \.php$ {
    fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;
    fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
    include /etc/nginx/fastcgi_params; # ¡Incluimos el archivo aquí!
}
```

**Explicación:**

- **`include /etc/nginx/fastcgi_params;`**: Esta directiva le dice a NGINX que incluya el contenido del archivo `/etc/nginx/fastcgi_params` en este punto de la configuración.
- **Parámetros comunes:** El archivo `fastcgi_params` ya define muchos parámetros importantes como `QUERY_STRING`, `REQUEST_METHOD`, `SCRIPT_NAME`, etc. ¡Te ahorra tener que definirlos uno por uno!

**Configuración final recomendada para PHP:**

```nginx
user www-data;

events {

}

http {

      include /etc/nginx/mime.types;

      server {

          listen 80;
          server_name nginx-handbook.test;
          root /srv/nginx-handbook-projects/php-demo;

          index index.php;

          location / {
              try_files $uri $uri/ =404;
          }

          location ~ \.php$ {
              fastcgi_pass unix:/var/run/php/php7.4-fpm.sock;
              fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
              include /etc/nginx/fastcgi_params; # Usamos el archivo predefinido
      }
   }
}
```

#### 3. **Notas o advertencias:**

- Usar `include /etc/nginx/fastcgi_params;` es la forma **recomendada** de configurar FastCGI para PHP en NGINX.
- A veces puedes ver ejemplos que usan `fastcgi.conf` en lugar de `fastcgi_params`. Es mejor usar `fastcgi_params` porque `fastcgi.conf` puede tener comportamientos inconsistentes.
- Puedes revisar el contenido de `/etc/nginx/fastcgi_params` para ver todos los parámetros que se están pasando a PHP-FPM.
