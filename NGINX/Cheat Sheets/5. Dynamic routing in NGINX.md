## A - Location Context en NGINX

#### 1. **Definición:**

El contexto `location` en NGINX define cómo el servidor responde a las peticiones de diferentes URIs (Uniform Resource Identifiers, o sea, las direcciones web). Piensa en `location` como una "ruta" o "dirección" dentro de tu sitio web que le dice a NGINX qué hacer cuando alguien visita esa dirección. Puedes tener múltiples bloques `location` dentro de un bloque `server` para manejar diferentes partes de tu sitio web de manera distinta.

#### 2. **Ejemplo:**

```nginx
location /agatha {
    return 200 "Miss Marple.\nHercule Poirot.\n";
}
```

**Explicación del ejemplo:**
Este ejemplo define un bloque `location` para la ruta `/agatha`. Cuando alguien visita `http://nginx-handbook.test/agatha` (o cualquier ruta que comience con `/agatha`), NGINX responderá con un código 200 (OK) y el texto "Miss Marple.\nHercule Poirot.\n".

#### 3. **Notas o advertencias:**

- El contexto `location` se usa dentro de los bloques `server` en tu configuración de NGINX.
- Puedes tener varios bloques `location` para diferentes rutas en tu sitio.

---

## B - Tipos de Coincidencia de `location`

NGINX ofrece diferentes formas de hacer coincidir la URI de la petición con un bloque `location`.

#### 1. **Definición:**

Existen cuatro tipos principales de coincidencias para `location`:

- **Coincidencia de prefijo (prefix match):** Coincide con URIs que _comienzan_ con la ruta especificada. Es el tipo por defecto.
- **Coincidencia exacta (exact match):** Coincide solo con la URI que es _exactamente igual_ a la ruta especificada.
- **Coincidencia por expresión regular (regex match):** Coincide con URIs que cumplen con una _expresión regular_ especificada.
- **Coincidencia de prefijo preferencial (preferential prefix match):** Similar a la coincidencia de prefijo, pero tiene _mayor prioridad_ que las coincidencias por expresión regular.

#### 2. **Ejemplo:**

**a) Coincidencia de prefijo (por defecto):**

```nginx
location /agatha { # Coincidencia de prefijo
    return 200 "Coincidencia de prefijo.\n";
}
```

Visitar `/agatha`, `/agatha-christie`, `/agatha/libro` activará este `location`.

**b) Coincidencia exacta:**

```nginx
location = /agatha { # Coincidencia exacta
    return 200 "Coincidencia exacta.\n";
}
```

Solo visitar `/agatha` activará este `location`. `/agatha/` o `/agatha-algo` no lo activarán.

**c) Coincidencia por expresión regular (sensible a mayúsculas):**

```nginx
location ~ /agatha[0-9] { # Regex sensible a mayúsculas
    return 200 "Regex sensible a mayúsculas.\n";
}
```

`/agatha0`, `/agatha9` activarán este `location`. `/agatha`, `/agathaA`, `/Agatha8` no lo activarán.

**d) Coincidencia por expresión regular (insensible a mayúsculas):**

```nginx
location ~* /agatha[0-9] { # Regex insensible a mayúsculas
    return 200 "Regex insensible a mayúsculas.\n";
}
```

`/agatha0`, `/agatha9`, `/Agatha8`, `/aGatHa5` activarán este `location`. `/agatha`, `/agathaA` no lo activarán.

**e) Coincidencia de prefijo preferencial:**

```nginx
location ^~ /Agatha8 { # Prefijo preferencial
    return 200 "Prefijo preferencial.\n";
}

location ~* /agatha[0-9] { # Regex insensible a mayúsculas
    return 200 "Regex insensible a mayúsculas.\n";
}
```

Visitar `/Agatha8` activará el `location` de prefijo preferencial, **incluso si el regex también coincide**, porque el prefijo preferencial tiene mayor prioridad en este caso.

#### 3. **Notas o advertencias:**

- **Prioridad de coincidencias (de mayor a menor):** Exacta (`=`), Prefijo preferencial (`^~`), Regex (`~` o `~*`), Prefijo (sin modificador).
- Las coincidencias por expresión regular (`~` y `~*`) tienen mayor prioridad que las coincidencias de prefijo normales.
- Usa `=` para coincidencias exactas cuando necesites que una ruta sea precisa.
- Usa `~` o `~*` para patrones más complejos con expresiones regulares.
- Usa `^~` para dar prioridad a un prefijo sobre un regex si es necesario.

---

## C - Variables en NGINX

#### 1. **Definición:**

Las variables en NGINX son como variables en programación: contenedores para guardar información que puedes usar en tu configuración. Puedes definir tus propias variables con la directiva `set`, y NGINX también tiene variables "integradas" que te dan acceso a información sobre la petición del cliente, el servidor, etc.

#### 2. **Ejemplo:**

**a) Definir una variable:**

```nginx
set $nombre_usuario "Farhan";
set $edad_usuario 25;
set $es_admin true;
```

**b) Usar variables integradas:**

```nginx
return 200 "Host - $host\nURI - $uri\nArgs - $args\n";
```

**Output al visitar `http://nginx-handbook.test/user?name=Farhan`:**

```text
Host - nginx-handbook.test
URI - /user
Args - name=Farhan
```

**c) Acceder a parámetros de la query string:**

```nginx
set $nombre $arg_name; # Obtiene el valor del parámetro 'name' de la query string

return 200 "Nombre - $nombre\n";
```

**Output al visitar `http://nginx-handbook.test?name=Farhan`:**

```text
Nombre - Farhan
```

**Explicación del ejemplo:**

- En **a)**, usamos `set` para crear variables `$nombre_usuario`, `$edad_usuario` y `$es_admin` con diferentes tipos de valores (string, entero, booleano).
- En **b)**, usamos variables integradas:
  - `$host`: El nombre del host del servidor (ej: `nginx-handbook.test`).
  - `$uri`: La URI solicitada (ej: `/user`).
  - `$args`: Todos los argumentos de la query string (ej: `name=Farhan`).
- En **c)**, `$arg_name` (o en general `$arg_<nombre_del_parametro>`) accede al valor de un parámetro específico de la query string. Si la query string es `?name=Farhan`, `$arg_name` contendrá "Farhan".

#### 3. **Notas o advertencias:**

- Las variables en NGINX siempre comienzan con el signo `$`.
- Puedes usar `set` para crear tus propias variables dentro de los bloques `http`, `server`, o `location`.
- NGINX tiene muchas variables integradas que te dan información útil sobre las peticiones y el servidor. Puedes encontrar una lista completa en la [documentación oficial de NGINX](https://nginx.org/en/docs/varindex.html).
- Las variables son muy útiles para la configuración dinámica y flexible de NGINX.

---

## D - Redirecciones (Redirects) en NGINX

#### 1. **Definición:**

Una redirección en NGINX es como decirle al navegador del usuario: "La página que buscas ya no está aquí, ahora está en otra dirección". Cuando configuras una redirección, el servidor envía una respuesta especial (código 3xx) que indica al navegador que debe ir a una nueva URL para encontrar el recurso. El navegador automáticamente hace una nueva petición a la nueva URL.

#### 2. **Ejemplo:**

```nginx
location = /index_page {
    return 307 /index.html;
}

location = /about_page {
    return 307 /about.html;
}
```

**Output al visitar `http://nginx-handbook.test/about_page`:**

```text
HTTP/1.1 307 Temporary Redirect
Server: nginx/1.18.0 (Ubuntu)
Date: Thu, 22 Apr 2021 18:02:04 GMT
Content-Type: text/html
Content-Length: 180
Location: http://nginx-handbook.test/about.html
Connection: keep-alive
```

**Explicación del ejemplo:**

- Cuando se visita `/index_page`, NGINX responde con un código de estado 307 (Temporary Redirect) y en la cabecera `Location` indica `/index.html`. El navegador automáticamente redirige a `/index.html`.
- Lo mismo ocurre para `/about_page`, redirigiendo a `/about.html`.
- `307` indica una redirección temporal, lo que significa que la página `/index_page` o `/about_page` podría volver a estar disponible en el futuro. También existen otros códigos de redirección como `301` (Permanent Redirect) para redirecciones permanentes.

#### 3. **Notas o advertencias:**

- Las redirecciones son visibles para el usuario: la URL en la barra del navegador cambia a la nueva dirección.
- Usa `return <código_de_redirección> <nueva_URL>;` para configurar redirecciones.
- Códigos de redirección comunes:
  - `301`: Redirección permanente (usar para URLs que han cambiado definitivamente).
  - `302`: Redirección temporal (sin caché, menos común).
  - `307`: Redirección temporal (mantiene el método HTTP original, recomendado para la mayoría de los casos temporales).

---

## E - Reescribir URLs (Rewrites) en NGINX

#### 1. **Definición:**

Una reescritura (rewrite) en NGINX cambia la URI de la petición _internamente_ en el servidor, sin que el navegador del usuario se dé cuenta. NGINX procesa la petición como si la URI original hubiera sido la URI reescrita. Es como si internamente "renombraras" la URL antes de que NGINX busque el contenido.

#### 2. **Ejemplo:**

```nginx
rewrite /index_page /index.html;
rewrite /about_page /about.html;
```

**Output al visitar `http://nginx-handbook.test/about_page`:**

```text
HTTP/1.1 200 OK
Server: nginx/1.18.0 (Ubuntu)
Date: Thu, 22 Apr 2021 18:09:31 GMT
Content-Type: text/html
Content-Length: 960
...
```

**Imagen ilustrativa (la URL en el navegador sigue siendo `/about_page` pero se muestra el contenido de `about.html`):**

![Image](https://www.freecodecamp.org/news/content/images/2021/04/rewrite.png)

**Explicación del ejemplo:**

- Cuando se visita `/index_page`, NGINX _internamente_ la reescribe a `/index.html`. El servidor busca y sirve el archivo `index.html` como si el usuario hubiera pedido `/index.html` directamente.
- Lo mismo ocurre para `/about_page`, reescrita internamente a `/about.html`.
- El navegador recibe una respuesta 200 (OK) con el contenido de `about.html`, pero la URL en la barra del navegador _permanece_ como `/about_page`.

#### 3. **Notas o advertencias:**

- Las reescrituras son _internas_ al servidor y no cambian la URL que ve el usuario en el navegador.
- Usa la directiva `rewrite <URI_original> <URI_reescrita>;` para configurar reescrituras.
- Las reescrituras son más "costosas" que las redirecciones porque NGINX tiene que volver a evaluar la configuración del `server` después de una reescritura.
- Las reescrituras son útiles para:
  - URLs "amigables" (ej: `/productos/123` reescrito a `/index.php?producto_id=123`).
  - Migración de URLs antiguas sin romper enlaces.
  - Organización interna de la estructura de tu sitio web.

---

## F - Directiva `try_files` en NGINX

#### 1. **Definición:**

La directiva `try_files` le dice a NGINX que intente servir archivos en un orden específico. Si el primer archivo no existe, intenta el segundo, y así sucesivamente. Si ninguno de los archivos existe, puede realizar una acción de "fallback", como mostrar un error 404 o redirigir a otra ubicación.

#### 2. **Ejemplo:**

**a) Intentar servir un archivo específico o mostrar error 404:**

```nginx
try_files /the-nginx-handbook.jpg /not_found;

location /not_found {
    return 404 "sadly, you've hit a brick wall buddy!\n";
}
```

Si `/the-nginx-handbook.jpg` existe en el directorio `root`, se sirve ese archivo. Si no existe, NGINX procesa el bloque `location /not_found` y devuelve un error 404 personalizado.

**b) Intentar servir el archivo solicitado (`$uri`) o mostrar error 404:**

```nginx
try_files $uri /not_found;

location /not_found {
    return 404 "sadly, you've hit a brick wall buddy!\n";
}
```

Si el archivo correspondiente a la URI solicitada (`$uri`) existe, se sirve ese archivo. Si no, se muestra el error 404 personalizado.

**c) Intentar servir el archivo solicitado o el `index.html` de un directorio o mostrar error 404:**

```nginx
try_files $uri $uri/ /not_found;

location /not_found {
    return 404 "sadly, you've hit a brick wall buddy!\n";
}
```

- Primero, intenta servir el archivo directamente (`$uri`).
- Si no existe, intenta servir el `index.html` dentro del directorio correspondiente a la URI (`$uri/`). NGINX busca automáticamente `index.html` dentro de un directorio si se solicita el directorio.
- Si ninguno de los dos existe, se muestra el error 404 personalizado.

**Imagen ilustrativa del ejemplo c) al visitar `http://nginx-handbook.test/` (se muestra `index.html`):**

![Image](https://www.freecodecamp.org/news/content/images/2021/04/image-95.png)

**Explicación del ejemplo:**

- `try_files` toma una lista de rutas de archivos (o ubicaciones) y las prueba en orden.
- El último elemento en la lista de `try_files` puede ser:
  - Una ruta de archivo: Si ninguno de los archivos anteriores existe, NGINX intenta servir este último archivo.
  - Una ubicación interna (que comienza con `@`): Si ninguno de los archivos anteriores existe, NGINX redirige internamente a esta ubicación para su procesamiento.
  - Una ubicación normal (como `/not_found` en los ejemplos): Si ninguno de los archivos anteriores existe, NGINX procesa este bloque `location`.

#### 3. **Notas o advertencias:**

- `try_files` es muy versátil para manejar diferentes escenarios de servicio de archivos y fallback.
- Es común usar `$uri` en `try_files` para intentar servir el archivo solicitado directamente.
- Usar `$uri $uri/` es una forma común de servir `index.html` cuando se visita la raíz de un directorio.
- El último parámetro de `try_files` es crucial para definir qué sucede si ninguno de los archivos anteriores se encuentra.
