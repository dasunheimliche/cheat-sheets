## A - Primer Archivo de Configuración NGINX

#### 1. **Definición:**

Para empezar a configurar tu servidor web, necesitas crear y editar el archivo `nginx.conf`. Este archivo es el corazón de la configuración de NGINX, donde le dirás cómo debe comportarse tu servidor.

#### 2. **Ejemplo:**

Primero, abre el archivo `nginx.conf` con el editor `nano`:

```bash
sudo nano /etc/nginx/nginx.conf
```

Luego, reemplaza el contenido de este archivo con lo siguiente:

```nginx
events {

}

http {

    server {

        listen 80;
        server_name nginx-handbook.test;

        return 200 "Bonjour, mon ami!\n";
    }

}
```

**Explicación del ejemplo:**

- **`events { ... }`**: Este bloque está reservado para configuraciones generales de manejo de eventos en NGINX. Por ahora, lo dejaremos vacío.
- **`http { ... }`**: Aquí dentro configuras todo lo relacionado con el protocolo HTTP, como servidores web, manejo de peticiones, etc.
- **`server { ... }`**: Define un servidor virtual, es decir, un sitio web específico dentro de tu servidor NGINX.
  - **`listen 80;`**: Indica que este servidor virtual escuchará las peticiones en el puerto 80, el puerto estándar para HTTP.
  - **`server_name nginx-handbook.test;`**: Define el nombre de dominio o nombre de servidor para este sitio web. En este caso, `nginx-handbook.test`.
  - **`return 200 "Bonjour, mon ami!\n";`**: Esta directiva le dice al servidor que responda a cualquier petición con un código de estado HTTP 200 (OK) y el mensaje "Bonjour, mon ami!".

#### 3. **Notas o advertencias:**

- Estamos usando `nano` como editor de texto porque es común en servidores. ¡Aprovecha para practicar con él! Si necesitas ayuda, consulta este [cheat sheet](https://www.nano-editor.org/dist/latest/cheatsheet.html).
- No te preocupes si no entiendes todo ahora. ¡Lo explicaremos paso a paso!

---

## B - Validar y Recargar la Configuración

#### 1. **Definición:**

Después de crear o modificar tu archivo de configuración, es crucial **validar** que no haya errores de sintaxis y luego **recargar** la configuración para que NGINX use los nuevos cambios.

#### 2. **Ejemplo:**

**Validar la configuración:**

```bash
sudo nginx -t
```

Si todo está bien, verás algo como esto:

```
# nginx: the configuration file /etc/nginx/nginx.conf syntax is ok
# nginx: configuration file /etc/nginx/nginx.conf test is successful
```

Si hay errores, el comando te indicará dónde están, incluyendo el número de línea.

**Recargar la configuración:**

Tienes dos opciones para recargar la configuración:

1.  **Reiniciar NGINX (más drástico):**

    ```bash
    sudo systemctl restart nginx
    ```

2.  **Recargar NGINX (más suave y preferido):**

    ```bash
    sudo nginx -s reload
    ```

El comando `nginx -s reload` envía una señal a NGINX para que recargue la configuración sin interrumpir las conexiones existentes. ¡Es la opción más rápida y limpia!

#### 3. **Notas o advertencias:**

- Siempre valida tu configuración con `nginx -t` antes de recargar. ¡Te ahorrará muchos dolores de cabeza!
- Usa `nginx -s reload` para recargar la configuración en la mayoría de los casos. Reiniciar NGINX (`systemctl restart nginx`) es útil si algo va muy mal o después de actualizar NGINX.
- La opción `-s` en `nginx -s` se usa para enviar **señales** a NGINX. Otras señales útiles son `stop`, `quit` y `reopen`.

---

## C - Directivas y Contextos en NGINX

#### 1. **Definición:**

Los archivos de configuración de NGINX se basan en **directivas** y **contextos**. Piensa en ellos como las instrucciones y las secciones de un programa.

- **Directiva:** Es una instrucción individual que le dice a NGINX qué hacer. Hay dos tipos:

  - **Directivas Simples:** Tienen un nombre y parámetros, y terminan con punto y coma (`;`). Ejemplos: `listen 80;`, `return 200 "OK";`.
  - **Directivas de Bloque:** Son como las simples, pero en lugar de punto y coma, terminan con llaves `{}` que encierran más instrucciones. Estas directivas de bloque definen **contextos**.

- **Contexto:** Es un bloque de configuración que agrupa directivas relacionadas. Piensa en ellos como "ámbitos" o "secciones" en otros lenguajes de programación. Hay cuatro contextos principales:

  1.  **`events { ... }`**: Configuración global para el manejo de eventos. Solo puede haber uno.
  2.  **`http { ... }`**: Configuración para HTTP y HTTPS. Solo puede haber uno.
  3.  **`server { ... }`**: Define servidores virtuales (sitios web). Puede haber varios dentro de `http`.
  4.  **`main`**: Es el contexto principal, el archivo de configuración en sí. Todo lo que está fuera de `events`, `http` y `server` pertenece al contexto `main`.

#### 2. **Ejemplo:**

En nuestra configuración básica:

```nginx
events {

}

http {

    server {

        listen 80;
        server_name nginx-handbook.test;

        return 200 "Bonjour, mon ami!\n";
    }

}
```

- `events`, `http` y `server` son **contextos** (directivas de bloque).
- `listen`, `server_name` y `return` son **directivas simples**.

#### 3. **Notas o advertencias:**

- Los contextos en NGINX son como "cajas dentro de cajas". `server` está dentro de `http`, que a su vez está en el contexto principal (`main`).
- Hay una especie de "herencia" entre contextos. Las configuraciones en contextos "superiores" pueden afectar a los "inferiores".
- Si quieres ver todas las directivas disponibles, consulta el [índice de directivas](https://nginx.org/en/docs/dirindex.html) en la documentación oficial de NGINX.

---

## D - Directiva `listen`

#### 1. **Definición:**

La directiva `listen` se usa dentro del contexto `server { ... }` para especificar en qué **puerto** y **dirección IP** (opcional) escuchará un servidor virtual las peticiones.

#### 2. **Ejemplo:**

```nginx
http {
    server {
        listen 80; # Escucha en el puerto 80 (HTTP estándar)
        server_name nginx-handbook.test;
        return 200 "Puerto 80!\n";
    }

    server {
        listen 8080; # Escucha en el puerto 8080
        server_name nginx-handbook.test;
        return 200 "Puerto 8080!\n";
    }
}
```

**Explicación del ejemplo:**

- Tenemos dos bloques `server`.
- El primer `server` escucha en el puerto `80`. Si accedes a `http://nginx-handbook.test:80` (o simplemente `http://nginx-handbook.test`, ya que el puerto 80 es el predeterminado para HTTP), recibirás "Puerto 80!".
- El segundo `server` escucha en el puerto `8080`. Si accedes a `http://nginx-handbook.test:8080`, recibirás "Puerto 8080!".

```bash
curl nginx-handbook.test:80
# Puerto 80!

curl nginx-handbook.test:8080
# Puerto 8080!
```

#### 3. **Notas o advertencias:**

- Puedes tener varios bloques `server` escuchando en diferentes puertos en el mismo servidor NGINX.
- Si no especificas la dirección IP, `listen` escucha en todas las interfaces de red disponibles en ese puerto.
- `listen` es una de las formas en que NGINX decide qué bloque `server` debe procesar una petición entrante.

---

## E - Directiva `server_name`

#### 1. **Definición:**

La directiva `server_name` también se usa dentro de `server { ... }` y define los **nombres de dominio** o **nombres de host** para los que este servidor virtual responderá. Permite configurar **hosts virtuales**, es decir, varios sitios web en el mismo servidor con la misma dirección IP, pero con diferentes nombres de dominio.

#### 2. **Ejemplo:**

```nginx
http {
    server {
        listen 80;
        server_name library.test; # Nombre de dominio: library.test
        return 200 "¡Tu biblioteca local!\n";
    }

    server {
        listen 80;
        server_name librarian.library.test; # Nombre de dominio: librarian.library.test
        return 200 "¡Bienvenido, bibliotecario!\n";
    }
}
```

**Explicación del ejemplo:**

- Ambos bloques `server` escuchan en el puerto 80, pero tienen diferentes `server_name`.
- Si accedes a `http://library.test`, NGINX usará el primer bloque `server` y responderá con "¡Tu biblioteca local!".
- Si accedes a `http://librarian.library.test`, NGINX usará el segundo bloque `server` y responderá con "¡Bienvenido, bibliotecario!".

```bash
curl http://library.test
# ¡Tu biblioteca local!

curl http://librarian.library.test
# ¡Bienvenido, bibliotecario!
```

Para que esto funcione en tu máquina local, necesitas añadir estos nombres de dominio a tu archivo `hosts`:

```
192.168.20.20   library.test
192.168.20.20   librarian.library.test
```

(Reemplaza `192.168.20.20` con la IP de tu servidor si es diferente).

#### 3. **Notas o advertencias:**

- `server_name` puede aceptar varios nombres de dominio separados por espacios. También soporta comodines y expresiones regulares para nombres de dominio más complejos.
- NGINX usa `server_name` (junto con `listen`) para determinar qué bloque `server` procesa una petición. Si el nombre de dominio en la petición coincide con un `server_name`, ese bloque `server` será el elegido.
- ¡Los hosts virtuales son una forma genial de alojar múltiples sitios web en un solo servidor!

---

## F - Directiva `return`

#### 1. **Definición:**

La directiva `return` dentro de `server { ... }` (o en otros contextos) se usa para hacer que NGINX envíe una **respuesta HTTP** específica al cliente. Es útil para respuestas rápidas, redirecciones o mensajes de prueba.

#### 2. **Ejemplo:**

Ya hemos visto ejemplos con `return`:

```nginx
return 200 "Bonjour, mon ami!\n"; # Responde con código 200 y mensaje
```

`return` puede usarse para diferentes códigos de estado:

```nginx
return 404 "Página no encontrada :(\n"; # Responde con código 404 (Not Found)
return 301 https://www.ejemplo.com; # Redirección permanente (código 301) a otra URL
```

#### 3. **Notas o advertencias:**

- `return` detiene el procesamiento de la petición inmediatamente y envía la respuesta.
- Es muy útil para pruebas rápidas y respuestas sencillas sin necesidad de configurar un servidor web completo.
- Los códigos de estado HTTP como 200, 404, 301, etc., son importantes para indicar el resultado de la petición al cliente (navegador, etc.).

---

## G - Servir Contenido Estático con NGINX

#### 1. **Definición:**

En lugar de solo responder con texto plano, NGINX es genial para servir **archivos estáticos** como HTML, CSS, imágenes, JavaScript, etc. Para esto, necesitamos decirle a NGINX dónde están esos archivos.

#### 2. **Ejemplo:**

Primero, vamos a guardar nuestros archivos estáticos en el directorio `/srv`. Es una convención para datos específicos del sitio.

Clona el repositorio de ejemplo en `/srv`:

```bash
cd /srv
sudo git clone https://github.com/fhsinchy/nginx-handbook-projects.git
```

Dentro de `nginx-handbook-projects/static-demo` encontrarás archivos HTML, CSS e imágenes.

Ahora, actualiza tu configuración de NGINX así:

```nginx
events {

}

http {

    server {

        listen 80;
        server_name nginx-handbook.test;

        root /srv/nginx-handbook-projects/static-demo; # Define el directorio raíz
    }

}
```

**Explicación del ejemplo:**

- Hemos reemplazado `return` con la directiva `root`.
- **`root /srv/nginx-handbook-projects/static-demo;`**: Esta línea le dice a NGINX que el directorio raíz para este sitio web es `/srv/nginx-handbook-projects/static-demo`. Cuando alguien pida un archivo (ej. `http://nginx-handbook.test/index.html`), NGINX buscará ese archivo dentro de este directorio raíz.
- NGINX es lo suficientemente inteligente para servir `index.html` automáticamente si solo se pide el directorio raíz (`http://nginx-handbook.test/`).

#### 3. **Notas o advertencias:**

- El directorio `/srv` es un buen lugar para guardar los archivos de tu sitio web en sistemas Linux.
- La directiva `root` es fundamental para servir contenido estático. ¡Sin ella, NGINX no sabrá dónde buscar los archivos!

---

## H - Manejo de Tipos de Archivos Estáticos

#### 1. **Definición:**

Cuando servimos archivos estáticos, es importante que NGINX envíe la cabecera HTTP `Content-Type` correcta para que el navegador sepa cómo interpretar el archivo (ej., HTML, CSS, imagen, etc.). NGINX necesita saber qué tipo de archivo es cada uno.

#### 2. **Ejemplo:**

Si visitas `http://nginx-handbook.test` con la configuración anterior, verás una página HTML, pero puede que se vea "rota" sin estilos CSS. Esto es porque NGINX por defecto no sabe que los archivos `.css` son hojas de estilo CSS.

Si inspeccionamos la respuesta para el archivo CSS (`http://nginx-handbook.test/mini.min.css`) con `curl -I`:

```bash
curl -I http://nginx-handbook.test/mini.min.css
```

Veremos que `Content-Type` es `text/plain` en lugar de `text/css`. ¡NGINX está sirviendo el CSS como texto plano!

Para solucionar esto, podemos usar el contexto `types { ... }` dentro de `http { ... }`:

```nginx
events {

}

http {

    types {
        text/html html; # Archivos .html son de tipo text/html
        text/css css;   # Archivos .css son de tipo text/css
    }

    server {

        listen 80;
        server_name nginx-handbook.test;

        root /srv/nginx-handbook-projects/static-demo;
    }
}
```

**Explicación del ejemplo:**

- Hemos añadido el contexto `types { ... }` dentro de `http { ... }`.
- **`text/html html;`**: Le decimos a NGINX que los archivos con extensión `.html` deben ser servidos con `Content-Type: text/html`.
- **`text/css css;`**: Igualmente, los archivos `.css` deben ser `Content-Type: text/css`.

Después de recargar la configuración, si vuelves a pedir el CSS con `curl -I`, verás que ahora el `Content-Type` es correcto: `text/css`. Y la página web debería verse bien en el navegador.

#### 3. **Notas o advertencias:**

- Si defines un contexto `types { ... }`, NGINX solo reconocerá los tipos de archivo que definas ahí. ¡Si olvidas el `text/html html;`, incluso los archivos HTML se servirán como texto plano!
- Configurar los tipos de archivo correctamente es crucial para que los navegadores interpreten los archivos de tu sitio web de la manera adecuada.

---

## I - Incluir Archivos de Configuración Parciales

#### 1. **Definición:**

Para proyectos grandes, definir todos los tipos de archivo en `types { ... }` puede ser largo y complicado. NGINX permite **incluir** archivos de configuración parciales para organizar mejor la configuración y reutilizarla.

#### 2. **Ejemplo:**

NGINX ya viene con un archivo llamado `mime.types` en `/etc/nginx/` que contiene una lista muy larga de tipos de archivo comunes. ¡Podemos incluir este archivo en nuestra configuración!

Reemplaza el contexto `types { ... }` con la directiva `include`:

```nginx
events {

}

http {

    include /etc/nginx/mime.types; # Incluye el archivo mime.types

    server {

        listen 80;
        server_name nginx-handbook.test;

        root /srv/nginx-handbook-projects/static-demo;
    }

}
```

**Explicación del ejemplo:**

- **`include /etc/nginx/mime.types;`**: Esta directiva le dice a NGINX que incluya el contenido del archivo `/etc/nginx/mime.types` en este punto de la configuración. Es como si copiaras y pegaras todo el contenido de `mime.types` dentro de tu archivo `nginx.conf`.

Ahora, NGINX usará la lista de tipos de archivo definida en `mime.types`, que es mucho más completa que la que definimos manualmente.

Si vuelves a probar con `curl -I http://nginx-handbook.test/mini.min.css`, verás que sigue funcionando correctamente y el `Content-Type` es `text/css`.

#### 3. **Notas o advertencias:**

- La directiva `include` es muy útil para modularizar la configuración de NGINX. Puedes dividir la configuración en varios archivos más pequeños y luego incluirlos en el archivo principal.
- NGINX usa `include` para organizar su propia configuración por defecto, como veremos más adelante. ¡Es una buena práctica usarla también en tus configuraciones!
