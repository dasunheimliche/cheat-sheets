## A - Server-Side Rendering (SSR)

**Definición:** Es la técnica de renderizar componentes de Vue en el servidor para generar HTML que se envía al navegador. Esto mejora la velocidad de carga inicial y el SEO, además de permitir usar el mismo lenguaje (Javascript) tanto en el back como el front. Imagina que preparamos toda la pagina en el restaurante (back-end) antes de servirla al comensal(front).

**Ejemplo:** Un sitio web donde la primera carga es HTML desde el servidor en lugar de JavaScript puro del navegador. Esto hace que el contenido se muestre al usuario instantaneamente (no muestra una página vacía). El servidor pinta inicialmente todo para el usuario de manera que no dependa en primera instancia del código Javascript de front end.

```html
// Ejemplo Conceptual
<div id="root">
  <h1>Este es mi title con SSR</h1>
  <div class="productCard">
    <p>Un prod</p>
    <span> $12 </span>
  </div>
</div>
```

**Descripción del ejemplo:** En un sistema SSR el servidor envia una respuesta de un `string html` pintado y listo para renderizar en el navegador del usuario, a diferencia de otros métodos de render en donde solo retorna el `index.html` y toda la pagina depende del JS de `front`.

## B - Isomorphic / Universal App

**Definición:** Aplicación cuyo código principal corre tanto en el servidor como en el cliente. Un "camaleón" que puede vivir en ambos entornos compartiendo logica.

**Ejemplo:** El componente `Button.vue` es usado tanto en el servidor al crear un string HTML como luego al pasar esa data al cliente y reactivar los eventos dinamicos de la pagina ya pintada por el server. El codigo es ejecutado indistintamente y sirve a la renderización tanto del HTML inicial, como luego del interactivo.

```vue
<template>
  <button @click="$emit('customClick')">Click</button>
</template>
<script>
//logica del Button (misma implementacion )
export default {
  setup(props, { emit }) {
    return () => emit("customClick"); // idem implementacion (back y front)
  },
};
</script>
```

**Descripción del ejemplo:** el código del `componente button.vue` puede ser ejecutado sin ningún tipo de modificaciones o dependencias ya que usa funciones javascript (pueden verse modificacadas las interfaces `onMounted` y `unMounted` y lifecycle hooks pero es un concepto abstracto). En un ambiente SSR el front-end tambien puede correr en el back sin ningun tipo de adaptación en particular, como ocurre en el render client side solo.

## C - Time-to-Content

**Definición:** Tiempo que tarda en aparecer el contenido en la pantalla del usuario (primera visualización del DOM) en forma significativa. Es clave en la experiencia de usuario , sobretodo para usuarios con baja conexion de internet o que accedan a nuestra app en devices antiguos o menos potentes. Se reduce cuando no debe ejecutar JS, sino simplemente se pinta la pagina enviada en `html`.

**Ejemplo:** La carga rápida de una web que renderiza html ya pre-renderizado en el back-end frente a webs donde un loader de `spin` se carga hasta que termina la ejecucion de javascript. El `SSR` optimiza notablemente esta medida en milisegundos.

```
// Ejemplo Conceptual
Usuario hace un pedido por HTTP -->  (SSR)- >  HTML  PINTADO-> navegador Muestra html rápidamente -> carga Js y reacciona.

Usuario hace un pedido por HTTP-->  (client-side)- >   index.html Vacio -> Carga  JS->Ejecuta -> renderiza componente final (tiempo extra en espera a pintarse )
```

**Descripción del ejemplo:** Con `SSR` (lado izquierda en esquema) , el usuario recibe el `html` pintado a mayor velocidad ya que todo el proceso render lo hace el server. A comparación del render `client-side` donde (parte derecha en esquema ) recibe el `index.html` vacio y tarda mucho mas tiempo, en espera de cargar `Js` para empezar el pintado. La reducción del tiempo es directamente proporcional a un mejor UX .

## D - Core Web Vitals

**Definición:** Métricas de Google para medir el rendimiento de una web desde el punto de vista de UX (user experience) con valores como `Largest Contentful Paint (LCP)`, `First Input Delay (FID)` , `Cumulative Layout Shift (CLS)` (estabilidad layout ), la latencia, tiempo al primer byte, (o las mediciones como: el Time to Content que veíamos antes).

**Ejemplo:** Aplicar buenas prácticas para mejorar el score que google le da al sitio, impactando en el SEO (posicionamiento del mismo). Uno de estos es el tiempo que tarda en visualizarse una app y la velocidad con que reacciona cuando el usuario interactua, entre otras métricas de la lista anterior.

```
// ejemplo Conceptual

Tiempo de carga ideal -> Core web vitals verdes.  Optima experiencia usuario y  mejor seo.

Tiempo de carga malo -> Core Web vitals Rojas .  Mala experiencia de usuario y bajo  seo en resultados de google.
```

**Descripción del ejemplo:** Un sistema con una optimización adecuada mostrara "métrica core" en verde, indicando que se adecua a la recomendación en términos de buenas prácticas para brindar una correcta UX (User experience), como ejemplo un sistema con SSR, con componentes que respondan rápidamente.

## E - SEO (Search Engine Optimization)

**Definición:** Técnicas para mejorar la visibilidad de un sitio web en los resultados de los buscadores web. Optimiza como las paginas aparecen listadas en google, o en otros motores de búsqueda, usando palabras claves, contenidos relevante. En esta practica la renderizacion de contenido HTML es clave.

**Ejemplo:** Tener urls accesibles o mostrar la informacion de texto importante (h1 tags etc) renderizada al navegador por medio de un `html` pintado de modo que el `bot` o araña de google pueda encontrar estos terminos rapidamente para asociarlos al listado del sitio en base a esas palabras claves. Si el robot ve una pagina vacia, no entendera de que va el sitio , ni de las intenciones de keywords relacionadas.

```html
// Ejemplo Conceptual SSR // html renderizado:

<!DOCTYPE html>
<html>
  <head>
    <title>La mejor app de SSR</title>
    <meta
      name="description"
      content="descripcion del producto,
        keywords importantes para seo"
    />
  </head>
  <body>
    <h1>title ssr de la app</h1>
    <div id="productos">productos</div>
  </body>
</html>

// client-side (sin pintar nada)
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>App JS vacía en inicio.</title>
  </head>
  <body>
    <div id="root"></div>
    <!-- sin datos iniciales-->
  </body>
</html>
```

**Descripción del ejemplo:** Un sitio renderizado del lado servidor (SSR-ej izq), permitira al `bot` (crawler o araña de google ) indexar palabras importantes contenidas en el mismo para aparecer mas relevantes al momento de que un usuario busque usando los terminos `keyword` en la app. A diferencia (lado derecho del ej) , las aplicaciones solo javascript entregan la pagina vacía al robot, la app se ve penalizada a la hora del ranqueo SEO. En resumen un `html` pintado inicialmente facilita esta actividad y ayuda al SEO .

## F - Static Site Generation (SSG)

**Definición:** Técnica para construir sitios webs que generán el `HTML` completo al tiempo del compilado. Estos archivos `html` generados se cargan directamente cuando un usuario visita una ruta determinada sin necesitad del ciclo render SSR para la generacion dinamica. La principal ventaja es velocidad de acceso a estos recurso y la poca necesidad de recursos en el server que los sirva (son archivos `html` estaticos sin ninguna dinamica )

**Ejemplo:** Un Blog, donde las páginas de cada post son las mismas para cada usuario que lo solicita (es un html estatico y un dato inmutable que no varía según el contexto), no debe compilarse en cada pedido o solicitud ya que es exactamente el mismo. A diferencia de SSR el render ya se ejecutó durante la construccion de la web (build process), obteniendose al momento de acceder a el: solo el "delivery" en una url. Ideal para webs donde la info es la misma para todos ( documentaciones etc ) no asi webs dinamicas.

```
// Ej conceptual de un flow:

[SSR - SERVER] user -> request URL  -> genera  html  dinamico(cada petición).

[SSG  - pre-RENDER] developer build code  --> generates files  HTML  -> (al user entrega file estatico html directamente).

```

**Descripción del ejemplo:** A grandes rasgos una página creada a partir del método SSG ya está pintada previamente al momento de deploy o cuando se realiza el comando build; con SSR en cambio cada nueva solicitud obliga al servidor (backend) a "pintar el `html` ". En esencia uno realiza la compilacion durante la contrucción del software el otro es dinámico , a cada petición que el usuario haga.

## G - Hydration (Client-Side)

**Definición:** Es el proceso mediante el cual el JavaScript que llega del front "toma el control" de una aplicación SSR , que llego en un formato HTML ( ya renderizado por back), pasando a tener toda la interacción (eventos , componentes dinamicos, etc). Le da a esa interfaz `HTML` una dinámica propia (Reactividad Vue) haciendo que deje de ser un texto estático en el browser. Imagina cuando en una obra de teatro los actores interactúan con escenografía ya montada al iniciar el show , con una previa interaccion desde back, con la diferencia que SSR usa las herramientas reactivas de un framewrok ( vue en este caso).

**Ejemplo:** Una pagina web con botones y comportamientos JS (click , load de contenido , rutas con framework, etc ) ya pinta al inicio un html (enviado desde back-end por el servidor). El front toma el `dom` existente, y comienza a escuchar los `click events` y otros que antes habian sido "estáticos" (pre-pintado de la parte html) haciendo a esta UI dinámica , reactiva . Ahora los estados vue funcionan correctamente a raiz de toda esta estructura `html` e implementando una reactividad propia y dinamica en la misma.

```js
// conceptual cliente js  para hydration .

import { createSSRApp } from "vue";

createSSRApp({}).mount("#root"); //  hace referencia al elemento existente pintado ya por el server al html .
// luego  toma  el  control ( eventlisteners, reactivity, etc ) sobre este `DOM`
```

**Descripción del ejemplo:** El framework `Vue` en el `client.js` toma el control, a traves de un "mount" haciendo referencia al `DOM` ya renderizado por SSR en la vista , para realizar el paso de "hydration" es decir a la `reactividad vue` haciendo interactiva la interface ya renderizada en su forma inicial, con el `string html` pintado.

## H - Universal Code

**Definición:** Código que puede ser ejecutado tanto en el lado servidor como en el cliente. Tiene el comportamiento y debe de poder ejecutarce indistintamente en cualquier ámbito o scope de JS (node.js como en el browser), para un render ya sea del lado `SSR`, como para un render que se le da el "control reactivo en cliente". Implica respetar que haya casos que se ejecutaran del lado server como luego también los mismos, del lado del navegador, todo con el fin de crear la UI que visualiza el usuario, tanto con la parte html pintada y también los `events`, cambios dinamicos que un framework de Javascript nos da por "default".

**Ejemplo:** Componentes que no utilizan la api de `windows` del navegador ni otros servicios que están solo disponibles `en client.js` . Sino que son "plano javascript", o bien, usando librerias (ej axios-fetch) en la forma en como envian request, tanto en front-end y también backend (es como un "transpilado" pero ejecutado de igual forma en backend como front-end . El mismo modulo de axios sirve a ambos ). El resto de funciones deberán encapsular lógica client side o de server side respectivamente.

```js
 // shared module js.  - conceptual

 //component.js o api.js etc..
export const  urlApi =  '/products.json'
  export async function getData ()  { //idem lógica con  el framework vue
    return await (await fetch ( urlApi)).json() //fetch sera lo mas parecido en el ambito `server y cliente`.
}
// Component  Vue  (idem implementacion
   import  { getData }  from "./api.js";

       setup(){
              onMounted(async ()  =>{
                   const  response  = await getData()  // llamado api por front.
              })

            render(){} //igual al momento de ejecutarse  render string.
       }


```

**Descripción del ejemplo:** En la parte del modulo js compartido (izq en ej conceptual ) las llamadas al backend o las API ( fetch en ejemplo ) corresponden al mismo código. Y la importación o las funciones que usen o que hagan referencia al `dom` (onMounted ) o como renderiza el template o la llamada de las funciones del mismo `framework Vue`(ej `setup()`), si bien tiene algunas directivas , hooks lifecycle `(onMounted/UnMounted)` para una particular y acotada ejecución, no obstante debe mantener cierta abstracción y modularizacion de codigo reutilizable, para crear una web `isomofica`, donde es indistinto si es SSR o render client side. Esto debe de poder ejecutarse en ambos ámbitos `front` o `back`, sin mucha diferencia.

## I - createSSRApp()

**Definición:** Función de Vue usada para crear una app Vue lista para renderizar tanto en el servidor con SSR, como tambien para usar esa parte de codigo html con hydration del client-side, esta api es esencial a la hora de usar SSR de manera efectiva en una aplicacion `vue`, junto a `renderToString()` de este contexto. Similar en su implementacion al `createApp()`, pero este render solo del lado `front` (el cliente del navegador ).

**Ejemplo:** Una función, que a diferencia de crear la `app Vue `tradicional ( con la function `createApp`), inicializa con todo el contexto para poder hacer una renderización en el `back` , para el envío de la pagina `html` para render `server-side`. Este framework a parte, tiene todo los callbacks para que la ejecución en modo de `hidratation` funciona en cliente ( el control de reactividad de los elementos de esa pagina previamente pintados ) , en otras palabras el mismo código es la semilla tanto para servidor como para cliente . Similar al `mount()` del componente en especifico, o la propia raiz (`div`) de este, pero en nivel `App()` (el objeto application principal de nuestra app) de ahí su importancia al usar SSR .

```js
//server side file ( conceptual)

import { createSSRApp  } from 'vue' //
import {  renderToString }  from "vue/server-render";


import App from "../App.vue"; // es mi app central

server.get('/', (req, res) => {
const app=createSSRApp ( App ); // inicio para modo SSR;
//render y responde con un HTML
const  appHtml =await renderToString( app  )

});

```

**Descripción del ejemplo:** La function `createSSRApp` reemplaza a `createApp` ya que a grandes rasgos debe dar todo el soporte para los casos SSR : desde su creacion (render en server , hasta la propia "hydration" del front-end). En el ejemplo vemos su aplicación a nivel servidor en conjunción con la funcion `renderToString` para que de resultado un HTML plano que se enviará a cliente, que finalmente terminará ejecutándose. La diferencia radica que crea el soporte extra en la capa `app` del programa en vez de que "sea simplemente la implementacion del component". Por ultimo cabe decir que su nombre es mas que auto-explicativo (Crea APP `SSR`)

## J - renderToString()

**Definición:** Es una API específica de `Vue` en un entorno del lado servidor que permite tomar una instancia de `app vue (creada con  createSSRApp())` y "renderizarla" a un string HTML (transformandola en un formato ya pintado) . Esto permite que nuestro programa `SPA` se envie ya renderizado (como cadena de texto html ) con toda su vista para su visualización directa por parte del user sin necesitar la carga y compilación por parte de javascript del front en una primera instacia. Es la esencia de las paginas `SSR`. Esta Api no existirá si no existe todo el contexto y configuración que provee un `server-side` y tampoco cuando uno realiza la ejecución solo por la parte client (un simple `<div id ="root"/>`) a través del `mount()` común del client js de Vue

**Ejemplo:** Es una funcion que usa la implementacion `SSR` creada con `createSSRApp()` para renderizar esta a un string, retornando una `promise<htmlstring>` , similar conceptualmente a lo que un motor tipo handlebars, EJS realiza (la función pintora de templates ), pero aplicado y ejecutando código js `vue` (todo componente en resumen es código Js o sus props ). La estructura ya construida ( componentes vue , setup ) pasa al sistema, esta la renderiza transformando al template o `v-html` correspondiente (ej los string `jsx`), esto finalmente se envía en la resuesta http del server como el html inicial y optimizado, mejorando el rendimiento con "Time to Content", la parte core web vitals o la seo , ya comentadas.

```js
// Ejemplo conceptual  API vue render to String:

import { createSSRApp } from "vue";
import { renderToString } from "vue/server-render";

const app = createSSRApp({
  template:
    "<h1> Hola</h1><button @click=$emit() ></button> <div ref='aDiv' ></div>",
  // component option (setup function props, )

  setup(props, { emit }) {
    return {};
  },
  // etc options...
});

async function doRenderServerSide() {
  const htmlString = await renderToString(app);
  // envia la string como respuesta del servidor http...

  return htmlString; // = string html plano  "<h1> hola </<h1>.....
}
```

**Descripción del ejemplo:** Esta Api `renderToString( createAppInstance )` de `Vue/ServerRender` retorna un `String HTML`. Lo principal y diferencial, es que realiza una ejecucion del programa de Vue pero `en lado servidor`; convirtiendo su arbol de componente (todo escrito en JavaScript) en su homonimo string `HTML`. Por último es importnte recalcar que para que el código funcione `createSSRApp` y esta funcion de `Vue/server-render` van siempre juntos, la existencia de uno esta ligada al uso del otro dentro de este nuevo paradigma.

## K - Cross-Request State Pollution

**Definición:** Es un problema en SSR que ocurre cuando el estado de una aplicación, se "contamina" con información que pertenece a otros usuarios. Usar state de manera incorrecta o a través de variables singleton definidas en global puede ocasionar la fuga de informacion entre multiples request `SSR`. Es un `leak` o "fuga" no intencionada de data en aplicaciones multiusuario que ejecutan sus funciones sobre el back, debido al concepto singletons de las variables compartidas y su persistencia en memoria de un server node. Evitar esta contaminación es el "desafío SSR a sortear" a la hora de utilizar esta forma de render ( no pasa con el client side render porque el js se ejecuta a nuevo por cada nueva solicitud y refresh de user en navegador ).

**Ejemplo:** Compartir `sessionStorage`, data `vuex` o variables definidas en scope global en js para varios users con la aplicación del lado `SSR` o en un `Server Component (nextjs)` pueden acarrear que la información entre users se vea "contaminada" por variables tipo singleton y compartidas en ejecución de back y puedan mezclar valores erroneamente . Por eso en vez de tener `global state` se deben generar nuevos "states" a cada user y/o por petición, de lo contrario otros usuarios podrian tener informacion "mezclada". Esto no pasa con client-side porque su `state` se renueva por cada nuevo acceso (o refresh del browser ), esta limpieza se la da de manera automática (esto implica mas render) . En un contexto `ssr` al reves debe ser cuidadosamente planeada la asignacion de nuevos estados `SSR` para cada request user

```js
// Error de compartir estado  en scope global  , ejemplo: (conceptual ).

 // en /dataGlobal.js  (modulo )

 let sessionStore = null;   // objeto session persistente, por server  (  "singleton" para todos )

 //  componente de back SSR que usa  `sessionStore`

function getData  () {

 const {userData } = ...  // extraccion  user de alguna sesion cookies
if ( sessionStore==null  ){
  sessionStore={};    // error singleton se reusa  para multiples request ( user 1 ...2 y muchos...)

  };

sessionStore.sessionUser= userData  ;  // dato del user 1

//.. respuesta  envia   el state o una data con el sesionStore para todos..
// error todos acceden   al sessionStore de otro y puede que mezcle info o se sobreescriba!!! ( `state pollution`)
 return { allData : {... , session :sessionStore }} ;  // la sesion no es la de un solo user...


 }
 //  multiples user en  server
//  user  2    userData=" datosUser_2 "    (se ejecuta encima sobreescribe!!! ).


```

**Descripción del ejemplo:** El state al ser singleton se convierte en un cuello de botella ( el error a sortear ), el programa cuando este es render en el back "lo recuerda" ya que se guarda en una variable con `let sessionStore`, el valor o referencia a ese mismo objeto , este error hace que se comparta información erronea en varias peticiones diferentes de los `users`, con valores sobrescritos.
Para estos problemas se aconseja la implementacion de state a nivel App, el contexto proveído del objeto request al usar framework, para realizar "proveer states únicos por solicitud" ya no usar un singletons. Para `vue` (o similar en otras frameworks ) se utiliza un contexto para compartir esta informacion entre components, un patron `provide` + `inject` a nivel componente , ya que a la hora del pintado del server el state solo sirve a esa `renderizacion de app` puntual para ese usuario y que la proxima petición no dependa de ese mismo valor por la ejecucion de memoria "singleton" . Con la salvedad de que esta data no persistirá si no es llevada hacia al `client` en forma segura o "hydrate"

## L - Hydration Mismatch

**Definición:** Error en las apps SSR que ocurre cuando la estructura DOM en el lado del servidor no concuerda o coincide con el `dom` en el lado del cliente. Las modificaciones inesperadas o no contempladas del cliente a partir de javascript y framework pueden hacer que lo renderizado no sea lo mismo en la parte cliente que lo ya pre renderizado desde el servidor y al hacer "hydratacion", puede que se generen estos errores en consola por falta de sincronia al momento de que front toma el control `DOM` ya "preparado". O que ciertas propiedades no existan , `css class`, `IDs` que no coinciden, en general es lo mas propenso a producir error y se debe controlar al desarrollar.

**Ejemplo:** Generar con JS aleatorios valores (ids o nombres) y atributos , también errores de nested-doms con reglas html. Estos errores generalmente ocurren por usar data dinámica en los server components que deberia estar sólo en el ámbito de la `reactivity  del cliente` o cuando no se siguen las convenciones `HTML `de como anidar el DOM. Ejemplo en un parrafo `<p>` incluir `<div>`. El navegador en el front corrige el error a <p/> y <div/> fuera de este contexto . Esta estructura luego al hacer "hydrate", Vue notara que ese div estaba adentro, ocasionando el error por `"Dom Hydration Mismatch"`, y también a perdida de optimizacion (performance render). Es de extrema atención cuando se usan componentes del server con los de client porque estos son propensos al error, la diferencia entre que pinte "A", del server y luego que espere una "B" ( en el cliente cuando arranca `reactivity`) que hace saltar este `hydratation error` en consola.

```html

// Ejemplo Mismatch del render en el cliente.
 // (mala estructrura ) del html o atributos, (ids, classname no existe ) en  ssr del server .


<p>
  <div>  Esto esta mal... genera error</div>  // mismatch!!

<div  id="idDinamicoDeAppSSR_userX ">   <!-- este id en particular sera problemático porque es diferente entre server y cliente. ( no debe ser dinámico -->


<span classname="aClassName" />  // falta className de referencia inicial del server a la que espera al momento  de la hidratación.
     </div>
    </p>


    <h1 v-if =" condicionVariable "> // v-if puede  provocar la perdida en `dom` y por ende un  "hydration error mismatch "   dependiendo del caso
            titulo del dom
    </h>
```

**Descripción del ejemplo:** Al usar ciertas convenciones y directivas dentro de un sistema ssr Vue podemos llegar a generar el `error` (ej nested html incorrectos o class dinamicas, `if` conditions) y de la mismia forma, tambien errores derivados en usar una variable tipo `uid o randomId` con diferente resultados entre el proceso del back render y front, provocando inconsistencia, ya que vue espera esa particular estructura o valores pero el `client` diferencia al tomar el control . En general en este contexto, con `hydrate` no deben ocurrir cambios sustanciales de como fue renderizado el `dom `en servidor (esto no quiere decir que debe mantener la logica o no pueda ser modificada por js `dinámico` del front-end sino solo el `dom`, en principio, luego JS si toma el control.)

## M - data-allow-mismatch

**Definición:** Atributo de vue (en sus versiones `>3.5`), que puede añadirse al `DOM `en el html generado por el server, para indicarle a `Vue` que esa parte DOM puede no tener `mismatch`. Facilita indicar la posible disparidad entre cliente y servidor para zonas con datos o atributos con cierta variación de acuerdo con el entorno pero que la aplicacion va a ejecutar de todas formas o en la que puede permitirse errores por su propia implementación interna. Esta opción es para casos especiales no comunes en una aplicación genérica. Esta opción silenciara estos `mismatch` en consola.

**Ejemplo:** Al usar generadores `uuid` que sabemos de antemano generaran un valor `html diferente` entre el proceso de renderizado SSR y su hidratación del cliente en `client.js`, pero aún asi en cierta instancia el programa pueda ejecutarse con o sin error con esa particularidad . Es recomendable primero analizar y verificar estos errores por medio de `debug` o correcciones directas al codigo y el uso del atributo es la opción "mas en el extremo" a la hora de mitigar el error (y no una solucion por si misma a lo mismo ) ya que lo ideal es la "correspondencia exacta entre back y front en el pintado del arbol dom".

```html
// ejemplo : supresion `hydratation mismatch`, con `data-allow-mismatch` attr.

<div :key="uuid() "></div>
// un key unico es una condición muy comun para usar esta API a causa de sus
aleatorios.

<span data-allow-mismatch>
  // al poner data-allow-mismatch vue omite este error.
</span>

<div :style="{" height:`myVarRandom`}></div>
// data dinamica style que provoca `hydration mismatch`

<span data-allow-mismatch class="classAleatoriaGeneradaJS">
  // el nombre o className podria variar generando la disparidad que el data-...
  suprimira la excepcion por default que se veria por este tipo de error en
  consola
</span>
```

**Descripción del ejemplo:** Al poner este atributo en particular `data-allow-mismatch` en la parte del arbol html se esta especificando a vue, en la fase `hydration`, para que no arroje error si existe esta falta de sincronia, ya sea un tag , style, classNames dinámicas etc. Esta API brinda herramientas (en casos donde no queda otra solución para la disparidad del estado ) de hacer que se mantenga "silente" un error del render ya preexistente y poder continuar con la "hydration" sin excepciones . Esto nos brinda libertad a los desarrolladores para continuar desarrollando aunque haya cierta "falta de precision" con el DOM .
Esta solución debe utilizarse bajo ciertas medidas y no de manera indiscriminada en toda nuestra aplicacion ya que un problema con `mismatch ` general deberia ser un aviso, en lugar de una excusa para taparlo (esta debe ser una última opción para poder "arreglar los problemas en produccion o cuando ya se probó y todo debió de haberse comprobado con su test respectivo.")
