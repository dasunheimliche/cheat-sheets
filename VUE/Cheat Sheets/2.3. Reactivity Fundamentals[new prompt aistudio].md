## A - Declaración de Estado Reactivo (Options API)

**Definición:** En la Options API, el estado reactivo se declara dentro de la propiedad `data` de un componente. Esta propiedad debe ser una función que retorne un objeto, y cada propiedad del objeto retornado será observada por Vue. Al hacer esto, cada vez que una de estas propiedades se actualiza, Vue detecta este cambio y modifica el DOM acorde al nuevo estado del componente. Imagínalo como una caja con varias gavetas, cada gaveta guarda algo y Vue está atento a cualquier cambio en ellas.
**Ejemplo:**

```javascript
export default {
  data() {
    return {
      count: 0,
      message: "Hola Mundo!",
    };
  },
  mounted() {
    // Puedes acceder al valor de data como propiedad del this del componente
    console.log(this.count);
    this.count = 1;
  },
};
```

**Descripción del ejemplo:** El código define una data donde `count` y `message` son propiedades reactivas. En el hook `mounted`, se accede y modifica `this.count`. Cualquier cambio de `count` disparará una nueva renderización en la vista. Si cambiamos a 2, veremos este valor nuevo en pantalla. El componente actúa como un "sensor" que reacciona ante estos cambios de valores.

## B - Reactive Proxy vs Original (Options API)

**Definición:** En Vue 3, el mecanismo de reactividad funciona mediante _Proxies_. Esto quiere decir, que cuando usas `data()` un objeto se convierte en un proxy, es decir una _réplica_, que es reactiva, y el original se deja intacto. Hay que siempre acceder y modificar los valores a través de su proxy, nunca desde el objeto original. Es como tener un espejo mágico: solo lo que ves reflejado es reactivo; el original queda igual.
**Ejemplo:**

```javascript
export default {
  data() {
    return {
      someObject: { id: 1 },
    };
  },
  mounted() {
    const newObject = { id: 2 };
    this.someObject = newObject;
    console.log(newObject === this.someObject);
    this.someObject.id = 3;
    console.log(newObject);
    console.log(this.someObject);
  },
};
```

**Descripción del ejemplo:** Se intenta igualar `someObject` ( que fue definida originalmente con el objeto { id: 1} en data), a `newObject` {id:2}. La igualdad nos retornará _false_, pues `this.someObject` es ahora una version reactiva (un proxy). Modificando la id del `this.someObject` con la instrucción `this.someObject.id = 3;`, lo único que veremos es la modificación en este objeto, mas el `newObject` permanece inalterable {id: 2}. Con esta idea queda clarísimo como Vue trabaja internamente para generar sus funcionalidades, generando "espejos" de las variables reactivas.

## C - Declaración de Estado Reactivo (Composition API) con `ref()`

**Definición:** En la Composition API, `ref()` es una función que envuelve un valor y retorna un objeto ref reactivo con una propiedad `.value`. Al actualizar `.value` se notifica cualquier cambio y Vue actualiza la vista. Es como un envoltorio mágico que nos avisa de cualquier modificación del valor interno, para luego realizar las actualizaciones pertinentes.
**Ejemplo:**

```javascript
import { ref } from "vue";

export default {
  setup() {
    const count = ref(0);

    function increment() {
      count.value++;
    }

    return {
      count,
      increment,
    };
  },
};
```

```template
      <button @click="increment">{{ count }}</button>
```

**Descripción del ejemplo:** `count` es un ref. Dentro de `setup()`, `count` debe ser llamado con `count.value` para acceder y modificar el valor interno, pero en la plantilla, se omite la extensión `.value`. El `button` actualiza la cuenta haciendo uso del metodo que se genera `increment`. Como una varita mágica el `ref` realiza un seguimiento del valor interno cuando se interactúa en la vista.

## D - `<script setup>`

**Definición:** Es una forma abreviada de escribir la Composition API dentro de componentes de un solo archivo `.vue`, donde los `imports`, las variables y las funciones se encuentran disponibles en la vista del componente de manera automática, sin la necesidad de declararlas en la función `setup` como vimos anteriormente. El template actúa como una función javascript con scope al `<script setup>`. Es como tener un asistente invisible que facilita las cosas: cualquier cosa declarada dentro `<script setup>` es accesible para la plantilla, ahorrándonos sintaxis innecesaria.
**Ejemplo:**

```vue
<script setup>
import { ref } from "vue";
const count = ref(0);
function increment() {
  count.value++;
}
</script>
<template>
  <button @click="increment">{{ count }}</button>
</template>
```

**Descripción del ejemplo:** El ejemplo declara `count` y `increment` dentro del `<script setup>` , sin declarar la function `setup` y son automáticamente accesibles para la plantilla sin hacer uso del `return`.

## E - ¿Por qué `refs`?

**Definición:** Los `refs` nos permiten detectar cambios en el estado debido a los `get` y `set`. Los navegadores Javascript no dan la opción de hacer eso en las variables nativas. Al encapsular la variable dentro del `.value` la api de Vue genera las operaciones que harán funcionar esta lógica del seguimiento, disparando la reactividad en cascada. Es como si a nuestras variables les pusiéramos unos pequeños radares que detectan cuando intentamos accederlas o modificarlas para asi disparar las reacciones pertinentes del DOM.
**Ejemplo:**

```javascript
// pseudo code
const myRef = {
  _value: 0,
  get value() {
    // aqui vue rastrea accesos y los trackea.
    console.log("Getter detectado");
    return this._value;
  },
  set value(newValue) {
    console.log("Setter detectado");
    this._value = newValue;
    // Vue actualiza componentes observando los refs
  },
};

let myValue = myRef;
console.log(myValue.value); // 0
myValue.value = 2;
console.log(myValue.value);
```

**Descripción del ejemplo:** `myRef` es la implementación simplificada de un ref de vue, si analizamos el código cada que accedemos a `myValue.value` nos imprime 'Getter detectado' y al cambiar su valor, imprimira 'Setter detectado'. Este mecanismo internamente realiza un seguimiento (tracking) para detectar cuando un componente necesita una actualizacion de la vista. Sin los refs este mecanismo no sería posible de manera directa en las variables de javascript nativas, esta funcionalidad hace único a Vue.

## F - Declarando Métodos

**Definición:** Los métodos se declaran dentro de la propiedad `methods` de un componente, en un objeto cuyas funciones harán referencia a acciones lógicas dentro del scope del componente. Usar métodos en componentes sirve para la ejecución de ciertas acciones o funciones con el contexto del this del componente (o sea el propio componente). Es como darles "habilidades" o "poderes" a los componentes.
**Ejemplo:**

```javascript
export default {
  data() {
    return {
      count: 0,
    };
  },
  methods: {
    incrementar() {
      this.count++;
    },
    showAlert() {
      alert("Hola desde el método");
    },
  },
};
```

```template
    <button @click="incrementar">Aumentar cuenta</button>
 <button @click="showAlert"> Mostrar alerta </button>
```

**Descripción del ejemplo:** Aquí, `incrementar` es un método que incrementa la propiedad `count`. A la vez existe otro método showAlert. Ambos métodos son declarados en la propiedad `methods`, la cual forma parte del objeto principal del componente, por ende son métodos del objeto del componente que pueden usarse en la vista de manera `onclick` mediante la declaración `{{método()}}`. Como una caja de herramientas el `this` de cada método puede acceder a cada una de las variables reactivas declaradas en el scope de su componente.

## G - Reactividad Profunda

**Definición:** En Vue, la reactividad es por defecto _profunda_, esto significa que cambios en objetos o arrays anidados activan los correspondientes renderizados, tanto en Option API como en Composition API. Vue tiene la capacidad de observar hasta los objetos anidados en los componentes de manera interna sin que tengamos que preocuparnos de nada al respecto. Imagínalo como un "ecosistema reactivo": si cambia algo por dentro, todo el ecosistema se da por enterado y se adapta.
**Ejemplo:**

```javascript
import { ref } from "vue";

export default {
  setup() {
    const obj = ref({
      nested: { count: 0 },
      arr: ["hola", "mundo"],
    });
    function mutateDeeply() {
      obj.value.nested.count++;
      obj.value.arr.push("!");
    }

    return { obj, mutateDeeply };
  },
};
```

```template
  <p>Contador:{{obj.nested.count}}</p>
    <ul>
     <li v-for="(item, index) in obj.arr" :key="index">{{item}}</li>
  </ul>
    <button @click="mutateDeeply">Mutar Objeto </button>
```

**Descripción del ejemplo:** `obj` es un `ref` con una estructura profunda: `obj.nested` es un objeto anidado. `mutateDeeply` actualiza las propiedades internas de obj: incrementa `nested.count` y añade una string al `array` de `arr`. Todo esto se realiza a través de la ref y cada cambio disparara una actualizacion a la vista que tiene atadas esas referencias internas. Gracias a que la reactividad es _deep_ estos cambios se pueden visualizar inmediatamente y Vue los tiene totalmente monitorizados.

## H - Tiempo de Actualización del DOM

**Definición:** Los cambios al DOM en Vue son asíncronos por rendimiento, por ende si hacemos multiples cambios, Vue los guarda hasta el _siguiente tick_ en el ciclo de vida. `nextTick()` nos permite esperar a la siguiente actualizacion del ciclo de vida de Vue (en este caso que la actualización en la vista se haya completado), esto es sumamente útil cuando necesitas obtener cambios renderizados. Es como si tuviéramos un mensajero que entrega todas las cartas juntas en vez de ir de una por una: `nextTick` espera al momento oportuno, en el que el mensajero (Vue) se encarga de notificar al usuario cada actualizacion ya consolidada y procesada en la vista del navegador.
**Ejemplo:**

```javascript
import { ref, nextTick } from "vue";
export default {
  setup() {
    const count = ref(0);

    async function increment() {
      count.value++;
      await nextTick();
      // El Dom ya está actualizado!
      console.log("dom updated!");
    }

    return { count, increment };
  },
};
```

```template
      <p>Conteo: {{ count }}</p>
  <button @click="increment"> Incrementar</button>
```

**Descripción del ejemplo:** `increment` usa nextTick() para que console log no se lance hasta que haya la seguridad de que se haya generado el nuevo `render`, sin nextTick puede ser que ese log se active con retraso o un valor anticuado que todavía no se actualiza. Vue va optimizado al milímetro y `nextTick` es su manera elegante de comunicarnos un 'aviso de renderizado ya actualizado' para una optima respuesta a los eventos disparados desde los componentes en tiempo real.

## I - `reactive()`

**Definición:** `reactive()` crea objetos proxificados reactivos directamente. Al usar reactive, todo el objeto generado se convierte en reactivo, la mayor diferencia con ref es que no necesita usar .value. Pero se limita a objetos, arrays, o estructuras coleccionadas como Map. Este tipo de reactividad deep permite cambios en todos sus niveles. Reactive genera replicas del objeto real y nos ayuda a trackear sus cambios al igual que ref con sus limitaciones que abordaremos posteriormente. Es como una 'plantilla mágica': un objeto que hace seguimiento de cualquier modificación que hagamos a cada propiedad.

**Ejemplo:**

```javascript
import { reactive } from "vue";
export default {
  setup() {
    const state = reactive({ count: 0, message: "hola" });
    return { state };
  },
};
```

```template
  <p> Conteo {{state.count}} y mensaje : {{state.message}}</p>
    <button @click="state.count++"> Aumentar </button>
```

**Descripción del ejemplo:** `state` se declara usando reactive. Cualquier cambio disparara la renderización de la vista.
A diferencia de ref que usa .value, acá accedemos directamente con state.count por ejemplo. Es útil si quieres manejar varios valores en un objeto (varias props). Un punto clave es que a diferencia de ref reactive trabaja únicamente en los objects, osea las primitives data ( number, strings , booleans) se deben usar dentro del formato objeto. Reactive es similar a ref en concepto pero más directo con objetos complejos con varias keys dentro.

## J - Reactive Proxy vs Original (Composition API)

**Definición:** Similar al caso Options API, cuando usas reactive en Composition Api este devuelve un proxy y el original queda intacto y cualquier manipulación en la versión original del object no tendrá efecto de reactividad. Se recomienda, una vez se ha convertido en proxy con reactive trabajar únicamente en el, el objeto original pasa a ser de lectura y en caso de hacer alguna acción nunca actualizara nada a los objetos de tipo 'proxys'. Es un _clon reactivo_, el que usaremos de ahora en más, para mantener el _enlace reactivo_.
**Ejemplo:**

```javascript
import { reactive } from "vue";
export default {
  setup() {
    const raw = { id: 1 };
    const proxy = reactive(raw);
    console.log(proxy === raw); //false
    raw.id = 2;
    console.log("Object raw original  ", raw); // { id: 2 }
    proxy.id = 3;
    console.log(proxy); //{ id: 3 }
    return { proxy };
  },
};
```

**Descripción del ejemplo:** `raw` es un objeto normal , cuando le aplicamos `reactive` crea un `proxy`. Si intentamos comparar el objeto original con el `proxy` retornará `false`. Luego modificamos `raw` `id= 2;`, el cual se ve alterado, sin embargo si modificamos a `proxy` con `proxy.id = 3;`, podemos apreciar que si se ven estos cambios a diferencia de `raw`, ahí se deja ver de manera explícita la dualidad existente. Como vemos el objeto _proxy_ (creado con `reactive` es nuestro aliado reactivo de aquí en más y la fuente original de la data debe ser solo tratada como información para _solo lectura_.

## K - Limitaciones de `reactive()`

**Definición:** El API de `reactive()` no funciona en datos primitivos. Además no podemos sustituir un objeto reactivo en sí mismo pues perdemos la _conexión de reactividad_, debemos siempre mutarlo desde adentro, no como una asignación completa. Finalmente no debemos extraer destructurando la informacion ya que pierde esa conexion entre las propiedades reactivas del proxy y la variable donde se ha destructurado esa data . Es como tener un _coche deportivo_ muy potente pero con un funcionamiento muy especifico. En el mismo no podemos modificar piezas completas del vehículo sin una revisión general y sus elementos están atados en una lógica concreta. Hay que usar con responsabilidad el _coche_ (reactive) porque aunque su motor sea muy poderoso requiere atenciones para manejarlo de manera apropiada.
**Ejemplo:**

```javascript
import { reactive } from "vue";
export default {
  setup() {
    let state = reactive({ count: 0 });
    console.log(state.count); // 0
    // mal no sustituir por otro reactivo porque perdemos la conexión reactiva
    // state = reactive({ count: 1}); //error

    //Mal perder la conexion reactiva haciendo destrucring y se desconecta el counter.
    let { count } = state;
    count++; //  esto no tendra ningun efecto al estar destructurado.

    function callSomeFunction(number) {
      //el cambio aqui tampoco afectaria la prop state,  porque perdemos la reactividad
      number++;
    }

    callSomeFunction(state.count);
    console.log(state.count); //0 porque las operaciones de +1  son al margen del  reactive original state;

    return { state };
  },
};
```

**Descripción del ejemplo:** Primero intentamos asignar a la `state` otra `state` que es nueva, lo cual causa el problema de perdida de conexión de reactividad. La `count` destructurada ya no actualizara a `state` que queda desatada del control reactivo y no hay rastreo de los nuevos valores que se procesen allí (ya sea incrementos de una primitiva number como se ve con count++ o asignaciónes directas a ese nuevo número). Esto tambien afecta a las funciones ya que pierden su reactividad cuando son invocadas usando un parámetro desestructurado ya sea directamente como propiedad `(state.count)` de `reactive` en la función o con una variable extraída por destructuración `{count}`. Como vimos la mejor manera de mantener los enlaces con los objetos reactivos de `reactive` es acceder desde el proxy completo `state`, sin la desestructuración. Los casos mas correctos, son con `ref` cuando es de tipo `primitivo`, ya que este ya es _conexionable por default_.

## L - Detalles Adicionales de Desencapsulación de Ref (Ref Unwrapping Details)

**Definición:** Los refs dentro de objetos reactivos, _se "desenvuelven"_ o _unwrapp_ (desencapsulados). Esto significa que cuando accedemos al ref dentro de la estructura de `reactive()`, ya no necesitamos `*.value*` si el objeto está profundamente ligado dentro de la declaración de una instancia. En cambio si el ref es elemento de un array no funciona el _desenvolvimiento_, siempre requerirá la sintaxis `.value`. La principal excepción son las `template strings` y allí si actúa este unwrapping , aunque debemos usarlo solamente por `convenencia` dado que este puede esconder la lógica subyacente cuando se usan con elementos del `template` que no tienen top level scope.
**Ejemplo:**

```javascript
import { ref, reactive } from "vue";
export default {
  setup() {
    const count = ref(0);
    const state = reactive({ count });
    console.log(state.count); // 0

    const books = reactive([ref("Vue 3 Guide")]);

    console.log(books[0].value); // 'Vue 3 Guide' es requerida la ext.value por estar dentro de un array

    return { state, count, books };
  },
};
```

```template
     <div>{{ count  + 1}}</div> <!--funciona-->
     <div>{{state.count + 1 }}</div> <!--Funciona por ser prop de reactive -->
     <div> {{ books[0] }}</div><!--funciona es una propiedad de textInterpolation-->
   <div> {{ books[0].value }} </div><!--funciona tambien y es explicito por si no queremos usar la conveniencia del textInterpolation y mostrar que el prop que usamos alli es una ref y por ende .value -->
     <!-- <div>{{object.id + 1}}</div> // Error ya que object no está en top scope -->

```

**Descripción del ejemplo:** Vemos que `count`, cuando se encuentra anidado dentro del object `state`, el cual está declarada como `reactive()` pasa a estar desenvuelta por lo que en el `console.log` no tenemos que acceder con la sintaxis `.value`. Vemos ademas que los ref dentro de arrays `books[0]` si requieren la sintaxis para acceso en js pero si es dentro de string template, lo tomara por `conveniencia`, siendo estas propiedades casos particulares y como nota debemos usarlos con cautela si no son `top level properties`, por eso, si nos guiamos por los logs del ejemplo al ser las propiedades `top level`, se generará el unwrapping por default o no y no se generaran errores. Se deja ver un punto clave de entender si quieres dominar en profundidad la reactividad de vue js
