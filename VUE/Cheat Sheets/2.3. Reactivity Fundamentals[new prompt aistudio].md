## A - API Preference

**Definición:** Permite alternar entre la sintaxis de la Options API y la Composition API en la documentación de Vue. Esto facilita la lectura y comprensión del código según la preferencia del usuario.

**Ejemplo:**

En la barra lateral izquierda de la documentación, hay un selector que permite elegir entre "Options API" y "Composition API". Al cambiar la selección, los ejemplos de código se actualizan para reflejar la sintaxis elegida.

```Javascript
// Ejemplo: Al seleccionar "Composition API", los ejemplos usan ref() y reactive()
import { ref } from 'vue'
const count = ref(0)
```

(Este selector permite adaptar la documentación a la forma de programar preferida por el usuario.)

## B - Declaring Reactive State

**Definición:** Es el proceso de crear variables o datos que Vue puede rastrear para actualizar la interfaz de usuario automáticamente cuando cambian. Esto se logra mediante las funciones ref() y reactive().

**Ejemplo:**

```Js
import { ref, reactive } from 'vue'

// Usando ref() para un valor primitivo
const count = ref(0)

// Usando reactive() para un objeto
const state = reactive({ message: 'Hola' })
```

(La reactividad permite que la interfaz de usuario se actualice automáticamente cuando cambian los datos.)

## C - ref()

**Definición:** Una función que toma un valor y lo envuelve en un objeto ref con una propiedad .value. Esto permite a Vue rastrear los cambios en el valor y actualizar la interfaz de usuario.

**Ejemplo:**

```Js
import { ref } from 'vue'

const count = ref(0)
console.log(count) // { value: 0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1
```

(La propiedad .value es necesaria para acceder y modificar el valor dentro de un ref en JavaScript.)

## D - Acceso a refs en templates

**Definición:** Para usar un ref en un template, se debe declarar y retornar desde la función setup() de un componente. En el template, el ref se desenvuelve automáticamente, por lo que no es necesario usar .value.

**Ejemplo:**

```Js
import { ref } from 'vue'

export default {
  setup() {
    const count = ref(0)
    return {
      count
    }
  }
}
```

```html
<div>{{ count }}</div>
```

(En el template, count se refiere al valor del ref, no al objeto ref en sí.)

## E - Mutación de refs en templates y handlers

**Definición:** Los refs pueden ser modificados directamente en los templates o en los manejadores de eventos. Para lógica más compleja, se pueden declarar funciones que muten los refs y exponerlas como métodos.

**Ejemplo:**

```html
<button @click="count++">{{ count }}</button>
```

```Js
import { ref } from 'vue'

export default {
  setup() {
    const count = ref(0)
    function increment() {
      count.value++
    }
    return {
      count,
      increment
    }
  }
}
```

```html
<button @click="increment">{{ count }}</button>
```

(En el template, count++ modifica el valor del ref. En JavaScript, se usa count.value++.)

## F - `<script setup>`

**Definición:** Una sintaxis simplificada para componentes de un solo archivo (SFC) que evita la necesidad de exponer manualmente el estado y los métodos desde setup(). Las variables y funciones declaradas en `<script setup>` son automáticamente accesibles en el template.

**Ejemplo:**

```Vue
<script setup>
import { ref } from 'vue'
const count = ref(0)
function increment() {
  count.value++
}
</script>

<template>
  <button @click="increment">{{ count }}</button>
</template>
```

(Con `<script setup>`, el código es más conciso y fácil de leer.)

## G - Reactivity System

**Definición:** El sistema de Vue que rastrea las dependencias entre los datos y la interfaz de usuario. Cuando un ref se usa en un template, Vue rastrea ese ref. Cuando el ref cambia, Vue actualiza el DOM.

**Ejemplo:**

Cuando un componente se renderiza por primera vez, Vue rastrea los refs usados. Si un ref cambia, Vue sabe qué componentes deben actualizarse.

```Js
// Pseudo código
const myRef = {
  _value: 0,
  get value() {
    track() // Vue rastrea que este ref se está usando
    return this._value
  },
  set value(newValue) {
    this._value = newValue
    trigger() // Vue actualiza la interfaz de usuario
  }
}
```

(El sistema de reactividad permite que la interfaz de usuario se mantenga sincronizada con los datos.)

## H - Deep Reactivity

**Definición:** Los refs hacen que sus valores sean profundamente reactivos. Esto significa que los cambios en objetos o arrays anidados también se detectan y actualizan la interfaz de usuario.

**Ejemplo:**

```Js
import { ref } from 'vue'

const obj = ref({
  nested: { count: 0 },
  arr: ['foo', 'bar']
})

function mutateDeeply() {
  obj.value.nested.count++
  obj.value.arr.push('baz')
}
```

(Los cambios en obj.value.nested.count y obj.value.arr activarán actualizaciones en la interfaz de usuario.)

## I - Shallow Refs

**Definición:** Refs que solo rastrean los cambios en la propiedad .value, no en los objetos anidados. Se usan para optimizar el rendimiento o cuando el estado interno es manejado por una librería externa.

**Ejemplo:**

```Js
import { shallowRef } from 'vue'

const obj = shallowRef({ nested: { count: 0 } })
obj.value.nested.count++ // No activará una actualización
obj.value = { nested: { count: 1 } } // Sí activará una actualización
```

(Los shallow refs son útiles para evitar el costo de rastrear objetos grandes.)

## J - DOM Update Timing

**Definición:** Las actualizaciones del DOM no son síncronas. Vue las almacena en búfer hasta el "siguiente tick" para asegurar que cada componente se actualice solo una vez.

**Ejemplo:**

```Js
import { nextTick } from 'vue'

async function increment() {
  count.value++
  await nextTick()
  // El DOM se ha actualizado
}
```

(Se usa nextTick() para esperar a que el DOM se actualice después de un cambio de estado.)

## K - reactive()

**Definición:** Una función que hace que un objeto sea reactivo. A diferencia de ref(), reactive() no envuelve el valor en un objeto, sino que convierte el objeto en un Proxy.

**Ejemplo:**

```Js
import { reactive } from 'vue'

const state = reactive({ count: 0 })
```

(Los objetos reactivos son Proxies que permiten a Vue rastrear los cambios en sus propiedades.)

## L - Reactive Proxy vs. Original

**Definición:** El valor retornado por reactive() es un Proxy del objeto original, no el objeto original en sí. Solo el Proxy es reactivo.

**Ejemplo:**

```Js
const raw = {}
const proxy = reactive(raw)
console.log(proxy === raw) // false

raw.count = 1 // No activará una actualización
proxy.count = 1 // Sí activará una actualización
```

(Es importante usar siempre el Proxy para mantener la reactividad.)

## M - Limitations of reactive()

**Definición:** reactive() tiene limitaciones: solo funciona con objetos, no con valores primitivos; no se puede reemplazar el objeto reactivo por completo; y no es amigable con la desestructuración.

**Ejemplo:**

```Js
let state = reactive({ count: 0 })
state = reactive({ count: 1 }) // Pierde la reactividad

let { count } = state // Pierde la reactividad
```

(Debido a estas limitaciones, se recomienda usar ref() como la API principal para declarar estado reactivo.)

## N - Ref Unwrapping as Reactive Object Property

**Definición:** Un ref se desenvuelve automáticamente cuando se accede o se modifica como una propiedad de un objeto reactivo.

**Ejemplo:**

```Js
const count = ref(0)
const state = reactive({ count })
console.log(state.count) // 0
state.count = 1
console.log(count.value) // 1
```

(En este caso, state.count se comporta como una propiedad normal, no como un ref.)

## O - Caveat in Arrays and Collections

**Definición:** No hay desenvuelto automático cuando un ref se accede como un elemento de un array reactivo o una colección como Map.

**Ejemplo:**

```Js
const books = reactive([ref('Vue 3 Guide')])
console.log(books[0].value) // Necesita .value

const map = reactive(new Map([['count', ref(0)]]))
console.log(map.get('count').value) // Necesita .value
```

(En arrays y colecciones, se debe usar .value para acceder al valor del ref.)

## P - Caveat when Unwrapping in Templates

**Definición:** El desenvuelto de refs en templates solo ocurre si el ref es una propiedad de nivel superior en el contexto de renderizado.

**Ejemplo:**

```Js
const count = ref(0)
const object = { id: ref(1) }
```

```html
{{ count + 1 }}
<!-- Funciona -->
{{ object.id + 1 }}
<!-- No funciona -->
```

(Para que object.id funcione, se debe desestructurar en una propiedad de nivel superior.)

```Js
const { id } = object
```

```html
{{ id + 1 }}
<!-- Funciona -->
```

(El desenvuelto automático solo se aplica a propiedades de nivel superior en el template.)
