## A - Testing

**Definición:** Es el proceso de verificar que tu aplicación funcione como se espera, previniendo errores y asegurando la calidad del software. Imagina un control de calidad continuo, revisando cada pieza de tu proyecto para evitar problemas en producción.

**Ejemplo:** Escribir casos de prueba que automaticen la verificación de funciones, componentes y flujo de datos.

```js
// Ejemplo conceptual de test
function suma(a, b) {
  return a + b;
}
function testSum() {
  if (suma(2, 2) === 4) {
    console.log("Test passed!");
  } else {
    console.log("Test failed!");
  }
}
testSum();
```

**Descripción del ejemplo:** Una sencilla función testea si la suma 2+2 retorna el resultado esperado (4), de lo contrario, el test fallará, haciendo evidente algun error en la function sum.

## B - Regressions

**Definición:** Errores introducidos en el código después de que funcionaba correctamente, generalmente como resultado de cambios o actualizaciones. Imagina un paso hacia atrás en lugar de avanzar. Los test previenen estos errores.

**Ejemplo:** Cambiar una función que anteriormente funcionaba e introducir un nuevo comportamiento erroneo en dicha function, ya sea porque fue realizada la modificación por otra persona del equipo o por no recordar los detalles.

```js
// Función anterior funcional.
function getPriceWithDiscount(precio) {
  return precio - precio * 0.1;
}

// Error en refactorización posterior
function getPriceWithDiscount(precio, discount) {
  return precio - precio * discount; // olvidamos el caso inicial
}
console.log(getPriceWithDiscount(10)); //output=10!  cuando deberia 9
```

**Descripción del ejemplo:** Una refactorización que olvida una de las casuisticas del requerimiento. Esto genera una regresión que se evidenciara si tuvieramos casos de pruebas establecidos.

## C - Unit Tests

**Definición:** Pruebas que verifican el comportamiento de piezas de código aisladas (funciones, clases, módulos), asegurando que cada unidad realice correctamente su tarea individual. Como comprobar si cada pieza de un reloj funciona antes de ensamblar el reloj completo.

**Ejemplo:** Probar que una función matemática simple haga lo que debe: sumar, restar etc...

```js
// Función suma para probar
function suma(a, b) {
  return a + b;
}
// Tests
function test_suma() {
  if (suma(2, 3) == 5) {
    console.log("Test Passed!");
  } else {
    console.log("Test Fail");
  }
}
test_suma();
```

**Descripción del ejemplo:** La function `test_suma()` invoca a `suma` con unos valores de ejemplo y evalua que la operacion cumpla con el valor esperado. Es el test unitario más simple de entender.

## D - Component Tests

**Definición:** Pruebas que verifican el funcionamiento de componentes individuales, simulando interacciones del usuario para confirmar que el componente se renderiza, se comporta y actúa de la forma esperada. Imagínalos como tests que ponen a prueba cada componente por separado.

**Ejemplo:** Simular clicks en botones o el llenado de un formulario para ver cómo reacciona un componente.

```vue
// MyButton.vue
<template>
  <button @click="handleClick">{{ label }}</button>
</template>
<script setup>
defineProps({
  label: String,
});
function handleClick() {
  //logic de clic del botón.
}
</script>

// Ejemplo conceptual Test component test('button click logic'() => { // Montar
MyButton con un evento @click const button= montarComponente(MyButton,
{label:"text"}) button.dispatchEvent('click') //emulacion de click expect(
button.text() )// validacion logica clic del botón });
```

**Descripción del ejemplo:** se monta el componente a ser evaluado con el prop y la function setup de la cual queremos testear su funcionamiento. En este caso se realiza una emulacion de click sobre el botón, se espera alguna accion dentro de la función. En la práctica deberia existir otra estructura como en las definiciones de prueba anteriores.

## E - End-to-end (E2E) Tests

**Definición:** Pruebas que simulan interacciones de un usuario real con toda la aplicación, abarcando múltiples páginas y funcionalidades. Se encargan de verificar cómo trabaja la aplicación como un conjunto completo e integrado. Es la comprobación final de que tu app realmente funciona para el usuario.

**Ejemplo:** Simular el proceso de un usuario que se loguea en la app y navega por diferentes secciones y páginas, hasta hacer un pedido y loguearse nuevamente para chequear su status.

```
// Ejemplo conceptual de flujo E2E:
    Navegar a la página principal
    Realizar login.
    Navegar a lista de producto.
    Seleccionar producto y agregarlo a carrito.
    Ir a caja realizar compra y checkout.
```

**Descripción del ejemplo:** A alto nivel y conceptual, un flujo completo de usuario, recorriendo varias secciones de una aplicacion y simulando acciones habituales como loguearse y comprar algo. Esto es precisamente lo que intentan recrear las pruebas E2E.

## F - Vitest

**Definición:** Es un framework de test unitario para Vite que usa la misma configuración y pipeline de transformaciones de Vite, integrándose fácilmente con proyectos basados en Vite y ejecutando los tests muy rápido. Imagínalo como el motor que necesitas para probar el código en aplicaciones Vue, pero en una forma integrada a Vite.

**Ejemplo:** Un conjunto de comandos que, instalando sus dependencias y siguiendo sus guias de configuración permiten hacer correr pruebas sobre nuestra aplicacion Vue creada a partir de Vite.

```js
// Comando para instalar las dependencias necesarias
npm install -D vitest happy-dom @testing-library/vue

//  Archivo configuración de vitest dentro de vite.config.js
  test: {
        // enable jest-like global test APIs
        globals: true,
        environment: 'happy-dom'
   }

// Ejemplo de codigo en un archivo `*.test.js`
   import { render } from '@testing-library/vue'
   import MyComponent from './MyComponent.vue'
     test('it should work', () => {
    const { getByText } = render(MyComponent, {
           props: {
       /* ... */
     } })
        getByText('...')  })
  npm test // correr la suite de test.
```

**Descripción del ejemplo:** Secuencia de código que muestra las instrucciones para ejecutar pruebas en aplicaciones Vue con el motor de `vitest` de forma sencilla y rápida.

## G - Jest

**Definición:** Un popular framework para tests en Javascript. Es útil si tienes un set de tests Jest para migrar a un proyecto Vite. No es la opción recomendada para aplicaciones Vue nuevas, ya que `vitest` se integra mejor y funciona más rápido con Vite.

**Ejemplo:** El motor con el cual correr las pruebas que hayas realizado. De ser una tecnologia en el framework Jest.
Es importante notar que tanto Vitest como Jest son motores para correr las pruebas; se pueden escribir casos de tests y que estos se ejecuten sobre la tecnologia vitest o jest. Ambos hacen lo mismo: correr tests pero internamente con otra logica y ventajas competitivas.

```js
// Archivo de prueba
describe('suma de numeros',()=> {
  it("Deberia sumar los dos numeros" ,() => {
    expect(suma(1,2).toBe(3);
 })
})

```

**Descripción del ejemplo:** Código conceptual que indica como se estructuran las pruebas dentro de una tecnologia Jest. Es un simil con el formato que usan `vitest` con otras particularidades de implementación que justifican usar un framework u otro.

## H - Cypress

**Definición:** Un framework para pruebas E2E en navegador, con excelente UI para la ejecución, depuración y un montón de funcionalidades extra. Su fortaleza está en las pruebas de componentes y el comportamiento de una aplicación que ya se ha puesto en marcha (con estilos y en la url especificada), incluyendo componentes dinámicos y la gestion de clicks y flujos que requiera nuestra aplicacion, ya sea en development o produccion.
A diferencia de vitest o jest, corre tests directamenten en un navegador que se levanta para correr las pruebas sobre el comportamiento completo y visible de la app.

**Ejemplo:** Una GUI que muestra los resultados de la pruebas junto con la aplicación web en un navegador, con herramientas de devtools. Un set de instrucciones para la instalacion, con comando similares a un script de programacion (tipo BDD -Behavior Driven Development) nos permitiran establecer todos los casos de pruebas deseados sobre nuestro proyecto.

```js
// Ejemplo instalacion  cypress (conceptual).

//package.json
{
  scripts: {
    "cypress":"cypress open"
 }
}
> npm run cypress

// un ejemplo de una de los test sobre la pagina del navegador.
describe('Test my Website' () => {
   it('login with good user and pass',()=>{
    cy.visit("miURL/login");
      cy.get("#userName").type("userTest")
      cy.get("#passWord").type("userPassword")
      cy.get("#btn-submit").click()
   })
});
```

**Descripción del ejemplo:** La herramienta `Cypress`, ofrece al developer correr la pruebas en entorno de navegacion (ya no con el happy-DOM en el motor, como `Vitest`) simulando exactamente el comportamiento de un usuario que interactua sobre la pagina de forma directa y sin "mockeos" .
Ofrece diferentes formas de instalacion y tambien presenta al usuario una UI intuitiva para evaluar todos los casos test.

## I - Testing Library

**Definición:** Conjunto de herramientas que facilitan hacer pruebas sobre componentes y simular la interación del usuario de forma fiel (accesibilidad), con independencia de la implementación del componente en concreto, y centrándose en el "qué" en lugar de "cómo". Se implementa tanto en unit test, tests de componente como en pruebas E2E a traves de diversas APIs .

**Ejemplo:** Emulando "buscar elementos" por la interfaz como si fuera un usuario: obtener un componente por el rol que ejecuta en la aplicación (`getByRole`), encontrar una palabra clave `getByText`,etc. Tambien sirve para realizar disparos de eventos `fireEvent`. En resumen nos ofrece una suite para realizar un buen test de front-end mas cerca al comportamiento de un usuario real y con alta accesibilidad.

```js
// ejemplo conceptual  Componente MyComponent.vue.
import {render, screen}  from "@testing-library/vue"
describe('Test con Testing Library en Componente ',() =>{
it('Verifica contenido label' () => {
  render(MyComponent); //componente montado.
  const labelElement =  screen.getByRole("label",
              {name:/valorDeMiLabel/i} );

       expect(labelElement).toBeInDocument;
 });
  it("verifica accion clic en boton ", () => {
          render(MyComponent)
          fireEvent.click(screen.getByRole("button")) // ejecuta click
      //validar alguna cosa que ejecuto el onClick (por ejemplo emit)

   }
});
```

**Descripción del ejemplo:** Se muestra ejemplos sencillos de la funcionalidad de Testing Library en Component Tests . Facilita escribir pruebas con "buenas practicas", desde el punto de vista de usuario y de su experiencia con el front-end.

## J - Composables

**Definición:** Funciones de Vue que encapsulan lógica reutilizable y gestion del state y permiten la modularización y centralizacion de funcionalidades de forma cómoda. En principio se asocia mas a lógica con reactividad con lifecycle y que deben ser testeados como tal en los distintos ambitos ya explicados de test ( unitarios o de componentes, E2E.).

**Ejemplo:** Funciones como un manejador de datos y acceso con los cambios en `LocalStorage` o en el propio navegador ( como las cookies), o tambien una gestion de estado (simular pinia) dentro de componentes , que necesite lógica particular para sus distintos comportamientos y requerimientos, como validaciónes con cambios dinámicos en `DOM` u otra accion con la API del navegador.

```js
import { ref, onMounted } from "vue";
export function useLocalStorage(key, defualValue) {
  const storedValue = ref(defualValue);
  function get() {
    let json = localStorage.getItem(key);
    if (json != null) storedValue.value = JSON.parse(json);
  }
  function set() {
    localStorage.setItem(key, JSON.stringify(storedValue.value));
  }
  onMounted(() => {
    get();
  });
  return {
    storedValue,
    set,
  };
}
```

**Descripción del ejemplo:** Ejemplo conceptual, para el `composable` que nos brinda toda la gestión para persistir una variable en `localStorage` al mismo tiempo nos provee con su value actualizado en tiempo real por la implementacion de ref (vue) para los componentes. Tambien vemos un lifecycle que indica donde y como buscar esta información en el navegador . Todo esto deberia tener tests propios y de su correcto funcionamiento a la par de que la application utilice los datos que facilita.

## K - Playwright

**Definición:** Framework para tests E2E que permite testing en chromium, webkit, y firefox (en windows, linux o MacOS). Con un set de funciones que elimina las flakys pruebas; y con una UI con debugabilidad integrado, asserts, ejecucion en paralelo, entre otras. La gran ventaja es la alta disponibilidad en diversos navegadores y versiones sin dejar de lado un conjunto de funcionalidades de gran valor al ejecutar las pruebas E2E sobre nuestro proyecto web o applicacion (SPA).

**Ejemplo:** Instalación (npm i playwright), el setup con su configuración inicial para proyectos ya creados con node, un ejemplo conceptual de test siguiendo metodologias BDD (behavior drive develop). En los conceptos que brinda cypress, playwright tiene funciones análogas (getByText, click events etc) en sintaxis similar al "driver", para navegar la página e interactuar con sus elementos simulando lo que el usuario haría en una app con toda la logica ya ejecutandose y rendereada.

```js
// Instalacion ( conceptual )
npm install -D @playwright/test
// Archivo configuration de test dentro de playwright.config.ts.

// Archivo *.spec.ts con las pruebas
  test("should logIn correctly ", async ({page}) =>{
  await page.goto("mipagina.com/login")
    await page.fill('input[name=username]'  ,'admin')
    await page.fill('input[name=password]' , 'adminPass')
   await  page.click("button");
   await expect(page.url().contains('welcome'))

   })
  //comando para ejecutar las pruebas
 npx playwright test

```

**Descripción del ejemplo:** Secuencia de codigo para ejecutar tests en el entorno Playwright que a alto nivel son casi idénticas a otros frameworks como cypress y el como los mismos simulan al usuario real cuando interactuan con la pagina , que tambien renderizada ya ha hecho las conexiones al back-end. Estos framework E2E facilitan verificar todo el conjunto del projecto (front y back, si existe) de forma unificada como un "Blackbox".

## L - Mounting Libraries

**Definición:** Bibliotecas que ayudan a "montar" (renderizar) componentes de Vue en un entorno de prueba de forma controlada (headless browser), lo cual te permite manipular las pruebas directamente a nivel `DOM` simulando la interaccion de los eventos de forma reactiva (click, change de inputs etc) en un test para su posterior analisis y test de funcionamiento.

**Ejemplo:** Utilizando la library `@vue/test-utils` (para Unit Tests y Component Tests ) permite, junto al driver correspondiente de testing (ej Vitest ), crear test del comportamiento que debe presentar el front. Similar pero en un scope E2E , library tipo cypress (browser based con el `dom` directamente sobre el browser de test en uso y visible o bien en un browser virtual para ejecutarse a la hora del CI-CD - continuos Integration Continuous Deploy.) permite hacer pruebas mas "completas" con lo "pintado" que ven los usuarios. Es en resumen: bibliotecas que nos ayudan a interactuar con nuestra interface a nivel código , permitiéndonos realizar los `test` correctamente, con sus diferentes abstracciones y levels , ya sean "head less" en vitest y @vue/test-utils como con drivers y pruebas en browser con `Cypress` o `playwright` por ejemplo.

```js
// Ejemplo con @vue/test-utils  . Component tests

    import {mount} from "@vue/test-utils"
    it('verifica propiedad label con valores ' , ()=>{
      const wrapper = mount(MiButtonComponent,
           { props :  {label:"unTextoLargo"} } );

         expect(wrapper.text()).toContain("unTextoLargo")

    });
    it ('Emite "submit-value" en click con  ' () =>{
          const wrapper = mount(MyForm,); // no prop por el momento.
             wrapper.get("button").trigger("click"); // disparo del clic de button.
            const emittedValue =   wrapper.emitted()['submit-value'] // capture emite;
            expect( emittedValue).toBe(/* some values  to compare  */);

    });

```

**Descripción del ejemplo:** Con la library `@vue/test-utils`, podemos acceder al arbol de `DOM` con las props que han sido injectadas a nuestros component (via props en el ejemplo). Adicionalmente ofrece las funciones `trigger` o `emitted` para obtener información adicional y ejecutar casos de pruebas completos simulando "un click o bien capturando alguna funcion que emita el componente, verificando así el buen funcionamiento. A similar modo trabajan otros framework (ver anteriores definiciones).

## M - Snapshot tests

**Definición:** pruebas que validan los strings HTML de la aplicación en un momento dado. NO DESCRIBEN el comportamiento de la app de manera correcta pero permiten verificar errores cuando este HTML cambia sin "aviso previo". No debe utilizarse solo este tipo de tests sino en complemento con otras practicas.

**Ejemplo:** Un sistema test , que registra el `string html` resultante de renderizar un componente, o una vista (y la persisten), y verifican que cualquier cambio en la renderizacion sea validado/ revisado previamente de subir un cambio a git, como sistema de alerta si algo cambio por fuera de lo que debia. No obstante no da garantías de buen comportamiento en cuanto a interacciones o eventos de `dom`.

```js
// test visual con Jest-snapshot
it("render snapshot  para componente X", () => {
  const componentRender = render(ComponentX, {
    props: { label: "Text del compX" },
  });

  expect(componentRender.container).toMatchSnapShot();
});
// En la siguiente ejecucion del test ... compara el html con la version guardada del "snapShot" anterior.
// El  test  fallará si hay una modificacion
```

**Descripción del ejemplo:** Código conceptual para un sistema visual (usando el snapShot) con tecnología Jest donde si cambia algo en la interface se rompera el snapShot. Importante, esta prueba deberia complementarse con otra de unit tests de la parte logica. Esto porque en terminos de "buenas practicas" no se debería usar sólo esta forma de "test visual", sin corroborar otras validaciones logicas y sobre el comportamiento del compoonente, para un desarrollo del sistema más profesional.
