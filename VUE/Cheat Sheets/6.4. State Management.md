## A - State Management

**Definición:** Es la forma de organizar y compartir datos (el "estado") entre diferentes partes de una aplicación, especialmente en interfaces de usuario complejas. Imagina un tablero de control central donde cada componente de tu aplicación mira para ver qué debe mostrar y cómo debe comportarse.

**Ejemplo:** En lugar de que cada componente tenga su propia copia de datos, todos acceden y modifican los mismos datos a través de un "administrador de estado".

```js
// Ejemplo conceptual:
let state = {
  contador: 0,
};

function actualizarContador(valor) {
  state.contador = valor;
}

//componente lee el state
console.log(state.contador);

actualizarContador(5);

//componente se entera de la modificacion del state
console.log(state.contador);
```

**Descripción del ejemplo:** El código ilustra como la modificacion de una variable, que podria considerarse el state, repercute en diferentes partes que hacen uso del mismo. Los componentes observarian las modificaciones del "state" y actuarian en consecuencia.

## B - State

**Definición:** Son los datos que hacen que tu aplicación se comporte y se muestre de una manera particular. El "estado" es la fuente de verdad de tu aplicación, como una foto fija de todo lo que está pasando en un momento dado.

**Ejemplo:** Un número de clicks en un botón, el texto actual de un formulario o la lista de usuarios cargada desde un servidor son ejemplos de state.

```js
// Estado de un componente simple:
let counter = 0;

function increment() {
  counter++;
}
```

**Descripción del ejemplo:** La variable `counter` y la acción de `incrementar` representan un simple manejo del "state" en este componente.

## C - View

**Definición:** Es la representación visual de tu estado. Piensa en una vista como un espejo que refleja el estado de la aplicación; cuando el estado cambia, la vista se actualiza para mostrarlo.

**Ejemplo:** Si el "estado" del número de clicks es 5, la "vista" mostrará "5" en un texto o label.

```html
// Representacion conceptual de una view
<div id="vista"></div>
//La view se actualiza cuando cambia el estado del componente.
<script>
  let vista = document.getElementById("vista");
  vista.innerHTML = state.counter;
</script>
```

**Descripción del ejemplo:** Este fragmento conceptual ilustra la representación html y el script que permiten modificar el "state" y a su vez "actualizar" la vista.

## D - Actions

**Definición:** Son las acciones que modifican el estado. Como interruptores que activan los cambios en la fuente de datos. Estas acciones pueden ser provocadas por interacciones del usuario.

**Ejemplo:** Un click en un botón o un texto cambiado en un formulario serian ejemplos de actions.

```js
// Action para incrementar un contador
function incrementar() {
  state.contador++;
}
```

**Descripción del ejemplo:** Esta es una funcion action que, en conjunto con el state (definido anteriormente) permite incrementar y llevar control del contador.

## E - One-Way Data Flow

**Definición:** Flujo de datos unidireccional. Significa que el estado de tu aplicación se modifica sólo a través de acciones, lo que hace que sea más fácil seguir y depurar cómo los datos se están actualizando y que la UI reaccione acorde. El state modifica la view, no a la inversa.

**Ejemplo:** Los eventos del usuario modifican el estado a través de las actions y el estado modificado repercute directamente en la vista. No al revés.

```
// Ilustracion conceptual:
Usuario -> Acción -> Estado -> Vista
```

**Descripción del ejemplo:** Los datos fluyen en una sola dirección, facilitando el mantenimiento. Es decir: El usuario (realiza una acción) ejecuta una función (modifica el state), repercutiendo directamente sobre la (vista).

## F - Prop Drilling

**Definición:** Es el problema que ocurre cuando necesitas pasar información (props) a través de varios niveles de componentes anidados, como si fueran niveles de un pozo profundo, lo que puede hacer que el código sea confuso y difícil de mantener.

**Ejemplo:** Pasar props de un componente A al componente D atravesando los componentes B y C, todos hijos o hermanos en el árbol de componentes.

```html
// Esquema conceptual
<ComponentA propA="dato" />

<ComponentB propB="propA" />

<ComponentC propC="propB" />

<ComponentD muestraProp="propC" />
```

**Descripción del ejemplo:** Ilustra como la prop "dato" debe atravesar todos los componentes anidados hasta llegar al componenten D que es quien finalmente hace uso del mismo.

## G - Template Refs

**Definición:** Es una forma de acceder directamente a elementos del DOM o a instancias de componentes hijos desde el template. Usarlo en exceso puede dificultar el mantenimiento. Como llamar al conserje en lugar de usar el ascensor.

**Ejemplo:** En Vue, el ref te da acceso al DOM de un elemento. Esto podría no ser necesario si usas el State Management correcto.

```vue
<template>
  <div ref="miDiv"></div>
</template>
<script setup>
import { ref, onMounted } from "vue";
const miDiv = ref(null);
onMounted(() => {
  // miDiv.value permite manipular el div
  console.log("div con ref", miDiv.value);
});
</script>
```

**Descripción del ejemplo:** Accedemos directamente a el `div` a traves de su ref una vez se monte en el DOM para manipular el elemento de forma arbitraria. Esta practica se deberia evitar para mejorar el codigo.

## H - Global Singleton

**Definición:** Es una instancia de un objeto que existe una sola vez en toda la aplicación y puede ser accedida desde cualquier parte, esto sirve para tener el State de tu aplicación en un único sitio al que recurrir, sin duplicidades y permitiendo mantener el flujo unidireccional de la información. Es como un faro en la noche.

**Ejemplo:** En un archivo "store.js" que expone datos y metodos accesibles de forma global.

```js
// store.js
const store = {
    contador :0;
}

// Importarlo y usarlo donde sea necesario
import store from './store.js';
store.contador=5
```

**Descripción del ejemplo:** Un objeto de tipo `store` definido en un unico lugar del sistema, puede ser accesible a toda la aplicacion permitiendo de forma comoda tener siempre presente el State, para la toma de desiciones.

## I - Reactivity API

**Definición:** Conjunto de funcionalidades (como `reactive()` y `ref()`) de Vue que permiten que los datos en JavaScript sean "reactivos". Esto significa que cuando cambias el valor de estos datos, la interfaz de usuario se actualiza automáticamente.

**Ejemplo:** Al usar un `ref()`, si cambias su valor, cualquier componente que lo use se actualizará inmediatamente en la vista.

```js
import { ref } from "vue";
// State con reactive:
const contador = ref(0);

function incrementar() {
  contador.value++; //el estado es .value
}
```

**Descripción del ejemplo:** el `contador` creado a partir del metodo `ref` permite la gestion reactiva de cambios al state. Cuando `contador.value` cambia la "view" asociada se modificara de forma automática.

## J - Pinia

**Definición:** Es una librería de manejo de estado oficial de Vue. Es más simple y con menos boiler plate que su predecesor, Vuex. Pinia gestiona state y permite que tu aplicación crezca con nuevas features.

**Ejemplo:** Similar a Vuex, permite estructurar el state y los actions de manera concisa y profesional. Se gestiona mediante "Stores", donde centralizaremos state, getters y actions.

```js
// store.js

import { defineStore } from "pinia";
export const useStore = defineStore("main", {
  state: () => ({
    counter: 0,
  }),
  actions: {
    incrementar() {
      this.counter++;
    },
  },
});
```

**Descripción del ejemplo:** En `pinia` define una "store" que agrupa, `state` con todos los datos, `actions` los métodos para interactuar con el state. Estos `stores` serán accesibles en la aplicacion facilitando el trabajo en equipo.

## K - Server-Side Rendering (SSR)

**Definición:** Es el proceso de renderizar tu aplicación web en el servidor, antes de enviarla al navegador. Esto mejora la velocidad de carga inicial y el SEO. Evita que el usuario final vea una pagina en blanco durante la peticion y ejecucion inicial del código Javascript.

**Ejemplo:** Cuando una aplicación web que usaba react inicialmente tardaba tiempo en cargar e iniciarse, el proceso SSR ejecuta la misma aplicacion y enruta y pinta al HTML por la request http de usuario, dando como resultado que al usuario ya no ve la pagina en blanco mientras javascript se inicia y permite interaccion con el sitio web.

```html
// HTML inicial pintado por SSR:
<!DOCTYPE html>
<html>
  <head>
    <title>Aplicacion con SSR</title>
    <meta content="HTML PINTADO DESDE EL SERVIDOR" />
  </head>
  <body>
    <div id="app">La pagina ha cargado!!</div>
  </body>
</html>
```

**Descripción del ejemplo:** El HTML de la pagina es construido y generado en el servidor antes de enviarlo al cliente. Asi los buscadores podran indexar los sitios que usen SSR facilitando su posicionamiento SEO, y también reduciendo el tiempo de primera interacción.
