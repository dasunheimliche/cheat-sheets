## A - Composables

**Definición:** Una función que encapsula lógica con estado (que cambia con el tiempo) utilizando la Composition API de Vue, permitiendo reutilizar esa lógica en múltiples componentes. A diferencia de las funciones que solo procesan datos (como las de lodash), los composables gestionan datos que pueden cambiar y reaccionan a esos cambios.

**Ejemplo:**

```JavaScript
// mouse.js
import { ref, onMounted, onUnmounted } from 'vue';

export function useMouse() {
  const x = ref(0);
  const y = ref(0);

  function update(event) {
    x.value = event.pageX;
    y.value = event.pageY;
  }

  onMounted(() => window.addEventListener('mousemove', update));
  onUnmounted(() => window.removeEventListener('mousemove', update));

  return { x, y };
}
```

(Este ejemplo muestra un composable useMouse que rastrea la posición del mouse en la pantalla. Utiliza ref para crear variables reactivas x e y, y los hooks de ciclo de vida onMounted y onUnmounted para gestionar el listener del evento mousemove. Retorna un objeto con las referencias x e y para que puedan ser usadas en los componentes.)

## B - Reutilización de Lógica con Estado

**Definición:** La capacidad de encapsular y reutilizar lógica que gestiona datos que cambian con el tiempo. Los composables permiten evitar la repetición de código y mantener la lógica organizada y modular.

**Ejemplo:**

```Vue
<script setup>
import { useMouse } from './mouse.js';

const { x, y } = useMouse();
</script>

<template>Mouse position is at: {{ x }}, {{ y }}</template>
```

(Este ejemplo muestra cómo un componente utiliza el composable useMouse para obtener la posición del mouse. El componente no necesita implementar la lógica de rastreo del mouse, simplemente consume el estado expuesto por el composable.)

## C - Anidamiento de Composables

**Definición:** La capacidad de un composable de llamar a otros composables, permitiendo construir lógica compleja a partir de unidades más pequeñas y aisladas. Esto facilita la organización y el mantenimiento del código.

**Ejemplo:**

```JavaScript
// event.js
import { onMounted, onUnmounted } from 'vue';

export function useEventListener(target, event, callback) {
  onMounted(() => target.addEventListener(event, callback));
  onUnmounted(() => target.removeEventListener(event, callback));
}

// mouse.js
import { ref } from 'vue';
import { useEventListener } from './event';

export function useMouse() {
  const x = ref(0);
  const y = ref(0);

  useEventListener(window, 'mousemove', (event) => {
    x.value = event.pageX;
    y.value = event.pageY;
  });

  return { x, y };
}
```

(En este ejemplo, el composable useMouse utiliza el composable useEventListener para gestionar el listener del evento mousemove, demostrando el anidamiento de composables.)

## D - Gestión de Estado Asíncrono

**Definición:** La capacidad de un composable de gestionar el estado de operaciones asíncronas, como la carga de datos desde una API, incluyendo estados de carga, éxito y error.

**Ejemplo:**

```JavaScript
// fetch.js
import { ref } from 'vue';

export function useFetch(url) {
  const data = ref(null);
  const error = ref(null);

  fetch(url)
    .then((res) => res.json())
    .then((json) => (data.value = json))
    .catch((err) => (error.value = err));

  return { data, error };
}
```

(Este ejemplo muestra un composable useFetch que realiza una petición a una API y gestiona los estados de carga, éxito y error. Retorna un objeto con las referencias data y error.)

## E - Aceptación de Estado Reactivo

**Definición:** La capacidad de un composable de aceptar como argumentos referencias (ref) o funciones getter, permitiendo que el composable reaccione a los cambios en esos argumentos.

**Ejemplo:**

```JavaScript
// fetch.js
import { ref, watchEffect, toValue } from 'vue';

export function useFetch(url) {
  const data = ref(null);
  const error = ref(null);

  const fetchData = () => {
    data.value = null;
    error.value = null;

    fetch(toValue(url))
      .then((res) => res.json())
      .then((json) => (data.value = json))
      .catch((err) => (error.value = err));
  };

  watchEffect(() => {
    fetchData();
  });

  return { data, error };
}
```

(Este ejemplo muestra una versión mejorada de useFetch que utiliza toValue para normalizar el argumento url (que puede ser una string, una ref o un getter) y watchEffect para que la petición se realice cada vez que url cambie.)

## F - toValue()

**Definición:** Una función de Vue que normaliza un valor, retornando el valor de una referencia (ref), el resultado de una función getter, o el valor en sí mismo si no es ni una ref ni un getter. Es útil para que los composables acepten diferentes tipos de argumentos.

**Ejemplo:**

```JavaScript
import { toValue } from 'vue';

function useFeature(maybeRefOrGetter) {
  const value = toValue(maybeRefOrGetter);
  // value ahora es el valor normalizado
}
```

(Este ejemplo muestra cómo toValue se utiliza para obtener el valor normalizado de un argumento que puede ser una ref, un getter o un valor simple.)

## G - Convenciones de Nombres

**Definición:** La convención de nombrar los composables con nombres en camelCase que comienzan con "use", como useMouse o useFetch.

**Ejemplo:**

```JavaScript
export function useMyComposable() {
  // ...
}
```

(Este ejemplo muestra la convención de nombres para un composable.)

## H - Retorno de Valores

**Definición:** La convención de que los composables retornen un objeto plano, no reactivo, que contenga múltiples referencias (ref). Esto permite la desestructuración en los componentes manteniendo la reactividad.

**Ejemplo:**

```JavaScript
export function useMyComposable() {
  const count = ref(0);
  const message = ref('Hello');
  return { count, message };
}

// En el componente:
const { count, message } = useMyComposable();
```

(Este ejemplo muestra cómo un composable retorna un objeto con referencias y cómo se desestructura en un componente.)

## I - Efectos Secundarios

**Definición:** La realización de acciones que modifican el estado fuera del componente, como la manipulación del DOM o la realización de peticiones a una API. Los composables pueden realizar efectos secundarios, pero deben gestionarse correctamente, especialmente en el contexto de la renderización del lado del servidor (SSR).

**Ejemplo:**

```JavaScript
import { onMounted, onUnmounted } from 'vue';

export function useMyComposable() {
  onMounted(() => {
    // Efecto secundario: añadir un listener al DOM
    window.addEventListener('resize', () => {});
  });

  onUnmounted(() => {
    // Limpieza del efecto secundario: remover el listener
    window.removeEventListener('resize', () => {});
  });
}
```

(Este ejemplo muestra cómo un composable gestiona un efecto secundario (un listener de evento) y su limpieza en los hooks de ciclo de vida.)

## J - Restricciones de Uso

**Definición:** Los composables solo deben ser llamados dentro de `<script setup>` o la función setup() de la Options API, y deben ser llamados de forma síncrona. También pueden ser llamados en hooks de ciclo de vida como onMounted().

**Ejemplo:**

```Vue
<script setup>
import { useMyComposable } from './myComposable.js';

const { data } = useMyComposable();
</script>
```

(Este ejemplo muestra el uso correcto de un composable dentro de `<script setup>`.)

## K - Organización del Código

**Definición:** Los composables pueden ser utilizados para organizar el código de los componentes, dividiendo la lógica en funciones más pequeñas y manejables basadas en preocupaciones lógicas.

**Ejemplo:**

```Vue
<script setup>
import { useFeatureA } from './featureA.js';
import { useFeatureB } from './featureB.js';

const { foo } = useFeatureA();
const { bar } = useFeatureB(foo);
</script>
```

(Este ejemplo muestra cómo los composables pueden ser utilizados para organizar la lógica de un componente en funciones separadas.)

## L - Uso en Options API

**Definición:** Los composables pueden ser utilizados en la Options API llamándolos dentro de la función setup(), y los valores retornados deben ser retornados desde setup() para que estén disponibles en this y en la plantilla.

**Ejemplo:**

```JavaScript
import { useMouse } from './mouse.js';

export default {
  setup() {
    const { x, y } = useMouse();
    return { x, y };
  },
  mounted() {
    console.log(this.x);
  },
};
```

(Este ejemplo muestra cómo un composable se utiliza dentro de la Options API.)

## M - Comparación con Mixins

**Definición:** Los composables son una alternativa a los mixins de Vue 2, con ventajas como la claridad en la fuente de las propiedades, la ausencia de colisiones de nombres y la comunicación explícita entre composables.

**Ejemplo:**

(No hay un ejemplo de código específico, pero la definición explica las ventajas de los composables sobre los mixins.)

## N - Comparación con Componentes Renderless

**Definición:** Los composables son una alternativa a los componentes renderless, con la ventaja de no incurrir en la sobrecarga de una instancia de componente adicional. Los composables se utilizan para reutilizar lógica pura, mientras que los componentes se utilizan para reutilizar lógica y diseño visual.

**Ejemplo:**

(No hay un ejemplo de código específico, pero la definición explica las ventajas de los composables sobre los componentes renderless.)

## O - Comparación con React Hooks

**Definición:** Los composables de Vue son similares a los hooks de React en términos de composición de lógica, pero se basan en el sistema de reactividad de Vue, que es diferente del modelo de ejecución de los hooks de React.

**Ejemplo:**

(No hay un ejemplo de código específico, pero la definición explica la similitud y diferencia entre composables y hooks.)
