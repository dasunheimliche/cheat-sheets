## A - Composable

**Definición:** Un "composable" en Vue es una función que utiliza la Composition API para encapsular y reutilizar lógica con estado. Imagina un "kit de herramientas" que contiene funciones para manejar la información y el comportamiento de tu aplicación, pero que puedes usar en cualquier parte. A diferencia de las funciones que solo toman datos y devuelven un resultado (lógica sin estado), los composables gestionan datos que cambian con el tiempo (lógica con estado), como la posición del ratón o el estado de una conexión a internet.

**Ejemplo:**

```js
// mouse.js
import { ref, onMounted, onUnmounted } from "vue";

export function useMouse() {
  const x = ref(0);
  const y = ref(0);

  function update(event) {
    x.value = event.pageX;
    y.value = event.pageY;
  }

  onMounted(() => window.addEventListener("mousemove", update));
  onUnmounted(() => window.removeEventListener("mousemove", update));

  return { x, y };
}
```

**Descripción del ejemplo:**
Este `composable`, llamado `useMouse`, rastrea la posición del ratón en la ventana.

1.  `ref(0)`: Crea dos variables reactivas `x` e `y` inicializadas en 0. Estas variables guardarán las coordenadas del ratón.
2.  `update(event)`: Función que se ejecuta cada vez que se mueve el ratón, actualizando `x.value` e `y.value` con las coordenadas actuales del evento.
3.  `onMounted`: Hook de ciclo de vida que se ejecuta cuando el componente se monta en el DOM. En este hook, se agrega un listener de eventos 'mousemove' que llama a la función `update`.
4.  `onUnmounted`: Hook de ciclo de vida que se ejecuta cuando el componente se desmonta. Aquí, se elimina el listener de eventos 'mousemove', evitando fugas de memoria y comportamientos inesperados.
5.  `return { x, y }`: El composable retorna un objeto con las referencias reactivas `x` e `y`, permitiendo que el componente que lo usa acceda y visualice las coordenadas del ratón de manera reactiva.

## B - Lógica con Estado (Stateful Logic)

**Definición:** Es la lógica que maneja datos que cambian con el tiempo y que impactan el comportamiento de una aplicación. Imagina un "termómetro" que registra y muestra la temperatura actual; la temperatura cambia, y esta información actualizada afecta lo que el termómetro muestra. Similarmente, en programación, la lógica con estado se encarga de controlar variables que se modifican con el tiempo, como la entrada de un usuario, la posición del ratón, el estado de una llamada a una API o la información de una sesión de usuario.

**Ejemplo:** El ejemplo de `useMouse` de arriba.

**Descripción del ejemplo:** En este caso, las coordenadas `x` e `y` cambian cada vez que se mueve el ratón. Esta información, que se va actualizando, representa el estado de la aplicación. El composable `useMouse` gestiona ese estado: lo inicializa, lo actualiza y lo provee a los componentes que lo necesitan.

## C - Lógica sin Estado (Stateless Logic)

**Definición:** Es la lógica que transforma datos sin cambiar su propio estado interno. Piensa en una "calculadora" que recibe números y devuelve un resultado, pero no almacena ni recuerda ninguna operación anterior. En programación, una función sin estado es aquella que siempre devuelve el mismo resultado para las mismas entradas y no guarda datos entre llamadas. La función `formatDate(date)` es un ejemplo, ya que siempre devolverá la misma fecha formateada para la misma fecha de entrada.

**Ejemplo:**

```js
// formatter.js
export function formatDate(date) {
  return new Intl.DateTimeFormat("en-US", {
    year: "numeric",
    month: "long",
    day: "numeric",
  }).format(date);
}
```

**Descripción del ejemplo:** Esta función `formatDate` toma una `date` y devuelve una representación formateada de esa fecha. No almacena ninguna información interna ni modifica el valor de `date`. Siempre que la entrada sea la misma, la salida será la misma.

## D - Composition API

**Definición:** Es un conjunto de APIs de Vue 3 que permiten componer la lógica de un componente de forma flexible y reutilizable. Es como tener un "lego" para construir componentes, donde cada "pieza" (API) tiene una función específica y se pueden combinar para crear comportamientos complejos. A diferencia del Options API, donde la lógica está dispersa en diferentes opciones como `data`, `methods` y `computed`, la Composition API permite agrupar la lógica relacionada dentro de funciones (`setup` y `composables`).

**Ejemplo:** En el ejemplo de `useMouse`, estamos utilizando APIs de la Composition API como `ref`, `onMounted` y `onUnmounted`.

**Descripción del ejemplo:** Estas APIs nos permiten crear variables reactivas (`ref`), registrar hooks de ciclo de vida (`onMounted`, `onUnmounted`) y encapsular lógica que podemos reutilizar en otros componentes.

## E - `ref`

**Definición:** `ref` es una función de la Composition API que crea una referencia reactiva a un valor. Es como una "caja mágica" que contiene un dato y que te avisa cada vez que el dato dentro cambia. Al acceder a la propiedad `.value` de esta caja, obtienes el valor actual del dato, y cualquier cambio que hagas a esta propiedad se reflejará automáticamente en la interfaz de usuario.

**Ejemplo:**
`const x = ref(0);`

**Descripción del ejemplo:** Esta línea crea una referencia reactiva llamada `x` y la inicializa con el valor 0. Al acceder a `x.value` obtendremos el valor 0, y al cambiarlo con `x.value = 10` cualquier componente que use esta referencia se actualizará automáticamente.

## F - `onMounted`

**Definición:** `onMounted` es un hook del ciclo de vida de un componente en la Composition API que se ejecuta después de que el componente ha sido montado en el DOM (Document Object Model). Imagínalo como un "evento de inicio" que se dispara cuando tu componente ya está "en la pantalla". Es el lugar perfecto para hacer cosas que requieran que el componente esté presente en el DOM, como añadir event listeners o iniciar animaciones.

**Ejemplo:**

```js
onMounted(() => {
  console.log("El componente se ha montado");
  window.addEventListener("mousemove", update);
});
```

**Descripción del ejemplo:** En el ejemplo de `useMouse`, el código dentro de `onMounted` se ejecuta después de que el componente que usa `useMouse` se monta. En este caso, se agrega un listener de eventos 'mousemove' al objeto `window` para detectar cuando el ratón se mueve.

## G - `onUnmounted`

**Definición:** `onUnmounted` es un hook de ciclo de vida que se ejecuta justo antes de que un componente sea desmontado del DOM. Es como una "fiesta de despedida" que ocurre cuando un componente está a punto de "irse de la pantalla". Este hook es fundamental para limpiar o anular cualquier efecto secundario que se haya creado en el componente, como eliminar event listeners para evitar fugas de memoria.

**Ejemplo:**

```js
onUnmounted(() => {
  console.log("El componente se va a desmontar");
  window.removeEventListener("mousemove", update);
});
```

**Descripción del ejemplo:** En el ejemplo de `useMouse`, el código dentro de `onUnmounted` se ejecuta justo antes de que el componente que usa `useMouse` se desmonte. Aquí se elimina el listener de eventos 'mousemove' del objeto `window`, previniendo fugas de memoria y errores.

## H - `useEventListener`

**Definición:** Es un composable que encapsula la lógica de agregar y eliminar listeners de eventos, haciendo más fácil la gestión de los mismos. Piensa en ello como un "gestor de eventos" que te ayuda a no olvidar añadir y quitar los listeners.

**Ejemplo:**

```js
// event.js
import { onMounted, onUnmounted } from "vue";

export function useEventListener(target, event, callback) {
  onMounted(() => target.addEventListener(event, callback));
  onUnmounted(() => target.removeEventListener(event, callback));
}
```

**Descripción del ejemplo:** `useEventListener` es un composable genérico que se encarga de agregar un event listener al `target` especificado en `onMounted` y removerlo en `onUnmounted`, ejecutando la `callback` cada vez que el evento sucede. Esto ayuda a que nuestros componentes se limpien a sí mismos al desmontarse.

## I - `watchEffect`

**Definición:** `watchEffect` es una función de la Composition API que ejecuta una función de callback cada vez que alguna de sus dependencias reactivas cambia. Imagina que es como un "vigilante" que está pendiente de ciertas variables y cuando alguna cambia, inmediatamente dispara una acción (la función de callback). Es similar a un `watch`, pero sin necesidad de especificar las dependencias explicitamente, ya que `watchEffect` las detecta automáticamente durante su ejecución.

**Ejemplo:**

```js
watchEffect(() => {
  console.log(`El valor de url es: ${toValue(url)}`);
  fetchData();
});
```

**Descripción del ejemplo:** Cada vez que `url` cambie (o cualquier otra variable reactiva usada dentro de `fetchData()`), el `watchEffect` ejecutará la función de callback. Esto permite que las funciones de fetch se ejecuten cada vez que la url cambie, actualizando los datos de manera reactiva.

## J - `toValue`

**Definición:** `toValue` es una función de utilidad de la Composition API que normaliza diferentes tipos de valores (refs, getters, o valores directos) a su valor real. Es como un "traductor" que convierte cualquier tipo de dato a su valor actual. Si le pasas un `ref`, devuelve su valor; si le pasas una función getter, llama a la función y devuelve su resultado, y si le pasas un valor normal, lo devuelve tal cual. Esto es útil para hacer que los composables sean más flexibles al aceptar diferentes tipos de entradas.

**Ejemplo:**

```js
const url = ref("/initial-url");

const { data, error } = useFetch(url);

// this should trigger a re-fetch
url.value = "/new-url";
```

**Descripción del ejemplo:** Aquí, la variable `url` es un ref, la `toValue()` de nuestro `useFetch` hará que `useFetch` pueda entender y reaccionar a estos valores reactivos o a la función que genera la url de una manera consistente.

## K - Mixins

**Definición:** En Vue 2, los mixins eran una forma de reutilizar código de componente. Imagina que eran como "pegatinas" que podías añadir a tus componentes, dándoles funcionalidades extra. Sin embargo, presentaban varios problemas, como la falta de claridad sobre qué propiedades provenían de qué mixin, colisiones de nombres y acoplamiento implícito. Por estas razones, los composables son la opción recomendada en Vue 3.

**Ejemplo:** Un mixin podría incluir una propiedad `count` y un método `increment`. Los componentes que usaran este mixin tendrían automáticamente acceso a esta propiedad y método.

**Descripción del ejemplo:** Los mixins eran una forma de reusar código, pero no eran tan flexibles como los composables. Los composables nos permiten crear una lógica más modular, con menos colisiones de nombres y mejor organización.

## L - Renderless Components

**Definición:** Son componentes que encapsulan lógica pero no renderizan nada por sí mismos. Utilizan slots para pasar la lógica a componentes que sí se encargan del renderizado. Imagina que son como "cerebros" que proveen la lógica de un componente sin preocuparse por la apariencia, dejando esta tarea a los componentes que los usan. Aunque útiles, generan cierta sobrecarga por la creación de instancias extra de componentes, por lo que los composables son más eficientes para lógica pura.

**Ejemplo:** Un componente renderless podría manejar la lógica de un slider, pasando los valores actuales a través de slots a los componentes que se encargan de la apariencia del slider.

**Descripción del ejemplo:** Los renderless components son útiles para compartir lógica y ui, pero no tan optimos como los composables para lógica pura. Los composables evitan la creación de nuevas instancias de componentes, optimizando el rendimiento de la app.
