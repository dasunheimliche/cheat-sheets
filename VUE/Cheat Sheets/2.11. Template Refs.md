## A - Template Refs

**Definición:** Los template refs son una forma de obtener referencias directas a elementos del DOM o instancias de componentes hijos después de que han sido montados en Vue. Piensa en ellos como "etiquetas" que colocas en el HTML y luego puedes "encontrar" para manipular o leer. Son útiles cuando necesitas interactuar directamente con el DOM o acceder a funcionalidades de un componente hijo. **Imagina que necesitas un carnet de acceso (el ref) para entrar a la oficina (elemento DOM o instancia del componente) desde el exterior de ella.**

**Ejemplo:**

```vue
<script setup>
import { useTemplateRef, onMounted } from "vue";

const input = useTemplateRef("my-input");

onMounted(() => {
  input.value.focus();
});
</script>

<template>
  <input ref="my-input" />
</template>
```

**Descripción del ejemplo:** En este ejemplo, `ref="my-input"` asigna un "carnet de acceso" llamado "my-input" al elemento input. En el `<script>`, `useTemplateRef('my-input')` se usa para conseguir la referencia al elemento. `onMounted()` garantiza que el acceso ocurre una vez que el componente está montado. Finalmente, `input.value.focus()` permite enfocar programáticamente ese elemento.

## B - Accessing the Refs

**Definición:** Para acceder a una referencia de template, debes utilizar la función `useTemplateRef()` en el Composition API de Vue 3. Si estás en una versión anterior a la 3.5, necesitas crear una ref normal con el nombre que coincida al del `ref` en el template, y también recordar el acceder al elemento con el modificador `.value`, o a través de `this.$refs`. En Options API, las refs son accedidas mediante `this.$refs`. **Piensa que si tienes un "carnet" debes usar una puerta (el `.value` o el `$refs`) específica para usarlo.**

**Ejemplo 1 (Composition API, Vue 3.5+):**

```vue
<script setup>
import { useTemplateRef, onMounted } from "vue";

const myInput = useTemplateRef("inputField");

onMounted(() => {
  console.log(myInput.value); // Referencia al elemento input
  myInput.value.focus();
});
</script>

<template>
  <input ref="inputField" type="text" />
</template>
```

**Descripción del ejemplo 1:** `useTemplateRef('inputField')` obtiene la referencia del input identificado con `ref="inputField"`. El `.value` accede al elemento HTML. `onMounted` asegura el acceso después que el DOM sea generado, y lo usa para dar foco al input.

**Ejemplo 2 (Composition API, Vue < 3.5):**

```vue
<script setup>
import { ref, onMounted } from "vue";

const input = ref(null);

onMounted(() => {
  console.log(input.value);
  if (input.value) input.value.focus();
});
</script>

<template>
  <input ref="input" type="text" />
</template>
```

**Descripción del ejemplo 2:** Se declara `const input = ref(null)`, y su nombre debe ser igual a la referencia usada en template, en este caso `ref="input"`. Como siempre `onMounted` nos permite asegurarnos que tenemos el nodo listo en el DOM y `input.value` es lo que contiene la referencia al input como elemento HTML. Se hace la validación porque puede no existir.

**Ejemplo 3 (Options API):**

```vue
<script>
export default {
  mounted() {
    console.log(this.$refs.input);
    this.$refs.input.focus();
  },
};
</script>

<template>
  <input ref="input" type="text" />
</template>
```

**Descripción del ejemplo 3:** `this.$refs.input` obtiene la referencia. Igualmente en Options API el acesso se hace tras el montaje por lo que se aprovecha `mounted`.

**Advertencia Importante:** ¡Solo puedes acceder a la ref **después** de que el componente haya sido montado! En un principio será `null` o `undefined`.

## C - Refs inside v-for

**Definición:** Cuando usas `ref` dentro de un `v-for`, la referencia obtenida es **un array** que contiene todos los elementos generados. Cada elemento del array se corresponde con cada uno de los elementos iterados en el `v-for`. Imagina que, en vez de un solo "carnet de acceso", tienes una lista de ellos, una por cada elemento. **Es como si el portero te entregara un paquete de tarjetas en vez de una sola.**

**Ejemplo:**

```vue
<script setup>
import { ref, useTemplateRef, onMounted } from "vue";

const list = ref(["A", "B", "C"]);

const itemRefs = useTemplateRef("items");

onMounted(() => console.log(itemRefs.value));
</script>

<template>
  <ul>
    <li v-for="item in list" ref="items">
      {{ item }}
    </li>
  </ul>
</template>
```

**Descripción del ejemplo:** `ref="items"` se aplica a cada `<li>` dentro del bucle `v-for`. `useTemplateRef('items')` almacena la referencia a cada elemento en `itemRefs.value` como un array que contendrá las referencias a cada elemento. `onMounted` garantiza el acceso a la referencia después del montaje del componente. Se puede ver que en este ejemplo, `console.log(itemRefs.value)` nos da acceso a `HTMLCollection[<li>,<li>,<li>]`.

**Advertencia Importante:** El orden del array de referencias no siempre será igual al orden de la lista original. No puedes asumir que el elemento en `itemRefs[0]` siempre coincida con el primer elemento de la lista usada con el `v-for` **Imagina que al repartir las tarjetas no van ordenadas en el paquete.**

## D - Function Refs

**Definición:** En lugar de usar un nombre como un `string`, el atributo `ref` se puede vincular a una función. Esta función recibe el elemento o instancia como el primer argumento. Esto da una total libertad para donde guardar la referencia. Piensa que, en vez de ser el carnet con una dirección a una caja con los nombres de referencia, tú mismo (la función) eres quien decide qué hacer con la referencia, dónde la vas a dejar, por ejemplo, si a una variable, etc.. **Imagina que en vez de darle el carnet a un portero para que la guarde en una caja etiquetada, el portero te da a ti la tarjeta en mano, y decides dónde la guardarás, o qué vas a hacer con ella**

**Ejemplo:**

```vue
<script setup>
import { ref, onMounted } from "vue";
const inputRef = ref(null);

onMounted(() => console.log("Function ref example mounted", inputRef.value));
</script>
<template>
  <input
    :ref="
      (el) => {
        inputRef.value = el;
      }
    "
  />
</template>
```

**Descripción del ejemplo:**`:ref="(el) => { inputRef.value = el; }"` enlaza a una función anónima que usa el argumento el, el cual se asigna a la ref declarada anteriormente llamada `inputRef`. De este modo, hemos guardado una referencia del input de una forma personalizada. `onMounted` garantiza la referencia esté disponible tras el montaje del DOM, y permite inspeccionar en el ejemplo, que la referencia del elemento haya sido guardada como un nodo html correctamente, tal como ` <input />`.

## E - Ref on Component

**Definición:** Cuando el `ref` es usado en un componente hijo, la referencia resultante es una instancia del componente, no un elemento del DOM. **En lugar de tener un "carnet de acceso" para una oficina (elemento HTML) tienes el carnet para toda una compañía (componente). Con ese "carnet" tienes acceso al director de la empresa y con él a muchos otros elementos** A través de ella podrás acceder a los datos expuestos por este. Es recomendable tener precaución al interactuar directamente entre padre e hijo mediante refs, pues lo adecuado es usar props y eventos. Los componentes definidos con `<script setup>` son privados, a no ser que usen `defineExpose()`.

**Ejemplo (Composition API):**

```vue
<!-- Parent Component -->
<script setup>
import { useTemplateRef, onMounted } from "vue";
import ChildComponent from "./ChildComponent.vue"; //importamos el hijo

const childRef = useTemplateRef("child"); //creamos la referencia
onMounted(() => {
  console.log("ref al hijo:", childRef.value);
  childRef.value.sayHi("Juan");
});
</script>

<template>
  <ChildComponent ref="child" />
</template>

<!-- Child Component (ChildComponent.vue) -->
<script setup>
import { ref } from "vue";
const msg = ref("Hello world!");
//usamos el macro para exponer propiedades y funciones
defineExpose({
  sayHi: (name) => {
    alert(`Hello from Child ${name}! ${msg.value}`);
  },
});
</script>
```

**Descripción del ejemplo:** En el componente padre se define `childRef = useTemplateRef('child')`, y en su plantilla se establece que en el `<ChildComponent  ref="child"/>`, el nombre `child` es el usado. Gracias al `useTemplateRef`, guardamos en childRef, la referencia, `onMounted` se ejecuta una vez que el DOM del hijo existe y nos permite la interacción. Desde `childRef.value`, podemos usar todas las funciones expuestas por `defineExpose()` del hijo, como el caso de `sayHi()`. El hijo, a su vez, declara el valor `msg`, la cual al estar declarada por fuera del scope de `defineExpose()` será privado para su consumo y solo visible si así fuera necesitado dentro de una funcion pública.
**Nota** El caso contrario de si el hijo estuviese hecho sin `script setup`, donde todos los elementos públicos del hijo quedarían visibles, en particular datos del `data()`, o métodos.
