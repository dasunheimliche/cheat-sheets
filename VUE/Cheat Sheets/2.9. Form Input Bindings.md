## A - `v-model` Directive

**Definición:** `v-model` es una directiva de Vue.js que crea un "puente" automático entre el valor de un elemento de formulario (como un input, textarea, select, etc.) y una propiedad de datos en tu componente. Piensa en `v-model` como un sistema de dos vías: cualquier cambio en el formulario actualiza la data, y cualquier cambio en la data actualiza el formulario. Es como tener un control remoto que sincroniza lo que ves en la tele con lo que quieres ver. Esto nos ahorra escribir mucho código repetitivo de listeners de eventos.

**Ejemplo:**

```html
<template>
  <input v-model="nombre" type="text" />
  <p>Hola, {{ nombre }}</p>
</template>

<script>
  export default {
    data() {
      return {
        nombre: "",
      };
    },
  };
</script>
```

**Descripción del ejemplo:** Aquí, `v-model` vincula el `input` con la propiedad `nombre`. Si escribes algo en el `input`, `nombre` cambia en la data. El párrafo `p` usa la data de `nombre` para mostrar "Hola, [lo que escribiste]". Si modificas `nombre` directamente en el script, el `input` se actualizará también.

## B - Tipos de Input con `v-model`

**Definición:** `v-model` funciona de manera inteligente dependiendo del tipo de elemento de formulario:

- **Text / Textarea**: usa la propiedad `value` y el evento `input`. Es decir, cada vez que escribas, se actualiza la data.
- **Checkbox / Radio**: usa la propiedad `checked` y el evento `change`. Es decir, solo actualiza la data cuando cambias de "checked" a "no checked", o viceversa.
- **Select**: usa `value` como prop y `change` como evento, actualizando la data cuando se selecciona otra opción.
  Analogía: Imagina que cada input tiene un interruptor distinto: el input text (como la luz de la habitación) se enciende o apaga conforme lo usas, mientras que el check y el radio se activan al presionar el interruptor por completo. Select es una perilla: al girar seleccionas otro valor.

**Ejemplo:**

```html
<template>
  <input type="text" v-model="texto" /> <br />
  <textarea v-model="textArea"></textarea> <br />
  <input type="checkbox" v-model="check" /> Check <br />
  <input type="radio" value="op1" v-model="radio" /> Opción 1
  <input type="radio" value="op2" v-model="radio" /> Opción 2<br />
  <select v-model="select">
    <option value="val1">Valor 1</option>
    <option value="val2">Valor 2</option>
  </select>
  <p>Text: {{ texto }}</p>
  <p>Text Area: {{ textArea }}</p>
  <p>Check: {{ check }}</p>
  <p>Radio: {{ radio }}</p>
  <p>Select: {{ select }}</p>
</template>

<script>
  export default {
    data() {
      return {
        texto: "",
        textArea: "",
        check: false,
        radio: null,
        select: "val1",
      };
    },
  };
</script>
```

**Descripción del ejemplo:** Este ejemplo demuestra el uso de `v-model` en diversos elementos. Cada input está vinculado a una propiedad de data, mostrando que el comportamiento cambia según el tipo. Un cambio en el input de texto o en el `textArea`, por ejemplo, actualiza las variables `texto` y `textArea`. El radio usa los atributos de `value`, mientras que el check funciona con true y false, y el select selecciona de las diferentes opciones.

## C - `v-model` y valores iniciales

**Definición:** Es importante recordar que `v-model` ignora los atributos `value`, `checked`, o `selected` iniciales de HTML. La "verdad" siempre proviene del estado Javascript vinculado con `v-model`, la fuente de la data es lo que le digas a vue. Analogía: El estado de Vue es la base de datos de todo. Si intentas setear un valor desde el HTML este será ignorado: todo viene y va del `data`.

**Ejemplo:**

```html
<template>
  <!--El valor "valorInicial" de abajo es IGNORADO-->
  <input v-model="mensaje" value="valorInicial" type="text" />
  <p>{{mensaje}}</p>
</template>

<script>
  export default {
    data() {
      return {
        mensaje: "valorReal",
      };
    },
  };
</script>
```

**Descripción del ejemplo:** En este ejemplo, el `input` tiene `value="valorInicial"` en el HTML, pero debido al data `mensaje:'valorReal'` es este ultimo valor el que prevalece en el template. `v-model` se asegurará que este valor se mantenga incluso despues de un nuevo input, por ende cualquier cosa que escribas será el valor actualizado. Esto resalta que debes definir valores iniciales usando la propiedad `data`.

## D - `v-model` con `true-value` y `false-value`

**Definición:** Para los `checkbox`, puedes cambiar los valores predeterminados `true/false` usando `true-value` y `false-value`. Puedes asignar dinámicamente los valores con `:true-value` y `:false-value` respectivamente. Estos atributos no se aplican al input html, sino al cambio de datos con `v-model`.. Esto te permite controlar que valor toman las variables en vez de true y false cuando es marcado.
Analía: Es como personalizar tu propia caja de verdad o mentira: decides que valor tomará la variable cuando se marca, o no, la casilla.

**Ejemplo:**

```html
<template>
  <input type="checkbox" v-model="estado" true-value="si" false-value="no" /> {{
  estado }}
  <input
    type="checkbox"
    v-model="estadoDos"
    :true-value="variableTrue"
    :false-value="variableFalse"
  />{{estadoDos}}
</template>

<script>
  export default {
    data() {
      return {
        estado: "no",
        estadoDos: "falso",
        variableTrue: "verdadero",
        variableFalse: "falso",
      };
    },
  };
</script>
```

**Descripción del ejemplo:** Aqui, si marcamos el primer checkbox el valor de `estado` será 'si' (string), si lo desmarcamos, 'no'. En el segundo check, al activarlo su valor será "verdadero", de otra forma "falso". Ambos utilizan data que contienen las diferentes string que personalizan sus resultados.

## E - `v-model` con modificadores: `.lazy`, `.number`, `.trim`

**Definición:** Los modificadores de `v-model` nos ofrecen una funcionalidad extra: - **`.lazy`:** Sincroniza la data con el `input` solamente cuando ocurre el evento `change` en vez de `input`. Útil para esperar hasta que el usuario termine de escribir. - **`.number`:** Convierte el valor del input en un número. Si no es posible convertirlo, mantiene el string original. - **`.trim`:** Elimina los espacios al inicio y al final del input.

Imagínalos como mini-herramientas adicionales dentro de `v-model`.

**Ejemplo:**

```html
<template>
  <input type="text" v-model.lazy="mensajeLazy" placeholder="Lazy update" />
  <p>Lazy Value: {{ mensajeLazy }}</p>
  <input type="text" v-model.number="edad" placeholder="Solo numeros" />
  <p>Edad: {{ edad }} - Tipo de data :{{typeof edad}}</p>
  <input type="text" v-model.trim="mensajeTrim" placeholder="Sin espacios" />
  <p>Con espacios eliminados: -{{ mensajeTrim }}-</p>
</template>

<script>
  export default {
    data() {
      return {
        mensajeLazy: "",
        edad: "",
        mensajeTrim: "",
      };
    },
  };
</script>
```

**Descripción del ejemplo:** `mensajeLazy` se actualiza solo al sacar el foco del `input`. `edad` intenta guardar un número; veras que el typeof mostrará string si introduces texto, mientras que el número hará un typeof "number". Por último, `mensajeTrim` tendrá los espacios eliminados, por lo cual "- hola -" resultará "-hola-".

## F - `v-model` en componentes

**Definición:** `v-model` también se puede usar con componentes propios, esto extiende su poder a lo largo de nuestra aplicación. La función sigue siendo la misma: crea una conección de doble vía entre el componente y la data principal de la app. De la misma manera, para implementarlo tenemos que usar el atributo prop `modelValue`, que permite interactuar y sincronizar la variable deseada con la directiva v-model
Imagínalo como un `v-model` "portátil": puedes crear componentes que se comportan como elementos nativos, pudiendo reusar inputs complejos de la misma manera que inputs básicos de HTML.

**Ejemplo:**

```html
//Componente MyInput.vue
<template>
  <input
    type="text"
    :value="modelValue"
    @input="$emit('update:modelValue',$event.target.value)"
  />
</template>

<script>
  export default {
    props: {
      modelValue: String,
    },
    emits: ["update:modelValue"],
  };
</script>

// En un componente Padre.vue
<template>
  <MyInput v-model="padreVariable" />
  <p>padreVariable {{padreVariable}}</p>
</template>
<script>
  import MyInput from "./MyInput.vue";
  export default {
    components: { MyInput },
    data() {
      return {
        padreVariable: "inicial",
      };
    },
  };
</script>
```

**Descripción del ejemplo:** El componente `MyInput` declara un prop `modelValue` para obtener datos y al emite evento 'update:modelValue' (es obligatorio llamarlo así para funcionar). El padre en cambio utiliza este componente de la misma manera en que usamos los inputs base de HTML. Al modificar `MyInput` modificaremos la `padreVariable`. Si bien este código necesita mas conceptos de vue, ilustra cómo reutilizar y sincronizar components con la magia de `v-model`.
