## A - Props

**Definición:** Los "props" son atributos que se pasan a un componente hijo desde su componente padre. Imagina que estás construyendo con bloques de LEGO: los props son como las instrucciones o las piezas adicionales que le das a un bloque hijo para que sepa qué forma debe tener o qué función debe cumplir. Permiten que los componentes sean más reutilizables y configurables.

**Ejemplo:**

```vue
// Componente hijo: MyComponent.vue
<script setup>
const props = defineProps({
  message: String,
  count: Number,
});

console.log(props.message);
console.log(props.count);
</script>

<template>
  <p>Mensaje: {{ message }}</p>
  <p>Contador: {{ count }}</p>
</template>
```

```vue
// Componente padre: App.vue
<template>
  <MyComponent message="Hola mundo" :count="10" />
</template>

<script setup>
import MyComponent from "./MyComponent.vue";
</script>
```

**Descripción del ejemplo:** En este ejemplo, `MyComponent` recibe dos props: `message` (tipo String) y `count` (tipo Number). El componente padre, `App.vue`, pasa los valores `"Hola mundo"` y `10` respectivamente. Los props permiten al componente hijo mostrar información diferente en función de los valores que recibe del padre. Es como personalizar un bloque de LEGO con calcomanías y otros accesorios.

## B - defineProps()

**Definición:** `defineProps()` es una macro de Vue que se utiliza en componentes que usan `<script setup>` para declarar los props que el componente puede recibir. Piensa en ello como la "lista de requerimientos" de un componente: define qué tipo de datos (como String, Number, etc.) y qué nombres de atributos debe aceptar. Es como indicar el tipo de conector que necesitas para un dispositivo.

**Ejemplo:**

```vue
<script setup>
const props = defineProps({
  title: String,
  items: Array,
  isEnabled: Boolean,
});
</script>
```

**Descripción del ejemplo:** En este ejemplo, `defineProps` declara que el componente acepta tres props: `title` (de tipo String), `items` (de tipo Array) e `isEnabled` (de tipo Boolean). Esta declaración permite a Vue saber que estos atributos son props y les da información para validar y reaccionar a sus cambios. Es como especificar el tipo de clavija para que el enchufe funcione correctamente.

## C - props (Option API)

**Definición:** En la Option API, `props` es una opción de configuración dentro del objeto del componente que cumple la misma función que `defineProps()` en `<script setup>`, es decir, declarar los props que un componente puede recibir. Es como tener un formulario en donde especificas que campos son los que puedes rellenar al usar el componente.

**Ejemplo:**

```js
export default {
  props: {
    name: String,
    age: Number,
    address: Object,
  },
  created() {
    console.log(this.name);
    console.log(this.age);
    console.log(this.address);
  },
};
```

**Descripción del ejemplo:** En este ejemplo, la propiedad `props` dentro del objeto de configuración declara tres props: `name` (String), `age` (Number) y `address` (Object). En `created()`, podemos acceder a estos props utilizando `this`. Es la manera en que la Option API te permite configurar qué datos pueden entrar a un componente.

## D - Destructuración Reactiva de Props

**Definición:** Es una característica de Vue 3.5+ que permite destructurar props declarados con `defineProps` en variables reactivas. Antes de Vue 3.5, al destructurar props se perdía la reactividad. Imagina que ahora puedes desempacar una caja de regalos y los elementos dentro permanecen "vivos", es decir, se actualizan automáticamente cuando el regalo cambia.

**Ejemplo:**

```vue
<script setup>
const { title, items } = defineProps({
  title: String,
  items: Array,
});

watchEffect(() => {
  console.log("El titulo ha cambiado:", title); // `title` es reactivo
  console.log("Los items han cambiado:", items); // `items` es reactivo
});
</script>
```

**Descripción del ejemplo:** Al destructurar `title` e `items`, estas variables se vuelven reactivas. `watchEffect` detectará cambios en ellos y ejecutará el callback, lo que no sucedía antes de Vue 3.5. Es como tener sensores en los regalos que te avisan cuando algo cambia dentro de la caja.

## E - Nombre de Props: camelCase vs kebab-case

**Definición:** Es la forma en que nombramos los props, ya sea con camelCase (ej: `greetingMessage`) en la declaración del componente, o kebab-case (ej: `greeting-message`) al pasar props en el template. CamelCase facilita la lectura en código JavaScript y kebab-case en HTML. Es como usar diferentes idiomas en diferentes contextos.

**Ejemplo:**

```js
// Declaración de props (camelCase):
defineProps({
  greetingMessage: String,
});

// Uso de props en el template (kebab-case):
<MyComponent greeting-message="Hola" />;
```

**Descripción del ejemplo:** Al declarar un prop como `greetingMessage` en el script del componente, lo podemos usar directamente como `greetingMessage` dentro de las expresiones del template. Pero al pasar el prop desde un componente padre, usamos kebab-case como en `greeting-message="Hola"`, siguiendo las convenciones del HTML.

## F - Props Estáticos vs Dinámicos

**Definición:** Los props estáticos son aquellos que tienen un valor fijo, mientras que los props dinámicos obtienen sus valores de variables o expresiones JavaScript. Es como tener una imagen en la pared (estático) versus un proyector que muestra diferentes imágenes (dinámico).

**Ejemplo:**

```vue
<template>
  <!-- Prop estático -->
  <BlogPost title="Mi viaje con Vue" />

  <!-- Prop dinámico -->
  <BlogPost :title="post.title" />
</template>
<script setup>
import { ref } from "vue";
const post = ref({
  title: "Ejemplo de props dinámicos",
});
</script>
```

**Descripción del ejemplo:** En el ejemplo, `title="Mi viaje con Vue"` es un prop estático, pues el valor es una cadena literal. `:` (o `v-bind:`) hace que `title` sea dinámico y obtenga su valor de la variable `post.title`. Los props dinámicos son como "enchufes" que cambian según el contexto.

## G - Tipos de Valores para Props

**Definición:** Los props pueden recibir cualquier tipo de valor JavaScript: números, booleanos, arrays, objetos, funciones, etc. Imagina que los props son como contenedores que pueden guardar diferentes tipos de objetos. Esto hace que los componentes sean muy versátiles.

**Ejemplo:**

```vue
<template>
  <MyComponent
    :count="42"
    :isValid="true"
    :items="['a', 'b', 'c']"
    :user="{ name: 'John' }"
  />
</template>

<script setup>
defineProps({
  count: Number,
  isValid: Boolean,
  items: Array,
  user: Object,
});
</script>
```

**Descripción del ejemplo:** En este caso, el componente `MyComponent` recibe un número (`count`), un booleano (`isValid`), un array (`items`), y un objeto (`user`) como props, mostrando la versatilidad del sistema de props de Vue. Cada uno de estos valores es como una pieza diferente en un rompecabezas.

## H - Vinculación de Múltiples Props con un Objeto

**Definición:** Se puede usar `v-bind` sin argumentos para pasar las propiedades de un objeto como props de un componente. Esto es muy útil para evitar tener que pasar prop por prop cuando tenemos muchos datos. Es como tener una caja de herramientas que se convierte en un conjunto de llaves individuales al instante.

**Ejemplo:**

```vue
<template>
  <BlogPost v-bind="post" />
</template>

<script setup>
import { ref } from "vue";
const post = ref({
  id: 1,
  title: "Mi post",
  author: "John Doe",
});
</script>
```

**Descripción del ejemplo:** En este caso, `v-bind="post"` pasa `post.id`, `post.title` y `post.author` como props del componente `BlogPost`, sin tener que escribirlos individualmente. Es como tener un "copiadora" que replica todos los atributos de un objeto a un componente.

## I - Flujo de Datos Unidireccional

**Definición:** Los props en Vue siguen un flujo de datos unidireccional, es decir, los datos fluyen del padre al hijo, pero no al revés. Esto previene mutaciones accidentales en el estado del padre. Imagina que los props son como flechas que solo apuntan del padre al hijo, evitando que el hijo modifique al padre directamente.

**Ejemplo:** En un componente hijo, no se debe hacer `props.foo = 'bar'`, porque eso intentaría mutar el prop directamente. En vez, se debe usar datos locales o avisar al padre para que actualice el dato.

**Descripción del ejemplo:** Este flujo unidireccional ayuda a que el estado de la aplicación sea más fácil de entender y depurar, ya que los cambios en los datos siguen un camino claro. Es como tener un sistema de tuberías donde el agua solo fluye en una dirección.

## J - Validación de Props

**Definición:** Vue permite definir reglas para validar los props, como tipos de datos, si son requeridos o valores por defecto. Esto ayuda a detectar errores en el desarrollo y crea componentes más robustos. Es como tener un controlador de calidad que asegura que los props cumplan con las especificaciones antes de que el componente los use.

**Ejemplo:**

```js
defineProps({
  age: {
    type: Number,
    required: true,
    default: 0,
  },
  status: {
    type: String,
    validator: (value) => ["active", "inactive"].includes(value),
  },
});
```

**Descripción del ejemplo:** Aquí, el prop `age` debe ser un número, es requerido y tiene un valor por defecto de `0`. El prop `status` debe ser un string y su valor solo puede ser `active` o `inactive`. Si estos requisitos no se cumplen, Vue mostrará avisos en la consola. Es como tener una lista de especificaciones para cada pieza de un mecanismo.

## K - Boolean Casting

**Definición:** Es una característica de Vue que permite que los props de tipo `Boolean` se comporten como atributos booleanos HTML. Si se incluye el prop sin valor, se considera `true`; si no se incluye, se considera `false`. Es como tener un interruptor de luz: encendido (true) o apagado (false).

**Ejemplo:**

```vue
// Componente hijo: MyComponent.vue
<script setup>
const props = defineProps({
  isDisabled: Boolean,
});
</script>

// Componente padre
<template>
  <!-- isDisabled es true -->
  <MyComponent isDisabled />

  <!-- isDisabled es false -->
  <MyComponent />

  <!-- isDisabled es false -->
  <MyComponent :isDisabled="false" />
</template>
```

**Descripción del ejemplo:** Si se incluye `disabled` sin valor, se infiere que `isDisabled` es `true`; si no se incluye el atributo `isDisabled`, su valor por defecto será `false`, o se establece el valor explícitamente con `isDisabled="false"`. Esto imita el comportamiento de los atributos booleanos de HTML, haciendo que el código sea más legible.
