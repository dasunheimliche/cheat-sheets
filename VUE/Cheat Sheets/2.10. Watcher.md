## A - watch

**Definición:** Función que permite ejecutar un callback cuando cambia una fuente reactiva. Se usa para realizar efectos secundarios.

**Ejemplo:**

```Vue
<template>
  <input v-model="question" />
  <p>{{ answer }}</p>
</template>

<script setup>
import { ref, watch } from 'vue';
const question = ref('');
const answer = ref('Haz una pregunta.');

watch(question, async (newQuestion) => {
  if (newQuestion.includes('?')) {
    const res = await fetch('https://yesno.wtf/api');
    answer.value = (await res.json()).answer;
  }
});
</script>
```

(Cuando cambia question, se hace una petición a la API y se actualiza answer.)

## B - Watch Source Types

**Definición:** El primer argumento de watch puede ser: un ref, un objeto reactivo, una función getter o un array de fuentes.

**Ejemplo:**

```Js
import { ref, reactive, watch } from 'vue';
const x = ref(0);
const y = ref(0);
const obj = reactive({ count: 0 });

watch(x, (newX) => console.log(`x: ${newX}`));
watch(() => x.value + y.value, (sum) => console.log(`suma: ${sum}`));
watch([x, () => y.value], ([newX, newY]) => console.log(`x: ${newX}, y: ${newY}`));
watch(() => obj.count, (count) => console.log(`count: ${count}`));
```

(Ejemplos de diferentes tipos de fuentes para watch.)

## C - Deep Watchers

**Definición:** Cuando se usa watch directamente en un objeto reactivo, se crea un watcher profundo que se activa con cualquier cambio anidado.

**Ejemplo:**

```Js
import { reactive, watch } from 'vue';
const obj = reactive({ count: 0, nested: { value: 1 } });

watch(obj, (newValue, oldValue) => {
  console.log('Cambio profundo', newValue, oldValue);
});

obj.nested.value++; // Activa el watcher
```

(El watcher se activa con cambios en propiedades anidadas.)

## D - Deep Watchers with Getter

**Definición:** Para un getter que retorna un objeto reactivo, el watcher solo se activa si el getter retorna un objeto diferente. Se puede usar deep: true para forzar un watcher profundo.

**Ejemplo:**

```Js
import { reactive, watch } from 'vue';
const state = reactive({ someObject: { value: 1 } });

watch(() => state.someObject, (newValue, oldValue) => {
  console.log('Cambio de objeto', newValue, oldValue);
});

watch(() => state.someObject, (newValue, oldValue) => {
  console.log('Cambio profundo', newValue, oldValue);
}, { deep: true });

state.someObject.value++; // No activa el primer watcher, pero sí el segundo
state.someObject = { value: 2 }; // Activa ambos watchers
```

(El primer watcher solo se activa si state.someObject es reemplazado, el segundo con cualquier cambio anidado.)

## E - Eager Watchers

**Definición:** Se puede ejecutar el callback de un watcher inmediatamente al crearlo usando immediate: true.

**Ejemplo:**

```Js
import { ref, watch } from 'vue';
const count = ref(0);

watch(count, (newCount) => console.log('Cambio', newCount), { immediate: true });
```

(El callback se ejecuta al crear el watcher y cuando cambia count.)

## F - Once Watchers

**Definición:** (Vue 3.4+) Se puede ejecutar el callback de un watcher solo una vez cuando la fuente cambia usando once: true.

**Ejemplo:**

```Js
import { ref, watch } from 'vue';
const count = ref(0);

watch(count, (newCount) => console.log('Cambio', newCount), { once: true });
count.value++; // El callback se ejecuta una vez
count.value++; // El callback no se ejecuta
```

(El callback se ejecuta solo la primera vez que cambia count.)

## G - watchEffect()

**Definición:** Función que ejecuta un callback y rastrea automáticamente las dependencias reactivas usadas dentro del callback.

**Ejemplo:**

```Vue
<template>
  <p>{{ data }}</p>
</template>

<script setup>
import { ref, watchEffect } from 'vue';
const todoId = ref(1);
const data = ref(null);

watchEffect(async () => {
  const res = await fetch(`https://jsonplaceholder.typicode.com/todos/${todoId.value}`);
  data.value = await res.json();
});
</script>
```

(El callback se ejecuta al crear el watcher y cuando cambia todoId.)

## H - watch vs. watchEffect

**Definición:** watch rastrea explícitamente la fuente, mientras que watchEffect rastrea automáticamente las dependencias dentro del callback. watch solo se activa cuando la fuente cambia, watchEffect se activa al inicio y cuando cambian las dependencias.

**Uso:** watch para control preciso, watchEffect para código más conciso.

## I - Side Effect Cleanup

**Definición:** Se puede usar onWatcherCleanup o el tercer argumento del callback de watch para registrar una función de limpieza que se ejecuta antes de que el watcher se vuelva a ejecutar.

**Ejemplo:**

```Js
import { ref, watch, onWatcherCleanup } from 'vue';
const id = ref(1);

watch(id, (newId, oldId, onCleanup) => {
  const controller = new AbortController();
  fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {
    // ...
  });
  onCleanup(() => controller.abort());
});

watch(id, (newId) => {
  const controller = new AbortController();
  fetch(`/api/${newId}`, { signal: controller.signal }).then(() => {
    // ...
  });
  onWatcherCleanup(() => controller.abort());
});
```

(Se cancela la petición anterior cuando cambia id.)

## J - Callback Flush Timing

**Definición:** Los callbacks de los watchers se ejecutan después de las actualizaciones de los componentes padres y antes de las actualizaciones del DOM del componente dueño.

## K - Post Watchers

**Definición:** Se puede ejecutar el callback de un watcher después de que Vue actualice el DOM usando flush: 'post'.

**Ejemplo:**

```Js
import { ref, watch, watchPostEffect } from 'vue';
const count = ref(0);

watch(count, () => console.log('Después del DOM'), { flush: 'post' });
watchPostEffect(() => console.log('Después del DOM (alias)'));
```

(El callback se ejecuta después de que Vue actualiza el DOM.)

## L - Sync Watchers

**Definición:** Se puede ejecutar el callback de un watcher sincrónicamente antes de cualquier actualización de Vue usando flush: 'sync'.

**Ejemplo:**

```Js
import { ref, watch, watchSyncEffect } from 'vue';
const count = ref(0);

watch(count, () => console.log('Sincrónico'), { flush: 'sync' });
watchSyncEffect(() => console.log('Sincrónico (alias)'));
```

(El callback se ejecuta sincrónicamente al cambiar count.)

## M - Stopping a Watcher

**Definición:** Los watchers creados sincrónicamente en setup() o `<script setup>` se detienen automáticamente al desmontar el componente. Para detener un watcher manualmente, se usa la función retornada por watch o watchEffect.

**Ejemplo:**

```Js
import { ref, watchEffect } from 'vue';
const count = ref(0);
const unwatch = watchEffect(() => console.log('Contador:', count.value));

// ...
unwatch(); // Detiene el watcher
```

(El watcher se detiene manualmente con unwatch().)
