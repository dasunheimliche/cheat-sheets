## A - Watchers: Concepto Básico

**Definición:** Los "watchers" en Vue.js son una herramienta que nos permite "observar" cambios en la data reactiva de nuestro componente y ejecutar una función ("callback") cada vez que estos cambios ocurran. Es como tener un perro guardián que reacciona cuando algo en la casa (data) cambia. A diferencia de las propiedades computadas, que se enfocan en calcular valores, los watchers son perfectos para ejecutar _efectos secundarios_, como solicitar data de una API, interactuar con el DOM, o disparar acciones cuando nuestra data cambie.

**Ejemplo:**

```html
<template>
  <input v-model="texto" type="text" placeholder="Escribe algo" />
</template>

<script>
  import { ref, watch } from "vue";

  export default {
    setup() {
      const texto = ref("");

      watch(texto, (newValue, oldValue) => {
        console.log("el texto cambio de " + oldValue + " a " + newValue);
        // Simular side effect, podria ser llamada a API
      });

      return { texto };
    },
  };
</script>
```

**Descripción del ejemplo:** Aquí, cuando `texto` cambie, se imprimirá en la consola la traza del cambio con `newValue` y `oldValue` . El watcher actuó tras la mutación reactiva y ejecuta su lógica, siendo diferente a lo que hacen las propiedades computadas.

## B - Sintaxis de `watch` en Options API vs Composition API

**Definición:** En Options API (data, methods), el watcher se define como una opción llamada `watch`, siendo un objeto que asocia el nombre de una propiedad (que queremos "observar") con el "callback" (la función que se ejecuta cuando hay un cambio). Con Composition API, usamos la función `watch()` importada desde Vue. Esto permite más flexibilidad y organización, además de ser parte de la funcionalidad setup() del componente.

**Ejemplo:**

```javascript
// Options API:
export default {
  data() {
    return {
      contador: 0
    }
  },
  watch: {
    contador(newValue, oldValue) {
      console.log('Options API: El contador cambio de', oldValue, 'a', newValue);
    }
  },
}

// Composition API
import { ref, watch } from 'vue'
export default {
  setup() {
    const contador = ref(0);

    watch(contador, (newValue, oldValue) => {
        console.log('Composition API: El contador cambió de', oldValue, 'a', newValue)
    });
        return {contador}
   }
};

```

**Descripción del ejemplo:** Ambos watchers funcionan igual, pero la forma en que se definen es diferente según si usas la Options o la Composition API. Ambos hacen el console.log del cambio del valor, evidenciando la misma lógica y comportamiento con sintaxis distinta.

## C - Tipos de Orígenes para `watch`

**Definición:** La función `watch()` de la Composition API es más flexible, y el primer argumento (`source`) puede ser una:
_ **ref**: Una variable reactiva simple.
_ **Función "getter"**: Que devuelve un valor que depende de otras propiedades reactivas, útil para reacciones derivadas de otras variables \* **Un objeto "reactive"** , o un array que contenga las anteriores

Esto nos da mas poder a la hora de ver la reaccion que puede disparar los "watchers", y con mayor flexibilidad. Es importante NO tratar de poner el nombre de las propiedades en objetos reactive, ya que en realidad estaremos entregando el _valor_ al watch, haciendo que el watch nunca reaccione. En vez de esto usa la funcion getter o mira todo el objeto reactive

**Ejemplo:**

```js
import { ref, reactive, watch } from "vue";

const x = ref(0);
const y = ref(0);
const obj = reactive({ count: 0 });
// watch usando  "ref"
watch(x, (newX) => {
  console.log(`el  valor  "x" cambio a  ${newX}`);
});
// watch  usando  un  "getter"
watch(
  () => x.value + y.value,
  (sum) => {
    console.log('suma  de  "x"  +  "y"  = ' + sum);
  }
);

// watch usando  "objeto"  "reactive"
watch(obj, (newObj) => {
  console.log("El objecto reactivo cambio " + JSON.stringify(newObj));
});
obj.count++; //Dispara la reaccion
x.value++; // Dispara la reaccion
y.value++; //Dispara la reaccion
```

**Descripción del ejemplo:** En este ejemplo, vemos que watch reacciona en los diferentes casos; cuando cambia un ref, el getter o un objecto reactivo completo.

## D - Watchers "Profundos" (`deep`)

**Definición:** Por defecto, un watcher solo detecta cambios superficiales, si trabajamos con objetos anidados, se requerirá el modificador `deep:true`, con este modificador el callback se dispara al detectar el cambio profundo, incluyendo cada propiedad interna del objeto.. Tambien la funicon `watch()` actua por defecto con `deep:true` cuando monitoreamos un objeto reactivo. Es como tener una lupa que no solo mira la superficie, sino también los cambios en la estructura interna del objeto.

**Ejemplo:**

```js
import { ref, reactive, watch } from "vue";

const miObjeto = reactive({
  datos: {
    nombre: "default",
    edad: 0,
  },
});
watch(
  () => miObjeto.datos,
  () => {
    console.log("superficial trigger"); //No  se disparará en las propiedades  profundas
  }
);
watch(miObjeto, () => {
  console.log("Trigger deep"); //Dispara cuando el objecto cambia de forma profunda o  directamente
});

watch(
  () => miObjeto.datos,
  (newVal) => {
    console.log("cambio superficial con nueva referencia");
  },
  { deep: true } // Necesario si se usa "getter" para profundidar en los valores.
);

miObjeto.datos.nombre = "Juan"; //disparara el profundo pero no superficial ni shallow
miObjeto.datos = { nombre: "Pablo", edad: 22 }; // Disparara el profundo y shallow.

console.log("el objeto final es " + JSON.stringify(miObjeto));
```

**Descripción del ejemplo:** La primer reaccion no funcionará, pues no vigila internamente a un cambio en las subpropiedades. Mientras tanto el segundo reacciona de forma "deep". Se aprecia la necesidad de especificar deep cuando usamos un getter de las sub propiedades para no tener comportamientos ambiguos en caso de no requerir que reaccione al cambio en el objeto "reactive" completo, si solo uno de los internos.

## E - Watchers "Impacientes" (`immediate`)

**Definición:** Un watcher común se ejecuta después de un cambio. Sin embargo, cuando un componente inicia (al renderizar), puedes requerir ejecutar el watch aunque no exista un cambio previo. Usando `immediate: true`, el watcher se ejecuta por primera vez al renderizar y luego se comporta de manera estándar, despues que existe algun cambio. Es como un detective que hace una investigación inicial antes de comenzar a buscar pistas por toda la casa.

**Ejemplo:**

```js
import { ref, watch, onMounted } from "vue";

const initialCount = ref(0);
const onInitialRenderWatch = () => {
  watch(
    initialCount,
    () => {
      console.log("Imediat  watch ejecuta sin mutar.");
    },
    { immediate: true }
  );
};
onMounted(() => initialCount.value++);
onInitialRenderWatch();
```

**Descripción del ejemplo:** El `watch` normal solo ejecutará su callback si la variable cambia; el initial render nunca sera gatillado por un cambio en la variable observada por watch , mientras que un immediate Watch si dispara por primera vez un log cuando su callback es iniciado. Es decir ejecuta una accion en el montaje (renderizado inicial) con un valor que luego sera sobreescrito al modificar la variable reactiva "inicialCount", esto deja al observer sin "valor inicial" que permita diferencias de la logica inmediata.

## F - Watchers de un "único uso" (`once`)

**Definición:** Este modificador asegura que la función "callback" de un "watcher" se ejecute como máximo una vez. Útil cuando queremos disparar algo que solo necesitemos hacer una vez (Ej: configurar algun estado externo), no es un tipo común, pues los `watcher`s estan enfocados en detectar multiples mutaciones reactivas. Esta funcion esta presente en las ultimas versiones.
Imagínalo como una alerta de "primer y único uso": una vez que se dispara, se desactiva.

**Ejemplo:**

```js
import { ref, watch, onMounted } from "vue";
const value = ref(1);

watch(
  value,
  () => {
    console.log("once callback - Primera y unica vez");
  },
  { once: true }
);

onMounted(() => {
  value.value++;
  value.value++; // se ejecuta, pero  el  log solo se gatillará  1 vez
});
```

**Descripción del ejemplo:** Como puedes ver el cambio del ref `value`, activa el watcher, pero aun asi el mensaje aparece 1 unica vez. Es util si requieres ejecutar una inicialización en funcion del componente y de datos reactivos pero unicamente la primera vez que ocurre un evento de modificación.

## G - `watchEffect()`: Dependencias automáticas

**Definición:** `watchEffect()` detecta automáticamente las dependencias reactivas en su callback; no tenemos que explicitar qué propiedad vamos a observar: es como un detective que mira los alrededores del evento, para ver que datos esta usando en vez de que se le diga previamente que datos va a inspeccionar, esto puede facilitar la mantención de nuestro código si es pequeño y sabemos que solo necesita ciertos parámetros para reaccionar. La funcion dispara su callback tanto en el "mount", o cuando sus dependencias se alteran

**Ejemplo:**

```js
import { ref, watchEffect } from "vue";
const dato1 = ref(0);
const dato2 = ref(0);

watchEffect(() => {
  console.log(
    "Datos Usados en  watchEffect, " + dato1.value + " " + dato2.value
  );
});

dato1.value++;
dato2.value++;
```

**Descripción del ejemplo:** El callback de `watchEffect` imprimirá en consola su primera reaccion. Las actualizaciones en `dato1` y `dato2` provocan nuevas llamadas, porque fueron detectadas por `watchEffect`. Simplifica y automatiza el tracking. Hay que tener ojo de no modificar props desde ahi si vas a utilizar esta sintaxis, o hacer request de forma sincronas , esto podria complicar la lectura del componente.

## H - `watchEffect()` vs. `watch`

**Definición:**
_ `watch` requiere indicar de forma explícita las dependencias que vigilará, su `callback` solo se ejecuta cuando esas fuentes especificadas cambian y podemos usar su antigua valor.
_ `watchEffect` se dispara ante cualquier dependencia reactiva usada, detectándolas en la primera ejecución o con sus mutaciones. El `callback` se dispara con cada mutación, detectando cada variable, e _ignorando los valores antiguos_.

Imaginalos como dos caminos diferentes para resolver el mismo problema: uno en que uno te dice donde esta lo relevante, el otro analiza la habitación buscando.

**Ejemplo:**

```js
import { ref, watch, watchEffect } from "vue";

const value1 = ref(0);
const value2 = ref(0);

watch(value1, (newVal, oldVal) => {
  console.log(
    "Valor del Watch tradicional",
    "Valor  Actual  " + newVal,
    "valor anterior: " + oldVal
  );
});

watchEffect(() => {
  console.log("valor actual en  watchEffect " + value1.value);
});
value1.value++;
value2.value++; // no gatilla watch pero gatilla  watchEffect;
```

**Descripción del ejemplo:** `watch` responde a las mutaciones de value1, imprimiendo ambas variables anterior y actual, `watchEffect`, por otra parte si `value2` cambia, watchEffect igual reaccionará ya que lo esta "utilizando" aunque no sea parte principal de las dependencias que se quieren monitorear. Por ultimo solo muestra su valor. `watchEffect` siempre debe mostrar resultados si usas data en su callback y es un watcher por default que reaccionará en cada mutación detectada; esto es útil pero tambien requiere entender bien sus resultados.

## I - Limpieza de Efectos Secundarios con `onWatcherCleanup`

**Definición:** Es muy comun cuando se solicita data remota que en una interacción los requests que pueden fallar o desfasar las variables. En los `watchers` se usa el callback para reaccionar de una variable para hacer el request con algun nuevo identificador o query , el `onWatcherCleanup` (o una funcion onCleanup similar entregada como tercer parámetro de los callbacks o por defecto en watchEffect) se usa para eliminar los recursos anteriores si la dependencia ya mutó. Con esto puedes parar los request al back cuando una propiedad que lo usa se invalida y genera un request no deseado (ya que se disparara con nueva data el ciclo). Este comportamiento se encuentra principalmente para mejorar la experiencia, usando menos ancho de banda y menos uso de recurso backend con los posibles errores.
Imagina el detective: necesita cancelar la misión antigua si llega una nueva llamada con datos actualizados.
Analogia: Un boton de reset cuando la peticion a servidor tiene algun fallo y requerimos interrumpir los cambios hasta resolver la solicitud de forma sincrónica .

**Ejemplo:**

```js
import { ref, watchEffect, onUnmounted, onWatcherCleanup } from "vue";

const id = ref(0);
let abortController = null;

watchEffect(() => {
  if (abortController) {
    console.log("peticion vieja cancelada");
    abortController.abort();
  }
  abortController = new AbortController();
  console.log("inicio nueva peticion");
  fetch("/fakeAPI", { signal: abortController.signal }).then(
    console.log("petion finsh OK")
  );
  onWatcherCleanup(() => {
    // este metodo tiene dependencia sincronica no async, sino onCleanup directo
    if (abortController) {
      console.log("Peticion cancelada antes de su fin ");
      abortController.abort();
    }
  });
});

id.value++;
id.value++; //cancela la anterior
// simulando que nos fuimos de la vista, debe parar todos lo watchEffects de esa vista para no crear fugas.
```

**Descripción del ejemplo:** Al hacer peticiones simuladas con el uso de `fetch`, podemos utilizar `abortController`, para que solo responda 1 callback , en cada modificacion el anterior request es abortado o se cancela hasta obtener una correcta peticion a un endpoint, al desmonatr componentes no debemos usar las propiedades que usaba ya que provocara una reaccion de watch o watcheffect despues de ser destruida, lo que significa una fuga.
`onWatcherCleanup` esta pensando para esta utilidad mejorando el ciclo de la lógica y datos con las vistas, pudiendo limpiar data si son dependientes de las vistas o no relevantes a la logica . Si queremos ejecutar limpieza después de la peticion del `fetch` tenemos `onCleanup`. La primera nos sirve de limpieza sincrona que no podrá hacer después del `await`. `onCleanup`, es similar pero no depende del ciclo de ejecución de funciones sincronas dentro de un watcher.

## J - Orden de ejecución del callback (`flush`)

**Definición:** Vue permite cambiar el orden de ejecucion del callback `watcher`, de 3 formas:

- `flush: 'pre'` (por defecto): Se ejecuta antes de que Vue renderice las actualizaciones de los hijos y antes de la propia view . Es decir: `(padre  hijos(before)=> view) `. Este método por default agrupa los watch y computadas de nuestro scope
- `flush: 'post'`: El callback se ejecuta después que Vue renderice el Dom ,es útil cuando necesitas el nuevo DOM generado para interactuar y usar la view. `(padre hijos view =>)` , útil si interactúas directamente con el Dom luego de una mutacion, tambien existe su version abreviada que funciona similar al watchEffect = `watchPostEffect`.
- `flush: 'sync'`: Este método ignora el batch de componentes padre y llama el callback antes que cualquier actualización se realize . Util para ver datos y cambios antes del ciclo `(padre,before => hijos ,view)`, si bien es útil puede resultar costoso a la larga. `watchSyncEffect`.

Imaginalos como prioridades de una cola : pre-callback , "ya", post-callback "luego de que todos cambien, sincronos: apenas haya algo que cambiar en la data reactiva de forma síncrona".

**Ejemplo:**

```js
import { ref, watch, watchPostEffect, onMounted } from "vue";
const valuePost = ref(0);
const valueSync = ref(0);
const value = ref(0);

const viewId = document.createElement("span");

watchPostEffect(
  () =>
    console.log(
      "Flush  Post ",
      valuePost.value,
      " textContent es ",
      viewId.textContent
    ),
  { flush: "post" }
); // alias de watch(valor,callback,{flush:"post"})

watch(
  valueSync,
  () =>
    console.log(
      "Flush  Sync  ",
      valueSync.value,
      "text content: " + viewId.textContent
    ),
  { flush: "sync" } // alias de watchSyncEffect( ()=>{}), no es async, ya que puede frenar los renders del padre y luego el hijo
);

watch(value, () =>
  console.log(
    "Default  Flush ",
    value.value,
    "Text content es ",
    viewId.textContent
  )
);

onMounted(() => {
  viewId.textContent = 0;
  document.body.appendChild(viewId);

  value.value++; //log antes render, pero despues hijos
  valuePost.value++; //log despues de  hijos  e incluso este componente, el post siempre debe verse ultimo.
  valueSync.value++; // ejecuta siempre antes que los demas por no agruparse en batchs

  setTimeout(() => {
    console.log("-----Ejecucion sync desdpues de espera, sin flush -----");
    valueSync.value++; //sync siempre ejecuta por no esperar un render padre.

    setTimeout(() => {
      console.log("-----Ejecucion  post, antes de render-----");
    }, 1);
  }, 0);
});

onMounted(() => {
  setTimeout(() => {
    console.log("------Flush despues del time out inicial, default-----");
    value++;
    setTimeout(
      () => console.log("-----post depues de timeOut inicial, sin flush -----"),
      0
    );
  }, 100);
});
```

**Descripción del ejemplo:** Se comprueba cómo el `callback` de watch ejecuta primero con flush 'sync', el que ejecuta "inmediatamente". Luego la secuencia default en general con prioridad sobre la mutación en las view hijas, luego con prioridad después que hizo el update el componente padre. Luego tenemos la logica despues del post que garantiza obtener valores correctos después de que la renderizacion en cascada sucedio en nuestros hijos, `setTimeout` nos sirve de ayuda para crear orden con un loop que usa 3 watcher de diferentes tipos (sync/post/normal ) y muestra como la primera iteracion puede provocar desorden. Se recomienda para performance dejar que los datos de la view sean consistentes en la mayoría de aplicaciones , lo que normalmente significa un flush post-view o un default-view. Sync nos permitirá en algunos casos debuggear datos antes de la vista pero requiere de mayor comprensión de como funciona su prioridad y como podría provocar performance no deseado al forzar muchas validaciones por su reaccion tan directa

## K - Creación Imperativa con `$watch()`

**Definición:** Con la instance de Vue (this), podemos utilizar `$watch` que hace lo mismo que las sintaxis ya dichas ,pero de forma imperativa (cuando y donde queramos), a su vez ofrece la habilidad de destruir y controlar si ese "watcher" necesita activarse con el transcurso de la logica del código (y NO desde que es compilado el componente). Esto puede ayudar si la condición en donde usaremos `watch`, o queremos crear `watchers` mas "dinámicos". Tambien nos es muy util cuando una lógica es dependiente de la interaction de nuestro componente, de modo que no deberia iniciar la ejecución en el mount sino hasta que dicha condicion o lógica se complete en la interacción del usuario o desde eventos de algun estado.
Imagina a `watch` con esta funcionalidad como un observador dinámico que se activa o desactiva según los requerimientos de una función especifica dentro del componente

**Ejemplo:**

```js
import { ref, onMounted, onUnmounted } from "vue";

const enabledWatch = ref(false);
const target = ref(0);
let unwatch = null;

const createWatcher = () => {
  if (enabledWatch.value) {
    unwatch = this.$watch(target, (newVal, oldVal) => {
      console.log("watch iniciado con this y reaccion activa " + newVal);
    });
  }
};
const destroyWatcher = () => {
  if (unwatch) {
    unwatch(); //  metodo del  this que detiene watchs dinamicos, requiere  igualarse  a algo para luego borrar
    console.log("watch destroy!");
  }
};

onMounted(() => {
  createWatcher();
  target.value++; // sin destroy este  hace update despues de llamar a watch imperativo
});

setTimeout(() => {
  console.log("------ Despues del timer destroy imperativo");
  enabledWatch.value = true;
  destroyWatcher(); // despues del  timer lo destruimos ya q enabled no se cumple

  setTimeout(() => {
    createWatcher(); // y luego con otro timer creamos un  nuevo watch por que esta en  true  enabled, ya la cond se da
    target.value++;
  }, 0);
}, 500);
onUnmounted(() => destroyWatcher()); // importante destruir watch cuando desmontamos vistas
```

**Descripción del ejemplo:** Al renderizar se llama createWatch que define el observer pero lo ejecuta cuando "enabled" es true .El cambio `target.value++` hace que `this.$watch` actue aunque enabled no sea verdadero ya que el montaje del comp es sincrono, en `setTimeout` con los timer y la variable de control creamos/destruimos los watchers con `createWatcher` y `destroyWatcher`, por ultimo es recomendable destruirlos usando el ciclo onUnmounted, con esta sintaxis debemos ser explicitos.

## L - Detener un watcher (o usar los scopes de setup)

**Definición:** `watchers` creados con `watch` (no `this.$watch`), al montar la vista, se detendrán automáticamente. `this.$watch`, en cambio, o `watchEffect` declarados asincronamente con setTimeout , **NO** se detendrán automaticamente , es responsabilidad detener la referencia o ejecutar una lógica de scope que ejecute dicha limpieza. Al guardar el handle (lo que retornan estas funciones watch) podemos llamarlas con el nombre de variables que nosotros querramos para terminar los "watchers", que en ocasiones al tener un loop provocarian efectos inesperados en variables cuando el usuario interactua . Debemos tener cuidado con el uso de asíncronia dentro setup(), con esto se espera que las acciones sean sincrónicas y estén unidas al componente de modo tal que eviten fugas de memoria. Con esto se crea una buena práctica al entender cómo funcionan los watchers imperativos. Si requieres usar alguna funcionalidad extra de setTimeout, crea siempre una condicional con variable y scope o destruye manualmente.

**Ejemplo:**

```js
import { ref, watch, watchEffect, onUnmounted, onMounted } from "vue";
const valorWatch = ref(0);
const valorEffect = ref(0);

let unWatch = null; // guarda funcion destroy de  $watch

// watchers que se desabilitan al destroy.
watch(valorWatch, () => console.log("destrucción automatica con setup scope")); // funciona ya que el component esta  en el ciclo syn

//  watch  destrucción async deber ser imperativa
setTimeout(() => {
  const stop = watch(valorEffect, () => {
    console.log("async  destruction in SetTimeOut ");
  });
  unWatch = () => {
    // este tipo requiere ser  manual
    stop();
    console.log("  destroy   Async Manual with variable");
  };
}, 0);

// esto falla ya q  watchEffect  esta dentro de setTimeout , el scopse de setup no lo cancela

setTimeout(() => {
  const destroyEffect = watchEffect(() => {
    console.log(
      "WatchEffect inside setimeOut, requiere destruccion manual con  el ref  "
    );
  });
  setTimeout(() => {
    destroyEffect();
    console.log("WatchEffect destroy in timeOut");
  }, 1);
}, 0);

onMounted(() => {
  valorWatch.value++; // si es setup funciona pero es async debes tener  cuidado y limpiar si lo haces en el unMounted
});
onUnmounted(() => {
  if (unWatch) unWatch(); //destruimos un watch async
});
```

**Descripción del ejemplo:** Con `watch` podemos demostrar la destruccion automatica de "setups", ya que con variables del scope (como refs declarados antes ) si se eliminan no seguirán "escuchando", lo cual con setTimeout es muy distinto. En estos casos hay que guardar en un closure la funcion retorno ( que permite destruir de watch o watcheffect ) y para usarlo despues. Como podemos observar los efectos `setTimeout`, o asincronos en general que generemos `watch` o `watchEffect` deben ser controlados si no hay una necesidad en el tiempo del renderizado; este código sirve para comprender cómo se debería lidiar en estos casos. Y, como se detienen la mayoria, en el cierre de nuestra view usando la funcion `onUnmounted`, el cual se recomienda tener siempre a mano cuando detectemos acciones similares con scope async o con `$this` si queremos parar o usar alguna dependencia de manera más dinámica dentro de nuestras vistas, mejorando de forma más controlada el comportamiento interno y memoria utilizada en Vue.js.
