## A - v-on (o @)

**Definición:** La directiva `v-on` (o su abreviatura `@`) en Vue.js te permite "escuchar" los eventos que ocurren en tu interfaz de usuario y ejecutar una función o código JavaScript cuando estos se activan (hacen "click", presionan "una tecla" del teclado etc) . Es como si "afinaras tus oídos" a los cambios de la interfaz y respondieras con una acción, por parte del software.
**Ejemplo:**

```html
<button v-on:click="incrementarContador">Incrementar</button>
<!-- es igual a  -->
<button @click="incrementarContador">Incrementar</button>
```

**Descripción del ejemplo:** Cuando se hace clic en este botón, se ejecutará la función `incrementarContador` definida en el componente. `@click` es una forma corta de escribir `v-on:click`, indicando al framework que en este botón hemos registrado (con `@`) un event listener (evento) llamado `click`, asociado al método javascript `incrementarContador`.

## B - Inline handlers

**Definición:** Los inline handlers son bloques de código JavaScript (en su versión simple, sin parámetros) que defines directamente dentro de tu template HTML para ser ejecutados en la activación de un evento, de modo rapido, aunque no es conveniente que su complejidad sea demasiado alta para evitar ilegibilidad. Es como "pequeñas funciones instantáneas" directamente adjuntas a las etiquetas html, pero cuyo propósito es de naturaleza funcional y con cierta simpleza para garantizar el buen entendimiento y mantenimiento futuro.
**Ejemplo:**

```html
<button @click="count++">Sumar</button>
```

**Descripción del ejemplo:** Al hacer clic, `count++` se ejecutará de forma local (directamente) incrementando el contador `count`, y reflejando la respuesta reactiva en el html con un mensaje. Este incremento sencillo (directo) dentro del handler de evento (evento `click`) sería un buen ejemplo del uso de un `inline handler` muy simple.

## C - Method handlers

**Definición:** Son la manera correcta de procesar un evento en `Vue.js`. Son el enlace directo, mediante `@`, entre la interfaz HTML y el código javascript. Un method handler es el nombre de una función existente en el componente (en sección methods), a la cual se le delega la logica de control o la modificación reactiva del DOM a partir de la deteccion de un determinado evento. En ellos `this` hace referencia a la instancia activa del componente. Un method handler es lo opuesto al `inline handler`, por su nivel de especialización (complejidad) y claridad conceptual, como elemento propio de lógica de negocio (o de aplicación) asociado a la estructura DOM
**Ejemplo:**

```html
<button @click="mostrarMensaje">Mostrar Alerta</button>
```

```javascript
 methods: {
    mostrarMensaje() {
      alert('Hola desde Vue!');
    }
 }
```

**Descripción del ejemplo:** Aquí, al hacer clic en el botón se ejecuta la funcion `mostrarMensaje` en `methods`, donde definimos nuestra lógica en formato `javascript`, incluyendo acceso a otras variables ó lógica relacionada de nuestro componente Vue.
El `event handler` tiene toda la funcionalidad que el programador necesite en su contexto. `this` dentro del contexto (methods) , es referencia directa a las propiedades declaradas en data , ref ó reactive y toda la funcionalidad del componente Vue en curso. `method handlers` es lo adecuado (lo bueno) cuando hay logica (o acceso a ella).

## D - Métodos en Inline Handlers

**Definición:** Cuando, por la naturaleza específica de nuestra aplicación o del diseño HTML y nuestras necesidades, un simple inline handler se nos queda corto para resolver nuestro objetivo en el procesado de un evento, pero tampoco queremos escribir un método separado, `Vue.js` permite añadir lógica y parámetros (variables o string, que sean relevantes a este handler particular) dentro del inline handler . Todo el potencial del `javascript` en nuestro componente al alcance de un inline handler. No es tan clara la legibilidad en esta solución hibrida; a la que debes acudir con cuidado.
**Ejemplo:**

```html
<button @click="mostrarMensaje('¡Mensaje personalizado!')">
  Mostrar mensaje
</button>
```

```javascript
 methods: {
    mostrarMensaje(msg) {
     alert(msg);
    },
  },
```

**Descripción del ejemplo:** Este ejemplo permite añadir como argumento `msg` a nuestro método (`mostrarMensaje`), gracias a una expresion funcional de javascript. Consecuencia: más personalización (si es necesaria), aunque tambien, y en consecuencia, cierta confusión, si abusas del modelo (por ejemplo con más argumentos y más funcionalidad anidada dentro del mismo handler inline)

## E - Acceso al Evento en Inline Handlers

**Definición:** En el ámbito de `inline handlers` es muy comun necesitar acceder al objeto de evento original del DOM ( como la posición de un raton ,el input value o la información detallada de una tecla presionada) por eso existe `$event`, como variable de ambito local que guarda referencia directa al DOM para todos estos casos y nos da acceso al elemento original (y su propiedades) que lanzó (disparó) ese evento en la interfaz. Un acceso al elemento DOM directo para obtener toda su información es lo que `event`, en resumen, provee a los inline handlers para su buen funcionamiento y procesado del evento. Esta variable `$event` no está definida si utilizas la versión (o la solución correcta, con metodos) del método handler donde el `event` ya se envia como argumento por la implementación.
**Ejemplo:**

```html
<button @click="procesarClick($event)">Procesar Evento</button>
```

```javascript
methods:{
   procesarClick(event)
      {
       console.log(event); // el target original que dispara evento en el html
        console.log(event.target.tagName); // "button"
      },
  },
```

**Descripción del ejemplo:** Al hacer clic en `Procesar Evento`, nuestro method handler `procesarClick` puede imprimir por consola (de desarrollo del navegador), tanto toda la info del evento, así como el nombre de la etiqueta que fue clickada (`<button>`). Esto da un altísimo nivel de precisión en el conocimiento y capacidad de actuar ante un evento de la interfaz HTML. `event` te dice, te revela (casi, susurra a tu oido "yo soy el causante y estas son mis propiedades").

## F - Modificadores de Eventos

**Definición:** Son postfijos que modifican (extienden) el comportamiento natural de un evento del DOM y añaden funcionalidad sobre cómo deben reaccionar. Son como "aditivos funcionales" que añades a tu event listener que hace la logica de programacion mas rapida y concisa a la hora de procesar un evento con logicas recurrentes sobre eventos tales como el `preventDefault`, el `stopPropagation`, etc. Los modificadores de evento en Vue.js son el atajo rápido (y recomendable), en la logica de evento. Todo por eficiencia y buenas prácticas.

**Ejemplos:**

```html
<a @click.stop="accion">Stop</a>
<form @submit.prevent="validar"></form>
<div @click.self="miMetodo()">...</div>
<div @click.capture="captureMode">...</div>
<a @click.once="mostrarUnicaVez">Click Unica vez</a>
<div @scroll.passive="onScroll">...</div>
```

**Descripción del ejemplo:**

- `.stop` detiene la propagación del evento. -`.prevent` previene la acción predeterminada del evento (el comportamiento nativo) del evento `submit` por defecto. -`.self` hace que el `handler` (o el escuchador del evento) solo se active si el origen de la activación es en la propia etiqueta y no en algun hijo que este anidado (una especifica accion se delega a su origen). -`.capture` provoca que el handler sea detectado antes de que lo haga cualquier otro handler anidado en sus nodos hijos .
- `.once` garantiza que la función registrada para este evento solo se activará (se procesará) una unica vez, siendo completamente ignoradas el resto de veces posteriores (muy util para tareas de configuracion o procesamientos especificos que no queramos se repitan mas que una vez.
- `passive` avisa al navegador que la función a la que esta asociado no realizara `preventDefault`, mejorando asi el rendimiento de ciertas tareas.
  Estos aditivos pueden incluso encadenarse entre ellos para combinarlos para una mayor eficacia, eficiencia y legibilidad de nuestro `template`, ahorrándonos la escritura (y la lectura posterior ) de mas lineas de codigo `javascript` . El orden sí importa: `@click.prevent.self` es distinto a `@click.self.prevent` o que `@click.stop.once` es diferente a `@click.once.stop`, ya que el código correspondiente se genera (procesa ) en dicho orden.

## G - Modificadores de Teclas

**Definición:** Son modificadores de evento, con una lógica de activacion vinculada con las teclas de un teclado , y a las combinaciones especificas (o únicas) de las mismas que definamos. Estos modificadores detectan qué teclas se han pulsado o están pulsadas y de que forma estan (o fueron) pulsadas , para un determinado event handler (event listener). Es decir son la solucion correcta (más concisa y mas limpia que si hicieras los controles manualmente en un handler javascript ) para determinar en el frontend, las acciones derivadas de una combinación especifica del uso del teclado, como atajos del sistema operativo en combinacion de CTRL + SHIFT, ó usando teclas especficas como el `ENTER`, el `TAB`, la `FLECHA  ARRIBA`, etc, para hacer una respuesta personalizada del programa, en la interfaz de usuario. Es el "mago" que adivina (detecta y actua de manera concreta) cuando y qué combinación (o una tecla en especifico), del teclado ha sido usado (pulsado) para tomar una acción relacionada al handler.
**Ejemplos:**

```html
<input @keyup.enter="buscar" />
<input @keyup.page-down="siguientePagina" />
<input @keyup.esc="cancelar" />
<button @keyup.ctrl.enter="submit">Enviar (con CTRL+ENTER)</button>
<button @click.ctrl="doSomething">CTRL+CLICK</button>
<input @keyup.alt.enter="borrarDatos" />
```

**Descripción del ejemplo:**

- `.enter` ejecuta el `handler`, sólo cuando la tecla "enter" se pulsa en la caja del input, desatendiendo la pulsacion de otras teclas
- `page-down` el evento sólo se ejecutará cuando se pulse la tecla "PageDown" y las demas se ignoraran .
- `.esc`, para `ESC`, igual a las anteriores, solo cuando es pulsada la tecla ESC el handler ejecuta su funcion relacionada
- `ctrl.enter` exige la combinación de la pulsación con CTRL ( a la vez de enter), es un acceso directo y es personalizable como necesites tu atajo concreto. (Es `CTRL + ENTER`)
- `click.ctrl` obliga al handler del evento `click` solo actue si hay una tecla `CTRL` pulsada, sino ignorara la activacion del evento click.
- `alt.enter`, como en las anteriores , exige que `alt+enter` se active de modo combinado para que este atajo actúe de forma personalizada, borrando en este caso la información en curso
  .
  De esta manera puedes ser especifico y personalizado en los requerimientos de acciones, ya sean de solo una tecla , como en las combinaciones (atajos de teclado), y, gracias a `vue` lo harás, de manera más legible, más concisa, eficiente y sostenible (a nivel de mantenimiento de software) en los tiempos que corren en las practicas de desarrollo. Vue da soporte a la mayoría de combinaciones necesarias para nuestro frontend. Tambien se pueden definir aliases que hacen mas facil nuestro codigo de control del evento, tales como `.tab`, `.delete`, `.esc`, `.space`, `.up`, `.down`, `.left` y `.right`.

## H - Modificadores de Teclas de Sistema

**Definición:** Son una variante de modificadores de eventos que responden a las pulsaciones específicas de ciertas teclas especiales, tales como `.ctrl`, `.alt`, `.shift` o `.meta` y que solo ejecutaran (activaran) la función javascript, si, al dispararse la activación de un evento (`click`, `keyup`), éstas estaban o siguen presionadas al momento de dicho evento, (funcionando con combinaciones complejas del teclado o haciendo funciones exclusivas del propio teclado o el ratón) a través del uso conjunto del teclado con modificadores ( y la lógica particular del código asociado en la instancia Vue). Es la sutileza fina en el comportamiento y personalización de tu `frontend`, si asi fuera necesario en el diseño o funcionalidad deseada para el proyecto.
**Ejemplos:**

```html
<input @keyup.alt.enter="resetear" />
<div @click.meta="select">Seleccionar (meta+click)</div>
<input @keyup.shift.esc="limpiarTodo" />
```

**Descripción del ejemplo:** -`.alt.enter`, ejecutará la función de reseteo del `form` en la combinación `alt + Enter`. -`click.meta`, para la acción que solo se activa cuando haya clic de ratón combinado con la tecla `Meta` del teclado (la tecla Windows/Cmd), -`keyup.shift.esc` el handler (escuchador del evento ) en input , sólo actuará cuando la tecla Shift + la tecla ESC sea presionadas y soltadas (a la vez, pues al ser `keyup`) .
El funcionamiento de `.meta` difiere según la plataforma usada; así en mac, el modificador `meta`, corresponde la tecla (Command) ⌘, mientras que en windows o linux , seria la tecla de windows ⊞.

Nota : recuerda que los modificadores tipo `keyup.ctrl`, requieren que el usuario tenga pulsada la tecla Ctrl en el instante que el usuario libere (suelte) una segunda tecla de interacción del teclado (sea la `enter`, una flecha direccional, una letra alfanumérica etc. Es decir , el modificador tiene que estar "vivo" durante la liberación.

## I - Modificador Exact

**Definición:** El modificador `.exact`, en combinación de otros modificadores, sirve para precisar qué combinacion especifica es requerida para que se ejecute un event listener especifico en nuestro template . Cuando hay una combinacion, y existen posibilidades en los modificadores de otras posibles combinaciones de teclas activadas juntamente a una primaria; con `.exact` especificas y dejas muy claro la exclusividad requerida en un handler y cuando la condición que activará el evento es `x`, no cualquier cosa que "se le parezca". El poder de personalización, a un nuevo nivel en `vue`. En este orden de ideas, el atributo `exact` asegura la correspondencia y especificidad entre un evento concreto y los modificadores usados.
**Ejemplos:**

```html
<button @click.ctrl="unaAccion()">
  Click Con Control (y otros modificadores opcionales
</button>
<button @click.ctrl.exact="otraAccion()">Click solo Control</button>
<button @click.exact="eventoSimple">Click Sin modificadores</button>
```

**Descripción del ejemplo:**

- El primer boton (sin `.exact`) , actuará (activará su funcion `unaAccion`), ante cualquier pulsación click en el que CTRL esté pulsado, independientemente si están (o no ) activados otros modificadores como shift o Alt (los cuales son opcionales, no son requeridos estrictamente).
- El segundo botón (`.exact`) requiere, obligatoriamente, solo CTRL y ningún modificador adicional más para la correcta activación (ejecución ) de la acción ( método `otraAccion` ). Si pulsa Shift+Control o ALT+CTRL el handler de click NO actuará en la etiqueta HTML asociada, haciendo clara y exclusiva la relacion evento - condición requerida
- En el tercer botón , al utilizar `@click.exact` especificamos, obligatoriamente, la no presencia ( ni actividad ) de ningún modificador sobre este listener , de modo que en la acción click, sea obligatoriamente, no actuado por modificadores adicionales en teclado para que actue ( o active `eventoSimple` )
  En esencia: la mayor flexibilidad y expresividad para diseñar interacciones en nuestra app Vue gracias a `.exact` como especificador de nuestras condicionalidades asociadas al handler de los eventos (incluyendo clicks).

## J - Modificadores de Botón de Ratón

**Definición:** Los modificadores de botón del ratón (.`left`, `.right` y `.middle` ) nos dan acceso a los botones que originan un `click`, a partir de la posición tradicional que las personas diestras utilizan con el ratón. No son realmente modificadores que dependan de los botones de `left, middle` o `right` de forma física , sino de una relacion de causa entre un tipo de pulsacion sobre un input con las relacionadas (las pulsaciones main , secundaria y auxiliar de eventos) generados sobre el DOM con dicho evento (aunque el comportamiento visual corresponda a botones del raton), sin depender estrictamente a los clicks físicos del raton como un objeto físico de hardware. La mayor flexibilidad posible ante las acciones del raton , o cualquier dispositivo similar que de click de pantalla en nuestras interfaces Vue . Todo para conseguir dar una experiencia al usuario ( o cliente, o usuario final), de calidad e inclusiva .
**Ejemplo:**

```html
<button @click.left="seleccionar()">Seleccionar (botón izquierdo)</button>
<div @click.right="mostrarMenuContextual">Menu contextual</div>
<div @click.middle="activarAyuda">
  Activar ayuda con el botón central del ratón
</div>
```

**Descripción del ejemplo:**

-`.left`, garantiza la activación (disparado) del event handler `seleccionar`, siempre y cuando este haya sido realizado por la acción correspondiente (o por el evento asignado a "main button"), por el click primario (típicamente izquierdo).

-`.right`, es análogo al `left`, pero a la pulsación (de clic) "secundario" , comunmente al clic del boton derecho de ratón , siendo responsable de la ejecución del `handler` para acciones de contexto (menu contextual). -`.middle`, similar a las dos anteriores acciones, para activar la función (`activarAyuda`) , a través del click (de accion auxiliar de puntero) asociado al click central del raton, por si se necesita realizar la accion particular y el evento derivado de esta pulsación. Es util sobre todo si usas (trackpad con tres dedos), y necesitas una accion para este tipo de eventos.

Estos modificadores nos proporcionan control sobre qué botón dispara los eventos que estamos utilizando como referencia en nuestros listeners . Son como detectores muy finos (con modificadores para raton), para un input "con puntero", o simulaciones por software con los que puedes dar más control y sutileza a tus diseños (aunque visualmente se relacionen con acciones tipicas asociadas al ratón).
