## A - Components Basics

**Definición:** Los componentes son bloques de construcción reutilizables y autocontenidos que permiten dividir una interfaz de usuario en partes independientes. **Piensa en los componentes como las piezas de LEGO; cada una es una pequeña unidad que puedes combinar y reutilizar para construir cosas más grandes**. En Vue, los componentes pueden encapsular tanto la estructura (HTML) como la lógica (JavaScript) de una parte de tu interfaz de usuario.

**Ejemplo:**

```vue
<script setup>
import { ref } from "vue";
const count = ref(0);
</script>

<template>
  <button @click="count++">You clicked me {{ count }} times.</button>
</template>
```

**Descripción del ejemplo:** Este código define un componente de contador con `<script setup>`, un elemento `button` que incrementa un valor de estado cuando se pulsa. El `<template>` define cómo se renderiza visualmente, y `<script>` la lógica funcional y reactiva del componente.

## B - Defining a Component

**Definición:** Hay varias formas de definir un componente en Vue. Lo más común, es utilizando SFC o componentes de un solo archivo (.vue), donde se encapsula HTML, JavaScript, y CSS en el mismo fichero. De no estar en una aplicación construida, un componente puede ser definido usando objetos planos de JS que contengan propiedades como `template` y funciones como `setup()` o `data()`.. **Imagina que tienes un plano de construcción donde indicas como va a ser y funcionar la casa (componente). Este plano es, o un fichero de extensión `.vue`, o un objecto js.**

**Ejemplo 1 (SFC con `<script setup>`):**

```vue
<script setup>
import { ref } from "vue";
const message = ref("Hello, Vue Component!");
</script>
<template>
  <div>{{ message }}</div>
</template>
```

**Descripción del ejemplo 1:** Ejemplo de un componente básico usando `<script setup>`, que es el formato moderno y simplificado para Vue 3. La lógica se define dentro de `<script>`, usando `ref` de composición, mientras que el HTML del componente se define en `<template>`.

**Ejemplo 2 (Objeto JS con setup() ):**

```js
import { ref } from "vue";
export default {
  setup() {
    const count = ref(0);
    return { count };
  },
  template: `
       <button @click="count++">
          You clicked me {{ count }} times.
      </button>`,
};
```

**Descripción del ejemplo 2:** Es otra forma, usada anteriormente a Vue 3 o en contadas ocasiones con `vue3`, definiendo el HTML dentro de `template`, y `setup()`, es donde se guarda la lógica reactiva. Nótese que como resultado de setup, devolvemos un objeto, donde en la propiedad `count`, guardamos la ref reactiva que controlamos en el HTML.

## C - Using a Component

**Definición:** Para usar un componente, primero se debe importar en el componente padre. En el `<template>` del componente padre, se usa el nombre con el que registrado el hijo como si fuera un nuevo elemento HTML. En `<script setup>`, los componentes se importan y usan en plantilla inmediatamente. Con Options API es preciso hacer una registro del componente con `components`. **Imagínalo como ir a la ferretería (importar) y comprar una pieza para tu construcción, tras lo cual la colocas como si fuera parte de tu sistema de LEGO (HTML)**

**Ejemplo (SFC):**

```vue
<!-- Parent Component (Parent.vue) -->
<script setup>
import ButtonCounter from "./ButtonCounter.vue"; //importación
</script>
<template>
  <h1>Here is a child component!</h1>
  <ButtonCounter />
</template>

<!-- Child Component (ButtonCounter.vue) -->
<script setup>
import { ref } from "vue";
const count = ref(0);
</script>

<template>
  <button @click="count++">You clicked me {{ count }} times.</button>
</template>
```

**Descripción del ejemplo:** En `Parent.vue` se importa `ButtonCounter` desde `ButtonCounter.vue`, donde también se definió dicho componente. `ButtonCounter` es usada dentro de `Parent.vue` directamente como `<ButtonCounter/>` como cualquier otro elemento. Si tienes un código ya escrito sin `script setup` deberás registrarlos bajo `components:{ButtonCounter}`.

**Nota importante:** Cada vez que uses un componente, se crea una instancia de este; es decir, cada componente maneja su estado individualmente.

## D - Passing Props

**Definición:** Las _props_ son atributos personalizados que se pueden declarar en los componentes. Permiten pasar información de un componente padre a un componente hijo. Piensa en los _props_ como la posibilidad que tiene el padre (por ejemplo una ficha en LEGO), para dar un extra (el dato) a su hijo **Imagina un sistema LEGO donde una pieza puede comunicarse o entregarle información a otra, donde estos son valores concretos que configuran su comportamiento** En Options API se declara bajo `props`, en Composition Api `defineProps`.

**Ejemplo 1 (Options API ):**

```vue
<!-- BlogPost.vue -->
<script>
export default {
  props: ["title"], // declaración
  template: "<h4>{{ title }}</h4>",
};
</script>
```

**Descripción del ejemplo 1:** Se declara el prop `title`, indicando que este componente recibirá un parámetro de este tipo, el cual usa para renderizar.

**Ejemplo 2 (SFC):**

```vue
<!-- BlogPost.vue -->
<script setup>
defineProps(["title"]); //declaración
</script>
<template>
  <h4>{{ title }}</h4>
</template>
```

**Descripción del ejemplo 2:** En la misma idea que el ejemplo anterior, se hace con la alternativa de `defineProps()`, declarando en su interior el parámetro esperado, que se usará en el template.

**Ejemplo de Uso (SFC en Parent.vue):**

```vue
<!-- Parent.vue -->
<script setup>
import { ref } from "vue";
import BlogPost from "./BlogPost.vue";

const posts = ref([
  { id: 1, title: "My first blog" },
  { id: 2, title: "My second blog" },
]);
</script>
<template>
  <BlogPost v-for="post in posts" :key="post.id" :title="post.title" />
</template>
```

**Descripción del ejemplo de Uso:** se observa cómo se pasa el parámetro al hijo (`:title="post.title"`), con `v-bind`, y también cómo cada componente usa una entrada distinta, en un `v-for`.
**Nota:** El `defineProps()` es un macro que es exclusivo de `<script setup>`, e importarse, ni devuelve nada.

## E - Listening to Events

**Definición:** Los componentes también se pueden comunicar hacia arriba utilizando _eventos personalizados_. Los hijos emiten un evento mediante la función `emit()` ( en el `setup` ), que se escucha desde el componente padre usando `@` o `v-on` a modo de receptor. **Piensa en estos eventos como señales de un emisor que se envía hacia una antena ( componente padre ), siendo esta un componente que reacciona en consecuencia** El Options Api se hace uso de la función `$emit()` directamente, si no estás dentro de setup.
**Ejemplo:**

```vue
<!-- Parent.vue -->
<script setup>
import { ref } from "vue";
import BlogPost from "./BlogPost.vue";

const posts = ref([{ id: 1, title: "My journey" }]);
const postFontSize = ref(1);
</script>

<template>
  <div :style="{ fontSize: postFontSize + 'em' }">
    <BlogPost
      v-for="post in posts"
      :key="post.id"
      :title="post.title"
      @enlarge-text="postFontSize += 0.1"
    />
  </div>
</template>

<!-- BlogPost.vue -->
<script setup>
defineProps(["title"]);
const emit = defineEmits(["enlarge-text"]);
</script>

<template>
  <div class="blog-post">
    <h4>{{ title }}</h4>
    <button @click="emit('enlarge-text')">Enlarge text</button>
  </div>
</template>
```

**Descripción del ejemplo:** El componente `BlogPost.vue` emite un evento `"enlarge-text"` al clickear en su `button`. El padre, `Parent.vue` , tiene declarado `@enlarge-text` para recibir la notificación y hacer que incremente `postFontSize`. Si usamos Options API en el componente hijo deberíamos invocar `this.$emit('enlarge-text')` en vez de `emit('enlarge-text')`, donde en ese caso `emit`, correspondería al contexto.

## F - Content Distribution with Slots

**Definición:** Los slots nos permiten insertar contenido en componentes. Un `slot`, es un "hueco" o marcador que define dónde se inserta el contenido del padre al hijo, dando la opción de reutilizar una estructura base para un componente. **Es como cuando tienes un hueco, que va a ser llenado por algo en específico que no tienes.** En los componentes hijo, se indica con `slot`, y en el componente padre, la estructura hijo es usado con la información del contenido entre tags del padre.
**Ejemplo:**

```vue
<!-- AlertBox.vue -->
<template>
  <div class="alert-box">
    <strong>This is an Error for Demo Purposes</strong>
    <slot />
  </div>
</template>
<!-- Parent.vue -->
<template>
  <AlertBox>Something bad happened.</AlertBox>
</template>
```

**Descripción del ejemplo:** En `AlertBox.vue`, `<slot/>` actua de hueco, donde `Something bad happened.` es la información usada por el padre. El código renderizado resultante, intercalará este mensaje en el `<slot/>`, entre los componentes padre y hijo.
**Nota**: Existe `Named Slots` y `Scoped Slots`, por si en algun momento necesitas otras opciones mas personalizables en tus aplicaciones.

## G - Dynamic Components

**Definición:** Con la ayuda de `<component>`, el atributo `is`, podemos decidir de forma dinámica cuál de ellos se tiene que renderizar. Esta técnica facilita, entre otros, la creación de interfaces con tabs, que muestran un único hijo distinto. **Piensa que esta funcionalidad es como cambiar las lente de tus gafas y ves de forma distinta según el componente usado**. Se puede indicar a `is`, tanto el string nombre de un componente registrado, como también un objeto de dicho componente. También `<KeepAlive>` forza a los componentes desactivados de `<component :is>` a estar 'vivos'.

**Ejemplo:**

```vue
<script setup>
import { ref } from "vue";
import Tab1 from "./Tab1.vue";
import Tab2 from "./Tab2.vue";
import Tab3 from "./Tab3.vue";

const currentTab = ref("Tab1"); // Estado del tab seleccionado.
</script>
<template>
  <button @click="currentTab = 'Tab1'">Tab 1</button>
  <button @click="currentTab = 'Tab2'">Tab 2</button>
  <button @click="currentTab = 'Tab3'">Tab 3</button>

  <component :is="currentTab"></component>
</template>

<!-- Tab1.vue -->
<template><h1>Componente de Tab 1</h1></template>
<!-- Tab2.vue -->
<template><h1>Componente de Tab 2</h1></template>
<!-- Tab3.vue -->
<template><h1>Componente de Tab 3</h1></template>
```

**Descripción del ejemplo:** Al pulsar un botón, cambiamos el `currentTab`, y el componente `component` es re renderizado según el valor actualizado de `is` que hace el componente `<component>`, lo cual hace dinámico este selector de vistas según una lógica definida por el código del parent.
**Nota**: Si trabajas con strings en el atributo `is` del componente `<component>`, tienes que registrar el string como componente bajo un campo `componentes` de Options Api

## H - in-DOM Template Parsing Caveats

**Definición:** Al usar los templates directamente en el DOM, algunas consideraciones deben de ser tenidas en cuenta. Como HTML no es case-sensitive, todo nombre PascalCase como las Props y `v-on`, deberán declararse como kebab-case (`-`) o guión, también, las tags deberán de ser cerradas, pues solo unos pocos elementos en HTML no requieren cerrar la tag (`img` `input` por ejemplo), y no siempre el componente será ubicado de la misma manera en el dom debido a como el motor del navegador puede intepretar que es una tag correcta o no para el lugar ( `<ul>, <ol>, <table>  o <select>`) y usando `is="vue:miComponente"` podemos decirle al compilador de Vue como componente nuestro `miComponente`. **Es como cuando tratas de construir LEGO con ladrillos distintos y tienes un manual en un idioma que no comprendes totalmente.** Los "templates string" usados en `.vue`, `script` `<template>`, no padecen estas limitaciones.

**Ejemplo de problemas de template en DOM (en una tag de type "text/html",):**

```html
<div id="app">
  <template type="text/html">
    <!-- Incorrecto. Debe ser 'kebab-case'  y  con closing tag.  -->
    <myComponent myProp="example" />
  </template>
</div>
```

**Descripción del ejemplo:** En `HTML` de forma inDOM y a un div principal de id `app` con una plantilla definida como texto en su interior; el `myComponent` debe ser renombrado a `my-component` en caso de no estar un string, y al haber props, deberán ir con kebab-case tambien; como `myProp`, donde debe escribirse como `my-prop`, como en `@updatePost` a `@update-post`. Igualmente todas tags deben tener tag de cierre `<my-component></div>`, incluso aunque parezca que la cerrada por una barra `<my-component />` sea correcta en HTML y para el editor.
