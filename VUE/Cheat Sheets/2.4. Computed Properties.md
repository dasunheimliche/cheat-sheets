## A - Computed Properties

#### 1. **Definicion:**

Imagina que tienes datos en tu aplicaci√≥n Vue que cambian, y necesitas mostrar informaci√≥n que se calcula o se deriva de esos datos. En lugar de hacer c√°lculos complejos directamente en tu template (el HTML), usas **computed properties**. Son como propiedades normales en tus datos, pero en lugar de guardar un valor directamente, definen una funci√≥n que calcula el valor autom√°ticamente cada vez que los datos de los que depende cambian. ¬°Es como magia reactiva!

#### 2. **Ejemplo:**

**Options API:**

```javascript
export default {
  data() {
    return {
      author: {
        name: "John Doe",
        books: ["Vue 2", "Vue 3"],
      },
    };
  },
  computed: {
    publishedBooksMessage() {
      return this.author.books.length > 0 ? "Yes" : "No";
    },
  },
};
```

**Composition API:**

```vue
<script setup>
import { reactive, computed } from "vue";

const author = reactive({
  name: "John Doe",
  books: ["Vue 2", "Vue 3"],
});

const publishedBooksMessage = computed(() => {
  return author.books.length > 0 ? "Yes" : "No";
});
</script>
```

**Explicaci√≥n del ejemplo:**
Aqu√≠, `publishedBooksMessage` es una computed property. Calcula si el autor tiene libros publicados (`author.books.length > 0`) y devuelve 'Yes' o 'No'. Vue se encarga de actualizar autom√°ticamente `publishedBooksMessage` cada vez que cambie `author.books`. En el template, simplemente usas `{{ publishedBooksMessage }}` como si fuera un dato normal.

#### 3. **Notas o advertencias:**

- Las computed properties son geniales para mantener tu template limpio y f√°cil de leer.
- Evitan repetir la misma l√≥gica de c√°lculo en varios lugares de tu template.

## B - Computed Properties vs. M√©todos

#### 1. **Definicion:**

Podr√≠as pensar, "¬øPor qu√© no usar simplemente un m√©todo en lugar de una computed property?". Ambos pueden calcular y devolver un valor. La **diferencia clave** est√° en el **cach√©**. Las computed properties son **inteligentes**: guardan el resultado del c√°lculo y **solo se recalculan** si alguna de las **dependencias reactivas** (los datos que usan para calcular) ha cambiado. Los m√©todos, en cambio, se ejecutan **siempre** que Vue necesita renderizar o actualizar la vista, ¬°incluso si los datos no han cambiado!

#### 2. **Ejemplo:**

**Computed Property (con cach√©):**

```javascript
computed: {
  now() {
    console.log('Computed property recalculating!');
    return Date.now();
  }
}
```

**M√©todo (sin cach√©):**

```javascript
methods: {
  nowMethod() {
    console.log('Method executing!');
    return Date.now();
  }
}
```

**Template:**

```html
<p>Computed: {{ now }}</p>
<p>Method: {{ nowMethod() }}</p>
```

**Explicaci√≥n del ejemplo:**
Si usas la computed property `now`, `console.log` se mostrar√° solo la primera vez y cuando algo reactivo en el componente cambie y fuerce una re-renderizaci√≥n (aunque `Date.now()` en s√≠ no es reactivo, el punto es que no se recalcula en cada re-renderizado _si nada de lo que depende reactivamente cambia_). Con el m√©todo `nowMethod()`, `console.log` se mostrar√° **cada vez** que Vue actualice la vista, ¬°incluso si no hay cambios relevantes!

#### 3. **Notas o advertencias:**

- **Rendimiento:** Usa computed properties para c√°lculos costosos o que se usan mucho en tu template. El cach√© mejora el rendimiento al evitar c√°lculos innecesarios.
- Usa m√©todos si necesitas que la funci√≥n se ejecute siempre en cada renderizado, o si no depende de datos reactivos del componente para su resultado (aunque en ese caso, quiz√°s no deber√≠a estar en el componente).

## C - Computed Properties "Writable" (con Setter)

#### 1. **Definicion:**

Normalmente, las computed properties son solo de "lectura" (getter-only). Calculan un valor, pero no puedes asignarles un valor directamente. Pero, en casos especiales, puedes crear computed properties "writable", es decir, que se puedan escribir. Para ello, defines tanto un **getter** (para obtener el valor) como un **setter** (para establecer un nuevo valor y actualizar los datos subyacentes).

#### 2. **Ejemplo:**

**Options API:**

```javascript
export default {
  data() {
    return {
      firstName: "John",
      lastName: "Doe",
    };
  },
  computed: {
    fullName: {
      get() {
        return this.firstName + " " + this.lastName;
      },
      set(newValue) {
        [this.firstName, this.lastName] = newValue.split(" ");
      },
    },
  },
};
```

**Composition API:**

```vue
<script setup>
import { ref, computed } from "vue";

const firstName = ref("John");
const lastName = ref("Doe");

const fullName = computed({
  get() {
    return firstName.value + " " + lastName.value;
  },
  set(newValue) {
    [firstName.value, lastName.value] = newValue.split(" ");
  },
});
</script>
```

**Explicaci√≥n del ejemplo:**
Aqu√≠, `fullName` es una computed property writable.

- **Getter:** `get()` se encarga de **leer** el valor de `fullName`, concatenando `firstName` y `lastName`.
- **Setter:** `set(newValue)` se ejecuta cuando intentas **asignar un nuevo valor** a `fullName` (ej: `this.fullName = 'Jane Smith'`). El setter toma el `newValue`, lo divide por espacios (`split(' ')`) y actualiza `firstName` y `lastName` con las partes correspondientes.

#### 3. **Notas o advertencias:**

- Las computed properties writable son √∫tiles cuando quieres presentar una "propiedad" en tu template que en realidad es una combinaci√≥n o transformaci√≥n de otros datos, pero tambi√©n quieres permitir que el usuario la modifique directamente, actualizando los datos originales.
- Usa setters con cuidado. Aseg√∫rate de que la l√≥gica del setter tenga sentido y actualice correctamente los datos subyacentes.

## D - Obtener el Valor Anterior (Previous Value)

#### 1. **Definicion:**

A partir de Vue 3.4, las computed properties tienen una caracter√≠stica genial: ¬°puedes acceder al **valor anterior** que devolvi√≥ la computed property! Esto es √∫til en situaciones donde necesitas comparar el valor actual con el anterior para tomar decisiones o realizar alguna l√≥gica espec√≠fica.

#### 2. **Ejemplo:**

**Options API:**

```javascript
export default {
  data() {
    return {
      count: 2,
    };
  },
  computed: {
    alwaysSmall(previous) {
      if (this.count <= 3) {
        return this.count;
      }
      return previous; // Devuelve el valor anterior si count > 3
    },
  },
};
```

**Composition API:**

```vue
<script setup>
import { ref, computed } from "vue";

const count = ref(2);

const alwaysSmall = computed((previous) => {
  if (count.value <= 3) {
    return count.value;
  }
  return previous; // Devuelve el valor anterior si count > 3
});
</script>
```

**Explicaci√≥n del ejemplo:**
En `alwaysSmall`, el primer argumento `previous` en la funci√≥n del `computed` contiene el valor que `alwaysSmall` devolvi√≥ en la **√∫ltima ejecuci√≥n**. En este ejemplo, `alwaysSmall` devuelve el valor de `count` mientras `count` sea menor o igual a 3. Si `count` se vuelve mayor que 3, `alwaysSmall` empieza a devolver el **valor anterior** que ten√≠a cuando `count` era 3 o menos.

#### 3. **Notas o advertencias:**

- Esta caracter√≠stica (`previous`) solo est√° disponible en Vue 3.4 y versiones posteriores.
- Es muy √∫til para l√≥gica condicional basada en cambios de valor en computed properties.

## E - Mejores Pr√°cticas - Getters sin "Side Effects"

#### 1. **Definicion:**

Los **getters** de las computed properties deben ser **"puras"**. Esto significa que solo deben hacer **c√°lculos** y **devolver un valor**. **¬°No deben hacer "side effects"!** ¬øQu√© son "side effects"? Son acciones que cambian algo **fuera** de la computed property misma, como:

- Modificar otros datos en tu componente (`this.otroDato = ...`).
- Hacer llamadas a APIs o peticiones as√≠ncronas.
- Modificar directamente el DOM (la p√°gina web).

#### 2. **Ejemplo de "Side Effect" MALO en un Getter:**

```javascript
computed: {
  badComputed() {
    this.count++; // ¬°MAL! Modifica 'count' (side effect)
    return this.count * 2;
  }
}
```

**Explicaci√≥n del ejemplo:**
En `badComputed`, el getter **modifica** `this.count` (increment√°ndolo). Esto es un side effect. Los getters de computed properties deben ser solo para **calcular** un valor, no para **cambiar** otros valores.

#### 3. **Notas o advertencias:**

- **Previsibilidad:** Los side effects en getters hacen que tu c√≥digo sea **dif√≠cil de entender y predecir**. Las computed properties deben ser reactivas y deterministas: dado el mismo conjunto de datos, siempre deben devolver el mismo resultado (sin side effects).
- **Para side effects, usa Watchers:** Si necesitas reaccionar a cambios en los datos y realizar acciones como llamadas a APIs o modificar el DOM, usa **watchers** en lugar de computed properties. Los watchers est√°n dise√±ados espec√≠ficamente para manejar side effects en respuesta a cambios reactivos. (Veremos watchers en otra cheat sheet üòâ).

## F - Mejores Pr√°cticas - No Modifiques el Valor de una Computed Property

#### 1. **Definicion:**

El valor que devuelve una computed property es un **valor derivado**. Pi√©nsalo como una "foto" temporal de un c√°lculo basado en otros datos. **No debes intentar modificar directamente** el valor que devuelve una computed property. En su lugar, si quieres cambiar el resultado de la computed property, debes **modificar los datos de los que depende**.

#### 2. **Ejemplo de Modificaci√≥n INCORRECTA:**

```html
<template>
  <p>Full name: {{ fullName }}</p>
  <button @click="modifyFullName">Modificar Nombre</button>
</template>

<script>
  export default {
    data() {
      return {
        firstName: "John",
        lastName: "Doe",
      };
    },
    computed: {
      fullName() {
        return this.firstName + " " + this.lastName;
      },
    },
    methods: {
      modifyFullName() {
        this.fullName = "Jane Smith"; // ¬°MAL! Intentando modificar computed property
      },
    },
  };
</script>
```

**Explicaci√≥n del ejemplo:**
En `modifyFullName`, intentamos asignar un nuevo valor a `this.fullName`. Esto **no funcionar√°** como esperas (o directamente Vue te dar√° un warning). `fullName` es una computed property, no una propiedad de datos normal que puedes modificar directamente.

#### 3. **Notas o advertencias:**

- **Flujo de datos unidireccional:** Vue promueve un flujo de datos unidireccional. Los datos fluyen **hacia** las computed properties para calcular valores, pero no al rev√©s.
- **Para modificar, actualiza los datos fuente:** Si quieres cambiar el "full name", debes modificar `firstName` o `lastName` directamente. Vue se encargar√° de recalcular `fullName` autom√°ticamente porque detecta que sus dependencias (`firstName`, `lastName`) han cambiado. Si necesitas que `fullName` sea modificable _directamente_, entonces necesitas una **computed property writable** (con setter), como vimos antes, o reconsiderar si realmente necesitas una computed property en este caso.
