## A - Computed Properties

**Definición:** Propiedades que derivan su valor de otras propiedades reactivas. Se usan para lógica compleja en el template y se almacenan en caché.

**Ejemplo:**

```Vue
<script setup>
import { reactive, computed } from 'vue'

const author = reactive({
  books: ['Libro 1', 'Libro 2']
})

const hasBooks = computed(() => author.books.length > 0)
</script>

<template>
  <p>¿Tiene libros?: {{ hasBooks }}</p>
</template>
```

(La propiedad hasBooks se actualiza automáticamente cuando cambia author.books.)

## B - Computed Caching vs. Methods

**Definición:** Las propiedades computadas se almacenan en caché, mientras que los métodos se ejecutan en cada renderizado.

**Ejemplo:**

```Vue
<script setup>
import { ref, computed } from 'vue'

const count = ref(0)

const expensiveComputation = computed(() => {
  console.log('Calculando...')
  return count.value * 2
})

function methodComputation() {
  console.log('Calculando con método...')
  return count.value * 2
}
</script>

<template>
  <p>Computada: {{ expensiveComputation }}</p>
  <p>Método: {{ methodComputation() }}</p>
  <button @click="count++">Incrementar</button>
</template>
```

(La propiedad computada solo se recalcula cuando count cambia, mientras que el método se ejecuta en cada renderizado.)

## C - Writable Computed

**Definición:** Propiedades computadas que tienen un getter y un setter, permitiendo modificar el valor derivado.

**Ejemplo:**

```Vue
<script setup>
import { ref, computed } from 'vue'

const firstName = ref('John')
const lastName = ref('Doe')

const fullName = computed({
  get() {
    return `${firstName.value} ${lastName.value}`
  },
  set(newValue) {
    [firstName.value, lastName.value] = newValue.split(' ')
  }
})
</script>
```

(Se puede asignar un nuevo valor a fullName, lo que actualiza firstName y lastName.)

## D - Getting the Previous Value

**Definición:** (Vue 3.4+) Se puede acceder al valor anterior de una propiedad computada a través del primer argumento del getter.

**Ejemplo:**

```Vue
<script setup>
import { ref, computed } from 'vue'

const count = ref(2)

const alwaysSmall = computed((previous) => {
  if (count.value <= 3) {
    return count.value
  }
  return previous
})
</script>
```

(Si count es mayor que 3, alwaysSmall mantiene su valor anterior.)

## E - Getters should be side-effect free

**Definición:** Los getters de las propiedades computadas deben ser funciones puras, sin efectos secundarios.

**Ejemplo:**

```Vue
<script setup>
import { ref, computed } from 'vue'

const count = ref(0)

// NO hacer esto:
const badComputed = computed(() => {
  count.value++ // Efecto secundario
  return count.value
})
</script>
```

(Los getters solo deben calcular y retornar un valor, no modificar otros datos.)

## F - Avoid mutating computed value

**Definición:** El valor retornado por una propiedad computada debe tratarse como de solo lectura. No se debe modificar directamente.

**Ejemplo:**

```Vue
<script setup>
import { ref, computed } from 'vue'

const count = ref(0)
const doubled = computed(() => count.value * 2)

// NO hacer esto:
// doubled.value = 10 // Error
</script>
```

(Para modificar el valor derivado, se debe modificar la propiedad reactiva de la que depende.)
