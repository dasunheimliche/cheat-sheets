## A - Computed Properties

**Definición:** Una computed property es una función que calcula un valor basado en otras propiedades reactivas. Funciona como un "cocinero" que prepara un plato (el valor computado) cada vez que cambian los ingredientes (las dependencias reactivas). La computed property "observa" esos ingredientes y actualiza el plato automáticamente. La principal ventaja es que solo recalcula el valor cuando cambian sus dependencias y ademas mantiene cacheada la última computación para un mejor rendimiento.

**Ejemplo:**

```vue
<template>
  <p>Nombre completo: {{ fullName }}</p>
  <button @click="firstName = 'Jane'">Cambiar nombre</button>
</template>

<script>
import { ref, computed } from "vue";

export default {
  setup() {
    const firstName = ref("John");
    const lastName = ref("Doe");

    const fullName = computed(() => {
      return `${firstName.value} ${lastName.value}`;
    });

    return {
      firstName,
      lastName,
      fullName,
    };
  },
};
</script>
```

**Descripción del ejemplo:** En este ejemplo, `fullName` es una computed property que concatena `firstName` y `lastName`. Al cambiar `firstName`, Vue recalculará `fullName`, ya que depende de `firstName`. Imagina que `fullName` es como un sandwich que cambia si le quitas o agregas algún ingrediente (`firstName` o `lastName`).

## B - Computed Caching vs. Methods

**Definición:** La diferencia clave entre las computed properties y los métodos está en cómo manejan las dependencias y la ejecución. Una computed property, al igual que una memoria prodigiosa, "recuerda" la última vez que calculó el valor y solo lo recalcula cuando las propiedades de las que depende cambian, ademas, guarda el último valor calculado (caching). Un método es como una calculadora que ejecuta la operación cada vez que se le pide un valor, sin recordar el resultado anterior. Es una decisión clave al momento de elegir una opción u otra para el desarrollo de código, ya que cuando la información a computar es grande el performance juega un papel muy importante y ahí se vuelve esencial la utilidad de computed properties.

**Ejemplo:**

```vue
<template>
  <p>Computado: {{ nowComputed }}</p>
  <p>Metodo: {{ nowMethod() }}</p>
  <p>Conteo: {{ count }}</p>
  <button @click="count++">Incrementar</button>
</template>

<script setup>
import { ref, computed } from "vue";

const count = ref(0);
const nowComputed = computed(() => {
  console.log("computed actualizado");
  return Date.now();
});
const nowMethod = () => {
  console.log("method ejecutado");
  return Date.now();
};
</script>
```

**Descripción del ejemplo:** `nowComputed` es una computed property, y `nowMethod` es un método. `nowComputed` se calcula una sola vez y se mantiene almacenado (cache). Mientras `nowMethod` se recalcula cada vez que cambia el estado del componente aunque no dependa del mismo. Lo cual quiere decir que, la ejecución en consola de 'computed actualizado' aparece la primera vez y luego no mas, y por otro lado 'method ejecutado' aparece en cada click del botón que actualiza el componente y no depende del valor de `nowMethod`, ahí vemos el "caching" en funcionamiento de una computed property vs el método que se ejecutada sin importar dependencia o no.

## C - Writable Computed

**Definición:** Una writable computed property permite tanto leer (obtener) como asignar (establecer) un valor a través de una función get y una función set, respectivamente. Es como tener una caja que puedes abrir para ver lo que hay dentro, pero también puedes usarla para guardar cosas nuevas, controlando cómo se maneja la información tanto al "sacar" como al "meter".

**Ejemplo:**

```vue
<template>
  <p>Nombre completo: {{ fullName }}</p>
  <input type="text" :value="fullName" @input="setFullName($event)" />
</template>
<script setup>
import { ref, computed } from "vue";

const firstName = ref("John");
const lastName = ref("Doe");

const fullName = computed({
  get: () => `${firstName.value} ${lastName.value}`,
  set: (newValue) => {
    [firstName.value, lastName.value] = newValue.split(" ");
  },
});

function setFullName(event) {
  fullName.value = event.target.value;
}
</script>
```

**Descripción del ejemplo:** `fullName` es una writable computed property que une `firstName` y `lastName` y a su vez permite cambiar estos últimos. El getter genera el nombre completo y el setter lo divide actualizando `firstName` y `lastName`. Imaginate que `fullName` es una persona, que tiene el nombre y el apellido, pero que si modificamos el nombre, el apellido va por otro camino (o viceversa).

## D - Getting the Previous Value

**Definición:** En las computed properties, el getter recibe un argumento `previous` el cual es el último valor calculado. Imagínalo como un "historial" que la computed property recuerda para poder saber qué resultado dio la última vez y compararlo con el actual si es necesario para una lógica de condicionales o lo que el programador estime conveniente.
**Ejemplo:**

```vue
<template>
  <p>Valor: {{ alwaysSmall }}</p>
  <button @click="count++">Incrementar</button>
</template>

<script setup>
import { ref, computed } from "vue";

const count = ref(2);

const alwaysSmall = computed((previous) => {
  if (count.value <= 3) {
    return count.value;
  }

  return previous;
});
</script>
```

**Descripción del ejemplo:** `alwaysSmall` muestra `count` si es menor o igual a 3, pero si es mayor muestra el último valor de `count` que cumplio la condición, por ej, si `count` es 5 y despues lo cambiamos a 6, alwaysSmall siempre sera el ultimo valor que cumplió la condición (osea 3). En este caso, previous funciona como un seguro que no deja que un número mas alto se visualice aunque su contador cambie hasta que ese contador vuelva a la condición original, en el caso de menor o igual a 3, ahí se visualizará la nueva info.

## E - Best Practices: Side-effect Free Getters y Mutating Computed Value

**Definición:** Es una regla fundamental de las computed properties el NO generar ningún tipo de cambio ajeno en su declaración (side-effect free), solamente debe enfocarse en obtener un valor resultante de los estados que las disparan. No deben generar peticiones asíncronas o tocar el DOM, osea cualquier cambio por fuera de la operación del valor resultante. Además, se recomienda **no mutar el valor devuelto** de una computed property, dado que es un valor de tipo "snapshot", un estado que se recalcula en caso de cambios, osea debe ser inmutable, en vez de modificar el snapshot, es recomendable actuar sobre los estados que disparan la computed property para generar un nuevo snapshot. En palabras más sencillas, debemos evitar el uso de la computed para fines ajenos a la simple computación de su resultado. Debemos siempre enfocarnos en tener getters puras sin efectos colaterales y dejar las mutaciones o acciones a un ciclo de vida mas apropriado o en métodos.

**Ejemplo (Malas prácticas):**

```vue
<template>
  <p>Valor computado: {{ badComputed }}</p>
  <button @click="incrementar">Incrementar Contador</button>
  <button @click="fetchData">Fetch Data</button>
  <p>Valor real: {{ count }}</p>

  <ul>
    <li v-for="(item, index) in list" :key="index">{{ item }}</li>
  </ul>
</template>

<script setup>
import { ref, computed, onMounted } from "vue";

const count = ref(0);
const list = ref([]);
const badComputed = computed(() => {
  // Mal: No se debe mutar una propiedad externa directamente desde el computed getter.
  count.value++;
  // Mal: No hacer solicitudes asincrónicas ni tocar el DOM en computed
  fetch("https://jsonplaceholder.typicode.com/todos/1")
    .then((response) => response.json())
    .then((json) => {
      list.value.push(json.title);
    });

  // Mal: No mutar un valor computado.
  return "Esto es incorrecto y puede causar bugs, ya que esto no debe existir";
});

function incrementar() {
  count.value++;
  console.log("El contador ha sido aumentado a", count.value);
}
async function fetchData() {
  try {
    const response = await fetch(
      "https://jsonplaceholder.typicode.com/todos/1"
    );
    if (!response.ok) {
      throw new Error("HTTP error, status = " + response.status);
    }

    const data = await response.json();

    list.value.push(data.title);
  } catch (error) {
    console.error("Failed to fetch data", error);
  }
}
</script>
```

**Descripción del ejemplo:** Aquí `badComputed` tiene múltiples malas practicas, se modifica `count`, llama a una peticion async y por si fuera poco intenta mutar su propio valor resultante. Los computed values deben usarse solamente para hacer una operacion que involucre a las variables observadas en él sin generar mutaciones u otras acciones a variables ajenas a esta computación. Si queremos hacer fetch data o modificar una variable que dispare el computed, esto debe hacerse desde el padre o una función auxiliar para tal fin y la variable resultado simplemente debe reflejar este cambio desde su declaración como dependencia observada.
