## A - Slots

**Definición:** Los "slots" son un mecanismo que permite a un componente padre insertar contenido de template (HTML) en un componente hijo en una ubicación definida. Imagina que son como "huecos" o "ranuras" en el componente hijo donde el padre puede colocar el contenido que desee. Permiten que los componentes sean más flexibles y reutilizables.

**Ejemplo:**

```vue
// Componente hijo: FancyButton.vue
<template>
  <button class="fancy-btn">
    <slot></slot>
  </button>
</template>
```

```vue
// Componente padre: ParentComponent.vue
<template>
  <FancyButton> ¡Haz clic aquí! </FancyButton>
</template>

<script setup>
import FancyButton from "./FancyButton.vue";
</script>
```

**Descripción del ejemplo:** `FancyButton` tiene un `<slot>` que actúa como un punto de inserción. El padre (`ParentComponent`) coloca el texto `¡Haz clic aquí!` dentro de ese slot. Es como si el padre diera el texto a su hijo para que lo mostrara en su estructura.

## B - Contenido y Salida de Slot

**Definición:** El "contenido de slot" es el código HTML que el componente padre proporciona para ser renderizado dentro del slot del componente hijo. La "salida de slot" es el elemento `<slot>` en el template del componente hijo, que indica dónde se debe insertar el contenido de slot. Son las dos partes de la misma funcionalidad: lo que se inserta y el lugar dónde se inserta.

**Ejemplo:** Ver el ejemplo anterior (sección A).

**Descripción del ejemplo:** `¡Haz clic aquí!` es el contenido de slot, y el elemento `<slot>` dentro del `<button>` es la salida de slot. El contenido se inserta en el lugar de la salida.

## C - Ámbito de Renderizado

**Definición:** El contenido de slot tiene acceso al ámbito de datos (data scope) del componente padre, donde está definido. No tiene acceso al ámbito de datos del componente hijo. Es como si el contenido slot viviera y usara los recursos del componente padre, no los del hijo.

**Ejemplo:**

```vue
// Componente padre
<template>
  <span>{{ message }}</span>
  <FancyButton>{{ message }}</FancyButton>
</template>

<script setup>
import { ref } from "vue";
import FancyButton from "./FancyButton.vue";

const message = ref("Hola mundo!");
</script>
```

**Descripción del ejemplo:** El `{{ message }}` dentro del componente padre y en el slot de `FancyButton` renderizarán `Hola mundo!`, porque el slot toma el contexto del padre. El contenido del slot solo usa la información del componente donde es definido, no del componente donde es renderizado.

## D - Contenido de Respaldo (Fallback)

**Definición:** El contenido de respaldo es el contenido por defecto que se muestra en un slot si el componente padre no proporciona ningún contenido para ese slot. Es como una opción "por si acaso" que el componente hijo ofrece para cuando el padre no envía nada.

**Ejemplo:**

```vue
// Componente hijo: SubmitButton.vue
<template>
  <button type="submit">
    <slot>Enviar</slot>
  </button>
</template>
```

```vue
// Componente padre 1: ParentComponent1.vue
<template>
  <SubmitButton />
  <!-- Muestra "Enviar" -->
</template>
```

```vue
// Componente padre 2: ParentComponent2.vue
<template>
  <SubmitButton>Guardar</SubmitButton>
</template>
```

**Descripción del ejemplo:** Si `SubmitButton` se usa sin contenido de slot, muestra el texto `Enviar`. Si se usa con un contenido, como en el segundo caso, muestra `Guardar`. El contenido de respaldo garantiza que siempre haya algo que mostrar.

## E - Slots Nombrados

**Definición:** Los slots nombrados permiten que un componente hijo tenga múltiples puntos de inserción con nombres únicos. Es como si el componente hijo ofreciera diferentes "bandejas" para que el padre coloque diferentes tipos de contenido.

**Ejemplo:**

```vue
// Componente hijo: BaseLayout.vue
<template>
  <div class="container">
    <header>
      <slot name="header"></slot>
    </header>
    <main>
      <slot></slot>
    </main>
    <footer>
      <slot name="footer"></slot>
    </footer>
  </div>
</template>
```

```vue
// Componente padre: ParentComponent.vue
<template>
  <BaseLayout>
    <template #header>
      <h1>Título de la página</h1>
    </template>
    <p>Contenido principal.</p>
    <template #footer>
      <p>Información de contacto.</p>
    </template>
  </BaseLayout>
</template>

<script setup>
import BaseLayout from "./BaseLayout.vue";
</script>
```

**Descripción del ejemplo:** `BaseLayout` tiene tres slots: `header` (con nombre), `default` (sin nombre) y `footer` (con nombre). El padre usa `#header` y `#footer` para especificar qué contenido va en cada uno. El slot `default` es implícito para el contenido que no esté dentro de un template. Es como si tuviéramos diferentes "entradas" en el componente para contenido específico.

## F - Slots Condicionales

**Definición:** Permite mostrar contenido diferente en un componente hijo en función de si el componente padre ha proporcionado o no contenido a un slot. Utiliza `v-if` junto con la propiedad `$slots` para determinar la existencia de contenido. Es como un "interruptor" que decide qué mostrar según si hay contenido en un slot o no.

**Ejemplo:**

```vue
// Componente hijo: Card.vue
<template>
  <div class="card">
    <div v-if="$slots.header" class="card-header">
      <slot name="header" />
    </div>
    <div v-if="$slots.default" class="card-content">
      <slot />
    </div>
    <div v-if="$slots.footer" class="card-footer">
      <slot name="footer" />
    </div>
  </div>
</template>
```

**Descripción del ejemplo:** `Card` muestra un header solo si se ha pasado contenido al slot `header`, un content solo si se ha pasado contenido default, y un footer solo si se ha pasado contenido al slot `footer`. `v-if` usa la información del objeto `$slots` para decidir qué mostrar. Es como un sistema de "detección" que muestra o esconde elementos según el contenido que reciba.

## G - Nombres de Slot Dinámicos

**Definición:** Permite definir el nombre de un slot de forma dinámica utilizando los argumentos dinámicos de las directivas (ej: `#[dynamicSlotName]`). Es como usar una variable para especificar a dónde va el contenido del slot.

**Ejemplo:**

```vue
<template>
  <base-layout>
    <template v-slot:[dynamicSlotName]>
      <h1>Hola!</h1>
    </template>
  </base-layout>
</template>

<script setup>
import { ref } from "vue";
import BaseLayout from "./BaseLayout.vue";
const dynamicSlotName = ref("header");
</script>
```

**Descripción del ejemplo:** El template usa `#[dynamicSlotName]` para definir a qué slot va el contenido. En este caso va al slot `header`, pero si cambiamos el valor de `dynamicSlotName`, irá a otro slot. Es como tener un "selector" dinámico que redirige el contenido al slot adecuado.

## H - Scoped Slots

**Definición:** Los scoped slots permiten a un componente hijo pasar datos al contenido del slot que proporciona el componente padre. Es como si el hijo le diera al padre un "kit de herramientas" para que este pueda crear el contenido que se va a mostrar. El padre usa estos datos para personalizar el contenido del slot.

**Ejemplo:**

```vue
// Componente hijo
<template>
  <div>
    <slot :text="greetingMessage" :count="1"></slot>
  </div>
</template>

<script setup>
import { ref } from "vue";
const greetingMessage = ref("Hola");
</script>
```

```vue
// Componente padre
<template>
  <MyComponent v-slot="slotProps">
    {{ slotProps.text }} {{ slotProps.count }}
  </MyComponent>
</template>

<script setup>
import MyComponent from "./MyComponent.vue";
</script>
```

**Descripción del ejemplo:** `MyComponent` pasa `greetingMessage` y `count` como props al slot. El padre usa `v-slot="slotProps"` para recibir esos props y usarlos en su template. Es como un intercambio de información entre el hijo y el padre a través del slot.

## I - Slots Nombrados con Scope

**Definición:** Permite combinar las ventajas de slots nombrados con scoped slots. Es como tener "bandejas de inserción" específicas, donde cada una de ellas recibe su propio "kit de herramientas" con props específicos.

**Ejemplo:**

```vue
// Componente hijo: MyComponent.vue
<template>
  <slot name="header" :message="headerMsg"></slot>
  <slot :default="defaultMsg"></slot>
  <slot name="footer" :message="footerMsg"></slot>
</template>

<script setup>
import { ref } from "vue";
const headerMsg = ref("Mensaje del header");
const defaultMsg = ref("Mensaje del default");
const footerMsg = ref("Mensaje del footer");
</script>
```

```vue
// Componente padre
<template>
  <MyComponent>
    <template #header="headerProps">
      Header: {{ headerProps.message }}
    </template>
    <template #default="defaultProps">
      Default: {{ defaultProps.defaultMsg }}
    </template>
    <template #footer="footerProps">
      Footer: {{ footerProps.message }}
    </template>
  </MyComponent>
</template>
```

**Descripción del ejemplo:** El componente hijo pasa props diferentes a cada slot. El padre usa `#header="headerProps"`, `#default="defaultProps"` y `#footer="footerProps"` para recibir los datos de cada slot y personalizarlos. Es como tener múltiples "canales de comunicación" que permiten al hijo enviar datos diferentes al padre para cada slot.

## J - Renderless Components

**Definición:** Son componentes que no renderizan ningún elemento visual por sí mismos. En vez de eso, solo encapsulan lógica y delegan la salida visual a través de scoped slots. Son como "motores" que dan lógica a un proceso pero dejan que otros componentes diseñen la interfaz.

**Ejemplo:**

```vue
// Componente hijo: MouseTracker.vue
<script setup>
import { ref, onMounted, onUnmounted } from "vue";
const x = ref(0);
const y = ref(0);

function update(event) {
  x.value = event.pageX;
  y.value = event.pageY;
}

onMounted(() => window.addEventListener("mousemove", update));
onUnmounted(() => window.removeEventListener("mousemove", update));
</script>
<template>
  <slot :x="x" :y="y"></slot>
</template>
```

```vue
// Componente padre
<template>
  <MouseTracker v-slot="{ x, y }">
    Posición del mouse: {{ x }}, {{ y }}
  </MouseTracker>
</template>

<script setup>
import MouseTracker from "./MouseTracker.vue";
</script>
```

**Descripción del ejemplo:** `MouseTracker` no tiene salida visual, pero captura la posición del mouse y la pasa al slot. El padre usa `v-slot` para obtener esos datos y mostrarlos. Es como un componente invisible que se encarga de la lógica y deja la interfaz a otros componentes.
