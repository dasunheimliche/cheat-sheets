## A - Slot Content y Outlet

#### 1. **Definici√≥n:**

Imagina que tienes un componente como una caja `<FancyButton>`. Un **slot outlet** `<slot>` dentro de la caja es como un hueco donde puedes poner cosas desde fuera. El **slot content** es justo lo que pones dentro de la caja `<FancyButton>` cuando la usas en otro componente.

#### 2. **Ejemplo:**

**Componente `FancyButton.vue` (el hijo):**

```vue
<template>
  <button class="fancy-btn">
    <slot></slot>
    <!-- üëà Aqu√≠ va el contenido del slot -->
  </button>
</template>

<style scoped>
.fancy-btn {
  background-color: lightblue;
  padding: 10px 20px;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}
</style>
```

**Componente padre (usando `FancyButton`):**

```vue
<template>
  <div>
    <FancyButton>
      ¬°Haz clic aqu√≠!
      <!-- üëà Esto es el slot content -->
    </FancyButton>
  </div>
</template>
```

**Resultado Renderizado:**

```html
<button class="fancy-btn">¬°Haz clic aqu√≠!</button>
```

**Explicaci√≥n del ejemplo:**
El componente `FancyButton` define c√≥mo se ve el bot√≥n (estilo "fancy"). El texto "¬°Haz clic aqu√≠!" se define en el componente padre y se "inyecta" dentro del `<slot>` en `FancyButton`. ¬°As√≠ el bot√≥n tiene el estilo de `FancyButton` pero el texto del padre!

#### 3. **Notas o advertencias:**

- Piensa en los slots como "huecos" en tus componentes hijos que llenas con contenido desde los componentes padres.
- El slot content puede ser texto, HTML, ¬°o incluso otros componentes Vue!

## B - Render Scope (Alcance de Renderizado)

#### 1. **Definici√≥n:**

El **slot content** se define en el componente padre, por lo que tiene acceso a **los datos del padre**, ¬°pero no a los datos del componente hijo! Es como si el contenido del slot "viviera" en el componente padre, aunque se muestre en el hijo.

#### 2. **Ejemplo:**

**Componente `FancyButton.vue` (hijo):**

```vue
<template>
  <button class="fancy-btn">
    <slot></slot>
  </button>
</template>
```

**Componente padre:**

```vue
<template>
  <div>
    <span>{{ mensaje }}</span>
    <!-- ‚úÖ Accede a 'mensaje' del padre -->
    <FancyButton>{{ mensaje }}</FancyButton>
    <!-- ‚úÖ Tambi√©n accede a 'mensaje' del padre -->
  </div>
</template>

<script>
export default {
  data() {
    return {
      mensaje: "Hola desde el padre",
    };
  },
};
</script>
```

**Explicaci√≥n del ejemplo:**
Ambos `{{ mensaje }}` muestran "Hola desde el padre" porque el slot content (en `<FancyButton>`) est√° definido en el padre y usa el `data` del padre.

#### 3. **Notas o advertencias:**

- Recuerda: **Padre para el contenido, Hijo para el estilo y estructura.**
- El slot content solo "ve" las variables del componente donde se define (el padre).

## C - Fallback Content (Contenido de Respaldo)

#### 1. **Definici√≥n:**

El **fallback content** es un contenido **por defecto** que se muestra en un slot **si el componente padre no proporciona ning√∫n slot content**. Es como un plan B, por si acaso.

#### 2. **Ejemplo:**

**Componente `SubmitButton.vue`:**

```vue
<template>
  <button type="submit">
    <slot>
      Enviar
      <!-- üëà Fallback content: "Enviar" -->
    </slot>
  </button>
</template>
```

**Uso 1 (sin slot content en el padre):**

```vue
<template>
  <SubmitButton />
</template>
```

**Resultado 1:**

```html
<button type="submit">Enviar</button>
<!-- Se muestra el fallback content -->
```

**Uso 2 (con slot content en el padre):**

```vue
<template>
  <SubmitButton>Guardar</SubmitButton>
</template>
```

**Resultado 2:**

```html
<button type="submit">Guardar</button>
<!-- Se muestra el slot content del padre -->
```

**Explicaci√≥n del ejemplo:**
Si usas `<SubmitButton>` sin nada dentro, se muestra "Enviar" (el fallback). Si pones algo dentro, como "Guardar", eso reemplaza el "Enviar".

#### 3. **Notas o advertencias:**

- El fallback content es genial para dar un comportamiento por defecto a tus componentes.
- Si el padre s√≠ da contenido, el fallback se ignora.

## D - Named Slots (Slots con Nombre)

#### 1. **Definici√≥n:**

Los **named slots** te permiten tener **m√∫ltiples "huecos"** dentro de un componente. Cada slot tiene un **nombre**, y as√≠ puedes decidir qu√© contenido del padre va en cada hueco espec√≠fico del hijo.

#### 2. **Ejemplo:**

**Componente `BaseLayout.vue` (con slots nombrados):**

```vue
<template>
  <div class="container">
    <header>
      <slot name="header"></slot>
      <!-- üëà Slot nombrado "header" -->
    </header>
    <main>
      <slot></slot>
      <!-- üëà Slot "default" (sin nombre) -->
    </main>
    <footer>
      <slot name="footer"></slot>
      <!-- üëà Slot nombrado "footer" -->
    </footer>
  </div>
</template>
```

**Componente padre (usando `BaseLayout`):**

```vue
<template>
  <BaseLayout>
    <template #header>
      <!-- üëà Slot "header" -->
      <h1>T√≠tulo de la p√°gina</h1>
    </template>

    <template #default>
      <!-- üëà Slot "default" -->
      <p>Contenido principal.</p>
    </template>

    <template #footer>
      <!-- üëà Slot "footer" -->
      <p>Informaci√≥n de contacto</p>
    </template>
  </BaseLayout>
</template>
```

![Diagrama de named slots](https://vuejs.org/assets/named-slots.CCIb9Mo_.png)

**Resultado Renderizado:**

```html
<div class="container">
  <header>
    <h1>T√≠tulo de la p√°gina</h1>
  </header>
  <main>
    <p>Contenido principal.</p>
  </main>
  <footer>
    <p>Informaci√≥n de contacto</p>
  </footer>
</div>
```

**Explicaci√≥n del ejemplo:**
`BaseLayout` tiene tres slots: `header`, `default` (sin nombre, es el principal) y `footer`. En el padre, usamos `<template #nombreSlot>` para indicar qu√© contenido va en cada slot del `BaseLayout`. `#` es una forma corta de `v-slot:`.

#### 3. **Notas o advertencias:**

- Usa named slots cuando quieras estructurar el contenido de un componente en diferentes secciones.
- El slot que no tiene `name` se llama "default".
- Puedes usar `<template v-slot:nombreSlot>` o la forma corta `<template #nombreSlot>`.

## E - Conditional Slots (Slots Condicionales)

#### 1. **Definici√≥n:**

Puedes decidir **si mostrar o no un slot** en el componente hijo **dependiendo de si el padre ha proporcionado contenido para ese slot**. Esto te da m√°s control sobre la estructura del componente hijo.

#### 2. **Ejemplo:**

**Componente `Card.vue` (con slots condicionales):**

```vue
<template>
  <div class="card">
    <div v-if="$slots.header" class="card-header">
      <!-- üëà Mostrar solo si hay slot 'header' -->
      <slot name="header" />
    </div>

    <div v-if="$slots.default" class="card-content">
      <!-- üëà Mostrar solo si hay slot 'default' -->
      <slot />
    </div>

    <div v-if="$slots.footer" class="card-footer">
      <!-- üëà Mostrar solo si hay slot 'footer' -->
      <slot name="footer" />
    </div>
  </div>
</template>

<style scoped>
.card {
  border: 1px solid #ccc;
  border-radius: 5px;
}
.card-header {
  padding: 10px;
  border-bottom: 1px solid #eee;
}
.card-content {
  padding: 20px;
}
.card-footer {
  padding: 10px;
  border-top: 1px solid #eee;
  text-align: right;
}
</style>
```

**Uso en el padre (solo con header y contenido):**

```vue
<template>
  <Card>
    <template #header>
      <h2>T√≠tulo de la tarjeta</h2>
    </template>
    <p>Este es el contenido de la tarjeta.</p>
  </Card>
</template>
```

**Explicaci√≥n del ejemplo:**
`Card.vue` usa `v-if="$slots.header"` para mostrar el `div` del header **solo si** el padre ha definido un slot con nombre "header". Lo mismo para `footer` y `default`. En el ejemplo de uso, no se define el slot `footer`, as√≠ que no se renderiza esa parte de la tarjeta.

#### 3. **Notas o advertencias:**

- `$slots` es un objeto que contiene informaci√≥n sobre los slots que ha recibido el componente.
- `$slots.nombreSlot` es `true` si hay contenido para el slot "nombreSlot", y `false` si no.
- √ötil para crear componentes que se adapten a diferentes usos seg√∫n el contenido que reciban.

## F - Dynamic Slot Names (Nombres de Slot Din√°micos)

#### 1. **Definici√≥n:**

Puedes usar **nombres de slot din√°micos**, es decir, el nombre del slot **no est√° fijo en el template**, sino que se calcula o se obtiene de una variable.

#### 2. **Ejemplo:**

```vue
<template>
  <BaseLayout>
    <template #[slotName]>
      <!-- üëà Nombre del slot din√°mico -->
      <!-- Contenido para el slot din√°mico -->
      Contenido para el slot: {{ slotName }}
    </template>
  </BaseLayout>
</template>

<script>
export default {
  data() {
    return {
      slotName: "header", // El nombre del slot puede cambiar din√°micamente
    };
  },
};
</script>
```

**Explicaci√≥n del ejemplo:**
`#[slotName]` usa el valor de la variable `slotName` (que es 'header' en este caso) como nombre del slot. Si cambias `slotName` a 'footer', el contenido se renderizar√° en el slot 'footer' de `BaseLayout`.

#### 3. **Notas o advertencias:**

- Los nombres de slot din√°micos son √∫tiles cuando necesitas decidir el slot a usar en tiempo de ejecuci√≥n.
- Recuerda las reglas de sintaxis para argumentos din√°micos en Vue.

## G - Scoped Slots (Slots con Alcance)

#### 1. **Definici√≥n:**

Los **scoped slots** permiten que el componente **hijo** pase **datos** al **slot content** definido en el componente **padre**. Es como si el hijo le diera "herramientas" al padre para que personalice el slot content.

#### 2. **Ejemplo:**

**Componente `MyComponent.vue` (hijo, pasando datos al slot):**

```vue
<template>
  <div>
    <slot :texto="mensajeSaludo" :contador="numero"></slot>
    <!-- üëà Pasando 'texto' y 'contador' al slot -->
  </div>
</template>

<script>
export default {
  data() {
    return {
      mensajeSaludo: "Hola desde el hijo",
      numero: 123,
    };
  },
};
</script>
```

**Componente padre (recibiendo datos del slot):**

```vue
<template>
  <MyComponent v-slot="slotProps">
    <!-- üëà Recibiendo los datos en 'slotProps' -->
    {{ slotProps.texto }} - {{ slotProps.contador }}
    <!-- üëà Usando los datos del hijo -->
  </MyComponent>
</template>
```

![Diagrama de scoped slots](https://vuejs.org/assets/scoped-slots.B67tIPc5.svg)

**Resultado Renderizado:**

```html
<div>Hola desde el hijo - 123</div>
```

**Explicaci√≥n del ejemplo:**
En `MyComponent`, `<slot :texto="mensajeSaludo" :contador="numero">` pasa los datos `mensajeSaludo` y `numero` al slot. En el padre, `v-slot="slotProps"` captura esos datos en la variable `slotProps`. Luego, el padre puede usar `slotProps.texto` y `slotProps.contador` para mostrar los datos del hijo dentro del slot content.

#### 3. **Notas o advertencias:**

- Los scoped slots son s√∫per potentes para crear componentes reutilizables pero personalizables.
- Piensa en los datos que pasas al slot como "props del slot".
- Puedes usar destructuring en `v-slot` para acceder a los datos directamente: `<MyComponent v-slot="{ texto, contador }">`.

## H - Named Scoped Slots (Slots con Alcance y Nombre)

#### 1. **Definici√≥n:**

Puedes combinar **named slots** y **scoped slots**. As√≠, tienes slots nombrados y, adem√°s, cada slot puede recibir datos del componente hijo.

#### 2. **Ejemplo:**

**Componente `MyComponent.vue` (hijo, con named scoped slots):**

```vue
<template>
  <div>
    <slot name="header" mensaje="Saludo del header"></slot>
    <!-- üëà Slot 'header' con datos -->
    <slot :mensaje="SaludoDefault"></slot>
    <!-- üëà Slot 'default' con datos -->
    <slot name="footer"></slot>
  </div>
</template>

<script>
export default {
  data() {
    return {
      SaludoDefault: "Saludo del slot default",
    };
  },
};
</script>
```

**Componente padre (usando named scoped slots):**

```vue
<template>
  <MyComponent>
    <template #header="headerProps">
      <!-- üëà Slot 'header' y sus props -->
      <h3>{{ headerProps.mensaje }}</h3>
    </template>

    <template #default="defaultProps">
      <!-- üëà Slot 'default' y sus props -->
      <p>{{ defaultProps.mensaje }}</p>
    </template>

    <template #footer>
      <!-- üëà Slot 'footer' (sin props) -->
      <p>Informaci√≥n del footer</p>
    </template>
  </MyComponent>
</template>
```

**Explicaci√≥n del ejemplo:**
`MyComponent` tiene slots `header`, `default` y `footer`. `header` y `default` pasan datos (`mensaje`). En el padre, `<template #header="headerProps">` recibe los datos del slot `header` en `headerProps`, y `<template #default="defaultProps">` recibe los datos del slot `default` en `defaultProps`. El slot `footer` no pasa datos, as√≠ que se usa como un named slot normal.

#### 3. **Notas o advertencias:**

- Para named scoped slots, usa `<template #nombreSlot="slotProps">`.
- Si mezclas named slots con el slot default scoped, usa `<template #default="slotProps">` expl√≠citamente para el slot default.

## I - Fancy List Example (Ejemplo de Lista Fancy)

#### 1. **Definici√≥n:**

Un ejemplo pr√°ctico de scoped slots es crear una lista flexible `<FancyList>`. `<FancyList>` se encarga de la l√≥gica de la lista (cargar datos, paginaci√≥n, etc.), pero deja que el componente padre defina **c√≥mo se ve cada elemento de la lista** usando un scoped slot.

#### 2. **Ejemplo:**

**Componente `FancyList.vue` (hijo, con scoped slot para los items):**

```vue
<template>
  <ul>
    <li v-for="item in items" :key="item.id">
      <slot name="item" v-bind="item"></slot>
      <!-- üëà Slot 'item' con datos de cada item -->
    </li>
  </ul>
</template>

<script>
export default {
  props: {
    items: {
      type: Array,
      required: true,
    },
  },
};
</script>
```

**Componente padre (usando `FancyList` y definiendo el aspecto de cada item):**

```vue
<template>
  <FancyList :items="listaDeDatos">
    <template #item="itemProps">
      <!-- üëà Slot 'item' y sus props (datos del item) -->
      <div class="item">
        <p>{{ itemProps.body }}</p>
        <p>Por {{ itemProps.username }} | {{ itemProps.likes }} likes</p>
      </div>
    </template>
  </FancyList>
</template>

<script>
export default {
  data() {
    return {
      listaDeDatos: [
        {
          id: 1,
          body: "Contenido del item 1",
          username: "UsuarioA",
          likes: 10,
        },
        { id: 2, body: "Contenido del item 2", username: "UsuarioB", likes: 5 },
      ],
    };
  },
};
</script>

<style scoped>
.item {
  border: 1px solid #ccc;
  margin-bottom: 10px;
  padding: 10px;
}
</style>
```

![Ejemplo de Fancy List](https://vuejs.org/assets/slots.CKcE8XYd.png)

**Explicaci√≥n del ejemplo:**
`FancyList` itera sobre `items` y renderiza el slot `item` **para cada item**, pasando los datos del item (`v-bind="item"`). El componente padre usa `<template #item="itemProps">` para definir **c√≥mo se muestra cada item**, usando los datos `itemProps` que le pasa `FancyList`.

#### 3. **Notas o advertencias:**

- Este ejemplo muestra c√≥mo los scoped slots permiten separar la l√≥gica de un componente (manejo de la lista) de su presentaci√≥n visual (aspecto de cada item).
- `v-bind="item"` es una forma abreviada de pasar todas las propiedades del objeto `item` como props del slot.

## J - Renderless Components (Componentes Sin Renderizado)

#### 1. **Definici√≥n:**

Un **renderless component** es un componente que **no renderiza nada por s√≠ mismo**. Su √∫nica funci√≥n es **encapsular l√≥gica** y **pasar datos** a trav√©s de scoped slots para que el componente padre se encargue de la presentaci√≥n visual completa.

#### 2. **Ejemplo:**

**Componente `MouseTracker.vue` (renderless component):**

```vue
<template>
  <div
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"
    @mousemove="onMouseMove"
  >
    <slot :x="x" :y="y"></slot>
    <!-- üëà Slot pasando las coordenadas del rat√≥n -->
  </div>
</template>

<script>
export default {
  data() {
    return {
      x: 0,
      y: 0,
    };
  },
  methods: {
    onMouseMove(event) {
      this.x = event.clientX;
      this.y = event.clientY;
    },
  },
};
</script>
```

**Componente padre (usando `MouseTracker` para mostrar la posici√≥n del rat√≥n):**

```vue
<template>
  <div>
    <MouseTracker v-slot="{ x, y }">
      <!-- üëà Recibiendo 'x' e 'y' del slot -->
      Posici√≥n del rat√≥n: X={{ x }}, Y={{ y }}
    </MouseTracker>
  </div>
</template>
```

**Explicaci√≥n del ejemplo:**
`MouseTracker` no renderiza nada visualmente relevante por s√≠ mismo (solo un `div` invisible que ocupa toda la pantalla para capturar eventos de rat√≥n). Su l√≥gica es rastrear la posici√≥n del rat√≥n y pasar las coordenadas `x` e `y` a trav√©s del slot. El componente padre usa el scoped slot para **renderizar la posici√≥n del rat√≥n como texto**.

#### 3. **Notas o advertencias:**

- Los renderless components son una t√©cnica avanzada para la reutilizaci√≥n de l√≥gica en Vue.
- Aunque son interesantes, la Composition API de Vue ofrece formas m√°s eficientes de lograr la reutilizaci√≥n de l√≥gica sin la necesidad de componentes renderless en muchos casos.
- Los scoped slots siguen siendo √∫tiles cuando necesitas combinar l√≥gica encapsulada con la composici√≥n de la salida visual, como en el ejemplo de `FancyList`.
