## A - Slot Content and Outlet

**Definición:** Un slot es un espacio reservado en la plantilla de un componente hijo donde el componente padre puede insertar contenido HTML. El <slot> en el componente hijo es el "outlet" y el contenido que se pasa desde el padre es el "content".

**Ejemplo:**

```Vue
// Componente hijo (FancyButton.vue)
<template>
  <button class="fancy-btn">
    <slot></slot>
  </button>
</template>
```

```Vue
// Componente padre
<template>
  <FancyButton>Click me!</FancyButton>
</template>
```

(En este ejemplo, el texto "Click me!" se inserta en el slot del componente FancyButton.)

## B - Render Scope

**Definición:** El contenido del slot tiene acceso al scope del componente padre, ya que se define en el padre. No tiene acceso al scope del componente hijo.

**Ejemplo:**

```Vue
// Componente padre
<template>
  <span>{{ message }}</span>
  <FancyButton>{{ message }}</FancyButton>
</template>
<script setup>
import { ref } from 'vue';
import FancyButton from './FancyButton.vue';
const message = ref('Hello');
</script>
```

(En este caso, ambos {{ message }} renderizarán "Hello", ya que el slot tiene acceso al scope del padre.)

## C - Fallback Content

**Definición:** Se puede definir contenido por defecto para un slot que se renderizará si el componente padre no proporciona ningún contenido para ese slot.

**Ejemplo:**

```Vue
// Componente hijo (SubmitButton.vue)
<template>
  <button type="submit">
    <slot>Submit</slot>
  </button>
</template>
```

```Vue
// Componente padre
<template>
  <SubmitButton>Save</SubmitButton>
  <SubmitButton />
</template>
```

(En este ejemplo, el primer SubmitButton renderizará "Save", mientras que el segundo renderizará el contenido por defecto "Submit".)

## D - Named Slots

**Definición:** Los named slots permiten tener múltiples espacios de inserción en un componente hijo, cada uno con un nombre único. Se usan con la directiva v-slot (o su abreviatura #) en el componente padre.

**Ejemplo:**

```Vue
// Componente hijo (BaseLayout.vue)
<template>
  <div class="container">
    <header>
      <slot name="header"></slot>
    </header>
    <main>
      <slot></slot>
    </main>
    <footer>
      <slot name="footer"></slot>
    </footer>
  </div>
</template>
```

```Vue
// Componente padre
<template>
  <BaseLayout>
    <template #header>
      <h1>Page Title</h1>
    </template>
    <p>Main content.</p>
    <template #footer>
      <p>Contact info.</p>
    </template>
  </BaseLayout>
</template>
```

(En este ejemplo, se usan named slots para insertar contenido en el header, main y footer del componente BaseLayout.)

## E - Conditional Slots

**Definición:** Se puede usar la propiedad $slots en combinación con v-if para renderizar contenido condicionalmente basado en si se ha pasado contenido a un slot.

**Ejemplo:**

```Vue
// Componente hijo (Card.vue)
<template>
  <div class="card">
    <div v-if="$slots.header" class="card-header">
      <slot name="header" />
    </div>
    <div v-if="$slots.default" class="card-content">
      <slot />
    </div>
    <div v-if="$slots.footer" class="card-footer">
      <slot name="footer" />
    </div>
  </div>
</template>
```

(En este ejemplo, los divs card-header, card-content y card-footer solo se renderizarán si se ha pasado contenido a los slots correspondientes.)

## F - Dynamic Slot Names

**Definición:** Se pueden usar nombres de slot dinámicos con v-slot usando argumentos dinámicos.

**Ejemplo:**

```Vue
// Componente padre
<template>
  <BaseLayout>
    <template #[dynamicSlotName]>
      ...
    </template>
  </BaseLayout>
</template>
<script setup>
import { ref } from 'vue';
import BaseLayout from './BaseLayout.vue';
const dynamicSlotName = ref('header');
</script>
```

(En este ejemplo, el nombre del slot se define dinámicamente usando la variable dynamicSlotName.)

## G - Scoped Slots

**Definición:** Los scoped slots permiten que el componente hijo pase datos al contenido del slot, permitiendo que el contenido del slot use datos tanto del padre como del hijo.

**Ejemplo:**

```Vue
// Componente hijo (MyComponent.vue)
<template>
  <div>
    <slot :text="greetingMessage" :count="1"></slot>
  </div>
</template>
<script setup>
import { ref } from 'vue';
const greetingMessage = ref('hello');
</script>
```

```Vue
// Componente padre
<template>
  <MyComponent v-slot="slotProps">
    {{ slotProps.text }} {{ slotProps.count }}
  </MyComponent>
</template>
<script setup>
import MyComponent from './MyComponent.vue';
</script>
```

(En este ejemplo, el componente hijo pasa greetingMessage y count al slot, que se usan en el componente padre.)

## H - Named Scoped Slots

**Definición:** Los named scoped slots combinan las características de los named slots y los scoped slots, permitiendo pasar datos a slots específicos.

**Ejemplo:**

```Vue
// Componente hijo (MyComponent.vue)
<template>
  <div>
    <slot name="header" message="hello"></slot>
    <slot name="default" text="default text"></slot>
    <slot name="footer"></slot>
  </div>
</template>
```

```Vue
// Componente padre
<template>
  <MyComponent>
    <template #header="headerProps">
      {{ headerProps.message }}
    </template>
    <template #default="defaultProps">
      {{ defaultProps.text }}
    </template>
    <template #footer>
      <p>Footer content</p>
    </template>
  </MyComponent>
</template>
<script setup>
import MyComponent from './MyComponent.vue';
</script>
```

(En este ejemplo, se pasan datos a los slots header y default, que se usan en el componente padre.)

## I - Fancy List Example

**Definición:** Un ejemplo de uso de scoped slots es un componente de lista que permite personalizar la apariencia de cada elemento de la lista.

**Ejemplo:**

```Vue
// Componente hijo (FancyList.vue)
<template>
  <ul>
    <li v-for="item in items">
      <slot name="item" v-bind="item"></slot>
    </li>
  </ul>
</template>
<script setup>
import { ref } from 'vue';
const items = ref([
  { body: 'Item 1', username: 'user1', likes: 10 },
  { body: 'Item 2', username: 'user2', likes: 20 }
]);
</script>
```

```Vue
// Componente padre
<template>
  <FancyList>
    <template #item="{ body, username, likes }">
      <div class="item">
        <p>{{ body }}</p>
        <p>by {{ username }} | {{ likes }} likes</p>
      </div>
    </template>
  </FancyList>
</template>
<script setup>
import FancyList from './FancyList.vue';
</script>
```

(En este ejemplo, el componente FancyList usa un scoped slot para permitir que el componente padre defina cómo se renderiza cada elemento de la lista.)

## J - Renderless Components

**Definición:** Un componente renderless es un componente que solo encapsula lógica y no renderiza nada por sí mismo. Delega completamente la salida visual al componente consumidor a través de scoped slots.

**Ejemplo:**

```Vue
// Componente hijo (MouseTracker.vue)
<template>
  <slot :x="x" :y="y"></slot>
</template>
<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
const x = ref(0);
const y = ref(0);
function update(event) {
  x.value = event.clientX;
  y.value = event.clientY;
}
onMounted(() => window.addEventListener('mousemove', update));
onUnmounted(() => window.removeEventListener('mousemove', update));
</script>
```

```Vue
// Componente padre
<template>
  <MouseTracker v-slot="{ x, y }">
    Mouse is at: {{ x }}, {{ y }}
  </MouseTracker>
</template>
<script setup>
import MouseTracker from './MouseTracker.vue';
</script>
```

(En este ejemplo, el componente MouseTracker solo rastrea la posición del mouse y pasa las coordenadas al slot, que se usa en el componente padre para renderizar la información.)
