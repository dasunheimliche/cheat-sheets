### A - Narrowing: El Arte de Reducir las Posibilidades üî¥

#### 1. **Introducci√≥n:**

"Narrowing" (que podr√≠amos traducir como "estrechamiento" o "acotaci√≥n") es el proceso m√°gico con el que TypeScript deduce un tipo m√°s espec√≠fico para una variable dentro de un bloque de c√≥digo, bas√°ndose en las comprobaciones que has hecho.

#### 2. **Ejemplo:**

Imagina que tienes una funci√≥n que acepta un `number` o un `string`. Al principio, TypeScript no sabe cu√°l de los dos es.

```typescript
function padLeft(padding: number | string, input: string) {
  // Aqu√≠, 'padding' puede ser 'number' O 'string'. TypeScript est√° alerta.
  if (typeof padding === "number") {
    // ¬°Magia! Dentro de este 'if', TypeScript SABE que 'padding' es un 'number'.
    // Ya no hay duda, por eso nos deja usar el m√©todo .repeat() que es solo para n√∫meros.
    return " ".repeat(padding) + input;
  }
  // Fuera del 'if', si el c√≥digo llega aqu√≠, es porque 'padding' NO era un n√∫mero.
  // Por l√≥gica, TypeScript deduce que TIENE que ser un 'string'.
  return padding + input;
}
```

**Explicaci√≥n del ejemplo:**
La variable `padding` empieza siendo un "sospechoso" que puede ser de dos tipos (`number | string`). La condici√≥n `if (typeof padding === "number")` act√∫a como una prueba de detective. Si la prueba es positiva, dentro de ese bloque, TypeScript ya no tiene dudas: `padding` es un `number`. Si la prueba falla, TypeScript sabe que la √∫nica posibilidad que queda es que sea un `string`. Este proceso de eliminar posibilidades es el "narrowing".

#### 3. **Desarrollo:**

Piensa en el "narrowing" como el cerebro de TypeScript en acci√≥n. No es algo que t√∫ "activas", sino un an√°lisis inteligente que TypeScript realiza constantemente sobre tu c√≥digo. Sigue el flujo de tu l√≥gica (`if`, `else`, `switch`, etc.) para entender el contexto y ofrecerte seguridad en cada paso. Es como tener un copiloto incre√≠blemente listo que te dice: "¬°Oye, en esta parte del c√≥digo, estoy 100% seguro de que esta variable es un n√∫mero, as√≠ que adelante, √∫sala como tal!". Sin este mecanismo, tendr√≠amos que estar constantemente dici√©ndole al compilador qu√© tipo de dato es una variable, lo cual ser√≠a tedioso y propenso a errores.

üî¥ **Fundamental**: El "narrowing" no es una caracter√≠stica opcional, es la esencia de c√≥mo TypeScript proporciona seguridad de tipos en el c√≥digo JavaScript del d√≠a a d√≠a. Entenderlo es entender la propuesta de valor principal de TypeScript.

---

### B - `typeof` Type Guards: Preguntando el Tipo Directamente üî¥

#### 1. **Introducci√≥n:**

Usar el operador `typeof` de JavaScript dentro de una condici√≥n (`if`) es la forma m√°s com√∫n de hacer "narrowing", permitiendo a TypeScript reducir el tipo de una variable a uno primitivo espec√≠fico.

#### 2. **Ejemplo:**

```typescript
function printValue(value: string | number) {
  if (typeof value === "string") {
    // TypeScript sabe que 'value' es un string aqu√≠.
    console.log(`Tu texto: ${value.toUpperCase()}`);
  } else {
    // Y por descarte, aqu√≠ sabe que es un n√∫mero.
    console.log(`Tu n√∫mero x 2: ${value * 2}`);
  }
}

printValue("hola mundo"); // Imprime: Tu texto: HOLA MUNDO
printValue(21); // Imprime: Tu n√∫mero x 2: 42
```

**Explicaci√≥n del ejemplo:**
La funci√≥n `printValue` acepta un `string` o un `number`. La comprobaci√≥n `typeof value === "string"` act√∫a como un "guardi√°n de tipo" (Type Guard). Si la condici√≥n se cumple, TypeScript permite usar m√©todos de `string` como `toUpperCase()`. Si no, en el bloque `else`, asume que es un `number` y permite operaciones matem√°ticas.

#### 3. **Desarrollo:**

El operador `typeof` es una herramienta nativa de JavaScript, y TypeScript es lo suficientemente inteligente como para entender sus resultados. Los posibles valores que `typeof` puede devolver y que TypeScript reconoce son: `"string"`, `"number"`, `"bigint"`, `"boolean"`, `"symbol"`, `"undefined"`, `"object"`, y `"function"`.

**¬°Cuidado con la trampa!** Como veremos a continuaci√≥n, `typeof` tiene algunas peculiaridades hist√≥ricas en JavaScript. La m√°s famosa es que `typeof null` devuelve `"object"`. ¬°No te preocupes! TypeScript est√° al tanto de esto y te ayudar√° a no caer en la trampa.

üî¥ **Fundamental**: Esta es tu herramienta de "narrowing" de cabecera. Es simple, directa y la usar√°s constantemente para diferenciar entre tipos primitivos.

---

### C - El Quirk de `typeof null`: La Trampa Hist√≥rica de JavaScript üü°

#### 1. **Introducci√≥n:**

Por un error hist√≥rico en JavaScript, `typeof null` no devuelve `"null"` como esperar√≠amos, sino que devuelve `"object"`, y TypeScript es consciente de este comportamiento para evitar que cometas errores.

#### 2. **Ejemplo:**

```typescript
function printAll(strs: string | string[] | null) {
  // Queremos imprimir los elementos si 'strs' es un array (que es un objeto).
  if (typeof strs === "object") {
    // ¬°PELIGRO! Esta condici√≥n es cierta para un array Y tambi√©n para 'null'.
    // TypeScript nos avisa del peligro: 'strs' podr√≠a ser 'null' aqu√≠.
    for (const s of strs) {
      // ERROR: 'strs' is possibly 'null'.
      console.log(s);
    }
  } else if (typeof strs === "string") {
    console.log(strs);
  }
}
```

**Explicaci√≥n del ejemplo:**
Nuestra intenci√≥n era comprobar si `strs` era un array (`string[]`) para poder iterar sobre √©l. Como los arrays son objetos en JavaScript, usamos `typeof strs === "object"`. El problema es que `typeof null` tambi√©n es `"object"`. TypeScript, que sabe esto, nos advierte: "¬°Cuidado! Dentro de este `if`, `strs` podr√≠a ser `string[]` o podr√≠a ser `null`, y no puedes iterar sobre `null`".

#### 3. **Desarrollo:**

Este es un ejemplo perfecto de por qu√© TypeScript es tan valioso. Un programador de JavaScript sin experiencia (¬°o incluso uno experimentado en un descuido!) podr√≠a escribir este c√≥digo, y solo fallar√≠a en tiempo de ejecuci√≥n cuando la funci√≥n reciba `null`, causando un `TypeError: null is not iterable`. TypeScript detecta este posible error mientras escribes el c√≥digo. Para solucionar esto, necesitar√≠amos una comprobaci√≥n adicional, como veremos en "Truthiness Narrowing".

üü° **Importante**: No necesitas memorizar todas las rarezas de JavaScript, pero esta es tan com√∫n que es crucial saberla. Saber que `typeof null` es `"object"` y que TypeScript te protege de ello te ahorrar√° muchos dolores de cabeza.

---

### D - Truthiness Narrowing: Aprovechando la Verdad a Medias üü°

#### 1. **Introducci√≥n:**

En JavaScript, cualquier valor puede ser evaluado como "verdadero" (truthy) o "falso" (falsy) en un contexto booleano (como un `if`), y TypeScript utiliza esta l√≥gica para eliminar `null` y `undefined` de las posibilidades.

#### 2. **Ejemplo:**

```typescript
function printAllFixed(strs: string | string[] | null) {
  // La primera comprobaci√≥n 'if (strs)' filtra el caso 'null'.
  // Si 'strs' es 'null', la condici√≥n es falsa y el c√≥digo de dentro no se ejecuta.
  if (strs && typeof strs === "object") {
    // Ahora s√≠. TypeScript sabe que 'strs' no es 'null' y es un 'object',
    // por lo que la √∫nica opci√≥n que queda es 'string[]'. ¬°Seguro!
    for (const s of strs) {
      console.log(s);
    }
  } else if (typeof strs === "string") {
    console.log(strs);
  }
}
```

**Explicaci√≥n del ejemplo:**
Al a√±adir `if (strs ...)` estamos haciendo una comprobaci√≥n de "truthiness". En JavaScript, los valores "falsy" son `null`, `undefined`, `0`, `NaN`, `""` (string vac√≠o), y `0n`. Todos los dem√°s son "truthy". Al comprobar `if (strs)`, TypeScript entiende que si el c√≥digo entra en el `if`, `strs` no puede ser `null` (porque `null` es falsy). Esto resuelve el problema que ten√≠amos en el ejemplo anterior.

#### 3. **Desarrollo:**

El "Truthiness narrowing" es un patr√≥n muy com√∫n y idiom√°tico en JavaScript. Es una forma r√°pida y concisa de protegerte contra valores nulos o no definidos.

**¬°Cuidado con la trampa!** Este m√©todo es poderoso, pero puede tener efectos secundarios sutiles. Por ejemplo, si tu variable pudiera ser un string vac√≠o (`""`) o el n√∫mero `0`, una comprobaci√≥n `if (miVariable)` tambi√©n los tratar√≠a como falsos, lo cual podr√≠a no ser lo que quieres.

```typescript
function processInput(text: string | null) {
  // ¬°CUIDADO! Si 'text' es un string vac√≠o "",
  // esta condici√≥n ser√° falsa y no se procesar√°.
  if (text) {
    console.log(`Procesando: ${text}`);
  }
}
processInput(""); // No imprime nada. ¬øEs lo que quer√≠amos?
```

üü° **Importante**: Es una t√©cnica fundamental en el arsenal de un programador de JavaScript/TypeScript, pero √∫sala con conciencia de qu√© valores son "falsy" para no filtrar casos que s√≠ quer√≠as manejar.

---

### E - Equality Narrowing: Refinando Tipos Mediante la Comparaci√≥n üî¥

#### 1. **Introducci√≥n:**

TypeScript es capaz de deducir tipos bas√°ndose en operadores de igualdad (`===`, `!==`, `==`, `!=`), especialmente cuando comparas una variable con un valor literal u otra variable.

#### 2. **Ejemplo:**

```typescript
function example(x: string | number, y: string | boolean) {
  if (x === y) {
    // Si x e y son iguales, ¬øqu√© tipo DEBEN tener en com√∫n?
    // TypeScript lo deduce: ¬°ambos tienen que ser 'string'!
    x.toUpperCase(); // OK, 'x' es string
    y.toLowerCase(); // OK, 'y' es string
  } else {
    console.log(x); // Aqu√≠ 'x' vuelve a ser 'string | number'
    console.log(y); // Y 'y' vuelve a ser 'string | boolean'
  }
}
```

**Explicaci√≥n del ejemplo:**
La variable `x` puede ser `string | number` y la `y` puede ser `string | boolean`. La √∫nica forma de que `x === y` sea `true` es si ambas son del tipo que tienen en com√∫n: `string`. TypeScript entiende esta l√≥gica y, dentro de ese `if`, trata a ambas variables como `string`.

#### 3. **Desarrollo:**

Esto tambi√©n funciona de maravilla para descartar `null`. De hecho, es una forma m√°s expl√≠cita y segura que el "truthiness narrowing" si solo quieres protegerte de `null` y no de otros valores "falsy" como `""` o `0`.

**Un truco √∫til de JavaScript que TypeScript entiende:** La comparaci√≥n `variable == null` (con doble igual) es una forma especial que comprueba si la variable es `null` O `undefined`, pero nada m√°s. Es una forma muy conveniente de limpiar ambos casos a la vez.

```typescript
function multiplyValue(
  container: { value: number | null | undefined },
  factor: number
) {
  // '!= null' con doble igual elimina tanto 'null' como 'undefined'.
  if (container.value != null) {
    // Aqu√≠, TypeScript sabe que 'container.value' es S√ç O S√ç un 'number'.
    console.log(container.value * factor);
  }
}
```

üî¥ **Fundamental**: La igualdad es una de las formas m√°s robustas y expl√≠citas de control de flujo. Usar `===` y `!==` para el "narrowing" es una pr√°ctica diaria y esencial para escribir c√≥digo TypeScript seguro y legible.

---

### F - `in` Operator Narrowing: Verificando la Existencia de Propiedades üü°

#### 1. **Introducci√≥n:**

El operador `in` de JavaScript comprueba si un objeto tiene una propiedad con un nombre espec√≠fico, y TypeScript lo usa para diferenciar entre tipos dentro de una uni√≥n.

#### 2. **Ejemplo:**

```typescript
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function move(animal: Fish | Bird) {
  // Si la propiedad "swim" existe en 'animal'...
  if ("swim" in animal) {
    // ...entonces TypeScript sabe que 'animal' tiene que ser de tipo 'Fish'.
    return animal.swim();
  }
  // Si no, por descarte, tiene que ser de tipo 'Bird'.
  return animal.fly();
}
```

**Explicaci√≥n del ejemplo:**
El par√°metro `animal` puede ser un `Fish` o un `Bird`. El tipo `Fish` tiene la propiedad `swim`, y el tipo `Bird` tiene la propiedad `fly`. La comprobaci√≥n `if ("swim" in animal)` le permite a TypeScript discernir: si `swim` est√° presente, estamos ante un `Fish`. Si no, debe ser un `Bird`.

#### 3. **Desarrollo:**

Esto es incre√≠blemente √∫til cuando trabajas con uniones de interfaces o tipos de objeto. Te permite diferenciar los objetos por las propiedades que los hacen √∫nicos.

**¬øY qu√© pasa con las propiedades opcionales?** ¬°Gran pregunta! Si una propiedad es opcional (marcada con `?`), puede existir o no. Por lo tanto, el "narrowing" con `in` se comporta de forma un poco diferente.

```typescript
type Human = { swim?: () => void; fly?: () => void };

function move(animal: Fish | Bird | Human) {
  if ("swim" in animal) {
    // 'animal' puede ser 'Fish' (que siempre tiene 'swim')
    // O puede ser 'Human' (que podr√≠a tener 'swim').
    animal; // Tipo: Fish | Human
  } else {
    // 'animal' puede ser 'Bird' (que nunca tiene 'swim')
    // O puede ser 'Human' (que podr√≠a no tener 'swim').
    animal; // Tipo: Bird | Human
  }
}
```

Como ves, `Human` aparece en ambas ramas porque la propiedad `swim` es opcional, por lo que la presencia o ausencia de `swim` no es suficiente para descartar que sea un `Human`.

üü° **Importante**: Una herramienta clave para trabajar con uniones de tipos de objeto. Es m√°s espec√≠fico que `typeof` (que solo dir√≠a `"object"` para todos ellos) y te permite escribir c√≥digo que reacciona a la "forma" de tus datos.

---

### G - `instanceof` Narrowing: Comprobando la Cadena de Prototipos üü°

#### 1. **Introducci√≥n:**

El operador `instanceof` de JavaScript comprueba si un objeto es una instancia de una clase espec√≠fica (o de algo que herede de ella), y TypeScript lo utiliza como un "type guard" muy eficaz.

#### 2. **Ejemplo:**

```typescript
function logValue(x: Date | string) {
  if (x instanceof Date) {
    // Si 'x' es una instancia de la clase 'Date'...
    // TypeScript sabe que 'x' es de tipo 'Date' aqu√≠.
    console.log(x.toUTCString());
  } else {
    // Por descarte, 'x' debe ser un 'string'.
    console.log(x.toUpperCase());
  }
}
```

**Explicaci√≥n del ejemplo:**
La funci√≥n `logValue` puede recibir un objeto `Date` o un `string`. La comprobaci√≥n `x instanceof Date` es inequ√≠voca. Si es `true`, TypeScript sabe que puede usar m√©todos de `Date` como `.toUTCString()`. En el `else`, sabe que es un `string`.

#### 3. **Desarrollo:**

`instanceof` es la herramienta de "narrowing" por excelencia cuando trabajas con clases. Mientras que `typeof` te dir√≠a simplemente `"object"` para una instancia de `Date`, `instanceof` te da la especificidad que necesitas. Funciona con cualquier valor que se pueda construir con `new`, como tus propias clases, `Date`, `RegExp`, `Map`, `Set`, etc.

üü° **Importante**: Si tu c√≥digo utiliza clases, `instanceof` ser√° tu mejor amigo para el "narrowing". Es la forma idiom√°tica y correcta de diferenciar entre instancias de diferentes clases.

---

### H - Assignments (Asignaciones): Cambiando el Tipo Percibido üü°

#### 1. **Introducci√≥n:**

Cuando asignas un nuevo valor a una variable, TypeScript analiza el valor de la derecha y refina (hace "narrowing") el tipo de la variable a partir de ese punto.

#### 2. **Ejemplo:**

```typescript
let x: string | number = Math.random() < 0.5 ? 10 : "hello world!";
// En este punto, TypeScript sabe que 'x' es 'string | number'.

x = 1;
console.log(x); // Al pasar el cursor sobre 'x' aqu√≠, el editor te dir√° que es 'number'.

x = "goodbye!";
console.log(x); // Y aqu√≠, el editor te dir√° que es 'string'.
```

**Explicaci√≥n del ejemplo:**
La variable `x` se declara con el tipo `string | number`. Despu√©s de la l√≠nea `x = 1;`, TypeScript observa que `x` ahora contiene un `number`, por lo que para el resto del c√≥digo (hasta la siguiente asignaci√≥n), lo tratar√° como tal. Luego, tras `x = "goodbye!"`, lo tratar√° como un `string`.

#### 3. **Desarrollo:**

Aqu√≠ hay un detalle crucial que puede confundir al principio. Aunque el _tipo observado_ de `x` cambia, su _tipo declarado_ (`string | number`) nunca lo hace. ¬øQu√© significa esto? Significa que la regla de asignaci√≥n siempre se basa en el tipo original.

```typescript
let x: string | number = 10;

x = "hello"; // OK, porque 'string' es asignable a 'string | number'.

x = true; // ¬°ERROR! Type 'boolean' is not assignable to type 'string | number'.
```

El error ocurre porque `boolean` no estaba en la declaraci√≥n de tipo original (`string | number`). El "narrowing" por asignaci√≥n afecta a c√≥mo puedes _usar_ la variable despu√©s, pero no a qu√© le puedes _asignar_ despu√©s.

üü° **Importante**: Entender esta distinci√≥n entre el tipo _declarado_ y el tipo _inferido_ en un punto del c√≥digo es clave para comprender por qu√© algunas asignaciones son v√°lidas y otras no, incluso cuando el tipo de la variable parece haber cambiado.

---

### I - Control Flow Analysis: El Cerebro Detr√°s de Todo üî¥

#### 1. **Introducci√≥n:**

El "An√°lisis de Flujo de Control" es el sofisticado proceso mediante el cual TypeScript analiza todas las rutas de ejecuci√≥n posibles de tu c√≥digo (ifs, returns, loops) para realizar el "narrowing" de la forma m√°s precisa posible.

#### 2. **Ejemplo:**

```typescript
function padLeft(padding: number | string, input: string) {
  if (typeof padding === "number") {
    // Si el c√≥digo entra aqu√≠, ejecuta el 'return' y la funci√≥n TERMINA.
    return " ".repeat(padding) + input;
  }
  // Si la funci√≥n contin√∫a, es porque NUNCA entr√≥ en el 'if' de arriba.
  // TypeScript analiza esto y concluye que 'padding' TIENE que ser 'string'.
  return padding + input; // (parameter) padding: string
}
```

**Explicaci√≥n del ejemplo:**
TypeScript no solo mira la condici√≥n del `if`. Ve que dentro del `if` hay un `return`. Esto significa que si `padding` es un `number`, la funci√≥n termina ah√≠ mismo. Por lo tanto, cualquier c√≥digo que venga _despu√©s_ de ese bloque `if` solo es alcanzable si la condici√≥n fue falsa. Esta "alcanzabilidad" es lo que le permite a TypeScript estar 100% seguro de que `padding` es un `string` en la √∫ltima l√≠nea.

#### 3. **Desarrollo:**

Este es el "ingrediente secreto" que hace que todo el "narrowing" se sienta tan intuitivo y m√°gico. TypeScript no solo aplica reglas simples; construye un grafo de todo el flujo de control de tu funci√≥n. Sabe cu√°ndo una variable puede cambiar de tipo, cu√°ndo una ruta de c√≥digo se vuelve inalcanzable y c√≥mo los tipos se "re-unen" despu√©s de un `if/else`.

```typescript
function example() {
  let x: string | number | boolean;

  x = Math.random() < 0.5;
  // x es 'boolean'

  if (Math.random() < 0.5) {
    x = "hello";
    // x es 'string'
  } else {
    x = 100;
    // x es 'number'
  }

  return x; // ¬øQu√© tipo es x aqu√≠? TypeScript sabe que ha pasado por una de las
  // dos ramas, por lo que el tipo es la uni√≥n de ambas: 'string | number'.
}
```

üî¥ **Fundamental**: No es una t√©cnica que aplicas, sino el motor que impulsa todas las dem√°s. Comprender que TypeScript analiza la "alcanzabilidad" del c√≥digo te ayuda a entender por qu√© el "narrowing" funciona de manera tan robusta y fiable.

---

### J - Type Predicates: Creando Tus Propios Guardianes de Tipo üîµ

#### 1. **Introducci√≥n:**

Un "predicado de tipo" es una funci√≥n especial que t√∫ defines para decirle a TypeScript c√≥mo hacer "narrowing" en situaciones complejas donde los guardianes autom√°ticos no son suficientes.

#### 2. **Ejemplo:**

```typescript
type Fish = { swim: () => void };
type Bird = { fly: () => void };

// Esta funci√≥n no devuelve 'boolean', devuelve un predicado: 'pet is Fish'.
// Esto le dice a TypeScript: "Si devuelvo 'true', puedes asumir que 'pet' es un 'Fish'".
function isFish(pet: Fish | Bird): pet is Fish {
  // Para ser un 'Fish', debe tener un m√©todo 'swim'.
  // (pet as Fish) es una aserci√≥n de tipo para poder acceder a .swim sin error.
  return (pet as Fish).swim !== undefined;
}

// --- C√≥mo se usa ---
let pet = getSmallPet(); // getSmallPet() devuelve Fish | Bird

if (isFish(pet)) {
  // Gracias al predicado, TypeScript sabe que 'pet' es 'Fish' aqu√≠.
  pet.swim();
} else {
  // Y por descarte, sabe que es 'Bird' aqu√≠.
  pet.fly();
}
```

**Explicaci√≥n del ejemplo:**
La funci√≥n `isFish` tiene un tipo de retorno especial: `pet is Fish`. Esto es el predicado. En lugar de simplemente devolver `true` o `false`, le est√° haciendo una promesa a TypeScript. Cuando la usamos en el `if`, TypeScript conf√≠a en esa promesa y realiza el "narrowing" correspondiente en la variable `pet`.

#### 3. **Desarrollo:**

Los predicados de tipo te dan el control total sobre la l√≥gica de "narrowing". Son √∫tiles cuando una simple comprobaci√≥n de `typeof`, `in` o `instanceof` no es suficiente. Por ejemplo, si la propiedad que discrimina los tipos est√° anidada o requiere una l√≥gica m√°s compleja para ser verificada. Tambi√©n son geniales para crear funciones de utilidad reutilizables, como un filtro para un array:

```typescript
const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];
// El m√©todo .filter() usa el predicado para devolver un array solo de 'Fish'.
const underWater: Fish[] = zoo.filter(isFish);
```

üîµ **Espec√≠fico**: No los usar√°s todos los d√≠as, pero son la herramienta a la que recurrir cuando necesitas un "narrowing" personalizado y reutilizable. Saber que existen te da una salida para situaciones m√°s enrevesadas.

---

### K - Discriminated Unions: El Patr√≥n de Oro para Modelar Datos üî¥

Esta es una de las ideas m√°s importantes y poderosas de TypeScript. Vamos a verla en dos pasos: el problema y la soluci√≥n, para que quede meridianamente claro por qu√© es tan genial.

#### **Paso 1: El Problema (Una mala estructura)**

Imagina que modelamos formas geom√©tricas. Un primer intento podr√≠a ser usar propiedades opcionales:

```typescript
// ¬°NO HAGAS ESTO! ESTA ES LA FORMA PROBLEM√ÅTICA.
interface Shape {
  kind: "circle" | "square";
  radius?: number; // Opcional
  sideLength?: number; // Opcional
}

function getArea(shape: Shape) {
  if (shape.kind === "circle") {
    // TypeScript se queja: 'shape.radius' podr√≠a ser 'undefined'.
    // ¬°Y tiene raz√≥n! Nada le garantiza que si kind es "circle", radius exista.
    return Math.PI * shape.radius ** 2; // ERROR
  }
}
```

**¬øPor qu√© esto es un problema?** Porque no hay una conexi√≥n _estructural_ entre `kind: "circle"` y la existencia de `radius`. Le estamos pidiendo a TypeScript que adivine una l√≥gica que no est√° expl√≠cita en los tipos. Podr√≠amos "callar" al compilador con un `!` (`shape.radius!`), pero eso es peligroso y es como barrer el problema debajo de la alfombra.

---

#### **Paso 2: La Soluci√≥n (La Uni√≥n Discriminada)**

Ahora, modelemos esto de la forma correcta, creando tipos separados y uni√©ndolos.

#### 1. **Introducci√≥n:**

Una "uni√≥n discriminada" es un patr√≥n que combina tres cosas: 1) tipos de objeto distintos que comparten una propiedad en com√∫n (el _discriminante_), 2) esa propiedad tiene un tipo literal √∫nico en cada objeto, y 3) una uni√≥n de esos tipos.

#### 2. **Ejemplo:**

```typescript
// 1. Tipos de objeto distintos
interface Circle {
  kind: "circle"; // El discriminante con un tipo literal
  radius: number; // Propiedad requerida
}

interface Square {
  kind: "square"; // El discriminante con un tipo literal
  sideLength: number; // Propiedad requerida
}

// 2. Una uni√≥n de esos tipos
type Shape = Circle | Square;

function getArea(shape: Shape) {
  // 3. Usamos el discriminante para el narrowing
  switch (shape.kind) {
    case "circle":
      // Dentro de este 'case', TypeScript SABE que 'shape' es 'Circle'.
      // Por lo tanto, 'shape.radius' existe y es un n√∫mero. ¬°Cero errores!
      return Math.PI * shape.radius ** 2; // (parameter) shape: Circle
    case "square":
      // Aqu√≠, TypeScript SABE que 'shape' es 'Square'.
      return shape.sideLength ** 2; // (parameter) shape: Square
  }
}
```

**Explicaci√≥n del ejemplo:**
La propiedad `kind` es el "discriminante". Como cada interfaz en la uni√≥n (`Circle`, `Square`) tiene un valor literal diferente para `kind` (`"circle"`, `"square"`), TypeScript puede usar una simple comprobaci√≥n de igualdad en `shape.kind` para saber _exactamente_ con cu√°l de los tipos de la uni√≥n estamos tratando, eliminando toda ambig√ºedad.

#### 3. **Desarrollo:**

Este patr√≥n es la forma m√°s robusta, segura y expresiva de modelar datos que pueden tener diferentes formas en TypeScript. Es perfecto para representar el estado de un componente en React, respuestas de una API, eventos en una aplicaci√≥n, etc. Elimina por completo la necesidad de propiedades opcionales y aserciones de no nulidad (`!`), haciendo tu c√≥digo m√°s seguro y f√°cil de entender.

üî¥ **Fundamental**: Si solo pudieras aprender un patr√≥n avanzado de TypeScript, ser√≠a este. Las uniones discriminadas son la columna vertebral del modelado de datos seguro y son absolutamente esenciales para escribir aplicaciones complejas y fiables.

---

### L - Exhaustiveness Checking con `never`: Asegurando que no te dejas nada üü°

#### 1. **Introducci√≥n:**

El tipo `never` representa un estado que nunca deber√≠a ocurrir, y podemos usarlo en una uni√≥n discriminada para que TypeScript nos obligue a manejar todos los casos posibles.

#### 2. **Ejemplo:**

```typescript
// Usando la 'Shape' del ejemplo anterior...
type Shape = Circle | Square;

function getArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.sideLength ** 2;
    default:
      // Si llegamos aqu√≠, 'shape' es de un tipo que no hemos manejado.
      // Le asignamos a una variable de tipo 'never'.
      const _exhaustiveCheck: never = shape;
      // En este momento, no hay error, porque hemos cubierto todos los casos
      // ('circle' y 'square'), por lo que 'shape' nunca llega aqu√≠.
      return _exhaustiveCheck;
  }
}
```

**Ahora, ¬øqu√© pasa si a√±adimos un nuevo tipo a `Shape`?**

```typescript
interface Triangle {
  kind: "triangle";
  sideLength: number;
}
type Shape = Circle | Square | Triangle; // A√±adimos Triangle

function getArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.sideLength ** 2;
    default:
      // ¬°ERROR! Type 'Triangle' is not assignable to type 'never'.
      const _exhaustiveCheck: never = shape;
      return _exhaustiveCheck;
  }
}
```

**Explicaci√≥n del ejemplo:**
El tipo `never` es el "callej√≥n sin salida" de los tipos. No se le puede asignar ning√∫n valor (excepto `never` a s√≠ mismo). En el primer `getArea`, hemos manejado `Circle` y `Square`. En la rama `default`, la variable `shape` ya ha sido "estrechada" a `never` (porque no quedan m√°s opciones), as√≠ que `never` es asignable a `never` y todo est√° bien.

Pero cuando a√±adimos `Triangle`, en la rama `default` la variable `shape` ahora es de tipo `Triangle`. El c√≥digo `const _exhaustiveCheck: never = shape;` intenta asignar un `Triangle` a `never`, lo cual es un error. ¬°Y eso es exactamente lo que queremos! TypeScript nos est√° gritando: "¬°Oye, te has olvidado de manejar el caso `Triangle`!".

#### 3. **Desarrollo:**

Esta t√©cnica, llamada "comprobaci√≥n de exhaustividad" (exhaustiveness checking), es un salvavidas. Convierte un posible error l√≥gico en tiempo de ejecuci√≥n (olvidarse de actualizar un `switch` despu√©s de a√±adir un nuevo tipo) en un error de compilaci√≥n que puedes arreglar inmediatamente. Es la guinda del pastel de las uniones discriminadas, haciendo tu c√≥digo a prueba de futuro.

üü° **Importante**: Un patr√≥n incre√≠blemente √∫til que va de la mano con las uniones discriminadas. Te da una red de seguridad para que nunca olvides manejar todos los casos posibles a medida que tu aplicaci√≥n evoluciona.
