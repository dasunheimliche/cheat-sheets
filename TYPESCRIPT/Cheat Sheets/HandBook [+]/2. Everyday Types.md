## A - Los Primitivos: `string`, `number` y `boolean` 🔴

#### 1. **Introducción:**

Son los ladrillos más básicos de JavaScript y, por lo tanto, de TypeScript: textos, números y valores de verdadero/falso.

#### 2. **Ejemplo:**

```typescript
let nombre: string = "Goku";
let ki: number = 9001;
let esSuperSaiyan: boolean = true;
```

**Explicación del ejemplo:**
Aquí le estamos diciendo a TypeScript, con una claridad que roza lo obsesivo:

- La variable `nombre` **siempre** será un texto (`string`).
- La variable `ki` **siempre** será un número (`number`).
- La variable `esSuperSaiyan` **siempre** será un valor booleano (`boolean`), es decir, `true` o `false`.

#### 3. **Desarrollo:**

Estos son los tipos más fundamentales que existen. Piensa en ellos como los átomos de tus datos.

- `string`: Para cualquier texto, como `"Hola"` o `'Adiós'`.
- `number`: Para cualquier tipo de número, ya sea `42` (entero) o `3.14` (decimal). En JavaScript (y por ende en TypeScript), no hay distinción entre `int` y `float`, ¡todo es un >`number`! Sencillo, ¿verdad?
- `boolean`: Solo puede tener dos valores: `true` o `false`. No hay más.

**¡Una trampa en la que NO caerás!**
A veces verás `String`, `Number` o `Boolean` con mayúscula. ¡No los uses! Esos son tipos especiales y complejos que casi nunca necesitarás. Usa siempre `string`, `number` y `boolean` en minúsculas. Te lo pido por favor.

🔴 **Fundamental**: No puedes escribir ni una sola línea de código útil sin entender estos tres tipos. Son la base de todo lo que construiremos.

---

## B - Arrays: Colecciones de un Mismo Tipo 🟡

#### 1. **Introducción:**

Para declarar una lista o colección de elementos que son todos del mismo tipo, como una lista de solo números o solo textos.

#### 2. **Ejemplo:**

```typescript
// Una lista de números que representan los niveles de poder
let nivelesDePoder: number[] = [800, 1200, 9001, 150000];

// Una lista de nombres de guerreros
let guerrerosZ: string[] = ["Goku", "Vegeta", "Piccolo"];

// Otra forma de escribirlo (significa EXACTAMENTE lo mismo)
let planetas: Array<string> = ["Tierra", "Namek", "Vegeta"];
```

**Explicación del ejemplo:**
La sintaxis `tipo[]` (como `number[]`) es la forma más común y directa de decir "un array de...". `nivelesDePoder` solo puede contener números. Si intentas meter un texto, TypeScript te gritará (con cariño) que eso no se puede. Lo mismo pasa con `guerrerosZ`, que solo acepta textos.

#### 3. **Desarrollo:**

Un array es simplemente una colección ordenada de valores. La clave en TypeScript es que podemos asegurar que **todos** los elementos de ese array sean del mismo tipo. Esto nos salva de errores tontísimos, como intentar sumar un número a un texto que se coló en nuestra lista de números.

La sintaxis `Array<tipo>` (como `Array<number>`) es equivalente a `tipo[]`. Es una sintaxis más "genérica" que entenderás a la perfección más adelante, pero por ahora, quédate con que ambas funcionan y la primera (`tipo[]`) es la más popular por su brevedad.

🟡 **Importante**: Usarás arrays constantemente. Definir su tipo es una de las primeras grandes victorias de usar TypeScript, ya que te da una seguridad inmensa sobre el contenido de tus colecciones.

---

## C - `any`: El Comodín Peligroso 🟡

#### 1. **Introducción:**

Es un tipo especial que le dice a TypeScript: "Tranquilo, yo me encargo, no revises nada aquí", desactivando todas las comprobaciones de tipo para un valor.

#### 2. **Ejemplo:**

```typescript
// Imagina que recibes un objeto de una API vieja y no sabes su forma
let objetoMisterioso: any = { x: 0 };

// Con 'any', TypeScript nos deja hacer cualquier cosa, sin quejarse...
objetoMisterioso.foo(); // Ok en compilación, pero fallará en ejecución si no existe.
objetoMisterioso(); // Ok en compilación, pero fallará si no es una función.
objetoMisterioso.bar = 100; // Ok, le añadimos una propiedad.
objetoMisterioso = "Ahora soy un string"; // Ok, cambiamos su tipo completamente.

const n: number = objetoMisterioso; // ¡Peligro! TypeScript confía en nosotros,
// pero si 'objetoMisterioso' no es un número,
// esto explotará en tiempo de ejecución.
```

**Explicación del ejemplo:**
Al declarar `objetoMisterioso` como `any`, le quitamos los ruedines a la bicicleta. TypeScript nos deja intentar acceder a `foo()`, llamarlo como si fuera una función o asignarle cualquier valor. El compilador no se quejará, asumiendo que nosotros, los sabios programadores, sabemos lo que hacemos. El problema es que a menudo... no lo sabemos, y esto causa errores cuando el código se ejecuta.

#### 3. **Desarrollo:**

`any` es una vía de escape. Es útil cuando estás migrando código de JavaScript a TypeScript y no quieres tipar todo de golpe, o cuando trabajas con librerías de terceros que no están bien tipadas. Sin embargo, su uso es un arma de doble filo: te da flexibilidad, pero a costa de perder la principal ventaja de TypeScript: la seguridad de tipos. Cada `any` en tu código es un posible nido de bugs.

🟡 **Importante**: Debes conocer `any` para entender por qué es mejor evitarlo. Es como conocer las reglas para saber cuándo romperlas (aunque en este caso, casi nunca deberías). Abusar de `any` es como comprar un coche de lujo para no sacarlo del garaje.

---

## D - `noImplicitAny`: Tu Conciencia Personal 🟡

#### 1. **Introducción:**

Es una regla del compilador que te obliga a ser explícito con tus tipos, prohibiendo que TypeScript infiera el tipo `any` por defecto.

#### 2. **Ejemplo:**

```typescript
// CON 'noImplicitAny' DESACTIVADO (comportamiento por defecto relajado)
function procesar(data) {
  // 'data' es implícitamente de tipo 'any'
  console.log(data.nombre); // TypeScript no se queja
}

// CON 'noImplicitAny' ACTIVADO (en tu archivo tsconfig.json)
function procesar(data) {
  // ERROR: El parámetro 'data' tiene implícitamente un tipo 'any'.
  //                 ^^^^
  // TypeScript te obliga a decidir: ¿qué tipo es 'data'?
  console.log(data.nombre);
}

// La solución es ser explícito:
function procesarSolucionado(data: { nombre: string }) {
  console.log(data.nombre); // ¡Ahora sí! Seguro y claro.
}
```

**Explicación del ejemplo:**
Cuando la opción `noImplicitAny` está activada en la configuración de tu proyecto (`tsconfig.json`), TypeScript se pone en modo "paranoico" (¡como yo!) y te dice: "Oye, no has especificado el tipo para `data`. No voy a asumir que es `any` porque eso es peligroso. Por favor, dime qué es". Esto te fuerza a tomar una decisión consciente y a mantener tu código seguro.

#### 3. **Desarrollo:**

Activar `noImplicitAny` es una de las mejores decisiones que puedes tomar en un proyecto de TypeScript. Te obliga a pensar en los tipos desde el principio y evita que los `any` se cuelen en tu código sin que te des cuenta. Es como un cinturón de seguridad: al principio puede parecer una molestia, pero te salvará de problemas graves.

🟡 **Importante**: Activar esta regla es una práctica recomendada fundamental. Te convierte en un programador más disciplinado y tu "yo" del futuro te lo agradecerá enormemente.

---

## E - Anotaciones de Tipo: Etiquetando tus Variables 🔴

#### 1. **Introducción:**

Es la forma explícita de decirle a TypeScript cuál es el tipo de una variable, parámetro o valor de retorno.

#### 2. **Ejemplo:**

```typescript
// La anotación de tipo va DESPUÉS del nombre de la variable, con dos puntos.
let miPlaneta: string = "Tierra";

function saludar(nombre: string): void {
  //       parámetro ^^^^^^^^   ^^^^^^ retorno
  console.log("¡Hola, " + nombre + "!");
}
```

**Explicación del ejemplo:**
La sintaxis `: tipo` es la "anotación". En `let miPlaneta: string`, estamos declarando que `miPlaneta` debe ser un `string`. En la función `saludar`, `nombre: string` significa que el parámetro `nombre` debe ser un `string`, y `: void` significa que la función no devuelve ningún valor.

#### 3. **Desarrollo:**

A diferencia de otros lenguajes donde el tipo va antes (`string miPlaneta`), en TypeScript siempre va después. Esta es la sintaxis central para ser explícito con tus tipos. Sin embargo, como veremos a continuación, ¡no siempre necesitas escribir estas anotaciones!

🔴 **Fundamental**: Es la sintaxis básica para definir tipos. Aunque la inferencia (el siguiente punto) te ahorrará escribir muchas de ellas, necesitas dominar esta sintaxis para los casos en que TypeScript no puede adivinar el tipo por sí solo, como en los parámetros de una función.

---

## F - Inferencia de Tipos: La Magia de TypeScript 🔴

#### 1. **Introducción:**

Es la habilidad de TypeScript para adivinar automáticamente el tipo de una variable basándose en el valor que le asignas.

#### 2. **Ejemplo:**

```typescript
// No necesitamos escribir ': string'. ¡TypeScript ya lo sabe!
let villano = "Freezer";
// TypeScript ve que le asignas un texto y piensa: "Aha, 'villano' es de tipo string".

// No necesitamos escribir ': number'.
let poderDePelea = 530000;
// TypeScript ve el número y dice: "Entendido, 'poderDePelea' es de tipo number".
```

**Explicación del ejemplo:**
En ambos casos, no escribimos `: string` o `: number`. Simplemente inicializamos la variable. TypeScript es lo suficientemente inteligente como para analizar el valor `"Freezer"` y deducir que el tipo de `villano` es `string`. Lo mismo ocurre con `poderDePelea`.

#### 3. **Desarrollo:**

La inferencia es tu mejor amiga. Hace que el código sea más limpio y menos verboso, sin sacrificar la seguridad. La regla de oro para un principiante es: **intenta no poner anotaciones de tipo en las variables y deja que TypeScript haga su magia**. Solo añádelas si TypeScript se queja o si no puede adivinar el tipo (como en los parámetros de una función, que no tienen un valor inicial). Confía en la inferencia, ¡funciona de maravilla!

🔴 **Fundamental**: Entender que la inferencia existe te ahorrará teclear muchísimo. Es una característica clave que hace que usar TypeScript sea un placer y no una carga.

---

## G - Funciones: Tipando Entradas y Salidas 🔴

#### 1. **Introducción:**

TypeScript te permite definir con precisión qué tipo de datos aceptan tus funciones (parámetros) y qué tipo de datos devuelven (retorno).

#### 2. **Ejemplo:**

```typescript
// Parámetros tipados: 'base' y 'potencia' DEBEN ser números.
// Retorno tipado: Esta función DEBE devolver un número.
function calcularKi(base: number, potencia: number): number {
  return base * potencia;
}

// El tipo de retorno también puede ser inferido, ¡pero ser explícito es bueno para la claridad!
function saludarGuerrero(nombre: string) {
  // El retorno se infiere como 'void' (no devuelve nada)
  console.log("¡Hola, " + nombre.toUpperCase() + "!");
}

// TypeScript te protege de errores:
saludarGuerrero(9001); // ERROR: El argumento de tipo 'number' no se puede asignar
// al parámetro de tipo 'string'.
```

**Explicación del ejemplo:**

- **Parámetros:** `(base: number, potencia: number)` establece un contrato. La función `calcularKi` solo aceptará dos argumentos que sean números.
- **Retorno:** El `: number` después de los paréntesis significa que la función _promete_ devolver un valor numérico. Si intentaras devolver un `string`, TypeScript te avisaría del error.

#### 3. **Desarrollo:**

Tipar funciones es, posiblemente, el uso más importante de TypeScript. Te da una garantía total sobre cómo se deben usar tus bloques de código, evitando errores en tiempo de ejecución y haciendo que tu código sea mucho más fácil de entender para otros (y para tu "yo" del futuro). Aunque el tipo de retorno a menudo se puede inferir, muchos equipos prefieren anotarlo explícitamente por claridad y para evitar cambios accidentales.

🔴 **Fundamental**: Si solo pudieras aprender una cosa sobre TypeScript, sería cómo tipar los parámetros y el retorno de las funciones. Es la base de la construcción de aplicaciones robustas y seguras.

---

## H - Funciones que Devuelven Promesas 🟡

#### 1. **Introducción:**

Para tipar el valor que una función asíncrona resolverá en el futuro, se utiliza el tipo genérico `Promise<Tipo>`.

#### 2. **Ejemplo:**

```typescript
// Esta función asíncrona promete que, cuando termine,
// devolverá un número.
async function obtenerNivelDePoder(): Promise<number> {
  // Imaginemos que aquí hay una llamada a una base de datos...
  return 9001;
}

// Al usarla, TypeScript sabe que 'nivel' será un número.
async function miFuncion() {
  const nivel = await obtenerNivelDePoder();
  console.log("El nivel es: " + nivel); // 'nivel' es de tipo 'number'
}
```

**Explicación del ejemplo:**
Una función `async` siempre devuelve una Promesa. La sintaxis `Promise<number>` no dice que la función devuelve un número directamente, sino que devuelve una _promesa que se resolverá con un número_. Esto es crucial. TypeScript sabe que después de usar `await`, el valor que obtendrás (`nivel`) será del tipo que especificaste dentro de los `< >`.

#### 3. **Desarrollo:**

En el JavaScript moderno, las operaciones asíncronas (como llamadas a APIs, acceso a bases de datos, etc.) son el pan de cada día. Saber tipar correctamente las promesas es esencial para trabajar con `async/await` de forma segura. `Promise<TipoResuelto>` te dice exactamente qué esperar cuando la operación asíncrona concluya.

🟡 **Importante**: Si trabajas con APIs, o cualquier operación asíncrona, este conocimiento no es opcional. Es una herramienta diaria para escribir código asíncrono robusto.

---

## I - Funciones Anónimas y Tipado Contextual 🟡

#### 1. **Introducción:**

TypeScript es tan inteligente que puede inferir los tipos de los parámetros de una función si sabe en qué contexto se está utilizando.

#### 2. **Ejemplo:**

```typescript
const nombres = ["Goku", "Vegeta", "Trunks"];

// NO necesitamos escribir 'nombre: string'.
// TypeScript sabe que 'nombres' es un 'string[]', por lo que 'forEach'
// le pasará un 'string' a la función en cada iteración.
nombres.forEach(function (nombre) {
  console.log(nombre.toUpperCase());
});

// Lo mismo aplica para las funciones de flecha. ¡Más corto y limpio!
nombres.forEach((nombre) => {
  console.log(nombre.toUpperCase());
});
```

**Explicación del ejemplo:**
Fíjate que en ningún momento escribimos `(nombre: string)`. No fue necesario. TypeScript mira el contexto: "Ok, estamos llamando al método `.forEach` de `nombres`. Sé que `nombres` es un array de strings (`string[]`). Por lo tanto, la función que se le pasa a `.forEach` recibirá un string como primer parámetro". A esto se le llama **tipado contextual**.

#### 3. **Desarrollo:**

Esta es otra de las características que hacen que TypeScript sea tan agradable de usar. El compilador utiliza la información que le rodea para ahorrarte trabajo. De nuevo, la regla es: no escribas los tipos si TypeScript ya puede deducirlos por el contexto. Esto mantiene tu código limpio y legible.

🟡 **Importante**: Entender esto te ayuda a escribir código más conciso y a confiar más en el compilador. Es una demostración de cómo TypeScript trabaja _contigo_ y no _contra ti_.

---

## J - Tipos de Objeto: Definiendo la Forma de tus Datos 🔴

#### 1. **Introducción:**

Para describir un objeto, simplemente listas sus propiedades y los tipos de cada una, definiendo su "forma" o "estructura".

#### 2. **Ejemplo:**

```typescript
// Esta función espera un objeto que TENGA una propiedad 'nombre' de tipo string
// y una propiedad 'planeta' de tipo string.
function imprimirGuerrero(guerrero: { nombre: string; planeta: string }) {
  console.log(`Guerrero: ${guerrero.nombre}, Planeta: ${guerrero.planeta}`);
}

// Le pasamos un objeto que cumple con esa forma.
imprimirGuerrero({ nombre: "Vegeta", planeta: "Vegeta" });

// Si no cumplimos, TypeScript nos avisa.
imprimirGuerrero({ nombre: "Goku" }); // ERROR: Falta la propiedad 'planeta'.
```

**Explicación del ejemplo:**
La anotación `{ nombre: string; planeta: string }` es un **tipo de objeto**. Es un contrato que dice: "quien sea que me llame, debe pasarme un objeto con estas propiedades y estos tipos exactos". No le importa nada más, solo que la _estructura_ coincida. Puedes usar `,` o `;` para separar las propiedades.

#### 3. **Desarrollo:**

Casi todo en JavaScript es un objeto. Ser capaz de definir la forma que deben tener tus objetos es, por tanto, una habilidad central. Esto elimina una categoría entera de errores, como escribir mal el nombre de una propiedad (`guerrero.nomber` en lugar de `guerrero.nombre`) o esperar un tipo de dato que no es (`guerrero.ki` como `string` cuando es `number`).

🔴 **Fundamental**: Junto con el tipado de funciones, esta es la otra piedra angular de TypeScript. La mayor parte de tu tiempo la pasarás definiendo y usando objetos con formas específicas.

---

## K - Propiedades Opcionales: Datos que Pueden o no Estar 🟡

#### 1. **Introducción:**

Puedes marcar propiedades en un tipo de objeto como opcionales añadiendo un `?` después de su nombre, indicando que podrían no existir.

#### 2. **Ejemplo:**

```typescript
function crearPersonaje(config: { nombre: string; raza: string; ki?: number }) {
  console.log(`Personaje creado: ${config.nombre} (${config.raza})`);
  // Si intentamos usar 'ki' directamente, TypeScript nos advierte.
  // console.log(config.ki.toFixed(2)); // ERROR: 'config.ki' es posiblemente 'undefined'.

  // Debemos comprobar si existe ANTES de usarlo.
  if (config.ki !== undefined) {
    console.log(`Su Ki es: ${config.ki}`);
  }

  // Una alternativa moderna y segura (optional chaining):
  console.log(`Su Ki (forma segura): ${config.ki?.toString()}`);
}

// Ambas llamadas son válidas:
crearPersonaje({ nombre: "Bulma", raza: "Humana" }); // 'ki' no se proporciona.
crearPersonaje({ nombre: "Gohan", raza: "Saiyan/Humano", ki: 3500 });
```

**Explicación del ejemplo:**
La propiedad `ki?: number` significa que un objeto de este tipo _puede_ tener una propiedad `ki` que sea un número, pero no es obligatorio. Como `ki` puede no existir (y por tanto ser `undefined`), TypeScript te obliga a comprobar su existencia antes de intentar usarlo. Esto previene el famoso error de JavaScript: `Cannot read property '...' of undefined`.

#### 3. **Desarrollo:**

Las propiedades opcionales son increíblemente útiles para describir objetos donde algunos campos no siempre están presentes, como en las respuestas de una API o en objetos de configuración. La clave es recordar siempre la regla que TypeScript te impone: si una propiedad es opcional, **debes** manejar el caso en que no exista.

🟡 **Importante**: Es una herramienta muy común para modelar datos del mundo real, que a menudo son imperfectos o incompletos. Dominar las propiedades opcionales y cómo trabajar con ellas de forma segura es crucial.

---

## L - Union Types: "Esto O Aquello" 🔴

#### 1. **Introducción:**

Un "tipo unión" te permite declarar que un valor puede ser de uno entre varios tipos posibles, usando el operador `|` (la barra vertical).

#### 2. **Ejemplo:**

```typescript
// Esta función acepta un 'id' que puede ser un número O un string.
function buscarPorId(id: number | string) {
  console.log("Buscando el ID: " + id);
  // PERO, no podemos usar métodos específicos de string o number aquí...
  // console.log(id.toUpperCase()); // ERROR: La propiedad 'toUpperCase' no existe en el tipo 'number'.
}

// Ambas llamadas son correctas:
buscarPorId(101);
buscarPorId("a-202-z");

// Esta llamada es incorrecta:
buscarPorId({ miId: 123 }); // ERROR: El objeto no es ni 'number' ni 'string'.
```

**Explicación del ejemplo:**
El tipo `number | string` se lee literalmente como "un número o un string". La variable `id` puede contener cualquiera de esos dos tipos. Esto es mucho más preciso que usar `any`, porque limitamos las posibilidades a un conjunto conocido.

#### 3. **Desarrollo:**

Los tipos unión son una de las herramientas más poderosas y flexibles de TypeScript. Te permiten modelar situaciones muy comunes donde un valor puede tener diferentes representaciones. El siguiente paso lógico es aprender a _trabajar_ con un valor que tiene un tipo unión, lo que nos lleva directamente al concepto de "narrowing".

🔴 **Fundamental**: Los usarás todos los días. Son la forma correcta de manejar valores que pueden tener múltiples tipos de forma segura y explícita.

---

## M - Trabajando con Union Types (Narrowing) 🔴

#### 1. **Introducción:**

Para poder usar métodos específicos de un tipo dentro de una unión, primero debes "estrechar" (narrow) el tipo, comprobando de qué tipo es el valor en ese momento.

#### 2. **Ejemplo:**

```typescript
function procesarId(id: number | string) {
  // Aquí, 'id' puede ser 'number' o 'string'.

  if (typeof id === "string") {
    // DENTRO de este 'if', TypeScript es listo y sabe que 'id' ES un 'string'.
    // Por lo tanto, podemos usar métodos de string sin problemas.
    console.log(id.toUpperCase());
  } else {
    // Si no era un 'string', por lógica, DEBE ser un 'number'.
    // Aquí, TypeScript sabe que 'id' ES un 'number'.
    console.log(id.toFixed(2));
  }
}

procesarId("xyz-123"); // Imprime: XYZ-123
procesarId(99.95); // Imprime: 99.95
```

**Explicación del ejemplo:**
Usamos una simple comprobación de JavaScript (`typeof id === "string"`). TypeScript analiza este código y entiende que, dentro del bloque `if`, el tipo de `id` se ha "estrechado" de `number | string` a solo `string`. Esto nos permite usar `toUpperCase()` de forma segura. En el `else`, por eliminación, sabe que `id` tiene que ser `number`. Este proceso se llama **narrowing** (estrechamiento o reducción).

#### 3. **Desarrollo:**

El narrowing es la técnica clave para trabajar con tipos unión. Es la forma en que le demuestras a TypeScript que sabes lo que estás haciendo, usando la lógica de tu propio código. Hay muchas formas de hacer narrowing: `typeof`, `instanceof`, `Array.isArray`, comprobaciones de propiedades (`if ("prop" in object)`), etc.

**¿Por qué una UNIÓN tiene la INTERSECCIÓN de propiedades?**
Puede parecer raro que `number | string` solo te deje usar propiedades que existen en _ambos_. Piensa en una habitación con dos grupos de personas: uno de "gente alta que lleva sombrero" y otro de "gente que habla español y lleva sombrero". Si los juntas a todos (una unión de personas), lo único que puedes afirmar con 100% de certeza sobre _cualquier persona_ de la sala es que... ¡lleva sombrero! Lo mismo pasa con los tipos.

🔴 **Fundamental**: No puedes usar `Union Types` de forma efectiva sin entender el `narrowing`. Es el mecanismo que desbloquea todo su poder y seguridad.

---

## N - Type Aliases: Poniéndole un Nombre a tus Tipos 🟡

#### 1. **Introducción:**

Un alias de tipo te permite crear un nombre personalizado para cualquier tipo, haciendo tu código más legible y reutilizable.

#### 2. **Ejemplo:**

```typescript
// Creamos un alias llamado 'Punto' para nuestro tipo de objeto.
type Punto = {
  x: number;
  y: number;
};

// Creamos otro alias para una unión de tipos.
type ID = number | string;

// Ahora podemos usar estos nombres en lugar de repetir la definición.
function mover(punto: Punto, nuevoId: ID) {
  console.log(`Moviendo el punto ${punto.x},${punto.y} con ID: ${nuevoId}`);
}

const miPunto: Punto = { x: 10, y: 20 };
const miId: ID = "personaje-1";

mover(miPunto, miId);
```

**Explicación del ejemplo:**
Con `type Punto = { ... }`, hemos creado un atajo. Ahora, en lugar de escribir `{ x: number; y: number; }` cada vez, simplemente escribimos `Punto`. Es más corto, más claro y si necesitamos cambiar la forma de `Punto` (por ejemplo, añadiendo una propiedad `z`), solo lo hacemos en un lugar.

#### 3. **Desarrollo:**

Los alias de tipo son solo eso: **alias**. No crean un tipo nuevo y distinto. Son simplemente nombres que hacen referencia a otra definición de tipo. Esto es genial para la legibilidad y el mantenimiento del código (principio DRY: Don't Repeat Yourself). Puedes crear alias para cualquier tipo: objetos, uniones, primitivos, etc.

🟡 **Importante**: A medida que tus tipos se vuelven más complejos, los alias se vuelven indispensables para mantener tu código limpio, organizado y fácil de entender.

---

## O - Interfaces: Otra Forma de Nombrar Tipos de Objeto 🟡

#### 1. **Introducción:**

Una `interface` es otra manera, muy similar a los `type aliases`, de darle un nombre a la forma de un objeto.

#### 2. **Ejemplo:**

```typescript
// Usando 'interface' para definir la forma de un objeto.
interface Personaje {
  nombre: string;
  ki: number;
  planeta?: string; // Las propiedades opcionales también funcionan aquí.
}

function mostrarStats(personaje: Personaje) {
  console.log(`Stats de ${personaje.nombre}: Ki de ${personaje.ki}`);
}

mostrarStats({ nombre: "Trunks", ki: 5000 });
```

**Explicación del ejemplo:**
Como puedes ver, el uso es prácticamente idéntico a un `type alias` para un objeto. Definimos una `interface` llamada `Personaje` y luego la usamos para tipar el parámetro de la función. TypeScript solo se preocupa de que el objeto que pasamos tenga la _estructura_ definida por la interfaz (`nombre` y `ki`).

#### 3. **Desarrollo:**

Las interfaces son una de las características más antiguas de TypeScript y son fundamentales para definir la "forma" de los objetos. Durante mucho tiempo, fueron la única manera de hacerlo. Ahora que también existen los `type aliases`, la pregunta es... ¿cuál uso? ¡Vamos a resolverlo de una vez por todas!

🟡 **Importante**: Las interfaces son extremadamente comunes en bases de código de TypeScript. Es esencial que sepas leerlas y usarlas, aunque en muchos casos sean intercambiables con los `type aliases`.

---

## P - Interfaces vs. Type Aliases: El Duelo Definitivo 🟡

#### 1. **Introducción:**

Ambos pueden describir la forma de un objeto, pero tienen diferencias clave en su capacidad de ser extendidos o modificados.

#### 2. **Ejemplo y Desarrollo (¡Atención máxima aquí!):**

La diferencia más importante y que debe quedar grabada a fuego es la **"Declaración Merging"** (fusión de declaraciones) de las interfaces.

**Diferencia Clave: Extensibilidad y Fusión**

| Característica              | `interface` (Interfaz)                                                                            | `type` (Alias de Tipo)                                                                      |
| :-------------------------- | :------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------ |
| **Extender**                | Se usa la palabra clave `extends`, muy natural e intuitiva.                                       | Se usan intersecciones (`&`), que es como "fusionar" dos tipos.                             |
| **Fusión de Declaraciones** | **Sí, se pueden fusionar.** Si declaras la misma interfaz dos veces, sus propiedades se combinan. | **No, no se pueden fusionar.** Declarar el mismo `type` dos veces da un error de duplicado. |

---

**1. Extender un tipo (Ambos pueden hacerlo, con sintaxis diferente)**

Imagina que tenemos un `Animal` y queremos crear un `Perro` que es un `Animal` pero también tiene la propiedad `raza`.

```typescript
// CON INTERFACE (usa 'extends')
interface Animal {
  nombre: string;
}

interface Perro extends Animal {
  raza: string;
}

const miPerro: Perro = { nombre: "Firulais", raza: "Mestizo" };
console.log(miPerro.nombre); // Ok
console.log(miPerro.raza); // Ok
```

```typescript
// CON TYPE ALIAS (usa intersección '&')
type AnimalType = {
  nombre: string;
};

type PerroType = AnimalType & {
  raza: string;
};

const miOtroPerro: PerroType = { nombre: "Fido", raza: "Golden" };
console.log(miOtroPerro.nombre); // Ok
console.log(miOtroPerro.raza); // Ok
```

**Conclusión Parcial:** Para extender, ambos funcionan. `extends` en las interfaces suele ser más legible para quienes vienen de programación orientada a objetos.

---

**2. Fusión de Declaraciones (¡LA GRAN DIFERENCIA!)**

Esta es la característica mágica de las interfaces. Imagina que quieres añadir una propiedad a una interfaz que ya existe, incluso si fue definida por una librería externa.

```typescript
// CON INTERFACE (¡Funciona!)
interface Ventana {
  titulo: string;
}

// En otro archivo, o más abajo, "reabrimos" la interfaz para añadir más cosas.
interface Ventana {
  versionApi: number;
}

// TypeScript fusiona ambas declaraciones en una sola:
// interface Ventana {
//   titulo: string;
//   versionApi: number;
// }

const miVentana: Ventana = { titulo: "Mi App", versionApi: 2 }; // ¡Correcto!
```

```typescript
// CON TYPE ALIAS (¡Error!)
type VentanaType = {
  titulo: string;
};

// Si intentas declarar el mismo 'type' de nuevo...
type VentanaType = {
  // ERROR: Identificador 'VentanaType' duplicado.
  versionApi: number;
};
```

**Conclusión Clave:** Las interfaces son "abiertas" y los `type aliases` son "cerrados". No puedes redefinir un `type` una vez creado. Esta capacidad de fusión es crucial para aumentar tipos globales o de librerías, como `window` en el navegador.

---

**Recomendación (La regla de oro para no volverte loco):**

> **Usa `interface` por defecto** para definir la forma de los objetos. Su capacidad de fusión y su sintaxis `extends` son muy poderosas y claras.
>
> **Usa `type` cuando necesites** características que las interfaces no tienen, como:
>
> - Crear un alias para un tipo unión (`type ID = string | number;`).
> - Crear un alias para un tipo primitivo (`type EmailString = string;`).
> - Definir un tipo tupla (`type Coordenada = [number, number];`).

🟡 **Importante**: Entender esta diferencia te eleva de "usuario" a "conocedor" de TypeScript. Saber cuándo usar cada uno te permitirá escribir código más modular y extensible.

---

## Q - Type Assertions: "Confía en Mí, TypeScript" 🟡

#### 1. **Introducción:**

Una aserción de tipo es cuando le dices al compilador que tú sabes más que él sobre el tipo de un valor específico.

#### 2. **Ejemplo:**

```typescript
// TypeScript solo sabe que esto devuelve un HTMLElement genérico.
const miCanvasElement = document.getElementById("mi_canvas");

// Pero nosotros SABEMOS que es un elemento <canvas>, así que se lo decimos.
const miCanvas = document.getElementById("mi_canvas") as HTMLCanvasElement;

// Ahora TypeScript nos deja usar propiedades específicas de Canvas.
// miCanvas.getContext("2d"); // ¡Correcto!

// Sin la aserción, esto daría un error:
// miCanvasElement.getContext("2d"); // ERROR: La propiedad 'getContext' no existe en 'HTMLElement'.
```

**Explicación del ejemplo:**
`document.getElementById` no puede saber qué tipo de elemento HTML encontrará. Devuelve un tipo base `HTMLElement`. Pero nosotros, que hemos escrito el HTML, sabemos que el elemento con ID "mi_canvas" es un `<canvas>`. La aserción `as HTMLCanvasElement` es nuestra forma de decirle a TypeScript: "Oye, este valor no es un `HTMLElement` cualquiera, es específicamente un `HTMLCanvasElement`. Confía en mí".

#### 3. **Desarrollo:**

**¡ADVERTENCIA DE MÁXIMA PARANOIA!**
Una aserción de tipo **NO** hace ninguna conversión ni comprobación en tiempo de ejecución. Es una pista que solo existe para el compilador. Si te equivocas y el elemento no es un canvas, tu código fallará estrepitosamente cuando intentes usar `getContext`, y TypeScript no habrá podido protegerte porque tú le dijiste que no lo hiciera.

Úsalas solo cuando estés 100% seguro de que el tipo es el que dices que es. Hay otra sintaxis, `<HTMLCanvasElement>`, pero la sintaxis `as` es preferible porque no entra en conflicto con JSX (usado en React).

🟡 **Importante**: Es una herramienta de escape necesaria para interactuar con APIs que no son totalmente seguras a nivel de tipos (como el DOM). Úsala con precaución y responsabilidad.

---

## R - Literal Types: Tipos que son Valores Específicos 🟡

#### 1. **Introducción:**

Puedes usar valores literales (como un string o número específico) como tipos para restringir una variable a solo esos valores exactos.

#### 2. **Ejemplo:**

```typescript
let direccion: "izquierda" | "derecha" | "arriba" | "abajo";

direccion = "izquierda"; // OK
direccion = "arriba"; // OK

direccion = "diagonal"; // ERROR: El tipo '"diagonal"' no se puede asignar al tipo
// '"izquierda" | "derecha" | "arriba" | "abajo"'.

// Otro ejemplo: una función que solo puede devolver -1, 0, o 1.
function compararNumeros(a: number, b: number): -1 | 0 | 1 {
  return a === b ? 0 : a > b ? 1 : -1;
}
```

**Explicación del ejemplo:**
Hemos definido que la variable `direccion` no puede ser cualquier `string`, sino que debe ser, literalmente, uno de esos cuatro valores. Esto es mucho más seguro y descriptivo que usar `string`. Es la combinación de tipos literales con tipos unión lo que los hace tan increíblemente útiles.

#### 3. **Desarrollo:**

Los tipos literales surgen naturalmente cuando usas `const`. Si declaras `const miNombre = "Goku"`, TypeScript infiere que el tipo de `miNombre` no es `string`, sino el tipo literal `"Goku"`, ¡porque sabe que nunca podrá cambiar! Usar uniones de estos tipos literales es una forma fantástica de modelar estados, opciones o cualquier variable que solo pueda tomar un conjunto finito y conocido de valores.

🟡 **Importante**: Son una alternativa excelente y más segura a los `enums` (que veremos más adelante) y al uso de strings mágicos en tu código. Hacen que tus APIs sean auto-documentadas y mucho más robustas.

---

## S - Inferencia Literal y `as const`: Controlando la Magia 🟡

#### 1. **Introducción:**

A veces, TypeScript es demasiado "general" al inferir tipos en objetos, pero podemos guiarlo para que sea más específico usando `as const`.

#### 2. **Ejemplo (El Problema):**

```typescript
// Esta función espera un método HTTP muy específico.
declare function enviarPeticion(url: string, method: "GET" | "POST"): void;

const peticion = {
  url: "https://api.com/data",
  method: "GET", // TypeScript infiere el tipo de 'method' como 'string'
};

// ¡ERROR! ¿Por qué?
enviarPeticion(peticion.url, peticion.method);
// Argumento de tipo 'string' no se puede asignar al parámetro de tipo '"GET" | "POST"'.
```

**Explicación del Problema:**
TypeScript ve `method: "GET"` dentro de un objeto declarado con `let` o `const` y piensa: "Bueno, esto es un objeto mutable. Alguien podría hacer `peticion.method = 'PUT'` más tarde. Para estar seguro, inferiré que `peticion.method` es de tipo `string`". Y un `string` genérico no es compatible con el tipo más específico `"GET" | "POST"`.

**Las Soluciones:**

```typescript
// Solución 1: Aserción de tipo en la propiedad (un poco verboso)
const peticion1 = {
  url: "https://api.com/data",
  method: "GET" as "GET",
};
enviarPeticion(peticion1.url, peticion1.method); // OK

// Solución 2: La mejor. 'as const' trata todo el objeto como inmutable y literal.
const peticion2 = {
  url: "https://api.com/data",
  method: "GET",
} as const; // ¡La magia está aquí!

enviarPeticion(peticion2.url, peticion2.method); // OK
// Ahora, TypeScript infiere que el tipo de 'peticion2.method' es el literal "GET", no 'string'.
```

#### 3. **Desarrollo:**

`as const` es una "aserción const". Le dice a TypeScript: "Trata este objeto como si fuera profundamente inmutable. Todas sus propiedades deben ser `readonly` y sus valores deben ser inferidos como tipos literales, no como tipos generales (`string`, `number`)". Es una herramienta increíblemente poderosa y concisa para preservar la literalidad de tus objetos de configuración.

🟡 **Importante**: `as const` es tu mejor aliado cuando trabajas con objetos que deben pasarse a funciones que esperan tipos literales. Es la forma moderna y preferida de resolver este problema de inferencia.

---

## T - `null` y `undefined`: Manejando la Ausencia (`strictNullChecks`) 🟡

#### 1. **Introducción:**

`null` y `undefined` son dos primitivos que representan la ausencia de un valor, y la opción `strictNullChecks` cambia radicalmente cómo TypeScript los trata.

#### 2. **Desarrollo (Comparación Crucial):**

**`strictNullChecks`: OFF (Modo Peligroso, no recomendado)**

- `null` y `undefined` pueden ser asignados a cualquier tipo (`string`, `number`, etc.).
- Puedes intentar acceder a propiedades de un valor que podría ser `null` sin que TypeScript se queje.
- **Resultado:** Es una fuente masiva de errores en tiempo de ejecución, el famoso `Cannot read property '...' of null`. Es el comportamiento antiguo y propenso a errores.

**`strictNullChecks`: ON (Modo Seguro, ¡SIEMPRE ACTÍVALO!)**

- `null` y `undefined` son tipos por sí mismos. No puedes asignarlos a una variable de tipo `string` a menos que lo declares explícitamente (`let nombre: string | null;`).
- Si un valor puede ser `null` o `undefined`, TypeScript te **obliga** a comprobarlo antes de usarlo.

#### 3. **Ejemplo (`strictNullChecks`: ON):**

```typescript
function saludarOpcional(nombre: string | null) {
  // Si intentamos usar 'nombre' directamente, hay un error.
  // console.log("Hola, " + nombre.toUpperCase()); // ERROR: 'nombre' es posiblemente 'null'.

  // Debemos hacer 'narrowing' para comprobar que no es null.
  if (nombre === null) {
    console.log("Hola, anónimo.");
  } else {
    // Dentro de este 'else', TypeScript sabe que 'nombre' ES un 'string'.
    console.log("Hola, " + nombre.toUpperCase());
  }
}

saludarOpcional("Vegeta"); // Imprime: Hola, VEGETA
saludarOpcional(null); // Imprime: Hola, anónimo.
```

**Explicación del ejemplo:**
Con `strictNullChecks` activado, TypeScript nos protege. Nos fuerza a manejar el caso en que `nombre` es `null`, eliminando una de las fuentes de errores más comunes en la historia de JavaScript.

🟡 **Importante**: Activar `strictNullChecks` en tu `tsconfig.json` es, junto con `noImplicitAny`, la decisión más importante que puedes tomar para mejorar la calidad y robustez de tu código. No es negociable en un proyecto serio.

---

## U - Operador de Aserción No Nula (`!`) 🔵

#### 1. **Introducción:**

El operador `!` al final de una expresión es un atajo para decirle a TypeScript: "Te juro que este valor no es `null` ni `undefined` en este punto".

#### 2. **Ejemplo:**

```typescript
function obtenerKi(nombre?: string | null): number {
  // Imaginemos que esta función siempre devuelve un número si el nombre no es nulo.
  if (nombre) return 9001;
  return 0;
}

let kiDeGoku: number | null = null;

// ... algo de código después ...
kiDeGoku = obtenerKi("Goku");

// TypeScript todavía piensa que 'kiDeGoku' podría ser 'null' (por su declaración inicial).
// Pero nosotros sabemos que después de la llamada a 'obtenerKi', ya no lo es.
// Usamos '!' para silenciar al compilador.
console.log(kiDeGoku!.toFixed(2)); // Imprime: 9001.00
```

**Explicación del ejemplo:**
`kiDeGoku!` es una aserción de tipo. Es funcionalmente similar a `(kiDeGoku as number)`, pero más corto. Le estamos diciendo a TypeScript: "Sé que declaré `kiDeGoku` como `number | null`, pero en esta línea de código específica, estoy 100% seguro de que no es `null`, así que déjame usar métodos de `number`".

#### 3. **Desarrollo:**

**¡OTRA ADVERTENCIA DE MÁXIMA PARANOIA!**
Al igual que `as`, el operador `!` **no hace nada en tiempo de ejecución**. No comprueba si el valor es nulo, simplemente elimina el error del compilador. Si te equivocas y el valor SÍ es `null`, tu programa se estrellará. Es una herramienta peligrosa si se abusa de ella. Úsala como último recurso, cuando estés absolutamente seguro y no haya una forma más limpia de hacer `narrowing` (como un `if`).

🔵 **Específico**: Es útil en ciertas situaciones, especialmente en tests o cuando trabajas con código donde la lógica de inicialización es compleja, pero siempre prefiere una comprobación explícita (`if (valor)`) antes que una aserción `!`.

---

## V - Enums: Listas de Constantes con Nombre 🔵

#### 1. **Introducción:**

Los `enums` son una característica que TypeScript añade a JavaScript para crear un conjunto de constantes con nombre, a menudo usadas para representar estados o categorías.

#### 2. **Ejemplo:**

```typescript
enum Direccion {
  Arriba, // por defecto es 0
  Abajo, // por defecto es 1
  Izquierda, // por defecto es 2
  Derecha, // por defecto es 3
}

let miMovimiento: Direccion = Direccion.Arriba;

if (miMovimiento === Direccion.Arriba) {
  console.log("Moviendo hacia arriba...");
}
```

**Explicación del ejemplo:**
Hemos creado un `enum` llamado `Direccion` que agrupa un conjunto de constantes relacionadas. Esto es más legible y seguro que usar números o strings "mágicos" (como `if (movimiento === 0)`).

#### 3. **Desarrollo:**

A diferencia de la mayoría de las características de TypeScript, los `enums` **generan código JavaScript en tiempo de ejecución**. No son solo una construcción a nivel de tipos. Por esta razón, y porque los tipos unión de literales (`type Direccion = "Arriba" | "Abajo" ...`) pueden lograr resultados similares de una manera más "ligera" y compatible con JavaScript puro, hay un debate en la comunidad sobre su uso.

🔵 **Específico**: Es bueno que sepas que existen, ya que los encontrarás en muchas bases de código. Sin embargo, para proyectos nuevos, considera si una unión de tipos literales (`string` o `number`) podría ser una alternativa más simple y moderna antes de decidirte por un `enum`.

---

## W - Primitivos Menos Comunes: `bigint` y `symbol` 🔵

#### 1. **Introducción:**

Son dos tipos primitivos más recientes en JavaScript para casos de uso muy específicos: números extremadamente grandes y la creación de identificadores únicos.

#### 2. **Ejemplo:**

```typescript
// bigint: para números más grandes que 2^53 - 1
const numeroGigante: bigint = BigInt(9007199254740991);
const otroNumeroGigante: bigint = 9007199254740992n; // la 'n' al final es la sintaxis literal

// symbol: para crear identificadores únicos que nunca colisionan
const idUnico1 = Symbol("descripcion");
const idUnico2 = Symbol("descripcion");

// Aunque la descripción sea la misma, los symbols son siempre diferentes.
if (idUnico1 === idUnico2) {
  // Esta condición siempre es falsa.
  // Este código nunca se ejecutará.
}
```

**Explicación del ejemplo:**

- `bigint` se usa cuando necesitas realizar cálculos matemáticos con enteros de una precisión que el tipo `number` normal no puede manejar.
- `symbol` se usa a menudo para crear propiedades de objeto "privadas" o para definir claves únicas que no chocarán con otras propiedades.

#### 3. **Desarrollo:**

No te encontrarás con estos tipos todos los días, a menos que trabajes en campos muy específicos como la criptografía, las finanzas de alta precisión (para `bigint`) o el desarrollo de librerías complejas (para `symbol`).

🔵 **Específico**: No son de uso diario, pero es bueno saber que existen por si alguna vez te enfrentas a un problema que requiera sus características únicas. No te preocupes por dominarlos al principio.
