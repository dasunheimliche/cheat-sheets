## A - Los Primitivos: `string`, `number` y `boolean` 游댮

#### 1. **Introducci칩n:**

Son los ladrillos m치s b치sicos de JavaScript y, por lo tanto, de TypeScript: textos, n칰meros y valores de verdadero/falso.

#### 2. **Ejemplo:**

```typescript
let nombre: string = "Goku";
let ki: number = 9001;
let esSuperSaiyan: boolean = true;
```

**Explicaci칩n del ejemplo:**
Aqu칤 le estamos diciendo a TypeScript, con una claridad que roza lo obsesivo:

- La variable `nombre` **siempre** ser치 un texto (`string`).
- La variable `ki` **siempre** ser치 un n칰mero (`number`).
- La variable `esSuperSaiyan` **siempre** ser치 un valor booleano (`boolean`), es decir, `true` o `false`.

#### 3. **Desarrollo:**

Estos son los tipos m치s fundamentales que existen. Piensa en ellos como los 치tomos de tus datos.

- `string`: Para cualquier texto, como `"Hola"` o `'Adi칩s'`.
- `number`: Para cualquier tipo de n칰mero, ya sea `42` (entero) o `3.14` (decimal). En JavaScript (y por ende en TypeScript), no hay distinci칩n entre `int` y `float`, 춰todo es un >`number`! Sencillo, 쯨erdad?
- `boolean`: Solo puede tener dos valores: `true` o `false`. No hay m치s.

**춰Una trampa en la que NO caer치s!**
A veces ver치s `String`, `Number` o `Boolean` con may칰scula. 춰No los uses! Esos son tipos especiales y complejos que casi nunca necesitar치s. Usa siempre `string`, `number` y `boolean` en min칰sculas. Te lo pido por favor.

游댮 **Fundamental**: No puedes escribir ni una sola l칤nea de c칩digo 칰til sin entender estos tres tipos. Son la base de todo lo que construiremos.

---

## B - Arrays: Colecciones de un Mismo Tipo 游리

#### 1. **Introducci칩n:**

Para declarar una lista o colecci칩n de elementos que son todos del mismo tipo, como una lista de solo n칰meros o solo textos.

#### 2. **Ejemplo:**

```typescript
// Una lista de n칰meros que representan los niveles de poder
let nivelesDePoder: number[] = [800, 1200, 9001, 150000];

// Una lista de nombres de guerreros
let guerrerosZ: string[] = ["Goku", "Vegeta", "Piccolo"];

// Otra forma de escribirlo (significa EXACTAMENTE lo mismo)
let planetas: Array<string> = ["Tierra", "Namek", "Vegeta"];
```

**Explicaci칩n del ejemplo:**
La sintaxis `tipo[]` (como `number[]`) es la forma m치s com칰n y directa de decir "un array de...". `nivelesDePoder` solo puede contener n칰meros. Si intentas meter un texto, TypeScript te gritar치 (con cari침o) que eso no se puede. Lo mismo pasa con `guerrerosZ`, que solo acepta textos.

#### 3. **Desarrollo:**

Un array es simplemente una colecci칩n ordenada de valores. La clave en TypeScript es que podemos asegurar que **todos** los elementos de ese array sean del mismo tipo. Esto nos salva de errores tont칤simos, como intentar sumar un n칰mero a un texto que se col칩 en nuestra lista de n칰meros.

La sintaxis `Array<tipo>` (como `Array<number>`) es equivalente a `tipo[]`. Es una sintaxis m치s "gen칠rica" que entender치s a la perfecci칩n m치s adelante, pero por ahora, qu칠date con que ambas funcionan y la primera (`tipo[]`) es la m치s popular por su brevedad.

游리 **Importante**: Usar치s arrays constantemente. Definir su tipo es una de las primeras grandes victorias de usar TypeScript, ya que te da una seguridad inmensa sobre el contenido de tus colecciones.

---

## C - `any`: El Comod칤n Peligroso 游리

#### 1. **Introducci칩n:**

Es un tipo especial que le dice a TypeScript: "Tranquilo, yo me encargo, no revises nada aqu칤", desactivando todas las comprobaciones de tipo para un valor.

#### 2. **Ejemplo:**

```typescript
// Imagina que recibes un objeto de una API vieja y no sabes su forma
let objetoMisterioso: any = { x: 0 };

// Con 'any', TypeScript nos deja hacer cualquier cosa, sin quejarse...
objetoMisterioso.foo(); // Ok en compilaci칩n, pero fallar치 en ejecuci칩n si no existe.
objetoMisterioso(); // Ok en compilaci칩n, pero fallar치 si no es una funci칩n.
objetoMisterioso.bar = 100; // Ok, le a침adimos una propiedad.
objetoMisterioso = "Ahora soy un string"; // Ok, cambiamos su tipo completamente.

const n: number = objetoMisterioso; // 춰Peligro! TypeScript conf칤a en nosotros,
// pero si 'objetoMisterioso' no es un n칰mero,
// esto explotar치 en tiempo de ejecuci칩n.
```

**Explicaci칩n del ejemplo:**
Al declarar `objetoMisterioso` como `any`, le quitamos los ruedines a la bicicleta. TypeScript nos deja intentar acceder a `foo()`, llamarlo como si fuera una funci칩n o asignarle cualquier valor. El compilador no se quejar치, asumiendo que nosotros, los sabios programadores, sabemos lo que hacemos. El problema es que a menudo... no lo sabemos, y esto causa errores cuando el c칩digo se ejecuta.

#### 3. **Desarrollo:**

`any` es una v칤a de escape. Es 칰til cuando est치s migrando c칩digo de JavaScript a TypeScript y no quieres tipar todo de golpe, o cuando trabajas con librer칤as de terceros que no est치n bien tipadas. Sin embargo, su uso es un arma de doble filo: te da flexibilidad, pero a costa de perder la principal ventaja de TypeScript: la seguridad de tipos. Cada `any` en tu c칩digo es un posible nido de bugs.

游리 **Importante**: Debes conocer `any` para entender por qu칠 es mejor evitarlo. Es como conocer las reglas para saber cu치ndo romperlas (aunque en este caso, casi nunca deber칤as). Abusar de `any` es como comprar un coche de lujo para no sacarlo del garaje.

---

## D - `noImplicitAny`: Tu Conciencia Personal 游리

#### 1. **Introducci칩n:**

Es una regla del compilador que te obliga a ser expl칤cito con tus tipos, prohibiendo que TypeScript infiera el tipo `any` por defecto.

#### 2. **Ejemplo:**

```typescript
// CON 'noImplicitAny' DESACTIVADO (comportamiento por defecto relajado)
function procesar(data) {
  // 'data' es impl칤citamente de tipo 'any'
  console.log(data.nombre); // TypeScript no se queja
}

// CON 'noImplicitAny' ACTIVADO (en tu archivo tsconfig.json)
function procesar(data) {
  // ERROR: El par치metro 'data' tiene impl칤citamente un tipo 'any'.
  //                 ^^^^
  // TypeScript te obliga a decidir: 쯤u칠 tipo es 'data'?
  console.log(data.nombre);
}

// La soluci칩n es ser expl칤cito:
function procesarSolucionado(data: { nombre: string }) {
  console.log(data.nombre); // 춰Ahora s칤! Seguro y claro.
}
```

**Explicaci칩n del ejemplo:**
Cuando la opci칩n `noImplicitAny` est치 activada en la configuraci칩n de tu proyecto (`tsconfig.json`), TypeScript se pone en modo "paranoico" (춰como yo!) y te dice: "Oye, no has especificado el tipo para `data`. No voy a asumir que es `any` porque eso es peligroso. Por favor, dime qu칠 es". Esto te fuerza a tomar una decisi칩n consciente y a mantener tu c칩digo seguro.

#### 3. **Desarrollo:**

Activar `noImplicitAny` es una de las mejores decisiones que puedes tomar en un proyecto de TypeScript. Te obliga a pensar en los tipos desde el principio y evita que los `any` se cuelen en tu c칩digo sin que te des cuenta. Es como un cintur칩n de seguridad: al principio puede parecer una molestia, pero te salvar치 de problemas graves.

游리 **Importante**: Activar esta regla es una pr치ctica recomendada fundamental. Te convierte en un programador m치s disciplinado y tu "yo" del futuro te lo agradecer치 enormemente.

---

## E - Anotaciones de Tipo: Etiquetando tus Variables 游댮

#### 1. **Introducci칩n:**

Es la forma expl칤cita de decirle a TypeScript cu치l es el tipo de una variable, par치metro o valor de retorno.

#### 2. **Ejemplo:**

```typescript
// La anotaci칩n de tipo va DESPU칄S del nombre de la variable, con dos puntos.
let miPlaneta: string = "Tierra";

function saludar(nombre: string): void {
  //       par치metro ^^^^^^^^   ^^^^^^ retorno
  console.log("춰Hola, " + nombre + "!");
}
```

**Explicaci칩n del ejemplo:**
La sintaxis `: tipo` es la "anotaci칩n". En `let miPlaneta: string`, estamos declarando que `miPlaneta` debe ser un `string`. En la funci칩n `saludar`, `nombre: string` significa que el par치metro `nombre` debe ser un `string`, y `: void` significa que la funci칩n no devuelve ning칰n valor.

#### 3. **Desarrollo:**

A diferencia de otros lenguajes donde el tipo va antes (`string miPlaneta`), en TypeScript siempre va despu칠s. Esta es la sintaxis central para ser expl칤cito con tus tipos. Sin embargo, como veremos a continuaci칩n, 춰no siempre necesitas escribir estas anotaciones!

游댮 **Fundamental**: Es la sintaxis b치sica para definir tipos. Aunque la inferencia (el siguiente punto) te ahorrar치 escribir muchas de ellas, necesitas dominar esta sintaxis para los casos en que TypeScript no puede adivinar el tipo por s칤 solo, como en los par치metros de una funci칩n.

---

## F - Inferencia de Tipos: La Magia de TypeScript 游댮

#### 1. **Introducci칩n:**

Es la habilidad de TypeScript para adivinar autom치ticamente el tipo de una variable bas치ndose en el valor que le asignas.

#### 2. **Ejemplo:**

```typescript
// No necesitamos escribir ': string'. 춰TypeScript ya lo sabe!
let villano = "Freezer";
// TypeScript ve que le asignas un texto y piensa: "Aha, 'villano' es de tipo string".

// No necesitamos escribir ': number'.
let poderDePelea = 530000;
// TypeScript ve el n칰mero y dice: "Entendido, 'poderDePelea' es de tipo number".
```

**Explicaci칩n del ejemplo:**
En ambos casos, no escribimos `: string` o `: number`. Simplemente inicializamos la variable. TypeScript es lo suficientemente inteligente como para analizar el valor `"Freezer"` y deducir que el tipo de `villano` es `string`. Lo mismo ocurre con `poderDePelea`.

#### 3. **Desarrollo:**

La inferencia es tu mejor amiga. Hace que el c칩digo sea m치s limpio y menos verboso, sin sacrificar la seguridad. La regla de oro para un principiante es: **intenta no poner anotaciones de tipo en las variables y deja que TypeScript haga su magia**. Solo a침치delas si TypeScript se queja o si no puede adivinar el tipo (como en los par치metros de una funci칩n, que no tienen un valor inicial). Conf칤a en la inferencia, 춰funciona de maravilla!

游댮 **Fundamental**: Entender que la inferencia existe te ahorrar치 teclear much칤simo. Es una caracter칤stica clave que hace que usar TypeScript sea un placer y no una carga.

---

## G - Funciones: Tipando Entradas y Salidas 游댮

#### 1. **Introducci칩n:**

TypeScript te permite definir con precisi칩n qu칠 tipo de datos aceptan tus funciones (par치metros) y qu칠 tipo de datos devuelven (retorno).

#### 2. **Ejemplo:**

```typescript
// Par치metros tipados: 'base' y 'potencia' DEBEN ser n칰meros.
// Retorno tipado: Esta funci칩n DEBE devolver un n칰mero.
function calcularKi(base: number, potencia: number): number {
  return base * potencia;
}

// El tipo de retorno tambi칠n puede ser inferido, 춰pero ser expl칤cito es bueno para la claridad!
function saludarGuerrero(nombre: string) {
  // El retorno se infiere como 'void' (no devuelve nada)
  console.log("춰Hola, " + nombre.toUpperCase() + "!");
}

// TypeScript te protege de errores:
saludarGuerrero(9001); // ERROR: El argumento de tipo 'number' no se puede asignar
// al par치metro de tipo 'string'.
```

**Explicaci칩n del ejemplo:**

- **Par치metros:** `(base: number, potencia: number)` establece un contrato. La funci칩n `calcularKi` solo aceptar치 dos argumentos que sean n칰meros.
- **Retorno:** El `: number` despu칠s de los par칠ntesis significa que la funci칩n _promete_ devolver un valor num칠rico. Si intentaras devolver un `string`, TypeScript te avisar칤a del error.

#### 3. **Desarrollo:**

Tipar funciones es, posiblemente, el uso m치s importante de TypeScript. Te da una garant칤a total sobre c칩mo se deben usar tus bloques de c칩digo, evitando errores en tiempo de ejecuci칩n y haciendo que tu c칩digo sea mucho m치s f치cil de entender para otros (y para tu "yo" del futuro). Aunque el tipo de retorno a menudo se puede inferir, muchos equipos prefieren anotarlo expl칤citamente por claridad y para evitar cambios accidentales.

游댮 **Fundamental**: Si solo pudieras aprender una cosa sobre TypeScript, ser칤a c칩mo tipar los par치metros y el retorno de las funciones. Es la base de la construcci칩n de aplicaciones robustas y seguras.

---

## H - Funciones que Devuelven Promesas 游리

#### 1. **Introducci칩n:**

Para tipar el valor que una funci칩n as칤ncrona resolver치 en el futuro, se utiliza el tipo gen칠rico `Promise<Tipo>`.

#### 2. **Ejemplo:**

```typescript
// Esta funci칩n as칤ncrona promete que, cuando termine,
// devolver치 un n칰mero.
async function obtenerNivelDePoder(): Promise<number> {
  // Imaginemos que aqu칤 hay una llamada a una base de datos...
  return 9001;
}

// Al usarla, TypeScript sabe que 'nivel' ser치 un n칰mero.
async function miFuncion() {
  const nivel = await obtenerNivelDePoder();
  console.log("El nivel es: " + nivel); // 'nivel' es de tipo 'number'
}
```

**Explicaci칩n del ejemplo:**
Una funci칩n `async` siempre devuelve una Promesa. La sintaxis `Promise<number>` no dice que la funci칩n devuelve un n칰mero directamente, sino que devuelve una _promesa que se resolver치 con un n칰mero_. Esto es crucial. TypeScript sabe que despu칠s de usar `await`, el valor que obtendr치s (`nivel`) ser치 del tipo que especificaste dentro de los `< >`.

#### 3. **Desarrollo:**

En el JavaScript moderno, las operaciones as칤ncronas (como llamadas a APIs, acceso a bases de datos, etc.) son el pan de cada d칤a. Saber tipar correctamente las promesas es esencial para trabajar con `async/await` de forma segura. `Promise<TipoResuelto>` te dice exactamente qu칠 esperar cuando la operaci칩n as칤ncrona concluya.

游리 **Importante**: Si trabajas con APIs, o cualquier operaci칩n as칤ncrona, este conocimiento no es opcional. Es una herramienta diaria para escribir c칩digo as칤ncrono robusto.

---

## I - Funciones An칩nimas y Tipado Contextual 游리

#### 1. **Introducci칩n:**

TypeScript es tan inteligente que puede inferir los tipos de los par치metros de una funci칩n si sabe en qu칠 contexto se est치 utilizando.

#### 2. **Ejemplo:**

```typescript
const nombres = ["Goku", "Vegeta", "Trunks"];

// NO necesitamos escribir 'nombre: string'.
// TypeScript sabe que 'nombres' es un 'string[]', por lo que 'forEach'
// le pasar치 un 'string' a la funci칩n en cada iteraci칩n.
nombres.forEach(function (nombre) {
  console.log(nombre.toUpperCase());
});

// Lo mismo aplica para las funciones de flecha. 춰M치s corto y limpio!
nombres.forEach((nombre) => {
  console.log(nombre.toUpperCase());
});
```

**Explicaci칩n del ejemplo:**
F칤jate que en ning칰n momento escribimos `(nombre: string)`. No fue necesario. TypeScript mira el contexto: "Ok, estamos llamando al m칠todo `.forEach` de `nombres`. S칠 que `nombres` es un array de strings (`string[]`). Por lo tanto, la funci칩n que se le pasa a `.forEach` recibir치 un string como primer par치metro". A esto se le llama **tipado contextual**.

#### 3. **Desarrollo:**

Esta es otra de las caracter칤sticas que hacen que TypeScript sea tan agradable de usar. El compilador utiliza la informaci칩n que le rodea para ahorrarte trabajo. De nuevo, la regla es: no escribas los tipos si TypeScript ya puede deducirlos por el contexto. Esto mantiene tu c칩digo limpio y legible.

游리 **Importante**: Entender esto te ayuda a escribir c칩digo m치s conciso y a confiar m치s en el compilador. Es una demostraci칩n de c칩mo TypeScript trabaja _contigo_ y no _contra ti_.

---

## J - Tipos de Objeto: Definiendo la Forma de tus Datos 游댮

#### 1. **Introducci칩n:**

Para describir un objeto, simplemente listas sus propiedades y los tipos de cada una, definiendo su "forma" o "estructura".

#### 2. **Ejemplo:**

```typescript
// Esta funci칩n espera un objeto que TENGA una propiedad 'nombre' de tipo string
// y una propiedad 'planeta' de tipo string.
function imprimirGuerrero(guerrero: { nombre: string; planeta: string }) {
  console.log(`Guerrero: ${guerrero.nombre}, Planeta: ${guerrero.planeta}`);
}

// Le pasamos un objeto que cumple con esa forma.
imprimirGuerrero({ nombre: "Vegeta", planeta: "Vegeta" });

// Si no cumplimos, TypeScript nos avisa.
imprimirGuerrero({ nombre: "Goku" }); // ERROR: Falta la propiedad 'planeta'.
```

**Explicaci칩n del ejemplo:**
La anotaci칩n `{ nombre: string; planeta: string }` es un **tipo de objeto**. Es un contrato que dice: "quien sea que me llame, debe pasarme un objeto con estas propiedades y estos tipos exactos". No le importa nada m치s, solo que la _estructura_ coincida. Puedes usar `,` o `;` para separar las propiedades.

#### 3. **Desarrollo:**

Casi todo en JavaScript es un objeto. Ser capaz de definir la forma que deben tener tus objetos es, por tanto, una habilidad central. Esto elimina una categor칤a entera de errores, como escribir mal el nombre de una propiedad (`guerrero.nomber` en lugar de `guerrero.nombre`) o esperar un tipo de dato que no es (`guerrero.ki` como `string` cuando es `number`).

游댮 **Fundamental**: Junto con el tipado de funciones, esta es la otra piedra angular de TypeScript. La mayor parte de tu tiempo la pasar치s definiendo y usando objetos con formas espec칤ficas.

---

## K - Propiedades Opcionales: Datos que Pueden o no Estar 游리

#### 1. **Introducci칩n:**

Puedes marcar propiedades en un tipo de objeto como opcionales a침adiendo un `?` despu칠s de su nombre, indicando que podr칤an no existir.

#### 2. **Ejemplo:**

```typescript
function crearPersonaje(config: { nombre: string; raza: string; ki?: number }) {
  console.log(`Personaje creado: ${config.nombre} (${config.raza})`);
  // Si intentamos usar 'ki' directamente, TypeScript nos advierte.
  // console.log(config.ki.toFixed(2)); // ERROR: 'config.ki' es posiblemente 'undefined'.

  // Debemos comprobar si existe ANTES de usarlo.
  if (config.ki !== undefined) {
    console.log(`Su Ki es: ${config.ki}`);
  }

  // Una alternativa moderna y segura (optional chaining):
  console.log(`Su Ki (forma segura): ${config.ki?.toString()}`);
}

// Ambas llamadas son v치lidas:
crearPersonaje({ nombre: "Bulma", raza: "Humana" }); // 'ki' no se proporciona.
crearPersonaje({ nombre: "Gohan", raza: "Saiyan/Humano", ki: 3500 });
```

**Explicaci칩n del ejemplo:**
La propiedad `ki?: number` significa que un objeto de este tipo _puede_ tener una propiedad `ki` que sea un n칰mero, pero no es obligatorio. Como `ki` puede no existir (y por tanto ser `undefined`), TypeScript te obliga a comprobar su existencia antes de intentar usarlo. Esto previene el famoso error de JavaScript: `Cannot read property '...' of undefined`.

#### 3. **Desarrollo:**

Las propiedades opcionales son incre칤blemente 칰tiles para describir objetos donde algunos campos no siempre est치n presentes, como en las respuestas de una API o en objetos de configuraci칩n. La clave es recordar siempre la regla que TypeScript te impone: si una propiedad es opcional, **debes** manejar el caso en que no exista.

游리 **Importante**: Es una herramienta muy com칰n para modelar datos del mundo real, que a menudo son imperfectos o incompletos. Dominar las propiedades opcionales y c칩mo trabajar con ellas de forma segura es crucial.

---

## L - Union Types: "Esto O Aquello" 游댮

#### 1. **Introducci칩n:**

Un "tipo uni칩n" te permite declarar que un valor puede ser de uno entre varios tipos posibles, usando el operador `|` (la barra vertical).

#### 2. **Ejemplo:**

```typescript
// Esta funci칩n acepta un 'id' que puede ser un n칰mero O un string.
function buscarPorId(id: number | string) {
  console.log("Buscando el ID: " + id);
  // PERO, no podemos usar m칠todos espec칤ficos de string o number aqu칤...
  // console.log(id.toUpperCase()); // ERROR: La propiedad 'toUpperCase' no existe en el tipo 'number'.
}

// Ambas llamadas son correctas:
buscarPorId(101);
buscarPorId("a-202-z");

// Esta llamada es incorrecta:
buscarPorId({ miId: 123 }); // ERROR: El objeto no es ni 'number' ni 'string'.
```

**Explicaci칩n del ejemplo:**
El tipo `number | string` se lee literalmente como "un n칰mero o un string". La variable `id` puede contener cualquiera de esos dos tipos. Esto es mucho m치s preciso que usar `any`, porque limitamos las posibilidades a un conjunto conocido.

#### 3. **Desarrollo:**

Los tipos uni칩n son una de las herramientas m치s poderosas y flexibles de TypeScript. Te permiten modelar situaciones muy comunes donde un valor puede tener diferentes representaciones. El siguiente paso l칩gico es aprender a _trabajar_ con un valor que tiene un tipo uni칩n, lo que nos lleva directamente al concepto de "narrowing".

游댮 **Fundamental**: Los usar치s todos los d칤as. Son la forma correcta de manejar valores que pueden tener m칰ltiples tipos de forma segura y expl칤cita.

---

## M - Trabajando con Union Types (Narrowing) 游댮

#### 1. **Introducci칩n:**

Para poder usar m칠todos espec칤ficos de un tipo dentro de una uni칩n, primero debes "estrechar" (narrow) el tipo, comprobando de qu칠 tipo es el valor en ese momento.

#### 2. **Ejemplo:**

```typescript
function procesarId(id: number | string) {
  // Aqu칤, 'id' puede ser 'number' o 'string'.

  if (typeof id === "string") {
    // DENTRO de este 'if', TypeScript es listo y sabe que 'id' ES un 'string'.
    // Por lo tanto, podemos usar m칠todos de string sin problemas.
    console.log(id.toUpperCase());
  } else {
    // Si no era un 'string', por l칩gica, DEBE ser un 'number'.
    // Aqu칤, TypeScript sabe que 'id' ES un 'number'.
    console.log(id.toFixed(2));
  }
}

procesarId("xyz-123"); // Imprime: XYZ-123
procesarId(99.95); // Imprime: 99.95
```

**Explicaci칩n del ejemplo:**
Usamos una simple comprobaci칩n de JavaScript (`typeof id === "string"`). TypeScript analiza este c칩digo y entiende que, dentro del bloque `if`, el tipo de `id` se ha "estrechado" de `number | string` a solo `string`. Esto nos permite usar `toUpperCase()` de forma segura. En el `else`, por eliminaci칩n, sabe que `id` tiene que ser `number`. Este proceso se llama **narrowing** (estrechamiento o reducci칩n).

#### 3. **Desarrollo:**

El narrowing es la t칠cnica clave para trabajar con tipos uni칩n. Es la forma en que le demuestras a TypeScript que sabes lo que est치s haciendo, usando la l칩gica de tu propio c칩digo. Hay muchas formas de hacer narrowing: `typeof`, `instanceof`, `Array.isArray`, comprobaciones de propiedades (`if ("prop" in object)`), etc.

**쯇or qu칠 una UNI칍N tiene la INTERSECCI칍N de propiedades?**
Puede parecer raro que `number | string` solo te deje usar propiedades que existen en _ambos_. Piensa en una habitaci칩n con dos grupos de personas: uno de "gente alta que lleva sombrero" y otro de "gente que habla espa침ol y lleva sombrero". Si los juntas a todos (una uni칩n de personas), lo 칰nico que puedes afirmar con 100% de certeza sobre _cualquier persona_ de la sala es que... 춰lleva sombrero! Lo mismo pasa con los tipos.

游댮 **Fundamental**: No puedes usar `Union Types` de forma efectiva sin entender el `narrowing`. Es el mecanismo que desbloquea todo su poder y seguridad.

---

## N - Type Aliases: Poni칠ndole un Nombre a tus Tipos 游리

#### 1. **Introducci칩n:**

Un alias de tipo te permite crear un nombre personalizado para cualquier tipo, haciendo tu c칩digo m치s legible y reutilizable.

#### 2. **Ejemplo:**

```typescript
// Creamos un alias llamado 'Punto' para nuestro tipo de objeto.
type Punto = {
  x: number;
  y: number;
};

// Creamos otro alias para una uni칩n de tipos.
type ID = number | string;

// Ahora podemos usar estos nombres en lugar de repetir la definici칩n.
function mover(punto: Punto, nuevoId: ID) {
  console.log(`Moviendo el punto ${punto.x},${punto.y} con ID: ${nuevoId}`);
}

const miPunto: Punto = { x: 10, y: 20 };
const miId: ID = "personaje-1";

mover(miPunto, miId);
```

**Explicaci칩n del ejemplo:**
Con `type Punto = { ... }`, hemos creado un atajo. Ahora, en lugar de escribir `{ x: number; y: number; }` cada vez, simplemente escribimos `Punto`. Es m치s corto, m치s claro y si necesitamos cambiar la forma de `Punto` (por ejemplo, a침adiendo una propiedad `z`), solo lo hacemos en un lugar.

#### 3. **Desarrollo:**

Los alias de tipo son solo eso: **alias**. No crean un tipo nuevo y distinto. Son simplemente nombres que hacen referencia a otra definici칩n de tipo. Esto es genial para la legibilidad y el mantenimiento del c칩digo (principio DRY: Don't Repeat Yourself). Puedes crear alias para cualquier tipo: objetos, uniones, primitivos, etc.

游리 **Importante**: A medida que tus tipos se vuelven m치s complejos, los alias se vuelven indispensables para mantener tu c칩digo limpio, organizado y f치cil de entender.

---

## O - Interfaces: Otra Forma de Nombrar Tipos de Objeto 游리

#### 1. **Introducci칩n:**

Una `interface` es otra manera, muy similar a los `type aliases`, de darle un nombre a la forma de un objeto.

#### 2. **Ejemplo:**

```typescript
// Usando 'interface' para definir la forma de un objeto.
interface Personaje {
  nombre: string;
  ki: number;
  planeta?: string; // Las propiedades opcionales tambi칠n funcionan aqu칤.
}

function mostrarStats(personaje: Personaje) {
  console.log(`Stats de ${personaje.nombre}: Ki de ${personaje.ki}`);
}

mostrarStats({ nombre: "Trunks", ki: 5000 });
```

**Explicaci칩n del ejemplo:**
Como puedes ver, el uso es pr치cticamente id칠ntico a un `type alias` para un objeto. Definimos una `interface` llamada `Personaje` y luego la usamos para tipar el par치metro de la funci칩n. TypeScript solo se preocupa de que el objeto que pasamos tenga la _estructura_ definida por la interfaz (`nombre` y `ki`).

#### 3. **Desarrollo:**

Las interfaces son una de las caracter칤sticas m치s antiguas de TypeScript y son fundamentales para definir la "forma" de los objetos. Durante mucho tiempo, fueron la 칰nica manera de hacerlo. Ahora que tambi칠n existen los `type aliases`, la pregunta es... 쯖u치l uso? 춰Vamos a resolverlo de una vez por todas!

游리 **Importante**: Las interfaces son extremadamente comunes en bases de c칩digo de TypeScript. Es esencial que sepas leerlas y usarlas, aunque en muchos casos sean intercambiables con los `type aliases`.

---

## P - Interfaces vs. Type Aliases: El Duelo Definitivo 游리

#### 1. **Introducci칩n:**

Ambos pueden describir la forma de un objeto, pero tienen diferencias clave en su capacidad de ser extendidos o modificados.

#### 2. **Ejemplo y Desarrollo (춰Atenci칩n m치xima aqu칤!):**

La diferencia m치s importante y que debe quedar grabada a fuego es la **"Declaraci칩n Merging"** (fusi칩n de declaraciones) de las interfaces.

**Diferencia Clave: Extensibilidad y Fusi칩n**

| Caracter칤stica              | `interface` (Interfaz)                                                                            | `type` (Alias de Tipo)                                                                      |
| :-------------------------- | :------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------ |
| **Extender**                | Se usa la palabra clave `extends`, muy natural e intuitiva.                                       | Se usan intersecciones (`&`), que es como "fusionar" dos tipos.                             |
| **Fusi칩n de Declaraciones** | **S칤, se pueden fusionar.** Si declaras la misma interfaz dos veces, sus propiedades se combinan. | **No, no se pueden fusionar.** Declarar el mismo `type` dos veces da un error de duplicado. |

---

**1. Extender un tipo (Ambos pueden hacerlo, con sintaxis diferente)**

Imagina que tenemos un `Animal` y queremos crear un `Perro` que es un `Animal` pero tambi칠n tiene la propiedad `raza`.

```typescript
// CON INTERFACE (usa 'extends')
interface Animal {
  nombre: string;
}

interface Perro extends Animal {
  raza: string;
}

const miPerro: Perro = { nombre: "Firulais", raza: "Mestizo" };
console.log(miPerro.nombre); // Ok
console.log(miPerro.raza); // Ok
```

```typescript
// CON TYPE ALIAS (usa intersecci칩n '&')
type AnimalType = {
  nombre: string;
};

type PerroType = AnimalType & {
  raza: string;
};

const miOtroPerro: PerroType = { nombre: "Fido", raza: "Golden" };
console.log(miOtroPerro.nombre); // Ok
console.log(miOtroPerro.raza); // Ok
```

**Conclusi칩n Parcial:** Para extender, ambos funcionan. `extends` en las interfaces suele ser m치s legible para quienes vienen de programaci칩n orientada a objetos.

---

**2. Fusi칩n de Declaraciones (춰LA GRAN DIFERENCIA!)**

Esta es la caracter칤stica m치gica de las interfaces. Imagina que quieres a침adir una propiedad a una interfaz que ya existe, incluso si fue definida por una librer칤a externa.

```typescript
// CON INTERFACE (춰Funciona!)
interface Ventana {
  titulo: string;
}

// En otro archivo, o m치s abajo, "reabrimos" la interfaz para a침adir m치s cosas.
interface Ventana {
  versionApi: number;
}

// TypeScript fusiona ambas declaraciones en una sola:
// interface Ventana {
//   titulo: string;
//   versionApi: number;
// }

const miVentana: Ventana = { titulo: "Mi App", versionApi: 2 }; // 춰Correcto!
```

```typescript
// CON TYPE ALIAS (춰Error!)
type VentanaType = {
  titulo: string;
};

// Si intentas declarar el mismo 'type' de nuevo...
type VentanaType = {
  // ERROR: Identificador 'VentanaType' duplicado.
  versionApi: number;
};
```

**Conclusi칩n Clave:** Las interfaces son "abiertas" y los `type aliases` son "cerrados". No puedes redefinir un `type` una vez creado. Esta capacidad de fusi칩n es crucial para aumentar tipos globales o de librer칤as, como `window` en el navegador.

---

**Recomendaci칩n (La regla de oro para no volverte loco):**

> **Usa `interface` por defecto** para definir la forma de los objetos. Su capacidad de fusi칩n y su sintaxis `extends` son muy poderosas y claras.
>
> **Usa `type` cuando necesites** caracter칤sticas que las interfaces no tienen, como:
>
> - Crear un alias para un tipo uni칩n (`type ID = string | number;`).
> - Crear un alias para un tipo primitivo (`type EmailString = string;`).
> - Definir un tipo tupla (`type Coordenada = [number, number];`).

游리 **Importante**: Entender esta diferencia te eleva de "usuario" a "conocedor" de TypeScript. Saber cu치ndo usar cada uno te permitir치 escribir c칩digo m치s modular y extensible.

---

## Q - Type Assertions: "Conf칤a en M칤, TypeScript" 游리

#### 1. **Introducci칩n:**

Una aserci칩n de tipo es cuando le dices al compilador que t칰 sabes m치s que 칠l sobre el tipo de un valor espec칤fico.

#### 2. **Ejemplo:**

```typescript
// TypeScript solo sabe que esto devuelve un HTMLElement gen칠rico.
const miCanvasElement = document.getElementById("mi_canvas");

// Pero nosotros SABEMOS que es un elemento <canvas>, as칤 que se lo decimos.
const miCanvas = document.getElementById("mi_canvas") as HTMLCanvasElement;

// Ahora TypeScript nos deja usar propiedades espec칤ficas de Canvas.
// miCanvas.getContext("2d"); // 춰Correcto!

// Sin la aserci칩n, esto dar칤a un error:
// miCanvasElement.getContext("2d"); // ERROR: La propiedad 'getContext' no existe en 'HTMLElement'.
```

**Explicaci칩n del ejemplo:**
`document.getElementById` no puede saber qu칠 tipo de elemento HTML encontrar치. Devuelve un tipo base `HTMLElement`. Pero nosotros, que hemos escrito el HTML, sabemos que el elemento con ID "mi_canvas" es un `<canvas>`. La aserci칩n `as HTMLCanvasElement` es nuestra forma de decirle a TypeScript: "Oye, este valor no es un `HTMLElement` cualquiera, es espec칤ficamente un `HTMLCanvasElement`. Conf칤a en m칤".

#### 3. **Desarrollo:**

**춰ADVERTENCIA DE M츼XIMA PARANOIA!**
Una aserci칩n de tipo **NO** hace ninguna conversi칩n ni comprobaci칩n en tiempo de ejecuci칩n. Es una pista que solo existe para el compilador. Si te equivocas y el elemento no es un canvas, tu c칩digo fallar치 estrepitosamente cuando intentes usar `getContext`, y TypeScript no habr치 podido protegerte porque t칰 le dijiste que no lo hiciera.

칔salas solo cuando est칠s 100% seguro de que el tipo es el que dices que es. Hay otra sintaxis, `<HTMLCanvasElement>`, pero la sintaxis `as` es preferible porque no entra en conflicto con JSX (usado en React).

游리 **Importante**: Es una herramienta de escape necesaria para interactuar con APIs que no son totalmente seguras a nivel de tipos (como el DOM). 칔sala con precauci칩n y responsabilidad.

---

## R - Literal Types: Tipos que son Valores Espec칤ficos 游리

#### 1. **Introducci칩n:**

Puedes usar valores literales (como un string o n칰mero espec칤fico) como tipos para restringir una variable a solo esos valores exactos.

#### 2. **Ejemplo:**

```typescript
let direccion: "izquierda" | "derecha" | "arriba" | "abajo";

direccion = "izquierda"; // OK
direccion = "arriba"; // OK

direccion = "diagonal"; // ERROR: El tipo '"diagonal"' no se puede asignar al tipo
// '"izquierda" | "derecha" | "arriba" | "abajo"'.

// Otro ejemplo: una funci칩n que solo puede devolver -1, 0, o 1.
function compararNumeros(a: number, b: number): -1 | 0 | 1 {
  return a === b ? 0 : a > b ? 1 : -1;
}
```

**Explicaci칩n del ejemplo:**
Hemos definido que la variable `direccion` no puede ser cualquier `string`, sino que debe ser, literalmente, uno de esos cuatro valores. Esto es mucho m치s seguro y descriptivo que usar `string`. Es la combinaci칩n de tipos literales con tipos uni칩n lo que los hace tan incre칤blemente 칰tiles.

#### 3. **Desarrollo:**

Los tipos literales surgen naturalmente cuando usas `const`. Si declaras `const miNombre = "Goku"`, TypeScript infiere que el tipo de `miNombre` no es `string`, sino el tipo literal `"Goku"`, 춰porque sabe que nunca podr치 cambiar! Usar uniones de estos tipos literales es una forma fant치stica de modelar estados, opciones o cualquier variable que solo pueda tomar un conjunto finito y conocido de valores.

游리 **Importante**: Son una alternativa excelente y m치s segura a los `enums` (que veremos m치s adelante) y al uso de strings m치gicos en tu c칩digo. Hacen que tus APIs sean auto-documentadas y mucho m치s robustas.

---

## S - Inferencia Literal y `as const`: Controlando la Magia 游리

#### 1. **Introducci칩n:**

A veces, TypeScript es demasiado "general" al inferir tipos en objetos, pero podemos guiarlo para que sea m치s espec칤fico usando `as const`.

#### 2. **Ejemplo (El Problema):**

```typescript
// Esta funci칩n espera un m칠todo HTTP muy espec칤fico.
declare function enviarPeticion(url: string, method: "GET" | "POST"): void;

const peticion = {
  url: "https://api.com/data",
  method: "GET", // TypeScript infiere el tipo de 'method' como 'string'
};

// 춰ERROR! 쯇or qu칠?
enviarPeticion(peticion.url, peticion.method);
// Argumento de tipo 'string' no se puede asignar al par치metro de tipo '"GET" | "POST"'.
```

**Explicaci칩n del Problema:**
TypeScript ve `method: "GET"` dentro de un objeto declarado con `let` o `const` y piensa: "Bueno, esto es un objeto mutable. Alguien podr칤a hacer `peticion.method = 'PUT'` m치s tarde. Para estar seguro, inferir칠 que `peticion.method` es de tipo `string`". Y un `string` gen칠rico no es compatible con el tipo m치s espec칤fico `"GET" | "POST"`.

**Las Soluciones:**

```typescript
// Soluci칩n 1: Aserci칩n de tipo en la propiedad (un poco verboso)
const peticion1 = {
  url: "https://api.com/data",
  method: "GET" as "GET",
};
enviarPeticion(peticion1.url, peticion1.method); // OK

// Soluci칩n 2: La mejor. 'as const' trata todo el objeto como inmutable y literal.
const peticion2 = {
  url: "https://api.com/data",
  method: "GET",
} as const; // 춰La magia est치 aqu칤!

enviarPeticion(peticion2.url, peticion2.method); // OK
// Ahora, TypeScript infiere que el tipo de 'peticion2.method' es el literal "GET", no 'string'.
```

#### 3. **Desarrollo:**

`as const` es una "aserci칩n const". Le dice a TypeScript: "Trata este objeto como si fuera profundamente inmutable. Todas sus propiedades deben ser `readonly` y sus valores deben ser inferidos como tipos literales, no como tipos generales (`string`, `number`)". Es una herramienta incre칤blemente poderosa y concisa para preservar la literalidad de tus objetos de configuraci칩n.

游리 **Importante**: `as const` es tu mejor aliado cuando trabajas con objetos que deben pasarse a funciones que esperan tipos literales. Es la forma moderna y preferida de resolver este problema de inferencia.

---

## T - `null` y `undefined`: Manejando la Ausencia (`strictNullChecks`) 游리

#### 1. **Introducci칩n:**

`null` y `undefined` son dos primitivos que representan la ausencia de un valor, y la opci칩n `strictNullChecks` cambia radicalmente c칩mo TypeScript los trata.

#### 2. **Desarrollo (Comparaci칩n Crucial):**

**`strictNullChecks`: OFF (Modo Peligroso, no recomendado)**

- `null` y `undefined` pueden ser asignados a cualquier tipo (`string`, `number`, etc.).
- Puedes intentar acceder a propiedades de un valor que podr칤a ser `null` sin que TypeScript se queje.
- **Resultado:** Es una fuente masiva de errores en tiempo de ejecuci칩n, el famoso `Cannot read property '...' of null`. Es el comportamiento antiguo y propenso a errores.

**`strictNullChecks`: ON (Modo Seguro, 춰SIEMPRE ACT칈VALO!)**

- `null` y `undefined` son tipos por s칤 mismos. No puedes asignarlos a una variable de tipo `string` a menos que lo declares expl칤citamente (`let nombre: string | null;`).
- Si un valor puede ser `null` o `undefined`, TypeScript te **obliga** a comprobarlo antes de usarlo.

#### 3. **Ejemplo (`strictNullChecks`: ON):**

```typescript
function saludarOpcional(nombre: string | null) {
  // Si intentamos usar 'nombre' directamente, hay un error.
  // console.log("Hola, " + nombre.toUpperCase()); // ERROR: 'nombre' es posiblemente 'null'.

  // Debemos hacer 'narrowing' para comprobar que no es null.
  if (nombre === null) {
    console.log("Hola, an칩nimo.");
  } else {
    // Dentro de este 'else', TypeScript sabe que 'nombre' ES un 'string'.
    console.log("Hola, " + nombre.toUpperCase());
  }
}

saludarOpcional("Vegeta"); // Imprime: Hola, VEGETA
saludarOpcional(null); // Imprime: Hola, an칩nimo.
```

**Explicaci칩n del ejemplo:**
Con `strictNullChecks` activado, TypeScript nos protege. Nos fuerza a manejar el caso en que `nombre` es `null`, eliminando una de las fuentes de errores m치s comunes en la historia de JavaScript.

游리 **Importante**: Activar `strictNullChecks` en tu `tsconfig.json` es, junto con `noImplicitAny`, la decisi칩n m치s importante que puedes tomar para mejorar la calidad y robustez de tu c칩digo. No es negociable en un proyecto serio.

---

## U - Operador de Aserci칩n No Nula (`!`) 游댯

#### 1. **Introducci칩n:**

El operador `!` al final de una expresi칩n es un atajo para decirle a TypeScript: "Te juro que este valor no es `null` ni `undefined` en este punto".

#### 2. **Ejemplo:**

```typescript
function obtenerKi(nombre?: string | null): number {
  // Imaginemos que esta funci칩n siempre devuelve un n칰mero si el nombre no es nulo.
  if (nombre) return 9001;
  return 0;
}

let kiDeGoku: number | null = null;

// ... algo de c칩digo despu칠s ...
kiDeGoku = obtenerKi("Goku");

// TypeScript todav칤a piensa que 'kiDeGoku' podr칤a ser 'null' (por su declaraci칩n inicial).
// Pero nosotros sabemos que despu칠s de la llamada a 'obtenerKi', ya no lo es.
// Usamos '!' para silenciar al compilador.
console.log(kiDeGoku!.toFixed(2)); // Imprime: 9001.00
```

**Explicaci칩n del ejemplo:**
`kiDeGoku!` es una aserci칩n de tipo. Es funcionalmente similar a `(kiDeGoku as number)`, pero m치s corto. Le estamos diciendo a TypeScript: "S칠 que declar칠 `kiDeGoku` como `number | null`, pero en esta l칤nea de c칩digo espec칤fica, estoy 100% seguro de que no es `null`, as칤 que d칠jame usar m칠todos de `number`".

#### 3. **Desarrollo:**

**춰OTRA ADVERTENCIA DE M츼XIMA PARANOIA!**
Al igual que `as`, el operador `!` **no hace nada en tiempo de ejecuci칩n**. No comprueba si el valor es nulo, simplemente elimina el error del compilador. Si te equivocas y el valor S칈 es `null`, tu programa se estrellar치. Es una herramienta peligrosa si se abusa de ella. 칔sala como 칰ltimo recurso, cuando est칠s absolutamente seguro y no haya una forma m치s limpia de hacer `narrowing` (como un `if`).

游댯 **Espec칤fico**: Es 칰til en ciertas situaciones, especialmente en tests o cuando trabajas con c칩digo donde la l칩gica de inicializaci칩n es compleja, pero siempre prefiere una comprobaci칩n expl칤cita (`if (valor)`) antes que una aserci칩n `!`.

---

## V - Enums: Listas de Constantes con Nombre 游댯

#### 1. **Introducci칩n:**

Los `enums` son una caracter칤stica que TypeScript a침ade a JavaScript para crear un conjunto de constantes con nombre, a menudo usadas para representar estados o categor칤as.

#### 2. **Ejemplo:**

```typescript
enum Direccion {
  Arriba, // por defecto es 0
  Abajo, // por defecto es 1
  Izquierda, // por defecto es 2
  Derecha, // por defecto es 3
}

let miMovimiento: Direccion = Direccion.Arriba;

if (miMovimiento === Direccion.Arriba) {
  console.log("Moviendo hacia arriba...");
}
```

**Explicaci칩n del ejemplo:**
Hemos creado un `enum` llamado `Direccion` que agrupa un conjunto de constantes relacionadas. Esto es m치s legible y seguro que usar n칰meros o strings "m치gicos" (como `if (movimiento === 0)`).

#### 3. **Desarrollo:**

A diferencia de la mayor칤a de las caracter칤sticas de TypeScript, los `enums` **generan c칩digo JavaScript en tiempo de ejecuci칩n**. No son solo una construcci칩n a nivel de tipos. Por esta raz칩n, y porque los tipos uni칩n de literales (`type Direccion = "Arriba" | "Abajo" ...`) pueden lograr resultados similares de una manera m치s "ligera" y compatible con JavaScript puro, hay un debate en la comunidad sobre su uso.

游댯 **Espec칤fico**: Es bueno que sepas que existen, ya que los encontrar치s en muchas bases de c칩digo. Sin embargo, para proyectos nuevos, considera si una uni칩n de tipos literales (`string` o `number`) podr칤a ser una alternativa m치s simple y moderna antes de decidirte por un `enum`.

---

## W - Primitivos Menos Comunes: `bigint` y `symbol` 游댯

#### 1. **Introducci칩n:**

Son dos tipos primitivos m치s recientes en JavaScript para casos de uso muy espec칤ficos: n칰meros extremadamente grandes y la creaci칩n de identificadores 칰nicos.

#### 2. **Ejemplo:**

```typescript
// bigint: para n칰meros m치s grandes que 2^53 - 1
const numeroGigante: bigint = BigInt(9007199254740991);
const otroNumeroGigante: bigint = 9007199254740992n; // la 'n' al final es la sintaxis literal

// symbol: para crear identificadores 칰nicos que nunca colisionan
const idUnico1 = Symbol("descripcion");
const idUnico2 = Symbol("descripcion");

// Aunque la descripci칩n sea la misma, los symbols son siempre diferentes.
if (idUnico1 === idUnico2) {
  // Esta condici칩n siempre es falsa.
  // Este c칩digo nunca se ejecutar치.
}
```

**Explicaci칩n del ejemplo:**

- `bigint` se usa cuando necesitas realizar c치lculos matem치ticos con enteros de una precisi칩n que el tipo `number` normal no puede manejar.
- `symbol` se usa a menudo para crear propiedades de objeto "privadas" o para definir claves 칰nicas que no chocar치n con otras propiedades.

#### 3. **Desarrollo:**

No te encontrar치s con estos tipos todos los d칤as, a menos que trabajes en campos muy espec칤ficos como la criptograf칤a, las finanzas de alta precisi칩n (para `bigint`) o el desarrollo de librer칤as complejas (para `symbol`).

游댯 **Espec칤fico**: No son de uso diario, pero es bueno saber que existen por si alguna vez te enfrentas a un problema que requiera sus caracter칤sticas 칰nicas. No te preocupes por dominarlos al principio.
