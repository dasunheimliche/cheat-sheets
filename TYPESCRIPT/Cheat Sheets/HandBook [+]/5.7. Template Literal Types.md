### A - Template Literal Types: Creando Tipos a partir de Texto üü°

#### 1. **Introducci√≥n:**

Imagina que tienes piezas de Lego que son textos. Los _Template Literal Types_ te permiten unir esas piezas para crear un nuevo "tipo" de texto, una nueva forma de Lego, que TypeScript entender√° y vigilar√° por ti.

#### 2. **Ejemplo:**

```typescript
// 1. Definimos una pieza de Lego de texto llamada "World"
type World = "world";

// 2. Creamos una plantilla que une "hello " con nuestra pieza "World"
type Greeting = `hello ${World}`;

// ¬øEl resultado? TypeScript entiende que 'Greeting' es EXACTAMENTE el texto "hello world"
// let miSaludo: Greeting = "hello world"; // ‚úÖ ¬°Perfecto!
// let miSaludo: Greeting = "hello mars";  // ‚ùå ¬°Error! No es el tipo "hello world"
```

**Explicaci√≥n del ejemplo:**
Es tan simple y potente como parece. Usamos las comillas invertidas (`` ` ``) igual que en JavaScript, pero en el mundo de los tipos. Dentro de `${...}` ponemos un tipo existente (`World`), y TypeScript lo reemplaza para crear un nuevo tipo literal de string (`"hello world"`).

#### 3. **Desarrollo:**

Esta es la base de todo. Es la misma idea que las "template strings" de JavaScript (`const message = \`Hello ${name}\``), pero la usamos para definir **qu√© forma puede tener un tipo**, no para crear un valor. Esto nos da un poder incre√≠ble para describir patrones de texto que nuestro c√≥digo debe seguir.

üü° **Importante**: Aunque este ejemplo es simple, es el pilar de todo lo que sigue. Entender que estamos _definiendo un molde_ (un tipo) y no _creando un valor_ es la clave. ¬°No lo olvides!

---

### B - Combinando Uniones: La F√°brica de Tipos de Texto üü°

#### 1. **Introducci√≥n:**

Aqu√≠ es donde la cosa se pone emocionante. ¬øQu√© pasa si la pieza de Lego que metes en la plantilla no es una sola forma, sino una caja con _varias_ formas posibles (un tipo `union`)? ¬°Pues que TypeScript crea todas las combinaciones posibles para ti!

#### 2. **Ejemplo:**

```typescript
// 1. Una "caja" con posibles identificadores para correos
type EmailLocaleIDs = "welcome_email" | "email_heading";

// 2. Una "caja" con posibles identificadores para el pie de p√°gina
type FooterLocaleIDs = "footer_title" | "footer_sendoff";

// 3. ¬°La magia! Creamos un nuevo tipo que combina CUALQUIERA de las cajas anteriores
//    con el sufijo "_id".
type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;

/*
TypeScript calcula esto por nosotros y el resultado es:
type AllLocaleIDs = "welcome_email_id" | 
                    "email_heading_id" | 
                    "footer_title_id" | 
                    "footer_sendoff_id";
*/
```

**Explicaci√≥n del ejemplo:**
Unimos dos uniones (`EmailLocaleIDs` y `FooterLocaleIDs`) en una sola. Luego, la plantilla `${...}_id` toma _cada uno_ de los elementos de esa uni√≥n combinada y le pega `_id` al final. Es como una mini f√°brica de tipos de texto.

#### 3. **Desarrollo:**

Esto es una locura de √∫til. En lugar de escribir a mano una lista largu√≠sima de posibles valores, defines los componentes y dejas que TypeScript construya el resultado. Esto hace tu c√≥digo m√°s f√°cil de mantener: si ma√±ana a√±ades un nuevo `ID` a `EmailLocaleIDs`, el tipo `AllLocaleIDs` se actualizar√° autom√°ticamente. ¬°Cero esfuerzo, m√°xima seguridad!

üü° **Importante**: Esta "expansi√≥n" de uniones es la caracter√≠stica m√°s poderosa de los Template Literals. Te permite crear sistemas de tipos muy expresivos y din√°micos a partir de piezas m√°s peque√±as.

---

### C - Multiplicaci√≥n Cruzada: Creando TODAS las Combinaciones Posibles üü°

#### 1. **Introducci√≥n:**

Si el concepto anterior era una f√°brica, esto es una l√≠nea de ensamblaje completa. Si pones _m√∫ltiples_ uniones en la misma plantilla, TypeScript las "multiplica", creando una combinaci√≥n de cada elemento de la primera con cada elemento de todas las dem√°s.

#### 2. **Ejemplo:**

```typescript
// 1. Nuestros idiomas posibles
type Lang = "en" | "ja" | "pt";

// 2. Nuestros IDs de mensaje (del ejemplo anterior)
type AllLocaleIDs = "welcome_email_id" | "email_heading_id"; // Usemos una versi√≥n corta

// 3. ¬°La multiplicaci√≥n! Cada idioma se combinar√° con cada ID.
type LocaleMessageIDs = `${Lang}_${AllLocaleIDs}`;

/*
TypeScript genera esta monstruosidad (¬°en el buen sentido!) por nosotros:
type LocaleMessageIDs = "en_welcome_email_id" | "en_email_heading_id" |
                        "ja_welcome_email_id" | "ja_email_heading_id" |
                        "pt_welcome_email_id" | "pt_email_heading_id";
*/
```

**Explicaci√≥n del ejemplo:**
Observa el patr√≥n:

- Toma el primero de `Lang` (`"en"`) y lo combina con todos los de `AllLocaleIDs`.
- Toma el segundo de `Lang` (`"ja"`) y lo combina con todos los de `AllLocaleIDs`.
- Y as√≠ sucesivamente.

Es una multiplicaci√≥n cartesiana: `(tama√±o de Lang) x (tama√±o de AllLocaleIDs)` = n√∫mero total de tipos generados.

#### 3. **Desarrollo:**

Esto es incre√≠blemente poderoso, pero ¬°cuidado! Como puedes ver, la cantidad de posibles strings puede crecer exponencialmente. Para uniones peque√±as es una maravilla, pero si tienes uniones muy grandes, podr√≠as hacer que TypeScript trabaje demasiado y ralentizar tu editor. √ösalo con sabidur√≠a.

üü° **Importante**: La multiplicaci√≥n cruzada es la culminaci√≥n de los conceptos anteriores. Te permite definir sistemas de claves, rutas o eventos muy complejos de forma declarativa y segura.

---

### D - Caso Pr√°ctico (1/2): Nombres de Eventos a Prueba de Errores üîµ

#### 1. **Introducci√≥n:**

Vale, basta de teor√≠a. Vamos a construir algo real. Crearemos una funci√≥n que "observa" un objeto y nos permite reaccionar a cambios en sus propiedades. Queremos que TypeScript nos grite si intentamos escuchar un evento que no existe.

#### 2. **Ejemplo:**

```typescript
// Este es el tipo que define c√≥mo funcionar√° nuestro sistema de eventos.
// ¬°Presta atenci√≥n a `eventName`!
type PropEventSource<Type> = {
  on(
    eventName: `${string & keyof Type}Changed`,
    callback: (newValue: any) => void
  ): void;
};

// Una funci√≥n imaginaria que toma un objeto y le a√±ade el m√©todo `on`.
declare function makeWatchedObject<Type>(
  obj: Type
): Type & PropEventSource<Type>;

// --- ¬°A usarlo! ---
const person = makeWatchedObject({
  firstName: "Saoirse",
  lastName: "Ronan",
  age: 26,
});

person.on("firstNameChanged", () => {}); // ‚úÖ ¬°Perfecto! El evento existe.
person.on("ageChanged", () => {}); // ‚úÖ ¬°Genial! Tambi√©n existe.

// ¬°Ahora mira c√≥mo TypeScript nos protege!
person.on("firstName", () => {}); // ‚ùå ERROR: Falta "Changed" al final.
person.on("frstNameChanged", () => {}); // ‚ùå ERROR: ¬°Typo! "frstName" no es una propiedad.
```

**Explicaci√≥n del ejemplo:**
La magia est√° aqu√≠: `eventName: \`${string & keyof Type}Changed\``. Vamos a desglosarlo como si fuera un conjuro:

1.  `keyof Type`: Esto significa "dame una uni√≥n con los nombres de todas las propiedades del objeto `Type`". Para nuestro `person`, `keyof Type` es `"firstName" | "lastName" | "age"`.
2.  `string & ...`: Esto es una peque√±a salvaguarda. `keyof` tambi√©n puede devolver n√∫meros o s√≠mbolos si las claves son de ese tipo. Con `string &`, nos aseguramos de quedarnos solo con las claves que son texto, que es lo que las plantillas necesitan.
3.  `${...}Changed`: Ahora, a cada una de esas claves de texto (`"firstName"`, `"lastName"`, `"age"`), le pegamos la palabra `"Changed"` al final.

El resultado es que `eventName` solo puede ser uno de estos valores: `"firstNameChanged" | "lastNameChanged" | "ageChanged"`. ¬°Cualquier otra cosa dar√° un error!

#### 3. **Desarrollo:**

Acabamos de eliminar toda una categor√≠a de errores. Ya no es posible cometer un error de tipeo en el nombre de un evento o intentar escuchar un evento que no corresponde a una propiedad real. TypeScript se convierte en nuestro guardi√°n, d√°ndonos autocompletado y validaci√≥n antes de que el c√≥digo se ejecute.

üîµ **Espec√≠fico**: Este patr√≥n es un poco m√°s avanzado, pero es un ejemplo perfecto del poder de los tipos para crear APIs (interfaces de programaci√≥n) m√°s seguras y f√°ciles de usar. Es algo que ver√°s mucho en librer√≠as y frameworks modernos.

---

### E - Caso Pr√°ctico (2/2): Inferencia M√°gica para Callbacks üîµ

#### 1. **Introducci√≥n:**

En el paso anterior, nuestro `callback` aceptaba un `newValue: any`. Eso no es muy seguro. ¬øNo ser√≠a genial si TypeScript supiera que para `"firstNameChanged"`, el `newValue` debe ser un `string`, y para `"ageChanged"`, debe ser un `number`? ¬°Pues claro que s√≠!

#### 2. **Ejemplo:**

```typescript
// La versi√≥n MEJORADA de nuestro tipo de eventos.
type PropEventSource<Type> = {
  // ¬°Ahora 'on' es un m√©todo gen√©rico!
  on<Key extends string & keyof Type>(
    eventName: `${Key}Changed`,
    callback: (newValue: Type[Key]) => void
  ): void;
};

declare function makeWatchedObject<Type>(
  obj: Type
): Type & PropEventSource<Type>;

// --- ¬°A usarlo de nuevo! ---
const person = makeWatchedObject({
  firstName: "Saoirse",
  lastName: "Ronan",
  age: 26,
});

// F√≠jate en el tipo de 'newName'. ¬°TypeScript lo sabe!
person.on("firstNameChanged", (newName) => {
  // (parameter) newName: string
  console.log(newName.toUpperCase()); // ‚úÖ Funciona, porque es un string.
});

// Y aqu√≠ tambi√©n sabe el tipo de 'newAge'.
person.on("ageChanged", (newAge) => {
  // (parameter) newAge: number
  if (newAge < 0) {
    // ‚úÖ Funciona, porque es un number.
    console.warn("¬°Edad negativa!");
  }
});
```

**Explicaci√≥n del ejemplo:**
El conjuro ha subido de nivel. Analicemos las dos mejoras clave en el m√©todo `on`:

1.  `<Key extends string & keyof Type>`: Hemos hecho a `on` un m√©todo _gen√©rico_. `Key` es como una variable para un tipo. Cuando llamas a `on("firstNameChanged", ...)` TypeScript es s√∫per listo y dice: "Ah, el patr√≥n es `${Key}Changed`, as√≠ que si me das 'firstNameChanged', entonces `Key` debe ser `'firstName'`". ¬°Infiere la parte del nombre de la propiedad!
2.  `callback: (newValue: Type[Key]) => void`: ¬°Esta es la recompensa! `Type[Key]` se llama "Indexed Access Type". Es como hacer `objeto['propiedad']` pero en el mundo de los tipos.
    - Si `Key` fue inferido como `"firstName"`, `Type[Key]` se convierte en `Type["firstName"]`, que es `string`.
    - Si `Key` fue inferido como `"age"`, `Type[Key]` se convierte en `Type["age"]`, que es `number`.

#### 3. **Desarrollo:**

Esto es brujer√≠a de tipos en su m√°xima expresi√≥n. Hemos creado una conexi√≥n irrompible entre el nombre del evento y el tipo de dato que maneja su callback. El nivel de seguridad y la experiencia de desarrollo (¬°hola, autocompletado perfecto!) que esto proporciona es inmenso. No solo sabes que el evento es correcto, sino que tambi√©n sabes exactamente qu√© tipo de datos vas a recibir, sin dudarlo.

üîµ **Espec√≠fico**: Este es un patr√≥n avanzado, pero entenderlo te abre las puertas a un nuevo nivel de maestr√≠a en TypeScript. Demuestra c√≥mo los gen√©ricos y los tipos literales pueden trabajar juntos para crear APIs casi m√°gicas.

---

### F - Utilidades de Texto Integradas üîµ

#### 1. **Introducci√≥n:**

Para ayudarte a manipular estos tipos de string, TypeScript incluye un peque√±o kit de herramientas integrado. Son como "funciones" que operan sobre tipos de string para transformarlos. No tienes que importarlas ni nada, simplemente existen.

#### 2. **Ejemplo General:**

```typescript
// Pone en may√∫scula la primera letra de un nombre de propiedad para crear un getter.
type Getter<T extends string> = `get${Capitalize<T>}`;
type NameGetter = Getter<"name">; // El tipo resultante es "getName"

// Pone en min√∫scula una ruta para normalizarla.
type Route<T extends string> = `/${Lowercase<T>}`;
type AdminRoute = Route<"ADMIN_PANEL">; // El tipo resultante es "/admin_panel"
```

**Explicaci√≥n del ejemplo:**
Como puedes ver, estas utilidades (`Capitalize`, `Lowercase`, etc.) se pueden anidar perfectamente dentro de los Template Literals para construir tipos a√∫n m√°s sofisticados.

#### 3. **Desarrollo:**

Aqu√≠ tienes el cat√°logo completo. Son muy directas, pero es bueno saber que existen para cuando las necesites.

- `Uppercase<StringType>`: Convierte **TODO** el texto a MAY√öSCULAS.
  ```typescript
  type Saludo = "Hello";
  type GRITO = Uppercase<Saludo>; // "HELLO"
  ```
- `Lowercase<StringType>`: Convierte **todo** el texto a min√∫sculas.
  ```typescript
  type Titulo = "TITANIC";
  type susurro = Lowercase<Titulo>; // "titanic"
  ```
- `Capitalize<StringType>`: Convierte **solo la primera letra** a may√∫scula.
  ```typescript
  type nombre = "pedro";
  type NombrePropio = Capitalize<nombre>; // "Pedro"
  ```
- `Uncapitalize<StringType>`: Convierte **solo la primera letra** a min√∫scula.
  ```typescript
  type Constante = "API_KEY";
  type variable = Uncapitalize<Constante>; // "aPI_KEY"
  ```

üîµ **Espec√≠fico**: No las usar√°s todos los d√≠as, pero son incre√≠blemente √∫tiles para tareas como generar nombres de getters/setters, normalizar claves de API, o cualquier situaci√≥n donde necesites aplicar una convenci√≥n de nombrado de forma consistente y autom√°tica a nivel de tipos.
