## A - Mapped Types: Tu Propia F√°brica de Tipos a Medida üî¥

#### 1. **Introducci√≥n:**

Imagina que puedes tomar la "forma" de un objeto (un tipo) y crear una nueva forma modificada, autom√°ticamente, sin tener que copiar y pegar cada propiedad a mano.

#### 2. **Ejemplo:**

Primero, un peque√±o calentamiento. ¬øRecuerdas las **firmas de √≠ndice**? Son una forma de decir "este objeto puede tener cualquier propiedad, siempre que su valor sea de este tipo":

```typescript
// Este tipo dice: "Acepto cualquier propiedad (key: string),
// siempre que su valor sea un booleano o un tipo 'Horse'".
type OnlyBoolsAndHorses = {
  [key: string]: boolean | Horse;
};
```

Ahora, el plato principal. Un **Mapped Type** usa una sintaxis parecida para construir un nuevo tipo a partir de las propiedades de otro.

```typescript
// 1. Creamos un tipo con algunas propiedades.
type Features = {
  darkMode: () => void; // Una funci√≥n para el modo oscuro
  newUserProfile: () => void; // Una funci√≥n para el perfil de usuario
};

// 2. Creamos un "molde" gen√©rico llamado OptionsFlags.
//    Este molde tomar√° cualquier tipo (`Type`) y...
type OptionsFlags<Type> = {
  // ...recorrer√° cada una de sus propiedades (`Property in keyof Type`)...
  // ...y convertir√° el tipo de esa propiedad en `boolean`.
  [Property in keyof Type]: boolean;
};

// 3. ¬°Usamos el molde!
type FeatureOptions = OptionsFlags<Features>;

/*
El resultado m√°gico es este nuevo tipo, generado autom√°ticamente:
type FeatureOptions = {
    darkMode: boolean;
    newUserProfile: boolean;
}
*/
```

**Explicaci√≥n del ejemplo:**
Hemos creado un tipo "plantilla" llamado `OptionsFlags`. Cuando le pasamos nuestro tipo `Features`, este recorre cada una de sus claves (`darkMode` y `newUserProfile`) y crea un nuevo tipo donde esas mismas claves ahora tienen un valor de tipo `boolean`. ¬°Es como una cadena de montaje para tus tipos!

#### 3. **Desarrollo**:

La magia reside en la expresi√≥n `[Property in keyof Type]`. Vamos a desglosarla para que no quede ni una sombra de duda:

- `keyof Type`: Este operador es como un detective. Investiga el tipo `Type` y te devuelve una uni√≥n de todas sus claves en formato de texto (string literals). Para nuestro `Features`, `keyof Features` ser√≠a `'darkMode' | 'newUserProfile'`.
- `Property in ...`: Esto es como un bucle `for...in` de JavaScript, pero para tipos. Itera sobre cada una de las claves que `keyof` nos devolvi√≥. En cada "vuelta", `Property` ser√° una de las claves (primero `'darkMode'`, luego `'newUserProfile'`).
- `: boolean`: Esta es la transformaci√≥n. Para cada propiedad que recorremos, le asignamos el nuevo tipo que queramos. En este caso, un simple `boolean`.

Esto te ahorra una cantidad de tiempo y errores incre√≠ble. Si ma√±ana a√±ades `betaTester: () => void;` a `Features`, el tipo `FeatureOptions` se actualizar√° solo, ¬°autom√°gicamente!

üî¥ **Fundamental**: Entender los Mapped Types es crucial. Es el pilar para escribir c√≥digo TypeScript avanzado, reutilizable y robusto, permiti√©ndote mantener tus tipos sincronizados sin esfuerzo (principio DRY - Don't Repeat Yourself).

---

## B - Modificadores de Mapeo (`+/-`): Poniendo y Quitando "Pegatinas" a tus Propiedades üü°

#### 1. **Introducci√≥n:**

Puedes usar los prefijos `+` o `-` durante el mapeo para a√±adir o quitar modificadores como `readonly` (solo lectura) y `?` (opcional) de las propiedades de un tipo.

#### 2. **Ejemplo:**

Piensa en `readonly` y `?` como "pegatinas" que tienen las propiedades. Con los modificadores de mapeo, podemos fabricar un nuevo tipo quitando o poniendo estas pegatinas.

**Quitando la pegatina `readonly`:**

```typescript
// Un tipo donde no puedes cambiar `id` ni `name`.
type LockedAccount = {
  readonly id: string;
  readonly name: string;
};

// Un molde que QUITA (-readonly) la pegatina de "solo lectura".
type CreateMutable<Type> = {
  -readonly [Property in keyof Type]: Type[Property];
};

// ¬°Aplicamos el molde!
type UnlockedAccount = CreateMutable<LockedAccount>;

/*
El resultado es un tipo donde S√ç puedes cambiar las propiedades:
type UnlockedAccount = {
    id: string;
    name: string;
}
*/
```

**Quitando la pegatina `?` (opcional):**

```typescript
// Un tipo donde `name` y `age` podr√≠an no existir.
type MaybeUser = {
  id: string;
  name?: string;
  age?: number;
};

// Un molde que QUITA (-?) la pegatina de "opcional", haci√©ndolas requeridas.
type Concrete<Type> = {
  [Property in keyof Type]-?: Type[Property];
};

// ¬°Aplicamos el molde!
type User = Concrete<MaybeUser>;

/*
El resultado es un tipo donde TODAS las propiedades son obligatorias:
type User = {
    id: string;
    name: string;
    age: number;
}
*/
```

**Explicaci√≥n del ejemplo:**
En el primer caso, `-readonly` le dice a TypeScript: "Oye, para cada propiedad que encuentres, si tiene el modificador `readonly`, qu√≠taselo". En el segundo, `-?` hace lo mismo para el modificador opcional `?`.

#### 3. **Desarrollo**:

La regla es s√∫per simple y te la tienes que grabar a fuego:

- **`-` (guion/resta):** Sirve para **quitar** un modificador. `-readonly` quita `readonly`. `-?` quita `?` (hace la propiedad requerida).
- **`+` (m√°s/suma):** Sirve para **a√±adir** un modificador. `+readonly` a√±ade `readonly`. `+?` a√±ade `?` (hace la propiedad opcional).

**¬°Un momento! ¬øY si no pongo ni `+` ni `-`?**
¬°Excelente pregunta! Me encanta que pienses as√≠. Si no pones ning√∫n prefijo, TypeScript asume que quer√≠as poner `+`. Es decir, `readonly` es lo mismo que `+readonly`. Por eso en los ejemplos anteriores no ves un `+` por ning√∫n lado, ¬°porque es el comportamiento por defecto!

üü° **Importante**: Esta t√©cnica es pan de cada d√≠a cuando trabajas con APIs o estados que tienen diferentes "versiones" de un mismo objeto. Por ejemplo, cuando recibes datos de un formulario (donde todo puede ser opcional) y quieres convertirlos a un tipo estricto para guardarlos en la base de datos.

---

## C - Remapeo de Claves con `as`: Renombrando Propiedades Sobre la Marcha üîµ

#### 1. **Introducci√≥n:**

Desde TypeScript 4.1, no solo puedes cambiar el _tipo_ del valor de una propiedad, sino que tambi√©n puedes cambiar el _nombre_ de la clave misma usando la palabra m√°gica `as`.

#### 2. **Ejemplo:**

Vamos a crear un tipo que transforma las propiedades de un objeto en funciones "getter" (funciones que obtienen un valor).

```typescript
// Nuestro objeto base.
interface Person {
  name: string;
  age: number;
  location: string;
}

// Nuestro molde transformador.
type Getters<Type> = {
  // Para cada propiedad...
  // ...ren√≥mbrala (`as`) para que empiece con "get" y la primera letra en may√∫scula.
  [Property in keyof Type as `get${Capitalize<
    string & Property
  >}`]: () => Type[Property];
};

// ¬°A transformar!
type LazyPerson = Getters<Person>;

/*
El incre√≠ble resultado:
type LazyPerson = {
    getName: () => string;
    getAge: () => number;
    getLocation: () => string;
}
*/
```

**Explicaci√≥n del ejemplo:**
La clave est√° en la cl√°usula `as`. Le dice a TypeScript: "Ok, est√°s recorriendo las propiedades (`name`, `age`, `location`), pero no uses ese nombre para la nueva clave. En su lugar (`as`), usa este nuevo nombre que te estoy construyendo". Aqu√≠ usamos _template literal types_ (`` `get${...}` ``) para construir din√°micamente los nuevos nombres: `getName`, `getAge`, etc.

#### 3. **Desarrollo**:

La sintaxis general es: `[OriginalKey in keyof Type as NewKeyType]: ValueType`.

- `OriginalKey in keyof Type`: El bucle de siempre, que recorre las claves originales.
- `as NewKeyType`: ¬°La novedad! Aqu√≠ es donde defines c√≥mo se llamar√° la nueva clave. Puedes usar template literals, tipos condicionales, o lo que necesites para generar el nuevo nombre.
- `: ValueType`: El tipo del valor para la nueva clave, que puede depender de la propiedad original (`Type[Property]`).

**¬øY ese `string & Property` tan raro?**
¬°Ojo de √°guila! Te explico. `Capitalize` es una utilidad de TypeScript que solo funciona con `string`. Pero `Property` (que viene de `keyof Type`) puede ser `string | number | symbol`. Para asegurarle a TypeScript que en este contexto `Property` se comportar√° como un `string`, usamos una intersecci√≥n (`& string`). Es un peque√±o truco para satisfacer al compilador y que nos deje en paz. ¬°No te preocupes demasiado por ello, solo recuerda que a veces es necesario!

üîµ **Espec√≠fico**: El remapeo de claves es una herramienta avanzada pero incre√≠blemente poderosa. Es perfecta para crear APIs m√°s descriptivas, adaptar datos entre diferentes partes de tu aplicaci√≥n (por ejemplo, del backend al frontend) o construir utilidades de tipos muy sofisticadas.

---

## D - Remapeo con `as`: Filtrando Claves con `never` üîµ

#### 1. **Introducci√≥n:**

Puedes usar el remapeo con `as` no solo para renombrar, sino tambi√©n para **eliminar** propiedades de un tipo, devolviendo el tipo especial `never` para las claves que no quieres.

#### 2. **Ejemplo:**

Imagina que tienes un tipo y quieres crear una versi√≥n nueva sin una propiedad espec√≠fica, como la propiedad `"kind"`.

```typescript
// Un tipo que tiene una propiedad "kind" que queremos eliminar.
interface Circle {
  kind: "circle";
  radius: number;
}

// Un molde que filtra propiedades.
type RemoveKindField<Type> = {
  // Recorre cada propiedad, pero...
  // ...ren√≥mbrala usando una condici√≥n:
  // Si la propiedad es "kind", la excluimos. Si no, la mantenemos.
  [Property in keyof Type as Exclude<Property, "kind">]: Type[Property];
};

// ¬°Filtramos!
type KindlessCircle = RemoveKindField<Circle>;

/*
El resultado, un c√≠rculo sin "kind":
type KindlessCircle = {
    radius: number;
}
*/
```

**Explicaci√≥n del ejemplo:**
Aqu√≠, `Exclude<Property, "kind">` es el mago. `Exclude` es un tipo de utilidad que toma una uni√≥n (`Property`) y le quita los miembros que especifiques (en este caso, `"kind"`). Cuando `Property` es `"kind"`, `Exclude<"kind", "kind">` da como resultado `never`. Y aqu√≠ est√° el truco: **cuando TypeScript ve `as never` en un remapeo, simplemente omite esa propiedad por completo.** ¬°La elimina del tipo final!

#### 3. **Desarrollo**:

Esta es una forma m√°s declarativa y a menudo m√°s legible de lograr lo que antes se hac√≠a con tipos condicionales m√°s complejos. La idea central es: si quieres mantener una clave, la cl√°usula `as` debe devolver su nombre (o uno nuevo). Si quieres **eliminarla**, la cl√°usula `as` debe devolver `never`.

Esto se puede hacer con `Exclude` como en el ejemplo, o con un tipo condicional directamente:

```typescript
type RemoveKindField_Alternative<Type> = {
  [Property in keyof Type as Property extends "kind"
    ? never
    : Property]: Type[Property];
};
// Esto hace EXACTAMENTE lo mismo. Dice: "Si la propiedad es 'kind',
// el nuevo nombre es 'never' (elim√≠nala). Si no, el nuevo nombre es el mismo de antes".
```

üîµ **Espec√≠fico**: Filtrar claves es muy √∫til para limpiar tipos, crear versiones "p√∫blicas" de tipos internos que no exponen ciertos campos, o adaptar objetos para funciones que solo esperan un subconjunto de propiedades.

---

## E - Mapeo sobre Uniones: M√°s All√° de `keyof` üîµ

#### 1. **Introducci√≥n:**

Los Mapped Types no solo pueden iterar sobre claves (`string | number | symbol`), sino que tambi√©n pueden iterar directamente sobre una **uni√≥n de tipos de objetos** para crear un nuevo tipo de objeto.

#### 2. **Ejemplo:**

Imagina que tienes varios tipos de eventos, y quieres crear un objeto de configuraci√≥n donde cada clave es el _tipo_ de evento y el valor es una funci√≥n que maneja ese evento espec√≠fico.

```typescript
// 1. Definimos nuestros tipos de eventos. Cada uno tiene una propiedad "kind".
type SquareEvent = { kind: "square"; x: number; y: number };
type CircleEvent = { kind: "circle"; radius: number };

// 2. Creamos una uni√≥n de todos los posibles eventos.
type AllEvents = SquareEvent | CircleEvent;

// 3. El molde m√°gico que itera sobre la UNI√ìN de eventos.
type EventConfig<Events extends { kind: string }> = {
  // Para cada Evento (E) en la uni√≥n de Eventos (Events)...
  // ...la nueva clave ser√° el valor de la propiedad "kind" de ese evento (E["kind"])...
  [E in Events as E["kind"]]: (event: E) => void;
};

// 4. ¬°Creamos la configuraci√≥n!
type Config = EventConfig<AllEvents>;

/*
El resultado es un objeto perfectamente tipado para manejar cada evento:
type Config = {
    square: (event: SquareEvent) => void;
    circle: (event: CircleEvent) => void;
}
*/
```

**Explicaci√≥n del ejemplo:**
¬°Presta mucha atenci√≥n aqu√≠, que esto es oro puro!

- `E in Events`: Esto no itera sobre claves. Itera sobre los **tipos** que componen la uni√≥n `Events`. En la primera vuelta, `E` es el tipo `SquareEvent`. En la segunda, `E` es el tipo `CircleEvent`.
- `as E["kind"]`: Para la nueva clave, no usamos el tipo `E` directamente. Accedemos a su propiedad `kind`. Cuando `E` es `SquareEvent`, `E["kind"]` es `"square"`. Cuando `E` es `CircleEvent`, `E["kind"]` es `"circle"`. ¬°As√≠ obtenemos nuestras claves!
- `: (event: E) => void`: Para el valor, definimos una funci√≥n. Y lo m√°s importante, el par√°metro `event` est√° tipado con `E`, el tipo actual de la iteraci√≥n. Esto garantiza que al manejador del evento `square` solo le puedas pasar un `SquareEvent`, y al de `circle`, solo un `CircleEvent`. ¬°Seguridad de tipos al m√°ximo nivel!

#### 3. **Desarrollo**:

Este patr√≥n se conoce como **uniones discriminadas** y es una de las caracter√≠sticas m√°s potentes de TypeScript. Usas una propiedad com√∫n (como `kind`) para diferenciar entre los tipos de una uni√≥n. Los Mapped Types te permiten transformar esa uni√≥n en una estructura de datos muy √∫til, como un mapa de manejadores de eventos, asegurando que nunca confundir√°s un tipo de evento con otro.

üîµ **Espec√≠fico**: Aunque es un patr√≥n avanzado, una vez que lo entiendes, lo usar√°s constantemente para manejar estados, eventos, acciones en Redux, o cualquier situaci√≥n donde una variable puede ser una de varias cosas bien definidas.

---

## F - Mapeo con Esteroides: Combinando con Tipos Condicionales üü°

#### 1. **Introducci√≥n:**

Los Mapped Types se vuelven a√∫n m√°s expresivos cuando los combinas con otras herramientas de TypeScript, como los **tipos condicionales**, para cambiar el tipo del valor bas√°ndote en una condici√≥n.

#### 2. **Ejemplo:**

Imagina que queremos analizar un tipo que representa campos de una base de datos y generar un nuevo tipo que nos diga (`true`/`false`) qu√© campos contienen Informaci√≥n Personalmente Identificable (PII) y necesitan ser tratados con cuidado (como exige el GDPR).

```typescript
// Nuestro tipo que describe los campos de la base de datos.
// F√≠jate que 'name' tiene una propiedad `pii: true`.
type DBFields = {
  id: { format: "incrementing" };
  name: { type: string; pii: true };
};

// Nuestro molde analizador.
type ExtractPII<Type> = {
  // Para cada propiedad...
  [Property in keyof Type]: // ...hacemos una pregunta sobre el tipo de su valor (Type[Property]):
  // ¬øEl tipo del valor tiene una propiedad `pii` que es literalmente `true`?
  Type[Property] extends { pii: true }
    ? true // Si s√≠, el nuevo tipo es `true`.
    : false; // Si no, el nuevo tipo es `false`.
};

// ¬°Analizamos!
type ObjectsNeedingGDPRDeletion = ExtractPII<DBFields>;

/*
El resultado es un mapa de riesgos de privacidad:
type ObjectsNeedingGDPRDeletion = {
    id: false;
    name: true;
}
*/
```

**Explicaci√≥n del ejemplo:**
Aqu√≠ no estamos cambiando los nombres de las claves. Estamos cambiando el tipo de los **valores**. Para cada propiedad (`id`, `name`), miramos su tipo (`Type[Property]`). Luego, el tipo condicional (`... extends ... ? ... : ...`) act√∫a como un `if/else` para tipos.

- Para `id`, su tipo es `{ format: "incrementing" }`. ¬øEste tipo `extends { pii: true }`? No. Entonces el resultado es `false`.
- Para `name`, su tipo es `{ type: string; pii: true }`. ¬øEste tipo `extends { pii: true }`? ¬°S√≠! Entonces el resultado es `true`.

#### 3. **Desarrollo**:

Esta combinaci√≥n es la cima de la manipulaci√≥n de tipos. Te permite crear transformaciones incre√≠blemente detalladas y espec√≠ficas. No est√°s limitado a cambiar todas las propiedades al mismo tipo; puedes decidir el nuevo tipo para cada propiedad individualmente bas√°ndote en sus caracter√≠sticas.

La sintaxis `CheckType extends OtherType ? TrueType : FalseType` es tu navaja suiza. La usar√°s dentro de Mapped Types, por s√≠ sola, en todas partes. Entender c√≥mo se complementan te da un superpoder para modelar casi cualquier estructura de datos que puedas imaginar.

üü° **Importante**: Combinar Mapped Types con Conditional Types es una habilidad esencial para el desarrollador de TypeScript intermedio/avanzado. Te permite crear abstracciones seguras y tipos de utilidad que hacen tu c√≥digo m√°s robusto y f√°cil de mantener.
