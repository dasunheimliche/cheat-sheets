## A - Expresiones de Tipo de Función: La "Etiqueta de Ingredientes" para tus Funciones 🟡

#### 1. **Introducción:**

Esta es la forma más directa y común de decirle a TypeScript: "Oye, esta variable o este parámetro espera una función con esta forma específica".

#### 2. **Ejemplo:**

```typescript
// Esta función 'greeter' necesita OTRA función como argumento.
// La etiqueta (fn: (a: string) => void) describe cómo debe ser esa función.
function greeter(fn: (a: string) => void) {
  // Como le prometimos a TypeScript que 'fn' recibe un string,
  // podemos llamarla con "Hello, World" sin problemas.
  fn("Hello, World");
}

// Esta función 'printToConsole' coincide perfectamente con la etiqueta:
// Recibe un string (s: string) y no devuelve nada (void).
function printToConsole(s: string) {
  console.log(s);
}

// ¡Funciona! Le pasamos una función que cumple con el contrato.
greeter(printToConsole);
```

**Explicación del ejemplo:**
Piensa en `(a: string) => void` como una etiqueta de ingredientes para una receta. Le dice a la función `greeter` que cualquier función que le pases (`fn`) **debe** aceptar un ingrediente (`a`) que sea un `string` y que al final no te devolverá nada (`void`), solo hará su trabajo (como imprimir en la consola). `printToConsole` cumple esa receta al pie de la letra, por eso TypeScript nos da luz verde.

#### 3. **Desarrollo:**

La sintaxis `(parámetros) => tipoDeRetorno` es tu pan de cada día para describir funciones. Es visualmente idéntica a una _arrow function_, lo que la hace muy intuitiva.

**¡CUIDADO, TRAMPA MORTAL!** El nombre del parámetro en la definición del tipo es **OBLIGATORIO** y súper importante.

- `(a: string) => void` significa: "una función con un parámetro llamado `a` que es de tipo `string`".
- `(string) => void` significa: "una función con un parámetro llamado `string` que es de tipo... `any`". ¡Sí, `any`! Un descuido aquí y pierdes toda la seguridad que TypeScript te da.

Para no repetir estas "etiquetas" por todos lados, puedes darles un nombre con un alias de tipo (`type`):

```typescript
// Creamos un nombre reutilizable para nuestro tipo de función.
type GreetFunction = (a: string) => void;

// Ahora el código es más limpio y fácil de leer.
function greeter(fn: GreetFunction) {
  fn("¡Hola de nuevo!");
}
```

🟡 **Importante**: Usarás esto constantemente. Es la base para trabajar con funciones de orden superior (funciones que reciben otras funciones), como en callbacks, frameworks de UI (React, Vue), etc. Dominar esto es crucial.

---

## B - Firmas de Llamada (Call Signatures): Funciones con "Mochila" 🔵

#### 1. **Introducción:**

Esto es para cuando necesitas describir algo que no solo es una función, sino que también tiene sus propias propiedades, como un objeto.

#### 2. **Ejemplo:**

```typescript
// Definimos un tipo para una función que tiene una propiedad 'description'.
type DescribableFunction = {
  description: string; // La propiedad (la "mochila")
  (someArg: number): boolean; // La firma de llamada (lo que hace la función)
};

function doSomething(fn: DescribableFunction) {
  console.log(fn.description + " returned " + fn(6));
}

function myFunc(someArg: number) {
  return someArg > 3;
}
// Le añadimos la propiedad 'description' para que cumpla el contrato.
myFunc.description = "default description";

doSomething(myFunc); // Funciona porque myFunc ahora tiene forma de DescribableFunction.
// Salida: "default description returned true"
```

**Explicación del ejemplo:**
Imagina una persona que puede cantar (es "callable") pero que también lleva una mochila con cosas (`description`). `DescribableFunction` describe exactamente eso. `myFunc` es nuestra persona. Por sí sola, solo sabe cantar (`return someArg > 3`). Pero si le colgamos la mochila (`myFunc.description = ...`), entonces ya cumple con todo lo que `doSomething` esperaba.

#### 3. **Desarrollo:**

La diferencia clave en la sintaxis con la expresión de tipo de función es sutil pero vital: aquí usamos dos puntos (`:`) entre los parámetros y el tipo de retorno, en lugar de la flecha (`=>`).

- **Expresión de tipo de función**: `(arg: Type) => ReturnType`
- **Firma de llamada**: `(arg: Type): ReturnType`

Esta sintaxis solo puede usarse dentro de un tipo de objeto (`type` o `interface`). Es la única manera de decirle a TypeScript: "Esto es un objeto, pero también puedes invocarlo como una función".

🔵 **Específico**: No lo usarás todos los días, pero es súper útil para describir APIs o librerías que exponen funciones con propiedades estáticas. Un ejemplo del mundo real podría ser una función de una librería que, además de hacer su trabajo, expone una propiedad `.version`.

---

## C - Firmas de Construcción (Construct Signatures): Para Funciones que son "Fábricas" 🔵

#### 1. **Introducción:**

Se usan para describir funciones que están diseñadas para ser llamadas con la palabra clave `new`, es decir, constructores de clases o fábricas de objetos.

#### 2. **Ejemplo:**

```typescript
// Este tipo describe algo que PUEDES llamar con 'new'.
type SomeConstructor = {
  new (s: string): Date; // Fíjate en el 'new' al principio.
};

function createObject(ctor: SomeConstructor) {
  // Gracias al tipo, TypeScript sabe que 'new ctor(...)' es una operación válida.
  return new ctor("hello");
}

// La clase Date de JavaScript encaja perfectamente con nuestro tipo SomeConstructor,
// porque puedes hacer 'new Date("...")'.
const myDate = createObject(Date);

console.log(myDate); // Muestra la fecha y hora actual.
```

**Explicación del ejemplo:**
`SomeConstructor` es como el plano de una fábrica. No describe un objeto, sino la _capacidad de construir_ un objeto. Le dice a la función `createObject`: "Te pasaré algo (`ctor`) que, si le pones `new` delante y le das un `string`, te fabricará un objeto `Date`". Como la clase `Date` nativa de JavaScript funciona exactamente así, podemos usarla sin problemas.

#### 3. **Desarrollo:**

La sintaxis es idéntica a una firma de llamada, pero con la palabra `new` al principio. Esto le da a TypeScript la señal inequívoca de que esta función es un constructor.

Algunos objetos en JavaScript, como `Date`, son especiales: puedes llamarlos como una función normal (`Date()`, que devuelve un string) o como un constructor (`new Date()`, que devuelve un objeto Date). Puedes modelar esto combinando firmas de llamada y de construcción en el mismo tipo:

```typescript
interface CallOrConstruct {
  new (s: string): Date; // Si la llamas con 'new' y un string...
  (n?: number): string; // Si la llamas normal, con un número opcional...
}

// La clase 'Date' cumple con esta interfaz.
const MyDateConstructor: CallOrConstruct = Date;
```

🔵 **Específico**: Esto es más avanzado. Lo necesitarás si estás escribiendo código de alto nivel que manipula clases o si creas funciones que aceptan diferentes clases como parámetros para instanciarlas (patrones como _Factory_ o _Dependency Injection_).

---

## D - Funciones Genéricas: Creando Plantillas de Funciones 🟡

#### 1. **Introducción:**

Los genéricos te permiten escribir una función que puede trabajar con una variedad de tipos, pero manteniendo la relación entre los tipos de entrada y los de salida.

#### 2. **Ejemplo:**

```typescript
// Sin genéricos, tendríamos que usar 'any', perdiendo información del tipo.
// function firstElement(arr: any[]) { return arr[0]; }

// Con genéricos: <Type> es como una variable para los tipos.
function firstElement<Type>(arr: Type[]): Type | undefined {
  return arr[0];
}

// TypeScript ve que le pasas un array de strings, así que infiere que 'Type' es 'string'.
const s = firstElement(["a", "b", "c"]); // 's' es de tipo 'string'

// Aquí, infiere que 'Type' es 'number'.
const n = firstElement([1, 2, 3]); // 'n' es de tipo 'number'
```

**Explicación del ejemplo:**
Piensa en `<Type>` como un comodín o un marcador de posición. Cuando declaras `function firstElement<Type>`, le estás diciendo a TypeScript: "Voy a usar un tipo que aún no conozco, lo llamaré `Type`. Cuando alguien llame a esta función, fíjate en el tipo de los argumentos y reemplaza `Type` por ese tipo concreto". Así, la función se adapta inteligentemente al dato que le pasas, y el tipo de lo que devuelve es mucho más preciso que un simple `any`.

#### 3. **Desarrollo:**

Los genéricos son la clave para escribir código reutilizable y con tipado seguro. Crean un **vínculo** entre diferentes valores. En `firstElement<Type>(arr: Type[]): Type`, el vínculo es claro: el tipo de los elementos del array de entrada (`Type[]`) determina el tipo del valor de salida (`Type`).

**Inferencia:**
Lo mejor es que la mayoría de las veces no tienes que especificar el tipo en el llamado. TypeScript es lo suficientemente listo para _inferirlo_ a partir de los argumentos que pasas.

**Múltiples Parámetros de Tipo:**
Puedes usar tantos como necesites. Imagina una función `map` que transforma un array de un tipo a otro:

```typescript
function map<Input, Output>(
  arr: Input[],
  func: (arg: Input) => Output
): Output[] {
  return arr.map(func);
}

// TypeScript infiere:
// - 'Input' es 'string' (por el array ["1", "2", "3"]).
// - 'Output' es 'number' (por el 'parseInt' que devuelve un número).
const parsed = map(["1", "2", "3"], (n) => parseInt(n)); // 'parsed' es de tipo 'number[]'
```

🟡 **Importante**: Los genéricos son un pilar de TypeScript. Al principio pueden parecer abstractos, pero son esenciales para escribir código flexible y robusto. Los encontrarás por todas partes, especialmente en APIs que manejan colecciones de datos o transformaciones.

---

## E - Restricciones Genéricas (Constraints): Poniendo Límites a tus Plantillas 🟡

#### 1. **Introducción:**

A veces no quieres que tu función genérica acepte _cualquier_ tipo, sino solo aquellos que cumplan ciertas condiciones (por ejemplo, que tengan una propiedad `length`).

#### 2. **Ejemplo:**

```typescript
// Con 'extends { length: number }', le decimos a TypeScript:
// "'Type' puede ser cualquier cosa, SIEMPRE Y CUANDO tenga una propiedad 'length' que sea un número."
function longest<Type extends { length: number }>(a: Type, b: Type): Type {
  if (a.length >= b.length) {
    return a;
  } else {
    return b;
  }
}

// Funciona: los arrays tienen 'length'.
const longerArray = longest([1, 2], [1, 2, 3]); // 'longerArray' es number[]

// Funciona: los strings tienen 'length'.
const longerString = longest("alice", "bob"); // 'longerString' es "alice" | "bob"

// ¡ERROR! Los números no tienen 'length'. TypeScript nos protege.
// const notOK = longest(10, 100);
```

**Explicación del ejemplo:**
La cláusula `extends` actúa como un guardia de seguridad en la puerta de tu función. `Type extends { length: number }` significa: "Oye, `Type`, para entrar aquí necesitas tener una propiedad `length`. Si no la tienes, no pasas". Esto es increíblemente útil porque dentro de la función `longest`, TypeScript ahora sabe con un 100% de certeza que `a.length` y `b.length` son accesos seguros. Sin la restricción, se quejaría porque `Type` podría ser un número o un booleano.

#### 3. **Desarrollo:**

Las restricciones son la forma de informar a TypeScript sobre las capacidades de tus tipos genéricos.

**¡CUIDADO! Un error muy común:**
No puedes simplemente devolver un objeto que _parezca_ cumplir la restricción. Debes devolver el mismo tipo que entró.

```typescript
function minimumLength<Type extends { length: number }>(
  obj: Type,
  minimum: number
): Type {
  if (obj.length >= minimum) {
    return obj; // Bien, devuelves el mismo objeto que entró.
  } else {
    // ¡ERROR! Prometiste devolver 'Type', no un objeto genérico que se le parece.
    // return { length: minimum };
    // ¿Por qué es un error? Porque si 'Type' era un array (que tiene .slice),
    // este nuevo objeto { length: ... } no lo es, y el código se rompería.
    // Para solucionarlo, tendrías que crear un nuevo objeto del mismo tipo 'Type',
    // lo cual es más complejo y depende del caso.
  }
}
```

La regla de oro es: la función promete devolver `Type` (el tipo _específico_ que se pasó, como `Array` o `string`), no solo _algo que cumpla la restricción_ `{ length: number }`.

🟡 **Importante**: Las restricciones son el complemento perfecto de los genéricos. Te dan la flexibilidad de los genéricos con la seguridad de saber qué propiedades y métodos están disponibles en tus tipos.

---

## F - Especificando Argumentos de Tipo: Cuando TypeScript Necesita una Pista 🔵

#### 1. **Introducción:**

Aunque TypeScript es genial infiriendo tipos, a veces necesita que le digas explícitamente qué tipo usar en una función genérica, especialmente cuando los argumentos no le dan suficiente información.

#### 2. **Ejemplo:**

```typescript
function combine<Type>(arr1: Type[], arr2: Type[]): Type[] {
  return arr1.concat(arr2);
}

// ¡ERROR! TypeScript infiere 'Type' como 'number' por el primer array,
// pero luego ve que el segundo array es de 'string' y se confunde.
// const arr = combine([1, 2, 3], ["hello"]);

// ¡SOLUCIÓN! Le damos una pista explícita.
// Le decimos: "Oye, para esta llamada, considera 'Type' como 'string | number'".
const arr = combine<string | number>([1, 2, 3], ["hello"]); // 'arr' es (string | number)[]
```

**Explicación del ejemplo:**
La función `combine` espera que ambos arrays sean del mismo tipo `Type`. Cuando le pasas un array de números y otro de strings, TypeScript entra en pánico: "¿`Type` es `number` o es `string`? ¡No puedo decidir!". Al escribir `<string | number>` justo después del nombre de la función, tomamos el control y le decimos: "Tranquilo, para esta ocasión, `Type` será la unión de ambos, `string | number`". Ahora todo tiene sentido para él y el código funciona.

#### 3. **Desarrollo:**

Especificar los argumentos de tipo se hace con la sintaxis de "diamante" `<...>` justo después del nombre de la función y antes de los paréntesis de los argumentos.

No es algo que hagas todo el tiempo, ya que la inferencia de TypeScript suele ser suficiente. Pero es una herramienta vital en tu arsenal para esos casos ambiguos en los que la inferencia falla o no produce el resultado que esperas.

🔵 **Específico**: Lo usarás en situaciones donde la inferencia de tipos es ambigua. Saber que esta herramienta existe te salvará de muchos dolores de cabeza cuando te encuentres con errores de tipo aparentemente ilógicos en funciones genéricas.

---

## G - Guía para Buenas Funciones Genéricas: Escribiendo Código que Otros Amen 🟡

#### 1. **Introducción:**

Escribir genéricos es poderoso, pero es fácil crear funciones complicadas e impredecibles; estas reglas te ayudarán a mantener tu código simple, claro y fácil de usar.

#### 2. **Regla 1: Empuja los Parámetros de Tipo Hacia Abajo**

**Principio:** Usa el parámetro de tipo directamente en lugar de restringir un tipo más amplio.

**Ejemplo:**

```typescript
// MAL 👎: La inferencia es pobre.
function firstElement_MAL<Type extends any[]>(arr: Type): any {
  return arr[0]; // TypeScript infiere 'any' porque se basa en la restricción.
}

// BIEN 👍: La inferencia es perfecta.
function firstElement_BIEN<Type>(arr: Type[]): Type | undefined {
  return arr[0]; // TypeScript infiere el tipo del elemento del array.
}

const a = firstElement_BIEN([1, 2, 3]); // 'a' es de tipo 'number'
const b = firstElement_MAL([1, 2, 3]); // 'b' es de tipo 'any' 😱
```

**Explicación:**
En la versión `_MAL`, le pides a TypeScript que infiera el tipo del array completo (`Type`) y luego intente adivinar el tipo de `arr[0]`. Se rinde y dice `any`. En la versión `_BIEN`, eres explícito: `Type` es el tipo del _elemento_, no del array. Esto le da a TypeScript la información precisa que necesita para inferir correctamente.

> **Regla:** Cuando sea posible, usa el parámetro de tipo en sí mismo (`Type[]`) en lugar de restringirlo (`Type extends any[]`).

#### 3. **Regla 2: Usa Menos Parámetros de Tipo**

**Principio:** Solo introduce un parámetro de tipo si relaciona al menos dos valores.

**Ejemplo:**

```typescript
// MAL 👎: 'Func' es innecesario y complica la función.
function filter_MAL<Type, Func extends (arg: Type) => boolean>(
  arr: Type[],
  func: Func
): Type[] {
  return arr.filter(func);
}

// BIEN 👍: Más simple y fácil de llamar.
function filter_BIEN<Type>(arr: Type[], func: (arg: Type) => boolean): Type[] {
  return arr.filter(func);
}
```

**Explicación:**
En la versión `_MAL`, el parámetro `Func` no aporta nada. No conecta ninguna otra parte de la función. Solo hace que la firma sea más larga y obliga a quien la llama a pensar en un tipo extra sin motivo. La versión `_BIEN` es más directa y logra exactamente lo mismo.

> **Regla:** Usa siempre la menor cantidad posible de parámetros de tipo.

#### 4. **Regla 3: Los Parámetros de Tipo Deben Aparecer Dos Veces**

**Principio:** Si un parámetro de tipo solo se usa una vez en la firma, probablemente no lo necesites.

**Ejemplo:**

```typescript
// MAL 👎: 'Str' no relaciona nada. Es un genérico innecesario.
function greet_MAL<Str extends string>(s: Str) {
  console.log("Hello, " + s);
}

// BIEN 👍: Un simple 'string' es más claro y hace lo mismo.
function greet_BIEN(s: string) {
  console.log("Hello, " + s);
}
```

**Explicación:**
El propósito de un genérico es **relacionar tipos**. Por ejemplo, relacionar el tipo de un argumento con el tipo del valor de retorno. En `greet_MAL`, el tipo `Str` solo se usa para el argumento `s`. No se relaciona con nada más. Por lo tanto, no aporta ningún valor sobre la versión `_BIEN`, que es más simple. Un parámetro de tipo debe usarse en al menos dos posiciones (p. ej., dos argumentos, o un argumento y el retorno) para ser útil.

> **Regla:** Si un parámetro de tipo solo aparece en una ubicación, reconsidera seriamente si realmente lo necesitas.

🟡 **Importante**: Estas no son leyes estrictas, sino principios de diseño. Seguir estas guías hará que tus APIs genéricas sean más predecibles, fáciles de depurar y un placer de usar para otros desarrolladores (¡incluido tu yo del futuro!).

---

## H - Parámetros Opcionales: Dando Flexibilidad a tus Funciones 🟡

#### 1. **Introducción:**

Puedes hacer que los parámetros de una función no sean obligatorios, ya sea marcándolos como opcionales con `?` o dándoles un valor por defecto.

#### 2. **Ejemplo:**

```typescript
// 'x' es opcional gracias al '?'
function opcional(x?: number) {
  // Dentro, 'x' puede ser 'number' o 'undefined'.
  console.log(x);
}

// 'y' tiene un valor por defecto.
function porDefecto(y = 10) {
  // Dentro, 'y' SIEMPRE será 'number'.
  // Si se llama sin argumento, 'y' será 10.
  console.log(y);
}

opcional(); // OK -> Imprime 'undefined'
opcional(5); // OK -> Imprime 5

porDefecto(); // OK -> Imprime 10
porDefecto(20); // OK -> Imprime 20
porDefecto(undefined); // OK -> También activa el valor por defecto, imprime 10
```

**Explicación del ejemplo:**
El signo de interrogación `?` le dice a TypeScript: "Este parámetro puede que no me lo pasen". Como resultado, dentro de la función, el tipo de `x` es en realidad `number | undefined`. Por otro lado, al dar un valor por defecto (`y = 10`), le aseguras a TypeScript que `y` _siempre_ tendrá un valor numérico, porque si el llamador no proporciona uno (o pasa `undefined`), se le asignará `10` automáticamente.

#### 3. **Desarrollo y ¡LA TRAMPA MÁS COMÚN!**

Cuando defines el tipo de una función callback, **NUNCA** uses un parámetro opcional a menos que realmente quieras decir que _tú_ podrías no pasar ese argumento al llamar al callback.

**Ejemplo del error:**

```typescript
// MAL 👎 - Esto es lo que la gente suele escribir por error.
function miForEach_MAL(
  arr: any[],
  callback: (arg: any, index?: number) => void
) {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i); // Siempre pasamos AMBOS argumentos.
  }
}

// El problema: al definir 'index?' como opcional, le dices a TypeScript:
// "El callback PODRÍA ser llamado sin el índice".
// Por eso, TypeScript se queja aquí, ¡aunque en la práctica 'i' nunca será undefined!
miForEach_MAL([1, 2, 3], (a, i) => {
  // console.log(i.toFixed()); // Error: 'i' es posiblemente 'undefined'.
});

// BIEN 👍 - La forma correcta.
function miForEach_BIEN(
  arr: any[],
  callback: (arg: any, index: number) => void
) {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i);
  }
}

// Ahora funciona, y lo mejor es que JavaScript permite esto:
// El usuario del callback puede elegir ignorar los parámetros que no necesita.
miForEach_BIEN([1, 2, 3], (a) => console.log(a)); // OK, ignora el índice.
miForEach_BIEN([1, 2, 3], (a, i) => console.log(a, i)); // OK, usa ambos.
```

**Explicación de la trampa:**
En JavaScript, puedes pasar una función que acepta menos argumentos donde se espera una que acepta más. `(a) => {}` es un sustituto válido para `(a, i) => {}`. El error común es pensar que `index?` en la definición del callback sirve para permitir que el _usuario_ omita el parámetro. ¡No! Sirve para permitir que el _implementador_ (`miForEach_MAL`) omita el parámetro al llamar al callback.

> **Regla de Oro para Callbacks:** Al escribir el tipo para un callback, **NUNCA** uses un parámetro opcional a menos que tengas la intención de **llamar** a ese callback sin pasar ese argumento. Define todos los parámetros que vas a pasar, y deja que el consumidor del callback decida cuáles usar.

🟡 **Importante**: Los parámetros opcionales y por defecto son fundamentales para crear APIs flexibles. Pero entender la diferencia de su comportamiento en callbacks es una de esas lecciones clave que separa a un principiante de un desarrollador de TypeScript con experiencia.

---

## I - Sobrecarga de Funciones (Function Overloads): Una Función, Múltiples "Caras" 🔵

#### 1. **Introducción:**

La sobrecarga te permite definir una función que puede ser llamada de varias maneras diferentes (con distintos números o tipos de argumentos).

#### 2. **Ejemplo:**

```typescript
// 1. Firmas de sobrecarga (las "caras" públicas de la función)
function makeDate(timestamp: number): Date;
function makeDate(m: number, d: number, y: number): Date;

// 2. Firma de implementación (la implementación real y "privada")
// Esta firma debe ser compatible con todas las de arriba.
function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
  if (d !== undefined && y !== undefined) {
    // Lógica para la segunda sobrecarga (mes, día, año)
    return new Date(y, mOrTimestamp, d);
  } else {
    // Lógica para la primera sobrecarga (timestamp)
    return new Date(mOrTimestamp);
  }
}

const d1 = makeDate(12345678); // OK, coincide con la primera sobrecarga.
const d2 = makeDate(5, 5, 5); // OK, coincide con la segunda sobrecarga.
// const d3 = makeDate(1, 3);      // ¡ERROR! No coincide con NINGUNA sobrecarga.
```

**Explicación del ejemplo:**
Piensa que `makeDate` tiene dos "anuncios" públicos: "Puedes llamarme con un solo número (un timestamp)" y "Puedes llamarme con tres números (mes, día, año)". Estos son las **firmas de sobrecarga**. Luego, hay una única implementación "en la trastienda" que es lo suficientemente inteligente para manejar ambos casos. Lo crucial es que desde fuera, **solo se ven los anuncios**. No puedes llamar a la función de una forma que no coincida con uno de los anuncios, aunque la implementación pudiera manejarlo.

#### 3. **Desarrollo:**

**¡La confusión más grande! La firma de implementación NO es visible desde fuera.**

El error más común es pensar que la firma de la implementación es una de las formas en que se puede llamar a la función. ¡No lo es!

```typescript
function fn(x: string): void; // La única "cara" pública.
// La implementación está oculta.
function fn() {
  // ...
}

// fn(); // ¡ERROR! Esperaba 1 argumento, pero recibió 0.
// Aunque la implementación no tiene argumentos, la única firma visible requiere un string.
```

> **Regla:** La firma de la implementación es un detalle interno. Su único propósito es proporcionar un cuerpo que sea compatible con todas las firmas de sobrecarga públicas. Siempre debes tener dos o más firmas de sobrecarga por encima de la implementación.

**Consejo para buenas sobrecargas:**
Si varias sobrecargas tienen el mismo número de argumentos y el mismo tipo de retorno, a menudo es mejor usar un tipo de unión en un solo parámetro.

```typescript
// En lugar de esto (con sobrecargas):
// function len(s: string): number;
// function len(arr: any[]): number;

// Es mejor esto (con uniones):
function len(x: string | any[]) {
  return x.length;
}

len(Math.random() > 0.5 ? "hello" : [0]); // ¡Funciona con uniones, pero fallaría con sobrecargas!
```

> **Regla:** Prefiere siempre parámetros con tipos de unión en lugar de sobrecargas cuando sea posible. Es más simple, más flexible y más fácil de mantener.

🔵 **Específico**: La sobrecarga es útil para modelar APIs existentes de JavaScript que se comportan de esta manera (como `createElement` en React o algunas funciones de Node.js). Sin embargo, para tu propio código, a menudo hay alternativas más simples como los parámetros opcionales o los tipos de unión.

---

## J - Declarando `this` en una Función: Domando al `this` Rebelde 🔵

#### 1. **Introducción:**

TypeScript te permite declarar explícitamente el tipo de `this` dentro de una función, lo cual es vital cuando el valor de `this` es determinado por quien llama a la función (como en los callbacks).

#### 2. **Ejemplo:**

```typescript
interface User {
  id: number;
  admin: boolean;
}

interface DB {
  // Esta función 'filterUsers' espera un callback.
  // El tipo del callback indica que, cuando sea ejecutado, 'this' será un 'User'.
  filterUsers(filter: (this: User) => boolean): User[];
}

// Simulemos que tenemos una base de datos y un usuario.
const db: DB = {
  filterUsers: function (filter) {
    let user1: User = { id: 1, admin: true };
    let user2: User = { id: 2, admin: false };
    let results = [];
    // 'call' nos permite ejecutar 'filter' estableciendo el valor de 'this'.
    if (filter.call(user1)) {
      results.push(user1);
    }
    if (filter.call(user2)) {
      results.push(user2);
    }
    return results;
  },
};

// ¡Aquí está la magia!
// Usamos 'function' para que 'this' sea flexible.
// TypeScript sabe que dentro de esta función, 'this' es de tipo 'User'.
const admins = db.filterUsers(function (this: User) {
  return this.admin; // ¡Acceso seguro a 'this.admin'!
});

console.log(admins); // [{ id: 1, admin: true }]
```

**Explicación del ejemplo:**
La parte `(this: User) => boolean` es una promesa. Le dice a `filterUsers`: "Te pasaré una función, y te prometo que cuando la llames, debes asegurarte de que `this` sea un objeto `User`". Dentro del callback, TypeScript confía en esta promesa y nos permite acceder a `this.admin` sin errores.

#### 3. **Desarrollo:**

Esto es una característica puramente de TypeScript. JavaScript no tiene una sintaxis para un parámetro llamado `this`, así que TypeScript aprovecha ese "espacio" para el tipado.

**¡CUIDADO! Las Arrow Functions no funcionan aquí.**
Las funciones de flecha (`=>`) tienen un comportamiento diferente con `this`: capturan el `this` del contexto en el que fueron creadas (lo que se llama `this` léxico). No puedes cambiar su `this` dinámicamente.

```typescript
// ¡ERROR! 'this' aquí no es el 'User', sino el 'this' del ámbito global
// (o donde sea que se haya definido este código).
// const admins = db.filterUsers(() => this.admin);
```

> **Regla:** Para usar la declaración de tipo de `this`, **debes** usar una declaración de función tradicional (`function() { ... }`).

🔵 **Específico**: Esto es crucial cuando trabajas con APIs orientadas a objetos o librerías que usan patrones de callbacks donde el contexto (`this`) es importante (por ejemplo, en manejadores de eventos de algunas librerías de UI o en plugins de jQuery si alguna vez te encuentras con ello).

---

## K - Otros Tipos que Debes Conocer: El Vocabulario Esencial 🔴

#### 1. **`void`: Para Funciones que No Devuelven Nada** 🔴

- **Introducción:** `void` se usa como tipo de retorno para funciones que no devuelven un valor.
- **Ejemplo:**
  ```typescript
  function logMessage(message: string): void {
    console.log(message);
    // No hay 'return', o hay un 'return;' vacío.
  }
  ```
- **Desarrollo:** ¡No lo confundas con `undefined`! Una función que devuelve `void` puede, en ciertos contextos (como en la implementación de un tipo), devolver un valor, pero este **será ignorado**. `void` significa "el valor de retorno no importa y no debe ser usado". `undefined` es un valor primitivo real. Veremos más sobre esto en la sección de "Asignabilidad".
  🔴 **Fundamental**: Es el tipo de retorno por defecto para cualquier función sin un `return` explícito. Lo verás y usarás constantemente.

#### 2. **`object`: Cualquier Cosa que No Sea un Primitivo** 🟡

- **Introducción:** `object` representa cualquier valor que no sea un primitivo (`string`, `number`, `boolean`, `symbol`, `null`, `undefined`, `bigint`).
- **Ejemplo:**
  ```typescript
  // Esta función acepta cualquier objeto, array, o función.
  function workWithObject(obj: object) {
    // console.log(obj.toString()); // Seguro, todos los objetos lo tienen.
  }
  workWithObject({ a: 1 }); // OK
  workWithObject([1, 2]); // OK
  workWithObject(() => {}); // OK, las funciones son objetos.
  // workWithObject("hello"); // ERROR: string es un primitivo.
  ```
- **Desarrollo:** ¡JAMÁS uses `Object` (con 'O' mayúscula)! `Object` es un tipo muy permisivo y problemático. **Usa siempre `object` (con 'o' minúscula)**. Tampoco lo confundas con `{}` (el tipo objeto vacío), que significa un objeto que no tiene propiedades propias.
  🟡 **Importante**: Es útil cuando necesitas aceptar una amplia gama de tipos no primitivos sin recurrir al peligroso `any`.

#### 3. **`unknown`: El Hermano Seguro de `any`** 🟡

- **Introducción:** `unknown` puede representar cualquier valor, pero a diferencia de `any`, no te deja hacer nada con él hasta que verifiques su tipo.
- **Ejemplo:**

  ```typescript
  function processValue(value: unknown) {
    // value.toFixed(2); // ERROR: 'value' es de tipo 'unknown'.

    if (typeof value === "number") {
      // ¡OK! Dentro de este 'if', TypeScript sabe que 'value' es un 'number'.
      console.log(value.toFixed(2));
    }
  }
  ```

- **Desarrollo:** `unknown` te fuerza a practicar el tipado seguro. Antes de poder operar sobre un valor `unknown`, debes usar una guarda de tipo (como `typeof`, `instanceof`, o aserción de tipo) para "convencer" a TypeScript de que sabes lo que estás haciendo. Es la opción preferida sobre `any` cuando recibes datos de fuentes externas (APIs, input del usuario).
  🟡 **Importante**: Es una herramienta clave para escribir código robusto que interactúa con el mundo exterior.

#### 4. **`never`: Para Situaciones que Nunca Ocurren** 🔵

- **Introducción:** `never` representa el tipo de valores que nunca ocurren.
- **Ejemplo:**

  ```typescript
  // 1. Funciones que nunca retornan.
  function throwError(message: string): never {
    throw new Error(message);
    // No hay forma de salir de esta función si no es con un error.
  }

  // 2. Tipos que se vuelven imposibles.
  function checkExhaustive(x: string | number) {
    if (typeof x === "string") {
      /* ... */
    } else if (typeof x === "number") {
      /* ... */
    } else {
      // 'x' aquí es de tipo 'never', porque ya cubrimos todos los casos posibles.
    }
  }
  ```

- **Desarrollo:** `never` es útil para dos cosas principales: indicar que una función siempre lanza una excepción o entra en un bucle infinito, y para realizar comprobaciones exhaustivas en uniones de tipos. Si en el futuro añades un `boolean` a la unión de `checkExhaustive` y olvidas añadir el `else if`, TypeScript te dará un error en la rama `else` final, porque `x` ya no sería `never`.
  🔵 **Específico**: Es un tipo más conceptual, pero muy poderoso para el análisis estático y para asegurar que manejas todos los casos posibles en tu lógica.

#### 5. **`Function`: El Tipo Genérico y Peligroso para Funciones** ⚪

- **Introducción:** Es un tipo global que describe cualquier valor de función en JavaScript.
- **Ejemplo:**
  ```typescript
  function callAnyFunction(f: Function) {
    f(1, "hello", true); // OK, pero... ¿qué devuelve? 'any'.
  }
  ```
- **Desarrollo:** Evítalo siempre que puedas. Aceptar `Function` es casi como aceptar `any`. No te da ninguna información sobre los parámetros o el tipo de retorno, y cualquier llamada que hagas a ella devolverá `any`. Es una llamada a función sin tipado.
- **Alternativa Segura:** Si necesitas aceptar una función arbitraria pero no tienes intención de llamarla, usa `() => void`. Es mucho más seguro.
  ⚪ **Raramente usado**: Se considera una mala práctica. Casi siempre hay una forma mejor y más segura de tipar tu función, como una expresión de tipo de función (`(args) => ret`) o `unknown`.

---

## L - Parámetros Rest y Argumentos Rest: Manejando un Número Infinito de Argumentos 🟡

#### 1. **Introducción:**

Te permiten trabajar con funciones que aceptan un número variable de argumentos, empaquetándolos en un array.

#### 2. **Ejemplo (Parámetros Rest):**

```typescript
// '...m' es el parámetro rest. Agrupa todos los argumentos EXTRA en un array llamado 'm'.
function multiply(n: number, ...m: number[]) {
  // 'm' será un array de números: [1, 2, 3, 4] en la llamada de abajo.
  return m.map((x) => n * x);
}

const a = multiply(10, 1, 2, 3, 4);
// 'a' es [10, 20, 30, 40]
```

**Explicación del ejemplo:**
El parámetro `rest` (`...m`) actúa como una aspiradora: el primer argumento (`10`) va a `n`, y la aspiradora recoge _todo lo que queda_ y lo mete en un array llamado `m`. El parámetro rest siempre debe ser el último en la lista de parámetros.

#### 3. **Ejemplo (Argumentos Rest / Spread Syntax):**

```typescript
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

// El operador spread '...' DESEMPAQUETA el array 'arr2'.
// Es como si hubiéramos escrito: arr1.push(4, 5, 6);
arr1.push(...arr2);

console.log(arr1); // [1, 2, 3, 4, 5, 6]
```

**Explicación del ejemplo:**
Aquí, el operador `...` (spread) hace lo contrario. En lugar de empaquetar, desempaqueta. Toma el array `arr2` y "esparce" sus elementos como argumentos individuales para la función `push`.

#### 4. **Desarrollo y una Sorpresa Común:**

TypeScript es muy estricto con el spread de arrays en funciones que esperan un número fijo de argumentos (tuplas).

```typescript
// Math.atan2 espera exactamente dos argumentos: (y: number, x: number)
const args = [8, 5]; // TypeScript infiere esto como 'number[]' (un array de CUALQUIER longitud)

// ERROR: TypeScript no puede garantizar que 'args' tenga exactamente 2 elementos.
// const angle = Math.atan2(...args);

// LA SOLUCIÓN: 'as const'
// Le decimos a TypeScript: "Trata esto como una tupla inmutable de exactamente dos números".
const argsConst = [8, 5] as const;
const angle = Math.atan2(...argsConst); // ¡OK!
```

`as const` es una herramienta poderosa que le pide a TypeScript que infiera el tipo más específico y literal posible. En este caso, convierte `number[]` en `readonly [8, 5]`, una tupla, que es exactamente lo que `Math.atan2` necesita para estar seguro.

🟡 **Importante**: Los parámetros rest y la sintaxis spread son características modernas de JavaScript que usarás con frecuencia para escribir funciones más flexibles y para manipular arrays de forma concisa. Entender el matiz de `as const` te salvará de errores sutiles.

---

## M - Desestructuración de Parámetros: Desempacando Argumentos con Estilo 🟡

#### 1. **Introducción:**

La desestructuración te permite extraer propiedades de un objeto pasado como argumento directamente en variables locales, haciendo tu código más limpio.

#### 2. **Ejemplo:**

```typescript
// Definimos un tipo para el objeto que esperamos.
type Point3D = { a: number; b: number; c: number };

// En lugar de 'function sum(coords: Point3D)', desestructuramos el parámetro.
// La anotación de tipo va DESPUÉS de la sintaxis de desestructuración.
function sum({ a, b, c }: Point3D) {
  // Ahora 'a', 'b', y 'c' son variables locales listas para usar.
  console.log(a + b + c);
}

sum({ a: 10, b: 3, c: 9 }); // Imprime 22
```

**Explicación del ejemplo:**
En lugar de recibir un objeto `coords` y luego tener que acceder a `coords.a`, `coords.b`, etc., la sintaxis `{ a, b, c }: Point3D` hace todo el trabajo por nosotros. Desempaca el objeto entrante y asigna sus propiedades a variables con el mismo nombre. Es más directo y reduce el código repetitivo.

#### 3. **Desarrollo:**

La sintaxis puede parecer extraña al principio: `({ ... } : Type)`. La clave es recordar que la desestructuración (`{ a, b, c }`) y el tipado (`: Point3D`) son dos operaciones separadas que ocurren en el mismo lugar.

1.  `{ a, b, c }`: Esto es JavaScript. Le dice al motor: "Espera un objeto y extrae sus propiedades `a`, `b`, y `c`".
2.  `: Point3D`: Esto es TypeScript. Le dice al compilador: "Por cierto, ese objeto que esperas debe tener la forma del tipo `Point3D`".

Usar un alias de tipo (`type` o `interface`) como `Point3D` es altamente recomendable para mantener el código limpio, especialmente si el objeto tiene muchas propiedades. Escribir el tipo en línea (`{ a, b, c }: { a: number; b: number; c: number }`) puede volverse muy verboso rápidamente.

🟡 **Importante**: Esta es una característica de JavaScript moderno que se integra perfectamente con TypeScript. La usarás muchísimo, especialmente en componentes de frameworks como React, donde los `props` son un único objeto que se suele desestructurar.

---

## N - Asignabilidad de Funciones y el `void` Misterioso 🔵

#### 1. **Introducción:**

El comportamiento del tipo de retorno `void` en la asignación de funciones puede ser anti-intuitivo, pero está diseñado para que un caso de uso muy común funcione sin problemas.

#### 2. **Ejemplo:**

```typescript
type VoidFunc = () => void;

// A pesar de que 'VoidFunc' espera un retorno 'void',
// podemos asignarle una función que SÍ devuelve algo.
const f1: VoidFunc = () => {
  return true; // TypeScript no se queja.
};

// Cuando llamamos a la función a través de su tipo 'VoidFunc',
// el valor de retorno es 'void' (es decir, se ignora).
const result = f1(); // 'result' es de tipo 'void', no 'boolean'.

// ¿POR QUÉ EXISTE ESTE COMPORTAMIENTO? Por esto:
const src = [1, 2, 3];
const dst = [0];

// .forEach espera un callback de tipo (el: number) => void.
// .push devuelve un número (la nueva longitud del array).
// Si TypeScript fuera estricto, la siguiente línea daría un error.
// ¡Pero gracias a este comportamiento, es perfectamente válido!
src.forEach((el) => dst.push(el));
```

**Explicación del ejemplo:**
La regla es: una función que devuelve un valor puede ser asignada a un tipo de función que espera `void`. Cuando esto sucede, el valor de retorno simplemente se ignora. TypeScript lo permite para que el código como `src.forEach((el) => dst.push(el))` sea válido. El método `forEach` no se preocupa por lo que devuelve su callback, solo lo ejecuta. Si TypeScript forzara a que el callback no devolviera nada, tendríamos que escribir código más torpe como `src.forEach((el) => { dst.push(el); });` solo para evitar devolver el resultado de `push`.

#### 3. **Desarrollo:**

Esta flexibilidad solo se aplica cuando se trabaja con un **tipo de función contextual** (como nuestra `VoidFunc` o el callback de `forEach`).

**La excepción a la regla:**
Si defines una función y anotas explícitamente su retorno como `void`, entonces esa función **no debe** devolver nada.

```typescript
// Aquí, la función en sí misma está declarada con retorno 'void'.
function f2(): void {
  // return true; // ¡ERROR! El tipo 'boolean' no es asignable al tipo 'void'.
}
```

Esta distinción es sutil pero importante:

- **Contextual (`const f: () => void = ...`)**: Permite devolver un valor, pero se ignora.
- **Declaración directa (`function f(): void { ... }`)**: Prohíbe devolver un valor.

🔵 **Específico**: Este es un detalle profundo de TypeScript. Entenderlo te ayudará a comprender por qué cierto código funciona y a evitar confusiones cuando trabajes con APIs que usan callbacks con retorno `void`, como `forEach`.
