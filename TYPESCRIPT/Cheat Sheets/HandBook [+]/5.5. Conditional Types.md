## A - Tipos Condicionales: El "Si... Entonces..." de los Tipos üî¥

#### 1. **Introducci√≥n:**

Imagina un `if/else` de JavaScript, pero en lugar de tomar decisiones sobre valores (como `if (x > 10)`), los usamos para tomar decisiones sobre **tipos** durante el desarrollo.

#### 2. **Ejemplo:**

```typescript
// Primero, definimos unas interfaces b√°sicas para que se entienda.
interface Animal {
  live(): void; // Todos los animales viven.
}
interface Dog extends Animal {
  woof(): void; // Los perros, adem√°s de vivir, ladran.
}

// Ahora, la magia del tipo condicional:
// PREGUNTA: ¬øEl tipo 'Dog' puede ser asignado a 'Animal'?
type Example1 = Dog extends Animal ? number : string;
// RESPUESTA: S√≠, un Perro ES un Animal. Por lo tanto, Example1 ser√° 'number'.

// OTRO CASO:
// PREGUNTA: ¬øEl tipo 'RegExp' (una Expresi√≥n Regular) puede ser asignado a 'Animal'?
type Example2 = RegExp extends Animal ? number : string;
// RESPUESTA: No, una Expresi√≥n Regular NO es un Animal. Por lo tanto, Example2 ser√° 'string'.
```

**Explicaci√≥n del ejemplo:**
La sintaxis `TipoA extends TipoB ? TipoSiVerdadero : TipoSiFalso` es el coraz√≥n de todo. Es una pregunta que TypeScript se hace: "¬ø`TipoA` es compatible o "hereda" de `TipoB`?".

- En `Example1`, la respuesta es "s√≠", as√≠ que TypeScript elige lo que est√° despu√©s del `?`: `number`.
- En `Example2`, la respuesta es "no", as√≠ que TypeScript elige lo que est√° despu√©s del `:`: `string`.

#### 3. **Desarrollo**:

Quiz√°s ahora mismo est√©s pensando: "Vale, muy bonito, pero yo ya s√© que un `Dog` es un `Animal`. ¬øPara qu√© quiero que TypeScript me lo diga?". ¬°Y esa es la pregunta PERFECTA! Tienes toda la raz√≥n.

El poder de los tipos condicionales no se ve en ejemplos tan simples. Su verdadera magia, su raz√≥n de existir, es cuando los combinas con **gen√©ricos**, es decir, cuando no sabes de antemano con qu√© tipo exacto vas a trabajar. Lo veremos en el siguiente punto y tu mente har√° "¬°clic!".

üî¥ **Fundamental**: Esta es la sintaxis b√°sica. Es la pieza de LEGO m√°s peque√±a. Si no entiendes esta estructura de `pregunta ? respuesta_si : respuesta_no`, todo lo que sigue ser√° confuso. ¬°Aseg√∫rate de que esto quede grabado a fuego!

---

## B - Adi√≥s a las Sobrecargas: Simplificando Funciones con Tipos Condicionales üî¥

#### 1. **Introducci√≥n:**

Usaremos los tipos condicionales para crear una √∫nica funci√≥n gen√©rica que reemplace un mont√≥n de "sobrecargas de funci√≥n" (m√∫ltiples declaraciones de la misma funci√≥n para distintos tipos), haciendo nuestro c√≥digo m√°s limpio y f√°cil de mantener.

#### 2. **Ejemplo:**

**El Problema: El "Modo Dif√≠cil" con Sobrecargas**

```typescript
interface IdLabel {
  id: number;
}
interface NameLabel {
  name: string;
}

// MODO DIF√çCIL: Tres firmas para una sola funci√≥n. ¬°Qu√© l√≠o!
function createLabel(id: number): IdLabel;
function createLabel(name: string): NameLabel;
function createLabel(nameOrId: string | number): IdLabel | NameLabel;
function createLabel(nameOrId: string | number): IdLabel | NameLabel {
  // ... aqu√≠ ir√≠a la l√≥gica
  throw "unimplemented";
}

let etiquetaConNombre = createLabel("typescript"); // TypeScript sabe que esto es NameLabel
let etiquetaConId = createLabel(123); // TypeScript sabe que esto es IdLabel
```

**La Soluci√≥n: El "Modo F√°cil" con un Tipo Condicional**

```typescript
interface IdLabel {
  id: number;
}
interface NameLabel {
  name: string;
}

// 1. Creamos nuestro "decisor" de tipos
type NameOrId<T extends number | string> = T extends number
  ? IdLabel
  : NameLabel;

// 2. Usamos el "decisor" en UNA SOLA funci√≥n gen√©rica. ¬°Mucho m√°s limpio!
function createLabel<T extends number | string>(idOrName: T): NameOrId<T> {
  // ... aqu√≠ ir√≠a la l√≥gica
  throw "unimplemented";
}

// ¬°Funciona exactamente igual, pero con mucho menos c√≥digo!
let etiquetaConNombre = createLabel("typescript"); // TypeScript infiere que T es 'string', y NameOrId<string> devuelve NameLabel
let etiquetaConId = createLabel(2.8); // TypeScript infiere que T es 'number', y NameOrId<number> devuelve IdLabel
let etiquetaMixta = createLabel(Math.random() ? "hola" : 42); // TypeScript sabe que puede ser NameLabel | IdLabel
```

#### 3. **Desarrollo**:

**Cara a Cara: Sobrecargas vs. Tipo Condicional Gen√©rico**

| Caracter√≠stica       | Sobrecargas de Funci√≥n (El Modo Dif√≠cil)                                                                                                               | Tipo Condicional Gen√©rico (El Modo F√°cil)                                                                  |
| :------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------- | ----------------------------------- | ----------------------------------------------------------------------------------------------------------- |
| **Escalabilidad**    | **P√©sima.** Si ma√±ana quieres aceptar `boolean`, tienes que a√±adir ¬°DOS sobrecargas m√°s! Una para `boolean` y otra para actualizar la general (`string | number                                                                                                     | boolean`). Se vuelve una pesadilla. | **Excelente.** Simplemente actualizas el tipo condicional. La funci√≥n ni la tocas. Es mucho m√°s mantenible. |
| **Claridad**         | **Enga√±osa.** Parece que hay tres funciones, pero solo hay una. Esto puede confundir a los principiantes.                                              | **Clara.** Hay una sola funci√≥n. La l√≥gica de tipos est√° encapsulada y reutilizable en el tipo `NameOrId`. |
| **Fuente de Verdad** | La l√≥gica de qu√© tipo de entrada produce qu√© tipo de salida est√° repartida en varias l√≠neas (las firmas de la funci√≥n).                                | La l√≥gica est√° centralizada en un solo lugar: el tipo condicional `NameOrId`. Mucho m√°s f√°cil de razonar.  |

La principal confusi√≥n que quiero evitarte es que pienses que son dos formas de hacer lo mismo. No, no lo son. Las sobrecargas son una herramienta √∫til, pero para este patr√≥n espec√≠fico de "si me das este tipo, te devuelvo este otro", los tipos condicionales son **infinitamente superiores**.

üî¥ **Fundamental**: Este es el "porqu√©" de los tipos condicionales. Este ejemplo justifica su existencia. Entender c√≥mo resuelven el problema de las sobrecargas te abre los ojos a su verdadero poder en el d√≠a a d√≠a.

---

## C - Restricciones Condicionales: Inspeccionando Tipos de Forma Segura üü°

#### 1. **Introducci√≥n:**

Usamos un tipo condicional para comprobar si un tipo gen√©rico `T` tiene una propiedad espec√≠fica (como `message`) y, solo si la tiene, accedemos a ella de forma segura.

#### 2. **Ejemplo:**

```typescript
// El PROBLEMA: TypeScript no nos deja acceder a 'T.message' porque no sabe si 'T' tiene esa propiedad.
// type MessageOf<T> = T["message"]; // ¬°ERROR! T puede ser cualquier cosa.

// LA SOLUCI√ìN: Usamos un tipo condicional como un "guardia de seguridad".
type MessageOf<T> = T extends { message: unknown } ? T["message"] : never;
// TRADUCCI√ìN:
// "Oye, tipo T... ¬øtienes una propiedad llamada 'message' (no me importa de qu√© tipo sea, por eso 'unknown')?
//  - Si S√ç: Genial, el resultado ser√° el tipo de esa propiedad 'message'.
//  - Si NO: Pues nada, el resultado ser√° 'never' (un tipo que significa 'imposible que ocurra')."

// Veamos c√≥mo funciona:
interface Email {
  message: string;
  subject: string;
}
interface Perro {
  ladrar(): void;
}

type ContenidoEmail = MessageOf<Email>; // Email S√ç tiene 'message', as√≠ que el resultado es 'string'.
type ContenidoPerro = MessageOf<Perro>; // Perro NO tiene 'message', as√≠ que el resultado es 'never'.
```

#### 3. **Desarrollo**:

La clave aqu√≠ es entender la diferencia entre restringir el gen√©rico directamente y usar una condici√≥n.

- **Restricci√≥n Directa:** `type MessageOf<T extends { message: unknown }> = T["message"];`

  - Esto **OBLIGA** a que cualquier tipo que uses con `MessageOf` deba tener la propiedad `message`. Si intentas hacer `MessageOf<Perro>`, te dar√° un error. Es r√≠gido.

- **Restricci√≥n Condicional (nuestro ejemplo):** `type MessageOf<T> = T extends ...`
  - Esto es mucho m√°s flexible. **PERMITE** cualquier tipo. No te da error con `MessageOf<Perro>`. Simplemente, si el tipo no cumple la condici√≥n, te devuelve amablemente `never` en lugar de explotar.

Piensa en ello como un portero de discoteca. La restricci√≥n directa es un portero que solo deja pasar a gente con invitaci√≥n. La restricci√≥n condicional es un portero que deja pasar a todo el mundo, pero dentro los dirige a la zona VIP (si tienen invitaci√≥n) o a la pista general (si no la tienen).

üü° **Importante**: Este patr√≥n es extremadamente com√∫n para crear "utility types" (tipos de ayuda) robustos. Te permite escribir c√≥digo que se adapta a diferentes formas de datos sin fallar, lo cual es esencial en librer√≠as o componentes reutilizables.

---

## D - El Mago `infer`: Adivinando Tipos por Ti üî¥

#### 1. **Introducci√≥n:**

La palabra clave `infer` nos permite "capturar" un tipo que est√° anidado dentro de otro durante una comprobaci√≥n condicional, sin tener que saber c√≥mo acceder a √©l manualmente.

#### 2. **Ejemplo:**

Vamos a crear un tipo `Flatten` que, si le pasas un array, te devuelve el tipo de los elementos de dentro.

**El Modo "Manual" (sin `infer`)**

````typescript
// Si T es un array (any[]), dame el tipo de sus elementos (T[number]). Si no, d√©jame T como est√°.
type Flatten<T> = T extends any[] ? T[number] : T;

type ElementosDeStringArray = Flatten<string[]>; // Resultado: string
type NumeroSinCambios = Flatten<number>;       // Resultado: number```
*Esto funciona, pero `T[number]` es un truco que tienes que saber.*

**El Modo M√°gico (con `infer`)**

```typescript
// Si T tiene la "forma" de un Array de "algo", captura ese "algo" en una variable llamada 'Item' y devu√©lvela.
type Flatten<Type> = Type extends Array<infer Item> ? Item : Type;

type ElementosDeStringArray = Flatten<string[]>; // Resultado: string
type NumeroSinCambios = Flatten<number>;       // Resultado: number
````

**Explicaci√≥n del ejemplo:**
`infer Item` es la estrella. Le dice a TypeScript: "Oye, si `Type` encaja en el patr√≥n `Array<...>`, no me digas solo que s√≠. Quiero que averig√ºes qu√© tipo est√° dentro de los `<...>` y me lo guardes en una nueva variable temporal llamada `Item`".

Luego, en la parte "verdadera" de la condici√≥n, simplemente usamos `Item`. Es mucho m√°s declarativo y legible. No le decimos a TypeScript _c√≥mo_ sacar el tipo (con `T[number]`), sino que le pedimos que _lo infiera_ por nosotros.

#### 3. **Desarrollo**:

**Cara a Cara: Acceso Manual vs. `infer`**

| Caracter√≠stica   | Acceso Manual (`T[number]`)                                                                                                                 | `infer`                                                                                                       |
| :--------------- | :------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------------------------------ |
| **Intenci√≥n**    | **Imperativo.** Le dices a TypeScript _c√≥mo_ hacer algo ("coge el tipo, accede a su √≠ndice num√©rico").                                      | **Declarativo.** Le dices a TypeScript _qu√©_ quieres ("si esto es un array, infiere su tipo de elemento").    |
| **Legibilidad**  | **Menos legible.** Requiere que sepas que `T[number]` es la forma de obtener el tipo de elemento de un array.                               | **Mucho m√°s legible.** `infer Item` deja clar√≠simo que est√°s tratando de extraer un tipo para usarlo despu√©s. |
| **Flexibilidad** | **Limitado.** Funciona bien para arrays, pero para estructuras m√°s complejas (como el tipo de retorno de una funci√≥n), se vuelve imposible. | **Muy flexible.** Es la herramienta est√°ndar para "desempaquetar" tipos de funciones, promesas, tuplas, etc.  |

No te dejes enga√±ar, `infer` puede parecer intimidante al principio, pero es tu mejor amigo para la metaprogramaci√≥n de tipos. Una vez que lo entiendes, ves oportunidades para usarlo en todas partes.

üî¥ **Fundamental**: `infer` es una de las caracter√≠sticas m√°s potentes y avanzadas de TypeScript. Es la clave para crear tipos de utilidad complejos y elegantes. Entender `infer` te sube de nivel como programador de TypeScript.

---

## E - `infer` en Acci√≥n: Extrayendo el Tipo de Retorno de una Funci√≥n üü°

#### 1. **Introducci√≥n:**

Un uso cl√°sico y s√∫per √∫til de `infer` es crear un tipo que pueda analizar una funci√≥n y decirte qu√© tipo de valor devuelve.

#### 2. **Ejemplo:**

```typescript
// Nuestro tipo de utilidad con 'infer'
type GetReturnType<Type> = Type extends (...args: any[]) => infer Return
  ? Return
  : never;
// TRADUCCI√ìN:
// "Si 'Type' tiene la forma de una funci√≥n (no me importan sus argumentos, por eso '...args: any[]'),
// entonces INFIERE el tipo que devuelve y gu√°rdalo en 'Return'.
// Luego, devuelve 'Return'. Si no es una funci√≥n, devuelve 'never'."

// ¬°A usarlo!
type Func1 = () => number;
type Func2 = (x: string) => string;
type Func3 = (a: boolean, b: boolean) => boolean[];

type Num = GetReturnType<Func1>; // Resultado: number
type Str = GetReturnType<Func2>; // Resultado: string
type Bools = GetReturnType<Func3>; // Resultado: boolean[]
```

#### 3. **Desarrollo**:

Este es un ejemplo perfecto de por qu√© `infer` es tan superior al acceso manual que vimos en el **Concepto D**. ¬øC√≥mo le dir√≠as a TypeScript "dame el tipo de retorno de una funci√≥n" sin `infer`? Simplemente... no puedes. No hay una sintaxis como `Type["return"]`.

`infer` nos permite describir la _estructura_ que esperamos (`(...args) => ReturnType`) y extraer las piezas que nos interesan.

De hecho, este tipo de utilidad es tan com√∫n que TypeScript ya lo incluye por defecto. Se llama `ReturnType<T>`. ¬°Pero ahora ya sabes exactamente c√≥mo funciona por dentro!

üü° **Importante**: Aunque TypeScript ya te da `ReturnType<T>`, entender c√≥mo se construye con `infer` es crucial. Te da el poder de crear tus propias utilidades a medida, como `GetPromiseResult<T>` (para inferir el tipo dentro de una Promesa) o `GetFirstArgument<T>` (para obtener el tipo del primer argumento de una funci√≥n).

---

## F - La Trampa de `infer`: Cuidado con las Funciones Sobrecargadas üîµ

#### 1. **Introducci√≥n:**

Cuando intentas usar `infer` (o el `ReturnType<T>` de TypeScript) en una funci√≥n con m√∫ltiples sobrecargas, hay una regla importante que debes conocer para no llevarte sorpresas.

#### 2. **Ejemplo:**

```typescript
// Esta funci√≥n tiene 3 firmas (sobrecargas)
declare function stringOrNum(x: string): number;
declare function stringOrNum(x: number): string;
declare function stringOrNum(x: string | number): string | number; // <-- La √∫ltima y m√°s general

// Ahora usamos el 'ReturnType' que vimos en el concepto E
type T1 = ReturnType<typeof stringOrNum>;

// ¬øCu√°l ser√° el resultado? ¬ø'number'? ¬ø'string'? ¬ø'string | number'?
// El resultado es: string | number
```

**Explicaci√≥n del ejemplo:**
¬°Aqu√≠ est√° la trampa! Podr√≠as pensar que TypeScript intentar√° ser s√∫per inteligente y resolver la sobrecarga, pero no lo hace. Cuando se enfrenta a m√∫ltiples firmas, `infer` **siempre mira la √∫ltima firma de la lista**.

¬øPor qu√©? Porque se asume que la √∫ltima firma es la m√°s general y abarcadora (la que "atrapa todo"). Es una regla simple y predecible para evitar ambig√ºedades.

#### 3. **Desarrollo**:

Esto no es un error, es un comportamiento definido. Es una de esas "cosas que tienes que saber". Si necesitas analizar una sobrecarga espec√≠fica, no puedes hacerlo directamente con `ReturnType` o un tipo `infer` gen√©rico. Necesitar√≠as t√©cnicas m√°s avanzadas o simplemente ser consciente de esta limitaci√≥n.

La lecci√≥n aqu√≠ es: si creas un tipo de utilidad con `infer` para analizar funciones, recuerda que no resolver√° sobrecargas por ti. Siempre se basar√° en la implementaci√≥n o la firma m√°s general (la √∫ltima).

üîµ **Espec√≠fico**: Este es un caso de uso particular que no te encontrar√°s todos los d√≠as, a menos que trabajes intensamente con librer√≠as que usan muchas sobrecargas. Es bueno saber que existe esta limitaci√≥n para que, si alguna vez obtienes un tipo inesperado de una funci√≥n sobrecargada, sepas exactamente por qu√© est√° pasando.

---

## G - Tipos Condicionales Distributivos: El "Uno por Uno" Autom√°tico üî¥

#### 1. **Introducci√≥n:**

Cuando un tipo condicional gen√©rico recibe una uni√≥n de tipos (como `string | number`), no act√∫a sobre la uni√≥n entera, sino que se "distribuye" y se aplica a cada miembro de la uni√≥n por separado.

#### 2. **Ejemplo:**

```typescript
// Un tipo condicional simple: si le pasas un tipo, lo envuelve en un array.
// La condici√≥n 'Type extends any' siempre es cierta, es un truco para activar la distribuci√≥n.
type ToArray<Type> = Type extends any ? Type[] : never;

// ¬°Aqu√≠ viene la magia! Le pasamos una UNI√ìN de tipos.
type StrArrOrNumArr = ToArray<string | number>;
```

**Explicaci√≥n del ejemplo:**
En lugar de hacer `(string | number)[]`, que ser√≠a `Array<string | number>`, TypeScript hace algo mucho m√°s interesante. Distribuye `ToArray` sobre la uni√≥n:

1.  Aplica `ToArray<string>`, que resulta en `string[]`.
2.  Aplica `ToArray<number>`, que resulta en `number[]`.
3.  Finalmente, une los resultados: `string[] | number[]`.

El resultado final de `StrArrOrNumArr` es `string[] | number[]`.

#### 3. **Desarrollo**:

Este comportamiento es, la mayor√≠a de las veces, exactamente lo que quieres. Es incre√≠blemente poderoso. Por ejemplo, imagina un tipo `Exclude<UnionType, MemberToExclude>` que quita un miembro de una uni√≥n. Funciona gracias a esta distribuci√≥n.

La clave para que la distribuci√≥n ocurra es que el tipo sobre el que se comprueba (`Type` en `Type extends any`) sea un **par√°metro gen√©rico sin "envolturas"**.

No te preocupes si el `Type extends any` te parece raro. Es una forma de decirle a TypeScript: "Quiero que esta condici√≥n se active para cualquier tipo, principalmente para que la distribuci√≥n sobre uniones funcione".

üî¥ **Fundamental**: Este comportamiento es una de las caracter√≠sticas definitorias de los tipos condicionales en TypeScript. No entender la distributividad es una de las mayores fuentes de confusi√≥n. Si alguna vez un tipo condicional te da un resultado que no esperas, lo primero que debes preguntarte es: "¬øSe est√° distribuyendo sobre una uni√≥n?".

---

## H - Evitando la Distribuci√≥n: "¬°Todos Juntos Ahora!" üü°

#### 1. **Introducci√≥n:**

A veces, el comportamiento distributivo del **Concepto G** no es lo que queremos, y necesitamos una forma de decirle a TypeScript que trate a la uni√≥n de tipos como una sola unidad.

#### 2. **Ejemplo:**

Recordemos nuestro tipo `ToArray` del concepto anterior, que distribu√≠a:
`type StrArrOrNumArr = ToArray<string | number>; // Resultado: string[] | number[]`

Ahora, ¬øc√≥mo obtenemos `(string | number)[]`?

**La Soluci√≥n: Envolver los Tipos en Corchetes `[]`**

```typescript
// La √∫nica diferencia son los corchetes alrededor de 'Type' y 'any'.
type ToArrayNonDist<Type> = [Type] extends [any] ? Type[] : never;

// ¬°Ahora le pasamos la misma uni√≥n!
type ArrOfStrOrNum = ToArrayNonDist<string | number>;
// RESULTADO: (string | number)[]
```

**Explicaci√≥n del ejemplo:**
Al envolver el tipo gen√©rico `Type` y el tipo contra el que se comprueba `any` entre corchetes (`[Type] extends [any]`), le estamos dando una pista a TypeScript. Le decimos: "Oye, no mires a `Type` directamente. Quiero que mires a esta tupla que contiene a `Type`".

Como el tipo que se comprueba ya no es un par√°metro gen√©rico "desnudo", sino `[Type]`, TypeScript desactiva el comportamiento distributivo. Trata a `string | number` como una sola unidad, y el resultado es un array de esa unidad: `(string | number)[]`.

#### 3. **Desarrollo**:

**Cara a Cara: Distributivo vs. No Distributivo**

| Comportamiento                 | ¬øCu√°ndo usarlo?                                                                                                                                                      | Ejemplo de Resultado para `string | number`    |
| :----------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------- | ---------- |
| **Distributivo (por defecto)** | Cuando quieres operar en **cada miembro** de la uni√≥n de forma individual. Ideal para filtrar (`Exclude`), mapear (`ToArray`) o transformar cada parte de una uni√≥n. | `string[]                         | number[]`  |
| **No Distributivo (con `[]`)** | Cuando quieres tratar a la **uni√≥n completa** como una sola entidad. √ötil cuando la uni√≥n en s√≠ misma es el tipo que te interesa y no sus partes constituyentes.     | `(string                          | number)[]` |

Esta es una t√©cnica crucial. Saber c√≥mo activar o desactivar la distributividad te da un control total sobre c√≥mo se comportan tus tipos condicionales, permiti√©ndote modelar l√≥gicas de tipo muy precisas.

üü° **Importante**: Saber c√≥mo detener la distribuci√≥n es tan importante como saber que existe. Es el interruptor que te da el control. Si alguna vez necesitas que un tipo condicional opere sobre `A | B` como un todo en lugar de sobre `A` y `B` por separado, este truco de los corchetes es tu salvaci√≥n.
