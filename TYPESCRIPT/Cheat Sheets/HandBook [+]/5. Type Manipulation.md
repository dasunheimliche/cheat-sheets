## A - Gen√©ricos (Generics): Creando "plantillas" para tus tipos üî¥

#### 1. **Introducci√≥n:**

Los gen√©ricos te permiten crear funciones, clases o interfaces que no se casan con un solo tipo, sino que pueden trabajar con cualquiera que t√∫ decidas al momento de usarlos.

#### 2. **Ejemplo:**

Imagina que quieres meter cosas en una caja. A veces meter√°s un n√∫mero, a veces un texto. No quieres fabricar una "caja para n√∫meros" y una "caja para texto". ¬°Quieres una "caja" y punto!

```typescript
// <T> es como decirle: "Aqu√≠ va a ir un tipo, pero a√∫n no s√© cu√°l. Lo llamaremos 'T' por ahora".
function meterEnCaja<T>(objeto: T): { contenido: T } {
  return { contenido: objeto };
}

// TypeScript es listo. Si le pasas un n√∫mero, sabe que T es 'number'.
let cajaDeNumero = meterEnCaja(10);
// Ahora, cajaDeNumero es de tipo: { contenido: number }

// Si le pasas un string, sabe que T es 'string'.
let cajaDeTexto = meterEnCaja("Hola, mundo");
// Ahora, cajaDeTexto es de tipo: { contenido: string }
```

**Explicaci√≥n del ejemplo:**
Piensa en `<T>` como un marcador de posici√≥n, una especie de variable ¬°pero para tipos! Cuando llamas a `meterEnCaja(10)`, TypeScript ve el `10` y dice: "¬°Aj√°! El tipo que el programador quiere usar aqu√≠ es `number`. Reemplazar√© todas las `T` con `number`". As√≠, la funci√≥n devuelve un objeto `{ contenido: number }`. Lo mismo pasa con `"Hola, mundo"`, que se convierte en `{ contenido: string }`. ¬°La misma funci√≥n, m√∫ltiples tipos, cero problemas y m√°xima seguridad!

#### 3. **Desarrollo**:

La alternativa sin gen√©ricos ser√≠a usar el tipo `any`, pero eso es como desactivar todas las alarmas de seguridad de tu casa. Si usaras `any`, TypeScript no se quejar√≠a si intentas sumar un texto con un n√∫mero que sacaste de la caja. Los gen√©ricos te dan la flexibilidad de `any` pero con toda la seguridad de los tipos de TypeScript. Mantienen la relaci√≥n entre lo que entra y lo que sale. Si metes un `number`, sabes que sacar√°s un `number`.

üî¥ **Fundamental**: No puedes vivir sin ellos en TypeScript. Son la base para trabajar con arrays (`Array<string>`), promesas (`Promise<Response>`) y pr√°cticamente cualquier librer√≠a o framework moderno. Entenderlos no es opcional, es la llave para usar TypeScript de verdad.

---

## B - El Operador `keyof`: Obteniendo las "llaves" de un tipo üü°

#### 1. **Introducci√≥n:**

El operador `keyof` inspecciona un tipo de objeto y crea un nuevo tipo que es, literalmente, una lista de los nombres de sus propiedades (sus "llaves").

#### 2. **Ejemplo:**

Imagina que tienes la ficha de un personaje de un videojuego. `keyof` te da una lista de todas las estad√≠sticas que puedes consultar en esa ficha.

```typescript
interface Personaje {
  nombre: string;
  nivel: number;
  clase: "Guerrero" | "Mago";
  estaActivo: boolean;
}

// 'keyof Personaje' crea un tipo que SOLO puede ser "nombre", "nivel", "clase" o "estaActivo".
type PropiedadesDelPersonaje = keyof Personaje;

let miPropiedad: PropiedadesDelPersonaje;

miPropiedad = "nombre"; // ¬°Correcto!
miPropiedad = "nivel"; // ¬°Correcto!
// miPropiedad = "vida";    // ¬°ERROR! 'vida' no es una de las llaves del tipo Personaje.
```

**Explicaci√≥n del ejemplo:**
`keyof Personaje` no te da los valores (`"Gandalf"`, `20`, `"Mago"`), te da los _nombres de las propiedades_ en formato de tipo. El resultado, `PropiedadesDelPersonaje`, es un tipo uni√≥n de literales de string: `"nombre" | "nivel" | "clase" | "estaActivo"`. Esto te obliga a que cualquier variable de este tipo _deba_ ser uno de esos cuatro strings, protegi√©ndote de errores tontos como escribir mal el nombre de una propiedad.

#### 3. **Desarrollo**:

Este operador es el mejor amigo de los gen√©ricos. Se usa much√≠simo para crear funciones que manipulan objetos sin saber de antemano qu√© objeto es, pero asegurando que solo se acceder√° a propiedades que realmente existen. Por ejemplo, una funci√≥n `obtenerPropiedad(obj, key)` puede usar `keyof` para garantizar que la `key` que le pasas es una propiedad v√°lida del `obj`.

üü° **Importante**: Aunque quiz√°s no lo escribas todos los d√≠as al principio, es crucial para entender c√≥mo funcionan muchas utilidades de TypeScript y para escribir c√≥digo gen√©rico y reutilizable que sea 100% seguro.

---

## C - El Operador `typeof`: Espiando el tipo de un valor üîµ

#### 1. **Introducci√≥n:**

El operador `typeof` de TypeScript te permite capturar la "forma" (el tipo) de una variable o constante que ya existe en tu c√≥digo.

#### 2. **Ejemplo:**

Supongamos que tienes un objeto de configuraci√≥n definido en un sitio. No quieres volver a escribir su tipo a mano en otro sitio. ¬°Simplemente le pides a TypeScript que lo copie por ti!

```typescript
// Imagina que este objeto lo define una librer√≠a o viene de una API.
const configuracionInicial = {
  servidor: "https://miapi.com",
  intentosDeReconexion: 5,
  usarCache: true,
};

// Usamos 'typeof' para crear un tipo que coincide EXACTAMENTE con la forma del objeto.
type TipoDeConfiguracion = typeof configuracionInicial;

/*
Autom√°gicamente, TipoDeConfiguracion ahora es:
{
  servidor: string;
  intentosDeReconexion: number;
  usarCache: boolean;
}
*/

// Ahora puedes usar este tipo para asegurar que otros objetos cumplan el contrato.
const otraConfig: TipoDeConfiguracion = {
  servidor: "https://otroapi.com",
  intentosDeReconexion: 3,
  usarCache: false,
}; // ¬°Perfecto!
```

**Explicaci√≥n del ejemplo:**
**¬°CUIDADO! No confundir con el `typeof` de JavaScript.** El `typeof` de JavaScript se ejecuta en tiempo de ejecuci√≥n y te devuelve un string como `"string"`, `"number"` u `"object"`. El `typeof` de TypeScript se usa en el _mundo de los tipos_ (antes de que el c√≥digo se ejecute) y te da el tipo estructural completo de la variable. Es una herramienta para no repetirnos (principio DRY: Don't Repeat Yourself).

#### 3. **Desarrollo**:

Es especialmente √∫til cuando trabajas con constantes o valores que vienen de fuera de tu control (como un objeto JSON importado) y quieres crear tipos basados en ellos sin tener que mantener dos fuentes de verdad (el valor y la definici√≥n del tipo). Si el objeto original cambia (por ejemplo, se a√±ade una nueva propiedad), TypeScript te avisar√° si otros objetos que usan su tipo no se actualizan.

üîµ **Espec√≠fico**: No lo usar√°s tan a menudo como una `interface`, pero es una herramienta fant√°stica para situaciones concretas, especialmente para derivar tipos de constantes y asegurar la sincronizaci√≥n entre valores y tipos.

---

## D - Tipos de Acceso Indexado (Indexed Access Types): "Buceando" dentro de un tipo üü°

#### 1. **Introducci√≥n:**

Los tipos de acceso indexado te permiten "extraer" el tipo de una propiedad espec√≠fica que est√° anidada dentro de otro tipo, usando la sintaxis de corchetes `[]` que ya conoces de JavaScript.

#### 2. **Ejemplo:**

Siguiendo con la ficha del personaje, ¬øy si solo te interesa saber de qu√© tipo es el `nivel`? ¬øO el tipo del `oro` que est√° dentro del `inventario`?

```typescript
interface Personaje {
  nombre: string;
  nivel: number;
  habilidades: string[];
  inventario: {
    oro: number;
    pociones: number;
  };
}

// Extraemos el tipo de la propiedad 'nivel'
type TipoDelNivel = Personaje["nivel"]; // El tipo es: number

// Tambi√©n funciona con propiedades anidadas
type TipoDelInventario = Personaje["inventario"]; // El tipo es: { oro: number; pociones: number; }
type TipoDelOro = Personaje["inventario"]["oro"]; // El tipo es: number

// Incluso puedes obtener el tipo de los elementos de un array
type TipoDeHabilidad = Personaje["habilidades"][number]; // El tipo es: string
```

**Explicaci√≥n del ejemplo:**
F√≠jate bien: `Personaje["nivel"]` no te da el _valor_ del nivel, sino el _tipo_ (`number`). Es como si le preguntaras a TypeScript: "Oye, en el tipo `Personaje`, si alguien accede a la propiedad `nivel`, ¬øqu√© tipo de dato deber√≠a esperar?". La parte de `[number]` para el array es un truco genial: como los arrays se acceden con un √≠ndice num√©rico, `[number]` te da el tipo de los elementos que contiene el array.

#### 3. **Desarrollo**:

Esta t√©cnica es el pan de cada d√≠a cuando se combina con `keyof` y gen√©ricos. Permite crear tipos que son din√°micamente dependientes de otros. Por ejemplo, puedes tener una funci√≥n gen√©rica que toma un objeto y el nombre de una de sus propiedades, y gracias a los tipos de acceso indexado, TypeScript sabr√° exactamente qu√© tipo de valor devolver√° esa funci√≥n.

üü° **Importante**: Es una t√©cnica de manipulaci√≥n de tipos muy com√∫n. Entenderla es clave para leer y escribir c√≥digo TypeScript avanzado y para aprovechar al m√°ximo la inferencia de tipos del lenguaje.

---

## E - Tipos Condicionales (Conditional Types): `if/else` para tus tipos üîµ

#### 1. **Introducci√≥n:**

Los tipos condicionales te permiten crear un tipo que puede ser una cosa u otra, dependiendo de si una condici√≥n sobre otro tipo se cumple, usando una sintaxis que se parece mucho a un operador ternario.

#### 2. **Ejemplo:**

Imagina que quieres crear un tipo que te diga si algo es "simple" o "complejo". Si es un `string` o un `number`, es simple. Si es un `object`, es complejo.

```typescript
// La sintaxis es: AlgunTipo extends OtroTipo ? TipoSiVerdadero : TipoSiFalso;
type Complejidad<T> = T extends string | number ? "Simple" : "Complejo";

// Vamos a probarlo:
type ComplejidadDeUnString = Complejidad<string>; // El tipo resultante es "Simple"
type ComplejidadDeUnNumero = Complejidad<number>; // El tipo resultante es "Simple"
type ComplejidadDeUnObjeto = Complejidad<{ id: number }>; // El tipo resultante es "Complejo"
type ComplejidadDeUnArray = Complejidad<boolean[]>; // El tipo resultante es "Complejo"
```

**Explicaci√≥n del ejemplo:**
Lee la l√≠nea `type Complejidad<T> = ...` como una pregunta: "El tipo `T` que me pasen, ¬øse puede asignar a (`extends`) un `string` o un `number`?".

- Si la respuesta es s√≠ (como cuando pasamos `string`), el tipo resultante es `"Simple"`.
- Si la respuesta es no (como cuando pasamos `{ id: number }`), el tipo resultante es `"Complejo"`.

Es literalmente una estructura `if/else` para tus tipos.

#### 3. **Desarrollo**:

Aunque parezca algo muy abstracto, los tipos condicionales son el motor de muchas de las utilidades m√°s poderosas de TypeScript (como `Exclude<T, U>`, que quita tipos de una uni√≥n, o `NonNullable<T>`, que quita `null` y `undefined`). No los escribir√°s todos los d√≠as, pero entender c√≥mo funcionan te abrir√° los ojos a un nuevo nivel de programaci√≥n con tipos.

üîµ **Espec√≠fico**: Esta es una herramienta avanzada. No necesitas dominarla al empezar, pero es bueno saber que existe. Cuando te encuentres en una situaci√≥n donde un tipo necesita cambiar dr√°sticamente basado en una entrada, te acordar√°s de esto.

---

## F - Tipos Mapeados (Mapped Types): Transformando propiedades en masa üü°

#### 1. **Introducci√≥n:**

Los tipos mapeados crean un nuevo tipo recorriendo todas las propiedades de un tipo existente y aplic√°ndoles una transformaci√≥n, como hacerlas opcionales o de solo lectura.

#### 2. **Ejemplo:**

Tienes tu `interface Personaje`, pero para el formulario de creaci√≥n, quieres que todas las propiedades sean opcionales. Y para mostrar los datos, quieres que todas sean de solo lectura para que no se puedan modificar por error.

```typescript
interface Personaje {
  nombre: string;
  nivel: number;
}

// Tipo Mapeado para hacer todas las propiedades opcionales
type PersonajeOpcional = {
  [Propiedad in keyof Personaje]?: Personaje[Propiedad];
};
// Resultado: { nombre?: string; nivel?: number; }

// Tipo Mapeado para hacer todas las propiedades de solo lectura
type PersonajeDeSoloLectura = {
  readonly [Propiedad in keyof Personaje]: Personaje[Propiedad];
};
// Resultado: { readonly nombre: string; readonly nivel: number; }
```

**Explicaci√≥n del ejemplo:**
Vamos a desglosar la sintaxis `[Propiedad in keyof Personaje]`:

1.  `keyof Personaje`: Como vimos en el **punto B**, esto nos da `"nombre" | "nivel"`.
2.  `in`: Act√∫a como un bucle `for...in`, iterando sobre cada string del paso 1.
3.  `Propiedad`: Es la variable del bucle. En la primera vuelta es `"nombre"`, en la segunda es `"nivel"`.
4.  `?`: En `PersonajeOpcional`, el `?` hace que la propiedad sea opcional.
5.  `readonly`: En `PersonajeDeSoloLectura`, `readonly` la hace de solo lectura.
6.  `: Personaje[Propiedad]`: Como vimos en el **punto D**, esto busca el tipo original de la propiedad que estamos iterando.

B√°sicamente, le est√°s diciendo a TypeScript: "Para cada propiedad del `Personaje` original, cr√©ame una nueva propiedad con el mismo nombre y el mismo tipo, pero a√±√°dele este modificador (`?` o `readonly`)".

#### 3. **Desarrollo**:

Esta es una de las caracter√≠sticas m√°s potentes y que m√°s trabajo ahorran en TypeScript. Es la magia detr√°s de utilidades integradas como `Partial<T>`, `Readonly<T>`, `Pick<T, K>` y `Omit<T, K>`. En lugar de usar nuestros tipos mapeados caseros del ejemplo, normalmente usar√≠as `Partial<Personaje>` y `Readonly<Personaje>`. Saber c√≥mo funcionan por dentro te hace un programador mucho m√°s competente.

üü° **Importante**: Entender el concepto es crucial. Aunque a menudo uses las utilidades ya hechas (`Partial`, `Readonly`), saber que funcionan gracias a los tipos mapeados te permite crear tus propias transformaciones personalizadas cuando las necesites.

---

## G - Tipos de Plantillas Literales (Template Literal Types): Creando tipos con "f-strings" üîµ

#### 1. **Introducci√≥n:**

Los tipos de plantillas literales te permiten construir nuevos tipos de string combinando otros tipos, de una forma muy parecida a como funcionan las plantillas literales (template strings) en JavaScript.

#### 2. **Ejemplo:**

Imagina que en tu aplicaci√≥n tienes m√°rgenes (`margin`) y rellenos (`padding`), y para cada uno, puedes especificar la direcci√≥n (`top`, `bottom`, `left`, `right`). Quieres crear un tipo que represente todas las posibles clases CSS que podr√≠as generar.

```typescript
type PropiedadCSS = "margin" | "padding";
type Direccion = "Top" | "Bottom" | "Left" | "Right";

// Usamos la sintaxis de plantilla literal para combinar los tipos
type ClaseCSS = `${PropiedadCSS}${Direccion}`;

/*
El tipo 'ClaseCSS' ahora es una uni√≥n de todas las combinaciones posibles:
"marginTop" | "marginBottom" | "marginLeft" | "marginRight" |
"paddingTop" | "paddingBottom" | "paddingLeft" | "paddingRight"
*/

let miClase: ClaseCSS = "paddingTop"; // ¬°Correcto!
// let otraClase: ClaseCSS = "padding-top"; // ¬°ERROR! No coincide con el formato.
```

**Explicaci√≥n del ejemplo:**
La sintaxis `` `${PropiedadCSS}${Direccion}` `` le dice a TypeScript: "Toma cada string posible de `PropiedadCSS`, y por cada uno de ellos, p√©gale al final cada string posible de `Direccion`". El resultado es un nuevo tipo uni√≥n con todas las 8 combinaciones. Esto te da un autocompletado incre√≠ble en tu editor y previene errores de tipeo en nombres de clases, eventos, etc.

#### 3. **Desarrollo**:

Esta es una caracter√≠stica m√°s moderna y es extremadamente poderosa para crear APIs muy descriptivas y seguras. Se puede usar para validar rutas de API, nombres de eventos (`user:created`, `post:deleted`), o para transformar las llaves de un objeto (combinado con tipos mapeados, puedes renombrar `nombre` a `getNombre`).

üîµ **Espec√≠fico**: Es una herramienta avanzada pero incre√≠blemente √∫til en dominios espec√≠ficos como el desarrollo de UI, librer√≠as o SDKs. No es algo que necesites para empezar, pero cuando te enfrentes al problema de manejar conjuntos grandes y predecibles de strings, esta ser√° tu arma secreta.
