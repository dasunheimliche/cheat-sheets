## A - El tipo `never` en TypeScript

#### 1. **Definicion:**

El tipo `never` en TypeScript representa un estado que **nunca deber√≠a ocurrir**. Imagina una funci√≥n que siempre lanza un error o que entra en un bucle infinito; en esos casos, la funci√≥n "nunca" retorna un valor normalmente. El tipo de retorno para estas funciones ser√≠a `never`. En el contexto de Type Narrowing, `never` aparece cuando TypeScript reduce las posibilidades de un tipo de uni√≥n hasta que **no quedan opciones posibles**. Es como llegar a un punto muerto en el proceso de narrowing.

#### 2. **Caracter√≠sticas clave de `never`:**

- **Asignable a todos los tipos:** Puedes asignar un valor de tipo `never` a cualquier otro tipo. (Aunque en la pr√°ctica, no hay "valores" de tipo `never` que puedas usar).
- **Ning√∫n tipo es asignable a `never` (excepto `never` mismo):** No puedes asignar ning√∫n valor de otro tipo (excepto `never` mismo) a una variable de tipo `never`. Esto refuerza la idea de que `never` representa algo que no deber√≠a tener un valor concreto.

#### 3. **Ejemplo (conceptual):**

```typescript
function lanzarError(mensaje: string): never {
  throw new Error(mensaje);
  // La funci√≥n NUNCA retorna normalmente, siempre lanza un error.
}

function bucleInfinito(): never {
  while (true) {
    // Bucle que NUNCA termina.
  }
  // La funci√≥n NUNCA retorna normalmente, entra en un bucle infinito.
}

let algo: string = lanzarError("¬°Esto es un error!"); // ‚úÖ No hay error de tipo, 'never' es asignable a 'string'
// let otraCosa: never = "hola"; // üö® Error: ¬°'string' no es asignable a 'never'!
```

**Explicaci√≥n del ejemplo:**

- `lanzarError` y `bucleInfinito` son funciones que nunca terminan de forma normal. Su tipo de retorno es `never`.
- Puedes asignar el resultado de `lanzarError` a una variable de tipo `string` (porque `never` es asignable a todos los tipos).
- Pero no puedes asignar una cadena de texto a una variable de tipo `never` (porque ning√∫n tipo, excepto `never` mismo, es asignable a `never`).

#### 4. **Notas o advertencias:**

- `never` puede parecer un tipo extra√±o al principio, pero es √∫til para representar situaciones donde algo no deber√≠a suceder o donde una funci√≥n no deber√≠a retornar normalmente.
- En Type Narrowing, `never` se usa principalmente para la "verificaci√≥n de exhaustividad" (ver el siguiente concepto).

## B - Exhaustiveness Checking (Verificaci√≥n de Exhaustividad) con `never`

#### 1. **Definicion:**

"Exhaustiveness Checking" (Verificaci√≥n de Exhaustividad) es una t√©cnica que usa el tipo `never` para asegurarse de que has manejado **todos los casos posibles** en una Discriminated Union, especialmente dentro de un `switch` statement. Al intentar asignar el valor de la variable de uni√≥n a una variable de tipo `never` en el caso `default` de un `switch`, TypeScript puede detectar si has olvidado alg√∫n caso. Si has manejado todos los casos, el tipo se estrechar√° a `never` en el `default`, y no habr√° error. Pero si olvidas un caso, el tipo en el `default` no ser√° `never`, y TypeScript te dar√° un error, ¬°avis√°ndote de que te falta manejar un caso!

#### 2. **Ejemplo con `Shape` y `never` en `default`:**

```typescript
type Shape = Circle | Square; // Discriminated Union (definida en ejemplos anteriores)

function getAreaExhaustive(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.sideLength ** 2;
    default:
      // Verificaci√≥n de exhaustividad:
      const _exhaustiveCheck: never = shape; // üëà Intentamos asignar 'shape' a 'never'
      return _exhaustiveCheck;
  }
}
```

**Explicaci√≥n del ejemplo:**

- En el `default` del `switch`, creamos una variable `_exhaustiveCheck` de tipo `never`.
- Intentamos asignar `shape` a `_exhaustiveCheck`: `const _exhaustiveCheck: never = shape;`.
- **Si hemos cubierto todos los casos de `shape.kind` (`"circle"` y `"square"`) en los `case` anteriores, entonces _no habr√° ning√∫n valor posible para `shape` que llegue al `default`_. En ese caso, TypeScript entender√° que en el `default`, el tipo de `shape` se ha estrechado a `never`, y la asignaci√≥n `const _exhaustiveCheck: never = shape;` **no causar√° error**. ¬°Todo est√° bien, hemos sido exhaustivos!**

#### 3. **Ejemplo: Olvidando un caso (y viendo el error):**

```typescript
interface Triangle {
  kind: "triangle";
  sideLength: number;
}
type Shape = Circle | Square | Triangle; // üí° Agregamos 'Triangle' a la uni√≥n

function getAreaIncompleta(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.sideLength ** 2;
    default:
      const _exhaustiveCheck: never = shape; // üö® Error de TypeScript!
      // Type 'Triangle' is not assignable to type 'never'.
      return _exhaustiveCheck;
  }
}
```

**Explicaci√≥n del ejemplo del error:**

- Agregamos un nuevo tipo `Triangle` a la uni√≥n `Shape`.
- Pero **olvidamos** agregar un `case "triangle":` en el `switch` de `getAreaIncompleta`.
- Ahora, cuando TypeScript llega al `default`, se da cuenta de que **todav√≠a hay un tipo posible para `shape` que no se ha manejado: `Triangle`**. Por lo tanto, en el `default`, el tipo de `shape` **no es `never`**, ¬°es `Triangle`!
- Como `Triangle` no es asignable a `never`, TypeScript da un **error**: `Type 'Triangle' is not assignable to type 'never'`. **¬°Este error nos avisa que hemos olvidado manejar el caso `Triangle` en nuestro `switch`!**

#### 4. **Notas o advertencias:**

- La verificaci√≥n de exhaustividad con `never` es una t√©cnica muy √∫til para hacer tu c√≥digo m√°s robusto y prevenir errores al trabajar con Discriminated Unions.
- Te ayuda a asegurarte de que has considerado todos los posibles tipos en tu uni√≥n, especialmente cuando agregas nuevos tipos en el futuro.
- Usar `const _exhaustiveCheck: never = shape;` en el `default` de un `switch` es una forma idiom√°tica de activar la verificaci√≥n de exhaustividad en TypeScript.
- Si no quieres usar `never`, TypeScript tambi√©n puede darte un error si no manejas todos los casos en un `switch` sobre una Discriminated Union, dependiendo de la configuraci√≥n de tu compilador (especialmente con la opci√≥n `strict: true`). Pero usar `never` en el `default` es una forma m√°s expl√≠cita y segura de lograr la verificaci√≥n de exhaustividad.
