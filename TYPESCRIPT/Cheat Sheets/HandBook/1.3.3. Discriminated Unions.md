## A - Problema con Uniones Simples para Representar Formas

#### 1. **Definicion:**

Cuando intentamos representar diferentes tipos de objetos que comparten algunas propiedades pero tambi√©n tienen propiedades √∫nicas, usar una uni√≥n simple con propiedades opcionales puede ser problem√°tico. TypeScript no siempre puede entender qu√© propiedades est√°n disponibles en cada caso, incluso si usamos una propiedad "discriminante" como `kind`.

#### 2. **Ejemplo (Primer intento fallido):**

```typescript
interface Shape {
  kind: "circle" | "square";
  radius?: number;
  sideLength?: number;
}

function getArea(shape: Shape) {
  return Math.PI * shape.radius ** 2; // üö® Error: 'shape.radius' podr√≠a ser 'undefined'
}
```

**Explicaci√≥n del ejemplo:**

- Definimos `Shape` como una interfaz donde `kind` puede ser `"circle"` o `"square"`. `radius` y `sideLength` son opcionales (`?`).
- En `getArea`, intentamos calcular el √°rea de un c√≠rculo usando `shape.radius`.
- **Error:** TypeScript se queja porque `shape.radius` es _opcional_. Incluso si sabemos que si `shape.kind` es `"circle"`, _deber√≠a_ tener `radius`, TypeScript no es lo suficientemente "inteligente" para deducirlo autom√°ticamente con esta definici√≥n.

#### 3. **Notas o advertencias:**

- Usar propiedades opcionales en uniones simples puede llevar a errores porque TypeScript no puede garantizar que una propiedad exista en un caso espec√≠fico de la uni√≥n.
- Aunque usemos `kind` para indicar el tipo de forma, TypeScript no relaciona autom√°ticamente `kind: "circle"` con la presencia de `radius`.

## B - Definiendo Formas con Interfaces Separadas

#### 1. **Definicion:**

Una mejor manera de representar diferentes tipos de objetos con propiedades espec√≠ficas es definir interfaces separadas para cada tipo. Luego, podemos usar una uni√≥n de estas interfaces para representar el tipo general. Esto permite que TypeScript entienda mejor qu√© propiedades est√°n disponibles para cada tipo espec√≠fico.

#### 2. **Ejemplo (Definici√≥n mejorada):**

```typescript
interface Circle {
  kind: "circle";
  radius: number; // ‚úÖ 'radius' es REQUERIDO para 'Circle'
}

interface Square {
  kind: "square";
  sideLength: number; // ‚úÖ 'sideLength' es REQUERIDO para 'Square'
}

type Shape = Circle | Square; // ‚úÖ 'Shape' es la uni√≥n de 'Circle' y 'Square'
```

**Explicaci√≥n del ejemplo:**

- Definimos `Circle` e `Square` como interfaces separadas.
- En `Circle`, `radius` es **requerido** (`radius: number;`). Igual para `sideLength` en `Square`.
- `Shape` es ahora una uni√≥n de `Circle` y `Square`.
- **Ventaja:** Ahora, TypeScript sabe que si algo es de tipo `Circle`, _siempre_ tendr√° la propiedad `radius`, y si es `Square`, _siempre_ tendr√° `sideLength`.

#### 3. **Notas o advertencias:**

- Esta forma de definir tipos es m√°s clara y precisa.
- TypeScript puede hacer un mejor Type Narrowing con uniones de interfaces separadas.
- Usar tipos literales de cadena para la propiedad `kind` (`"circle"`, `"square"`) es clave para las "Discriminated Unions".

## C - ¬øQu√© es una "Discriminated Union" (Uni√≥n Discriminada)?

#### 1. **Definicion:**

Una "Discriminated Union" (Uni√≥n Discriminada) es un patr√≥n en TypeScript donde tienes una uni√≥n de tipos, y cada tipo en la uni√≥n tiene una propiedad **com√∫n** (llamada "discriminante") que usa **tipos literales** (como cadenas literales o n√∫meros literales) para indicar de qu√© tipo espec√≠fico se trata. TypeScript puede usar esta propiedad discriminante para estrechar el tipo a un miembro espec√≠fico de la uni√≥n.

#### 2. **Ejemplo ( `Shape` como Discriminated Union):**

En nuestro ejemplo de `Shape`:

- La uni√≥n `Shape = Circle | Square` es una Discriminated Union.
- La propiedad **com√∫n** es `kind`.
- Los **tipos literales** para `kind` son `"circle"` en `Circle` y `"square"` en `Square`.

**Explicaci√≥n del ejemplo:**

La clave para que TypeScript reconozca una Discriminated Union es:

1.  **Uni√≥n de tipos:** Tienes un tipo que es la uni√≥n de varios otros tipos (ej. `Circle | Square`).
2.  **Propiedad Discriminante Com√∫n:** Todos los tipos en la uni√≥n comparten una propiedad con el mismo nombre (ej. `kind`).
3.  **Tipos Literales en la Discriminante:** El tipo de la propiedad discriminante es un tipo literal (cadena literal, n√∫mero literal, etc.) diferente para cada tipo en la uni√≥n (ej. `"circle"` y `"square"`).

#### 3. **Notas o advertencias:**

- Las Discriminated Unions son muy poderosas para modelar datos donde tienes diferentes "variantes" o "casos".
- La propiedad discriminante act√∫a como una "etiqueta" que le dice a TypeScript de qu√© tipo espec√≠fico se trata.
- TypeScript puede usar esta "etiqueta" para hacer Type Narrowing de forma autom√°tica y segura.

## D - Type Narrowing con Discriminated Unions

#### 1. **Definicion:**

Cuando trabajas con una Discriminated Union, TypeScript puede usar la propiedad discriminante para estrechar el tipo a un miembro espec√≠fico de la uni√≥n dentro de bloques `if` o `switch`. Al verificar el valor de la propiedad discriminante, TypeScript sabe qu√© tipo espec√≠fico de la uni√≥n est√°s manejando y puede acceder a sus propiedades espec√≠ficas de forma segura.

#### 2. **Ejemplo con `if` y Discriminated Union `Shape`:**

```typescript
function getAreaCircle(shape: Shape) {
  if (shape.kind === "circle") {
    // üëà Comprobaci√≥n de la propiedad discriminante 'kind'
    return Math.PI * shape.radius ** 2; // ‚úÖ ¬°Funciona! TypeScript sabe que 'shape' es 'Circle' aqu√≠
  }
  // ... (manejar otros tipos de Shape)
}
```

**Explicaci√≥n del ejemplo:**

- `if (shape.kind === "circle")`: Al comparar `shape.kind` con el tipo literal `"circle"`, TypeScript es lo suficientemente inteligente para entender que _dentro del `if`_, `shape` debe ser de tipo `Circle`.
- Como TypeScript sabe que `shape` es `Circle`, permite acceder a `shape.radius` sin error, porque `radius` es una propiedad **requerida** en la interfaz `Circle`.

#### 3. **Ejemplo con `switch` y Discriminated Union `Shape`:**

```typescript
function getAreaSwitch(shape: Shape) {
  switch (
    shape.kind // üëà 'switch' en la propiedad discriminante 'kind'
  ) {
    case "circle":
      return Math.PI * shape.radius ** 2; // ‚úÖ TypeScript sabe que 'shape' es 'Circle' aqu√≠
    case "square":
      return shape.sideLength ** 2; // ‚úÖ TypeScript sabe que 'shape' es 'Square' aqu√≠
    // No necesitamos 'default' si cubrimos todos los casos de 'kind'
  }
}
```

**Explicaci√≥n del ejemplo:**

- `switch (shape.kind)`: Usar un `switch` en la propiedad discriminante `kind` tambi√©n permite a TypeScript hacer Type Narrowing.
- `case "circle":`: Dentro de este `case`, TypeScript estrecha el tipo de `shape` a `Circle`, permitiendo acceder a `shape.radius`.
- `case "square":`: Dentro de este `case`, TypeScript estrecha el tipo de `shape` a `Square`, permitiendo acceder a `shape.sideLength`.

#### 4. **Notas o advertencias:**

- El Type Narrowing con Discriminated Unions es muy seguro y legible.
- TypeScript te ayuda a escribir c√≥digo m√°s robusto y sin errores al entender la estructura de tus datos.
- Usar `switch` con Discriminated Unions puede ayudar a evitar errores de "fall-through" accidental en los `case` (si olvidas un `break` en JavaScript puro).

## E - Beneficios y Usos de Discriminated Unions

#### 1. **Definicion:**

Las Discriminated Unions ofrecen varios beneficios importantes en TypeScript, incluyendo mayor seguridad de tipos, c√≥digo m√°s claro y legible, y la capacidad de modelar estructuras de datos complejas de forma efectiva. Son √∫tiles en muchas situaciones donde necesitas representar diferentes tipos de "mensajes", "eventos", "estados" o "variantes" de datos.

#### 2. **Beneficios Clave:**

- **Seguridad de Tipos:** TypeScript puede verificar que est√°s usando las propiedades correctas para cada tipo espec√≠fico en la uni√≥n, evitando errores en tiempo de ejecuci√≥n.
- **C√≥digo M√°s Claro:** La estructura de Discriminated Unions hace que tu c√≥digo sea m√°s f√°cil de entender, ya que la propiedad discriminante indica claramente de qu√© tipo se trata en cada caso.
- **Mantenibilidad:** Si necesitas agregar nuevos tipos a la uni√≥n, es f√°cil extender la Discriminated Union agregando una nueva interfaz y un nuevo caso en tus `switch` o `if` statements.
- **Refactorizaci√≥n Segura:** TypeScript te ayudar√° a detectar errores si cambias la estructura de tu Discriminated Union, asegurando que tu c√≥digo siga siendo correcto despu√©s de las modificaciones.

#### 3. **Ejemplos de Uso Com√∫n (m√°s all√° de formas):**

- **Comunicaci√≥n Cliente/Servidor:** Representar diferentes tipos de mensajes que se env√≠an entre el cliente y el servidor (ej. `MessageType: "request" | "response" | "error"`).
- **Gesti√≥n de Estado (State Management):** Modelar diferentes tipos de acciones o eventos que pueden cambiar el estado de una aplicaci√≥n (ej. `ActionType: "loadData" | "updateUser" | "submitForm"`).
- **M√°quinas de Estado (State Machines):** Representar los diferentes estados en los que puede estar una m√°quina de estado y los eventos que pueden causar transiciones entre estados.
- **Parsing de Datos:** Manejar diferentes formatos de datos que pueden venir de una API o un archivo (ej. `DataType: "json" | "xml" | "csv"`).

#### 4. **Notas o advertencias:**

- Las Discriminated Unions son una herramienta fundamental en TypeScript para escribir c√≥digo robusto y bien estructurado.
- Dominar este patr√≥n te permitir√° aprovechar al m√°ximo el sistema de tipos de TypeScript y evitar muchos errores comunes.
- Considera usar Discriminated Unions siempre que tengas una uni√≥n de tipos donde quieras distinguir entre los diferentes miembros de la uni√≥n de forma clara y segura.
