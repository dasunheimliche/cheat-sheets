## A - Truthiness Narrowing (Estrechamiento por Veracidad)

#### 1. **Definicion:**

"Truthiness" es una idea de JavaScript (no una palabra oficial, ¬°pero muy usada!) que se refiere a c√≥mo ciertos valores se consideran "verdaderos" o "falsos" en lugares donde se espera un valor booleano, como dentro de un `if`. TypeScript usa esta idea para hacer Type Narrowing. Si un valor se considera "verdadero" en JavaScript, TypeScript puede asumir que no es `null`, `undefined`, `0`, o una cadena vac√≠a, ¬°y estrechar su tipo!

#### 2. **Ejemplo:**

```typescript
function getUsersOnlineMessage(numUsersOnline: number) {
  if (numUsersOnline) {
    // üëà Truthiness check!
    return `Hay ${numUsersOnline} usuarios online ahora!`;
  }
  return "No hay nadie aqu√≠. :(";
}

console.log(getUsersOnlineMessage(5)); // Output: Hay 5 usuarios online ahora!
console.log(getUsersOnlineMessage(0)); // Output: No hay nadie aqu√≠. :(
```

**Explicaci√≥n del ejemplo:**

- En JavaScript, y TypeScript, el n√∫mero `0` se considera "falsy" (falso en un contexto booleano), mientras que cualquier otro n√∫mero (como `5`) se considera "truthy" (verdadero).
- En el `if (numUsersOnline)`, TypeScript sabe que si el c√≥digo entra dentro del `if`, es porque `numUsersOnline` es "truthy", lo que significa que _no_ es `0`, `null`, `undefined`, etc. Aunque en este ejemplo, `numUsersOnline` ya era `number`, en otros casos, si fuera un tipo m√°s amplio (ej. `number | null`), TypeScript lo estrechar√≠a dentro del `if` a solo `number` (excluyendo `null` y otros falsy values).

#### 3. **Valores "falsy" en JavaScript:**

Estos valores siempre se consideran "falsos" en un contexto booleano:

- `0` (cero)
- `NaN` (Not a Number)
- `""` (cadena vac√≠a)
- `0n` (BigInt cero)
- `null`
- `undefined`
- `false` (obviamente)

**Cualquier otro valor es "truthy" (verdadero).**

#### 4. **Notas o advertencias:**

- Truthiness checking es muy com√∫n en JavaScript para verificar si un valor "existe" o tiene un valor significativo.
- TypeScript usa truthiness para hacer Type Narrowing, especialmente para descartar `null` y `undefined`.
- ¬°Ten cuidado! A veces, usar truthiness puede ser confuso. Por ejemplo, `0` es falsy, pero a veces `0` es un valor v√°lido que quieres manejar. En esos casos, es mejor usar comprobaciones m√°s expl√≠citas (como `valor !== null` o `valor !== undefined`).

## B - Estrechamiento por Igualdad (`Equality Narrowing`)

#### 1. **Definicion:**

TypeScript usa las comparaciones de igualdad (`===`, `!==`, `==`, `!=`) y las sentencias `switch` para hacer Type Narrowing. Cuando comparas si dos cosas son iguales (o no), TypeScript puede deducir que sus tipos tambi√©n deben ser iguales (o diferentes) en ciertas partes de tu c√≥digo.

#### 2. **Ejemplo con `===`:**

```typescript
function ejemploIgualdadEstricta(x: string | number, y: string | boolean) {
  if (x === y) {
    // üëà Comprobaci√≥n de igualdad estricta
    // Si 'x === y' es verdadero, TypeScript sabe que 'x' e 'y' deben tener el mismo tipo.
    // El √∫nico tipo que 'x' e 'y' pueden compartir es 'string'.
    x.toUpperCase(); // ‚úÖ ¬°Funciona! TypeScript sabe que 'x' es string aqu√≠
    y.toLowerCase(); // ‚úÖ ¬°Funciona! TypeScript sabe que 'y' es string aqu√≠
  } else {
    console.log(x); // 'x' sigue siendo 'string | number' aqu√≠
    console.log(y); // 'y' sigue siendo 'string | boolean' aqu√≠
  }
}
```

**Explicaci√≥n del ejemplo:**

- `x` puede ser `string` o `number`, e `y` puede ser `string` o `boolean`.
- `if (x === y)`: Si `x` es estrictamente igual a `y`, significa que deben ser del mismo valor _y_ del mismo tipo. Dado los tipos originales de `x` e `y`, la √∫nica posibilidad para que sean estrictamente iguales es que ambos sean de tipo `string`.
- Dentro del `if`, TypeScript estrecha el tipo de `x` e `y` a `string`. Por eso, puedes usar m√©todos de string como `toUpperCase()` y `toLowerCase()` sin error.
- En el `else`, TypeScript no puede estrechar los tipos, porque `x` e `y` no son iguales, as√≠ que mantienen sus tipos originales (`string | number` y `string | boolean`).

#### 3. **Ejemplo con `!== null`:**

```typescript
function printAllAgain(strs: string | string[] | null) {
  if (strs !== null) {
    // üëà Comprobaci√≥n de desigualdad con null
    // Si 'strs !== null' es verdadero, TypeScript sabe que 'strs' NO es null.
    if (typeof strs === "object") {
      for (const s of strs) {
        // ‚úÖ TypeScript sabe que 'strs' es string[] aqu√≠ (no null)
        console.log(s);
      }
    } else if (typeof strs === "string") {
      console.log(strs); // ‚úÖ TypeScript sabe que 'strs' es string aqu√≠ (no null)
    }
  }
}
```

**Explicaci√≥n del ejemplo:**

- `if (strs !== null)`: Esta comprobaci√≥n descarta la posibilidad de que `strs` sea `null`.
- Dentro del `if`, TypeScript estrecha el tipo de `strs` a `string | string[]` (eliminando `null`). Luego, las comprobaciones de `typeof` dentro del `if` hacen el resto del Type Narrowing (a `string[]` o `string`).

#### 4. **Ejemplo con `== null` (o `== undefined`):**

```typescript
interface Container {
  value: number | null | undefined;
}

function multiplyValue(container: Container, factor: number) {
  if (container.value != null) {
    // üëà Comprobaci√≥n con '!=' y 'null'
    // 'container.value != null' verifica si es NO es null NI undefined.
    // Si es verdadero, TypeScript sabe que 'container.value' es solo 'number'.
    console.log(container.value); // ‚úÖ TypeScript sabe que 'container.value' es number aqu√≠
    container.value *= factor; // ‚úÖ Operaci√≥n segura con n√∫mero
  }
}
```

**Explicaci√≥n del ejemplo:**

- `container.value != null`: En JavaScript, `== null` y `== undefined` son especiales. `valor == null` es verdadero si `valor` es `null` _o_ `undefined`. Lo mismo para `valor == undefined`. Y `valor != null` (o `valor != undefined`) es verdadero si `valor` _no_ es ni `null` ni `undefined`.
- En el `if (container.value != null)`, TypeScript entiende que si la condici√≥n es verdadera, `container.value` no puede ser ni `null` ni `undefined`. Por lo tanto, estrecha el tipo de `container.value` a solo `number`.

#### 5. **Notas o advertencias:**

- Las comparaciones de igualdad son herramientas muy √∫tiles para Type Narrowing.
- Recuerda la peculiaridad de `== null` y `== undefined` en JavaScript, que TypeScript tambi√©n tiene en cuenta para el narrowing.
- Usar `!== null` o `!== undefined` es una forma com√∫n de descartar expl√≠citamente valores nulos o indefinidos y permitir que TypeScript estreche los tipos.

## C - Estrechamiento con el operador `in`

#### 1. **Definicion:**

El operador `in` de JavaScript verifica si un objeto tiene una propiedad con un nombre espec√≠fico (directamente o en su prototipo). TypeScript usa el operador `in` como un Type Guard. Cuando usas `"propiedad" in objeto`, TypeScript puede estrechar el tipo de `objeto` bas√°ndose en si se espera que tenga o no esa propiedad.

#### 2. **Ejemplo:**

```typescript
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function moverAnimal(animal: Fish | Bird) {
  if ("swim" in animal) {
    // üëà Operador 'in' como Type Guard
    // Si '"swim" in animal' es verdadero, TypeScript asume que 'animal' es de tipo 'Fish'
    return animal.swim(); // ‚úÖ ¬°Funciona! TypeScript sabe que 'animal' es Fish aqu√≠
  }
  return animal.fly(); // En el 'else', TypeScript asume que 'animal' es de tipo 'Bird'
}
```

**Explicaci√≥n del ejemplo:**

- `animal` puede ser de tipo `Fish` (que tiene la propiedad `swim`) o `Bird` (que tiene la propiedad `fly`).
- `if ("swim" in animal)`: Este es el Type Guard con `in`. Si `animal` tiene la propiedad `"swim"`, TypeScript estrecha el tipo de `animal` a `Fish` dentro del `if`.
- En el `else`, si `animal` no tiene la propiedad `"swim"`, TypeScript deduce que debe ser de tipo `Bird` (dado que solo puede ser `Fish` o `Bird` al principio).

#### 3. **Ejemplo con propiedades opcionales:**

```typescript
type Fish = { swim: () => void };
type Bird = { fly: () => void };
type Human = { swim?: () => void; fly?: () => void }; // Propiedades opcionales

function moverCriatura(animal: Fish | Bird | Human) {
  if ("swim" in animal) {
    // üëà Operador 'in' con propiedades opcionales
    animal; // üí° TypeScript estrecha 'animal' a 'Fish | Human' aqu√≠
  } else {
    animal; // üí° TypeScript estrecha 'animal' a 'Bird | Human' aqu√≠
  }
}
```

**Explicaci√≥n del ejemplo:**

- Ahora `animal` puede ser `Fish`, `Bird`, o `Human`. `Human` tiene propiedades `swim` y `fly` _opcionales_ (`swim?: ...`, `fly?: ...`).
- `if ("swim" in animal)`: Incluso si `Human` _podr√≠a_ tener `swim`, el operador `in` no puede distinguir si _realmente_ la tiene en un caso espec√≠fico de `Human`. Por lo tanto, TypeScript estrecha el tipo a `Fish | Human` en el `if` (porque `Fish` seguro tiene `swim`, y `Human` _podr√≠a_ tenerla).
- En el `else`, si no tiene `"swim"`, puede ser `Bird` (que no tiene `swim`) o `Human` (que _podr√≠a_ no tenerla, o no se detect√≥ con `in` en este caso debido a la opcionalidad). TypeScript estrecha a `Bird | Human`.

#### 4. **Notas o advertencias:**

- El operador `in` es √∫til para Type Narrowing basado en la existencia de propiedades.
- Funciona bien con tipos de uni√≥n donde algunos tipos tienen ciertas propiedades y otros no.
- Con propiedades opcionales, el narrowing con `in` puede ser menos preciso, ya que no puede determinar con certeza si una propiedad opcional _existe_ en un caso dado, solo si el tipo _podr√≠a_ tenerla.

## D - Estrechamiento con `instanceof`

#### 1. **Definicion:**

El operador `instanceof` en JavaScript verifica si un objeto es una "instancia" de una clase o constructor. M√°s precisamente, verifica si la cadena de prototipos del objeto contiene `Constructor.prototype`. TypeScript tambi√©n reconoce `instanceof` como un Type Guard.

#### 2. **Ejemplo:**

```typescript
function logValue(x: Date | string) {
  if (x instanceof Date) {
    // üëà Operador 'instanceof' como Type Guard
    // Si 'x instanceof Date' es verdadero, TypeScript sabe que 'x' es de tipo 'Date'
    console.log(x.toUTCString()); // ‚úÖ ¬°Funciona! M√©todos de Date disponibles
  } else {
    console.log(x.toUpperCase()); // En el 'else', TypeScript asume que 'x' es de tipo 'string'
  }
}

logValue(new Date());
logValue("hola");
```

**Explicaci√≥n del ejemplo:**

- `x` puede ser de tipo `Date` o `string`.
- `if (x instanceof Date)`: Este es el Type Guard con `instanceof`. Si `x` es una instancia de la clase `Date`, TypeScript estrecha el tipo de `x` a `Date` dentro del `if`.
- En el `else`, si `x` no es una instancia de `Date`, TypeScript deduce que debe ser de tipo `string` (dado que solo puede ser `Date` o `string` al principio).

#### 3. **Notas o advertencias:**

- `instanceof` es √∫til para Type Narrowing cuando trabajas con clases y herencia en JavaScript (y TypeScript).
- Funciona bien para distinguir entre objetos creados con diferentes constructores.
- Es importante entender c√≥mo funciona `instanceof` en JavaScript (verificaci√≥n de la cadena de prototipos) para usarlo correctamente como Type Guard.

## E - Estrechamiento por Asignaci√≥n (`Assignments`)

#### 1. **Definicion:**

Cuando asignas un valor a una variable, TypeScript observa el tipo del valor que est√°s asignando y puede estrechar el tipo de la variable en adelante. Sin embargo, el estrechamiento por asignaci√≥n siempre est√° limitado por el tipo _declarado_ originalmente para la variable.

#### 2. **Ejemplo:**

```typescript
let x: string | number = Math.random() < 0.5 ? 10 : "hola mundo!";
// üí° Inicialmente, 'x' es de tipo 'string | number'

x = 1;
console.log(x); // üí° Despu√©s de 'x = 1', TypeScript estrecha 'x' a 'number' aqu√≠

x = "adi√≥s!";
console.log(x); // üí° Despu√©s de 'x = "adi√≥s!"', TypeScript estrecha 'x' a 'string' aqu√≠
```

**Explicaci√≥n del ejemplo:**

- `let x: string | number`: Declaramos que `x` puede ser `string` o `number`.
- `x = 1;`: Asignamos un n√∫mero a `x`. TypeScript ve esto y estrecha el tipo de `x` a `number` desde este punto en adelante.
- `x = "adi√≥s!";`: Luego, asignamos una cadena a `x`. TypeScript vuelve a estrechar el tipo de `x`, esta vez a `string`.

**Importante:** Ambas asignaciones son v√°lidas porque `string` y `number` est√°n dentro del tipo declarado originalmente (`string | number`).

#### 3. **Ejemplo de asignaci√≥n inv√°lida:**

```typescript
let x: string | number = Math.random() < 0.5 ? 10 : "hola mundo!";
// üí° Inicialmente, 'x' es 'string | number'

x = true; // üö® Error de TypeScript: ¬°'boolean' no es asignable a 'string | number'!
console.log(x);
```

**Explicaci√≥n del ejemplo:**

- `x = true;`: Intentamos asignar un valor booleano a `x`. **Esto causa un error de TypeScript.**
- ¬øPor qu√©? Porque el tipo declarado de `x` es `string | number`. `boolean` no es ni `string` ni `number`, as√≠ que TypeScript no permite esta asignaci√≥n. El estrechamiento por asignaci√≥n solo puede refinar el tipo dentro de los l√≠mites del tipo declarado originalmente.

#### 4. **Notas o advertencias:**

- La asignaci√≥n puede estrechar el tipo de una variable, pero siempre dentro del rango de tipos que se declararon inicialmente para esa variable.
- Si intentas asignar un valor de un tipo que no est√° en el tipo declarado, TypeScript te dar√° un error.
- El estrechamiento por asignaci√≥n es √∫til para refinar el tipo de una variable a medida que avanza el flujo del programa.

## F - An√°lisis de Flujo de Control (`Control Flow Analysis`)

#### 1. **Definicion:**

El An√°lisis de Flujo de Control es la capacidad de TypeScript para entender c√≥mo se ejecuta tu c√≥digo, no solo l√≠nea por l√≠nea, sino siguiendo las ramas de ejecuci√≥n (como `if/else`, bucles, etc.). TypeScript usa este an√°lisis para aplicar Type Narrowing de forma inteligente en diferentes partes de tu c√≥digo, teniendo en cuenta las condiciones y las asignaciones.

#### 2. **Ejemplo con `return` dentro de un `if`:**

```typescript
function padLeftAgain(padding: number | string, input: string) {
  if (typeof padding === "number") {
    return " ".repeat(padding) + input; // üëà La funci√≥n RETORNA aqu√≠ si 'padding' es number
  }
  return padding + input; // üí° Esta l√≠nea solo se alcanza si 'padding' NO es number
}
```

**Explicaci√≥n del ejemplo:**

- En la funci√≥n `padLeftAgain`, si `padding` es de tipo `number`, la funci√≥n **retorna** dentro del primer bloque `if`.
- TypeScript es lo suficientemente inteligente para darse cuenta de que si el c√≥digo llega a la l√≠nea `return padding + input;` _despu√©s_ del `if`, es porque el `if` _no_ se ejecut√≥, lo que significa que `padding` _no_ era un `number`.
- Por lo tanto, para la l√≠nea `return padding + input;`, TypeScript estrecha el tipo de `padding` a solo `string` (eliminando la posibilidad de que sea `number`).

#### 3. **Ejemplo con m√∫ltiples ramas y re-fusi√≥n del flujo:**

```typescript
function ejemploFlujoComplejo() {
  let x: string | number | boolean; // üí° 'x' puede ser string, number o boolean
  x = Math.random() < 0.5; // üí° Ahora 'x' es solo 'boolean'
  console.log(x);

  if (Math.random() < 0.5) {
    x = "hola"; // üí° Dentro del 'if', 'x' se estrecha a 'string'
    console.log(x);
  } else {
    x = 100; // üí° Dentro del 'else', 'x' se estrecha a 'number'
    console.log(x);
  }
  return x; // üí° Despu√©s del 'if/else', 'x' vuelve a ser 'string | number' (porque podr√≠a venir del 'if' o del 'else')
}
```

**Explicaci√≥n del ejemplo:**

- TypeScript rastrea el tipo de `x` a trav√©s de diferentes caminos de ejecuci√≥n.
- Despu√©s de `x = Math.random() < 0.5;`, `x` se estrecha a `boolean`.
- Dentro del `if`, se estrecha a `string`, y dentro del `else`, a `number`.
- Despu√©s del `if/else`, el flujo de control se "re-fusiona". Como `x` podr√≠a haber venido del bloque `if` (string) o del bloque `else` (number), TypeScript vuelve a ampliar el tipo de `x` a `string | number` para el `return` final.

#### 4. **Notas o advertencias:**

- El An√°lisis de Flujo de Control es un mecanismo poderoso que permite a TypeScript hacer Type Narrowing de forma muy precisa y autom√°tica.
- Tiene en cuenta las estructuras de control de flujo de JavaScript para entender c√≥mo los tipos cambian a lo largo de la ejecuci√≥n del c√≥digo.
- Esto hace que el Type Narrowing sea muy natural y se integre bien con la forma en que escribimos c√≥digo JavaScript normalmente.

## G - Usando Type Predicates (Predicados de Tipo)

#### 1. **Definicion:**

Un Type Predicate es una forma de crear tus _propios_ Type Guards. Es una funci√≥n que defines para decirle a TypeScript: "Si esta funci√≥n devuelve `true`, entonces puedes asumir que la variable que le pas√© es de este tipo espec√≠fico". Se define usando una sintaxis especial en el tipo de retorno de la funci√≥n: `parameterName is Type`.

#### 2. **Ejemplo: Funci√≥n `isFish` como Type Predicate:**

```typescript
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function isFish(pet: Fish | Bird): pet is Fish {
  // üëà Type Predicate
  return (pet as Fish).swim !== undefined; // L√≥gica para determinar si es un Fish
}

function hacerAlgoConMascota(pet: Fish | Bird) {
  if (isFish(pet)) {
    // üëà Usando 'isFish' como Type Guard
    pet.swim(); // ‚úÖ ¬°Funciona! TypeScript sabe que 'pet' es Fish aqu√≠
  } else {
    pet.fly(); // ‚úÖ TypeScript sabe que 'pet' es Bird aqu√≠
  }
}
```

**Explicaci√≥n del ejemplo:**

- `function isFish(pet: Fish | Bird): pet is Fish`: Esta es la clave. `pet is Fish` es el Type Predicate. Significa: "Esta funci√≥n toma un par√°metro `pet` que puede ser `Fish` o `Bird`, y _si devuelve `true`_, entonces podemos asumir que `pet` es de tipo `Fish`".
- Dentro de `isFish`, la l√≥gica `(pet as Fish).swim !== undefined` es una forma de verificar si `pet` tiene la propiedad `swim` (asumiendo que `Fish` tiene `swim` y `Bird` no). El `as Fish` es un "type assertion" (afirmaci√≥n de tipo) para decirle a TypeScript que trate temporalmente `pet` como `Fish` para poder acceder a `swim`.
- En `hacerAlgoConMascota`, `if (isFish(pet))`: Al llamar a `isFish(pet)` dentro de un `if`, TypeScript usa `isFish` como un Type Guard. Si `isFish(pet)` devuelve `true`, TypeScript estrecha el tipo de `pet` a `Fish` dentro del `if`. En el `else`, lo estrecha a `Bird`.

#### 3. **Ejemplo con `filter` y Type Predicate:**

```typescript
const zoo: (Fish | Bird)[] = [
  /* ... */
]; // Un array de Fish y Birds
const pecesEnZoo: Fish[] = zoo.filter(isFish); // üëà Usando 'isFish' con 'filter'

const pecesEnZoo2: Fish[] = zoo.filter(isFish) as Fish[]; // Otra forma (con 'as Fish[]')

const pecesSinSharkey: Fish[] = zoo.filter((pet): pet is Fish => {
  // üëà Type Predicate inline
  if ((pet as any).name === "sharkey") return false; // Ejemplo de l√≥gica m√°s compleja
  return isFish(pet);
});
```

**Explicaci√≥n del ejemplo:**

- `zoo.filter(isFish)`: Puedes usar tu Type Predicate `isFish` con el m√©todo `filter` de arrays. `filter` espera una funci√≥n que devuelva `true` o `false` para cada elemento. Al pasar `isFish`, TypeScript entiende que `filter` va a devolver un nuevo array que contiene _solo_ los elementos para los cuales `isFish` devolvi√≥ `true`, y por lo tanto, estrecha el tipo del array resultante a `Fish[]`.
- `as Fish[]`: A veces, TypeScript necesita una peque√±a ayuda para entender completamente el Type Narrowing con `filter` y Type Predicates. Usar `as Fish[]` es una forma de "afirmar" expl√≠citamente a TypeScript que el resultado de `filter(isFish)` es un array de `Fish`.
- Type Predicate "inline": Tambi√©n puedes definir un Type Predicate directamente dentro de la funci√≥n de `filter`, como en el ejemplo de `pecesSinSharkey`.

#### 4. **Notas o advertencias:**

- Los Type Predicates te dan un control m√°s directo sobre c√≥mo ocurre el Type Narrowing en tu c√≥digo.
- Son √∫tiles cuando las comprobaciones de tipo est√°ndar (`typeof`, `instanceof`, `in`, etc.) no son suficientes para expresar la l√≥gica de Type Guard que necesitas.
- La sintaxis `parameterName is Type` es clave para definir un Type Predicate.
- Puedes usar Type Predicates con `if` statements, `filter` de arrays, y en otros contextos donde necesites Type Narrowing personalizado.

## H - Assertion Functions (Funciones de Aserci√≥n)

#### 1. **Definicion:**

Las Assertion Functions (Funciones de Aserci√≥n) son otra forma de estrechar tipos en TypeScript, introducidas en TypeScript 3.7. Son funciones que, en lugar de _retornar_ un valor booleano como los Type Predicates, **lanzan un error si una cierta condici√≥n no se cumple**. Si la funci√≥n no lanza un error (es decir, "pasa" la aserci√≥n), TypeScript asume que la condici√≥n _s√≠_ se cumple y puede estrechar los tipos en consecuencia.

#### 2. **Ejemplo (conceptual - para m√°s detalles, ver el enlace):**

```typescript
function assertIsString(val: any): asserts val is string {
  if (typeof val !== "string") {
    throw new Error("¬°El valor no es una cadena!");
  }
  // Si no se lanza un error, TypeScript asume que 'val' es string desde aqu√≠ en adelante.
}

function usarCadena(valor: any) {
  assertIsString(valor); // üëà Funci√≥n de aserci√≥n
  valor.toUpperCase(); // ‚úÖ ¬°Funciona! TypeScript sabe que 'valor' es string aqu√≠ (si assertIsString no lanz√≥ error)
}
```

**Explicaci√≥n del ejemplo:**

- `function assertIsString(val: any): asserts val is string`: `asserts val is string` es la sintaxis de funci√≥n de aserci√≥n. Significa: "Esta funci√≥n _asegura_ que `val` es de tipo `string`. Si no lo es, lanzar√° un error".
- Dentro de `assertIsString`, si `typeof val !== "string"`, se lanza un error. Si la funci√≥n _no_ lanza un error, significa que la condici√≥n `typeof val === "string"` se cumpli√≥.
- En `usarCadena`, despu√©s de llamar a `assertIsString(valor)`, si la ejecuci√≥n contin√∫a (es decir, `assertIsString` no lanz√≥ un error), TypeScript estrecha el tipo de `valor` a `string`.

#### 3. **Notas o advertencias:**

- Las Assertion Functions son √∫tiles para expresar aserciones sobre tipos que deben cumplirse en ciertos puntos de tu c√≥digo.
- Si la aserci√≥n falla (la condici√≥n no se cumple), la funci√≥n lanza un error, deteniendo la ejecuci√≥n (a menos que se capture el error).
- Si la aserci√≥n pasa, TypeScript usa esa informaci√≥n para estrechar los tipos.
- Para m√°s detalles y ejemplos, consulta el enlace proporcionado en el texto original sobre Assertion Functions en TypeScript 3.7.
