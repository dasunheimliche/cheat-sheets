## A - Type Narrowing

#### 1. **Definicion:**

Type Narrowing es como TypeScript se vuelve m√°s "inteligente" sobre el tipo de una variable dentro de tu c√≥digo. Imagina que tienes una variable que podr√≠a ser un n√∫mero o una cadena de texto. Al principio, TypeScript la ve como "n√∫mero o cadena". Pero, si usas ciertas herramientas en tu c√≥digo, como un `if` que revisa si es un n√∫mero, TypeScript se da cuenta y dentro de ese `if`, ¬°piensa en esa variable _solo_ como un n√∫mero! Es como si el tipo se hiciera m√°s "estrecho" o espec√≠fico dentro de ciertas partes de tu c√≥digo.

#### 2. **Ejemplo:**

```typescript
function padLeft(padding: number | string, input: string): string {
  if (typeof padding === "number") {
    return " ".repeat(padding) + input;
  }
  return padding + input;
}
```

**Explicaci√≥n del ejemplo:**

En este ejemplo, la funci√≥n `padLeft` puede recibir `padding` como un n√∫mero o una cadena de texto.

- **Al principio**, TypeScript ve `padding` como `number | string` (n√∫mero o cadena).
- **Dentro del `if (typeof padding === "number")`**, TypeScript es lo suficientemente listo para entender que _si el c√≥digo entra aqu√≠_, es porque `padding` _es_ un n√∫mero. ¬°As√≠ que dentro del `if`, `padding` se considera solo como `number`! Esto permite usar funciones como `repeat()` que solo funcionan con n√∫meros.
- **Si no entra en el `if`**, significa que `padding` no es un n√∫mero, por lo tanto, TypeScript asume que es la otra opci√≥n: `string`. En el `return padding + input;` fuera del `if`, `padding` se considera solo como `string`.

#### 3. **Notas o advertencias:**

- Type Narrowing ayuda a TypeScript a entender mejor tu c√≥digo y a evitar errores.
- Funciona autom√°ticamente con cosas comunes de JavaScript como `if`, `else`, etc.
- Es una forma de hacer que TypeScript sea m√°s flexible y se adapte a c√≥mo escribimos JavaScript normalmente.

## B - Type Guards (Guardianes de Tipo)

#### 1. **Definicion:**

Los Type Guards son como "detectives de tipo" en tu c√≥digo. Son ciertas expresiones o construcciones de JavaScript que le dicen a TypeScript: "¬°Oye, aqu√≠ estoy seguro de que esta variable es de este tipo!". Cuando TypeScript ve un Type Guard, conf√≠a en ti y "estrecha" el tipo de la variable en esa parte del c√≥digo. Piensa en ellos como se√±ales que gu√≠an a TypeScript para entender mejor los tipos en diferentes partes de tu programa.

#### 2. **Ejemplo:**

En el ejemplo anterior de `padLeft`, `typeof padding === "number"` es un Type Guard.

```typescript
function padLeft(padding: number | string, input: string): string {
  if (typeof padding === "number") {
    // üëà Type Guard!
    return " ".repeat(padding) + input;
  }
  return padding + input;
}
```

**Explicaci√≥n del ejemplo:**

- `typeof padding === "number"` es la pregunta clave. Le pregunta a JavaScript: "¬øEs el tipo de `padding` un 'number'?"
- Si la respuesta es "s√≠" (verdadero), TypeScript dice: "¬°Ah! ¬°Entendido! Dentro de este `if`, `padding` es definitivamente un n√∫mero". Act√∫a en consecuencia, permiti√©ndote usar operaciones de n√∫meros.
- Si la respuesta es "no" (falso), TypeScript sabe que no es un n√∫mero, y en el `else` impl√≠cito (o fuera del `if` en este caso), asume que es el otro tipo posible (en este caso, `string`).

#### 3. **Notas o advertencias:**

- `typeof`, `instanceof`, `in`, y las "funciones que retornan un tipo" (que veremos m√°s adelante) son ejemplos de Type Guards.
- Los Type Guards son esenciales para que TypeScript pueda trabajar con tipos m√°s complejos y flexibles, especialmente cuando tienes uniones de tipos (como `number | string`).
- Te permiten escribir c√≥digo JavaScript natural y al mismo tiempo obtener los beneficios de la seguridad de tipos de TypeScript.

## C - `typeof` como Type Guard

#### 1. **Definicion:**

Usar `typeof` es una de las formas m√°s comunes y sencillas de crear un Type Guard. Cuando comparas el resultado de `typeof` con un tipo espec√≠fico (como `"number"`, `"string"`, `"boolean"`, etc.), le est√°s dando a TypeScript una pista muy clara sobre el tipo de la variable en ese punto de tu c√≥digo.

#### 2. **Ejemplo:**

```typescript
function ejemploTypeof(valor: any): string {
  if (typeof valor === "string") {
    return "Es una cadena: " + valor.toUpperCase(); // ‚úÖ TypeScript sabe que valor es string aqu√≠
  } else if (typeof valor === "number") {
    return "Es un n√∫mero: " + valor.toFixed(2); // ‚úÖ TypeScript sabe que valor es number aqu√≠
  } else {
    return "No s√© qu√© es.";
  }
}
```

**Explicaci√≥n del ejemplo:**

- La funci√≥n `ejemploTypeof` puede recibir cualquier tipo de valor (`any`).
- `if (typeof valor === "string")`: Este es un Type Guard. Si `typeof valor` es igual a `"string"`, TypeScript sabe que dentro de este bloque `if`, `valor` es una cadena. Por lo tanto, te permite usar m√©todos de cadena como `toUpperCase()`.
- `else if (typeof valor === "number")`: Otro Type Guard. Si `typeof valor` es `"number"`, TypeScript sabe que dentro de este bloque, `valor` es un n√∫mero, y puedes usar m√©todos num√©ricos como `toFixed()`.
- En el `else` final, TypeScript no tiene informaci√≥n espec√≠fica sobre el tipo de `valor` (m√°s all√° de que no es ni string ni number en este caso).

#### 3. **Notas o advertencias:**

- `typeof` funciona con los tipos primitivos de JavaScript: `"string"`, `"number"`, `"boolean"`, `"symbol"`, `"bigint"`, `"undefined"`, y `"object"`, y `"function"`.
- Es una forma muy directa y legible de hacer Type Narrowing.
- Recuerda usar los nombres de tipo de `typeof` en _min√∫sculas_ (ej. `"number"`, no `"Number"`).

## D - An√°lisis de Flujo de Control

#### 1. **Definicion:**

El An√°lisis de Flujo de Control es la capacidad de TypeScript para "seguir el hilo" de tu c√≥digo. TypeScript no solo mira las l√≠neas de c√≥digo una por una, sino que entiende c√≥mo se _ejecuta_ tu programa. Analiza estructuras como `if/else`, bucles (`for`, `while`), condicionales ternarios (`? :`), y otras formas en que el flujo de tu programa puede cambiar. Usando este an√°lisis, TypeScript aplica Type Narrowing autom√°ticamente en diferentes partes de tu c√≥digo.

#### 2. **Ejemplo:**

```typescript
function ejemploFlujoControl(valor: number | null): string {
  if (valor !== null) {
    return "El valor no es nulo: " + valor.toFixed(2); // ‚úÖ TypeScript sabe que valor NO es null aqu√≠
  } else {
    return "El valor es nulo.";
  }
}
```

**Explicaci√≥n del ejemplo:**

- `valor` puede ser `number` o `null`.
- `if (valor !== null)`: Esta condici√≥n es analizada por TypeScript. Si el c√≥digo entra dentro del `if`, significa que la condici√≥n `valor !== null` fue verdadera. TypeScript es lo suficientemente inteligente para deducir que _dentro del `if`, `valor` no puede ser `null`_. Por lo tanto, en este bloque, TypeScript "estrecha" el tipo de `valor` a solo `number`.
- En el `else`, si la condici√≥n `valor !== null` fue falsa, significa que `valor` _s√≠_ es `null`. Aunque en este ejemplo no usamos `valor` en el `else`, TypeScript tambi√©n tiene en cuenta esta informaci√≥n sobre el tipo.

#### 3. **Notas o advertencias:**

- El An√°lisis de Flujo de Control es lo que hace que Type Narrowing sea tan poderoso y autom√°tico en TypeScript.
- No solo funciona con `typeof`, sino con muchas otras condiciones y estructuras de control de JavaScript.
- Te permite escribir c√≥digo que se siente natural y legible, sin tener que hacer "trucos" extra√±os para que TypeScript entienda los tipos.
- TypeScript est√° constantemente mejorando su An√°lisis de Flujo de Control para entender construcciones de c√≥digo cada vez m√°s complejas.
