## A - Compatibilidad de Tipos y Subtipado Estructural

#### 1. **Definici√≥n:**

En TypeScript, la compatibilidad de tipos se basa en el **subtipado estructural**. Esto significa que dos tipos son compatibles si tienen la misma estructura, es decir, los mismos miembros (propiedades y m√©todos), independientemente de c√≥mo se llamen o de si son clases o interfaces. ¬°Lo importante es lo que hacen, no c√≥mo se llaman! üé≠

#### 2. **Ejemplo:**

```typescript
interface Pet {
  name: string;
}

class Dog {
  name: string;
}

let pet: Pet;
pet = new Dog(); // ¬°Esto es v√°lido!
```

**Explicaci√≥n del ejemplo**:
Aunque `Dog` no "implementa" expl√≠citamente `Pet`, TypeScript permite la asignaci√≥n porque `Dog` tiene una propiedad `name` de tipo `string`, igual que `Pet`.

## B - Subtipado Estructural vs. Tipado Nominal

#### 1. **Definici√≥n:**

El subtipado estructural de TypeScript es diferente del **tipado nominal** que se usa en lenguajes como C# o Java. En el tipado nominal, los tipos deben declararse expl√≠citamente como compatibles (por ejemplo, implementando una interfaz). TypeScript es m√°s flexible y se basa en la estructura. üß©

#### 2. **Ejemplo:**

En C# o Java, el ejemplo anterior dar√≠a un error a menos que `Dog` declarara expl√≠citamente que implementa la interfaz `Pet`.

**Explicaci√≥n del ejemplo**:
TypeScript es m√°s flexible y se adapta mejor a la forma en que se escribe c√≥digo en JavaScript, donde los objetos an√≥nimos son muy comunes.

## C - Una Nota sobre la Solidez

#### 1. **Definici√≥n:**

El sistema de tipos de TypeScript no es completamente "s√≥lido". Esto significa que permite ciertas operaciones que no se pueden garantizar como seguras en tiempo de compilaci√≥n. Sin embargo, estas decisiones se toman cuidadosamente para permitir patrones comunes en JavaScript. ‚ö†Ô∏è

#### 2. **Ejemplo:**

Algunas de las flexibilidades que ofrece TypeScript pueden llevar a errores en tiempo de ejecuci√≥n, pero son necesarias para que el lenguaje sea pr√°ctico.

**Explicaci√≥n del ejemplo**:
TypeScript prioriza la usabilidad y la compatibilidad con JavaScript sobre la solidez estricta.

## D - Empezando con la Compatibilidad

#### 1. **Definici√≥n:**

La regla b√°sica es: `x` es compatible con `y` si `y` tiene al menos los mismos miembros que `x`. Es decir, `y` debe tener todas las propiedades y m√©todos que tiene `x`, y sus tipos deben ser compatibles. üéØ

#### 2. **Ejemplo:**

```typescript
interface Pet {
  name: string;
}

let pet: Pet;
let dog = { name: "Lassie", owner: "Rudd Weatherwax" };
pet = dog; // ¬°Esto es v√°lido!
```

**Explicaci√≥n del ejemplo**:
`dog` tiene una propiedad `name` de tipo `string`, que es lo que `pet` requiere. La propiedad extra `owner` no importa.

## E - Compatibilidad en Llamadas a Funciones

#### 1. **Definici√≥n:**

La misma regla de compatibilidad se aplica a los argumentos de las funciones. Si una funci√≥n espera un tipo `Pet`, puedes pasarle un objeto que tenga al menos las propiedades de `Pet`. üìû

#### 2. **Ejemplo:**

```typescript
interface Pet {
  name: string;
}

let dog = { name: "Lassie", owner: "Rudd Weatherwax" };

function greet(pet: Pet) {
  console.log("Hola, " + pet.name);
}

greet(dog); // ¬°Esto es v√°lido!
```

**Explicaci√≥n del ejemplo**:
La funci√≥n `greet` espera un `Pet`, y `dog` cumple con los requisitos.

## F - Literales de Objeto y Propiedades Extra

#### 1. **Definici√≥n:**

¬°Cuidado! Los literales de objeto solo pueden especificar propiedades conocidas. Si declaras expl√≠citamente que un objeto es de tipo `Pet`, no puedes a√±adirle propiedades extra. üö´

#### 2. **Ejemplo:**

```typescript
interface Pet {
  name: string;
}

let dog: Pet = { name: "Lassie", owner: "Rudd Weatherwax" }; // ¬°Error!
```

**Explicaci√≥n del ejemplo**:
TypeScript no permite propiedades extra en literales de objeto cuando se especifica un tipo.

## G - Comparando Dos Funciones

#### 1. **Definici√≥n:**

La compatibilidad de funciones es un poco m√°s compleja. Para que una funci√≥n `x` sea compatible con una funci√≥n `y`, cada par√°metro de `x` debe tener un par√°metro correspondiente en `y` con un tipo compatible. Los nombres de los par√°metros no importan, solo sus tipos. ü§π‚Äç‚ôÄÔ∏è

#### 2. **Ejemplo:**

```typescript
let x = (a: number) => 0;
let y = (b: number, s: string) => 0;

y = x; // ¬°Esto es v√°lido!
x = y; // ¬°Error!
```

**Explicaci√≥n del ejemplo**:
`x` puede asignarse a `y` porque `y` tiene al menos un par√°metro compatible con el de `x`. Pero `y` no puede asignarse a `x` porque `x` no tiene un segundo par√°metro.

## H - Descartando Par√°metros de Funciones

#### 1. **Definici√≥n:**

TypeScript permite "descartar" par√°metros de funciones. Esto es com√∫n en JavaScript, donde las funciones a menudo reciben m√°s argumentos de los que necesitan. üóëÔ∏è

#### 2. **Ejemplo:**

```typescript
let items = [1, 2, 3];
items.forEach((item, index, array) => console.log(item)); // ¬°Esto es v√°lido!
items.forEach((item) => console.log(item)); // ¬°Esto tambi√©n es v√°lido!
```

**Explicaci√≥n del ejemplo**:
`forEach` proporciona tres par√°metros, pero podemos usar solo el primero sin problemas.

## I - Compatibilidad de Tipos de Retorno

#### 1. **Definici√≥n:**

El tipo de retorno de una funci√≥n debe ser un subtipo del tipo de retorno de la funci√≥n a la que se asigna. Es decir, el tipo de retorno de la funci√≥n fuente debe ser compatible con el tipo de retorno de la funci√≥n destino. ‚Ü©Ô∏è

#### 2. **Ejemplo:**

```typescript
let x = () => ({ name: "Alice" });
let y = () => ({ name: "Alice", location: "Seattle" });

x = y; // ¬°Esto es v√°lido!
y = x; // ¬°Error!
```

**Explicaci√≥n del ejemplo**:
`y` puede asignarse a `x` porque el tipo de retorno de `y` tiene al menos las propiedades del tipo de retorno de `x`.

## J - Bivariancia de Par√°metros de Funci√≥n

#### 1. **Definici√≥n:**

TypeScript permite que los par√°metros de funci√≥n sean bivariantes. Esto significa que la asignaci√≥n tiene √©xito si el par√°metro fuente es asignable al par√°metro destino, o viceversa. Esto puede ser inseguro, pero permite patrones comunes en JavaScript. üîÑ

#### 2. **Ejemplo:**

```typescript
enum EventType {
  Mouse,
  Keyboard,
}

interface Event {
  timestamp: number;
}

interface MyMouseEvent extends Event {
  x: number;
  y: number;
}

function listenEvent(eventType: EventType, handler: (n: Event) => void) {
  /* ... */
}

listenEvent(EventType.Mouse, (e: MyMouseEvent) => console.log(e.x + "," + e.y)); // ¬°Esto es v√°lido!
```

**Explicaci√≥n del ejemplo**:
Aunque `MyMouseEvent` es m√°s espec√≠fico que `Event`, la asignaci√≥n es v√°lida.

## K - Par√°metros Opcionales y Rest

#### 1. **Definici√≥n:**

Los par√°metros opcionales y los par√°metros rest son intercambiables al comparar funciones. Los par√°metros opcionales extra en la funci√≥n fuente no son un error, y los par√°metros opcionales en la funci√≥n destino sin par√°metros correspondientes en la fuente tampoco son un error. ‚ùì

#### 2. **Ejemplo:**

```typescript
function invokeLater(args: any[], callback: (...args: any[]) => void) {
  /* ... */
}

invokeLater([1, 2], (x, y) => console.log(x + ", " + y)); // ¬°Esto es v√°lido!
invokeLater([1, 2], (x?, y?) => console.log(x + ", " + y)); // ¬°Esto tambi√©n es v√°lido!
```

**Explicaci√≥n del ejemplo**:
TypeScript es flexible con los par√°metros opcionales y rest.

## L - Funciones con Sobrecargas

#### 1. **Definici√≥n:**

Si una funci√≥n tiene sobrecargas, cada sobrecarga en el tipo destino debe tener una firma compatible en el tipo fuente. Esto asegura que la funci√≥n fuente pueda ser llamada en todos los casos en que la funci√≥n destino puede ser llamada. üîÄ

#### 2. **Ejemplo:**

Si una funci√≥n tiene dos sobrecargas, la funci√≥n que se le asigna debe tener al menos dos sobrecargas compatibles.

**Explicaci√≥n del ejemplo**:
TypeScript asegura que las funciones con sobrecargas sean compatibles en todos los casos.

## M - Enums

#### 1. **Definici√≥n:**

Los enums son compatibles con n√∫meros, y los n√∫meros son compatibles con enums. Sin embargo, los valores de enums de diferentes tipos no son compatibles. üî¢

#### 2. **Ejemplo:**

```typescript
enum Status {
  Ready,
  Waiting,
}

enum Color {
  Red,
  Blue,
  Green,
}

let status = Status.Ready;
status = Color.Green; // ¬°Error!
```

**Explicaci√≥n del ejemplo**:
No puedes asignar un valor de un enum a una variable de otro enum.

## N - Clases

#### 1. **Definici√≥n:**

Las clases funcionan de manera similar a los literales de objeto y las interfaces, pero solo se comparan los miembros de la instancia. Los miembros est√°ticos y los constructores no afectan la compatibilidad. üè¢

#### 2. **Ejemplo:**

```typescript
class Animal {
  feet: number;
  constructor(name: string, numFeet: number) {}
}

class Size {
  feet: number;
  constructor(numFeet: number) {}
}

let a: Animal;
let s: Size;
a = s; // ¬°Esto es v√°lido!
s = a; // ¬°Esto tambi√©n es v√°lido!
```

**Explicaci√≥n del ejemplo**:
Solo se compara la propiedad `feet` de la instancia.

## O - Miembros Privados y Protegidos en Clases

#### 1. **Definici√≥n:**

Los miembros privados y protegidos en una clase afectan su compatibilidad. Si el tipo destino tiene un miembro privado, el tipo fuente debe tener un miembro privado que provenga de la misma clase. Lo mismo aplica para los miembros protegidos. üîí

#### 2. **Ejemplo:**

Una clase puede ser compatible con su superclase, pero no con clases de otra jerarqu√≠a de herencia, aunque tengan la misma forma.

**Explicaci√≥n del ejemplo**:
TypeScript asegura que los miembros privados y protegidos se respeten en la compatibilidad de clases.

## P - Gen√©ricos

#### 1. **Definici√≥n:**

Los par√°metros de tipo gen√©rico solo afectan el tipo resultante cuando se usan como parte del tipo de un miembro. Si no se usan, los tipos gen√©ricos son compatibles. üß¨

#### 2. **Ejemplo:**

```typescript
interface Empty<T> {}

let x: Empty<number>;
let y: Empty<string>;
x = y; // ¬°Esto es v√°lido!
```

**Explicaci√≥n del ejemplo**:
`x` e `y` son compatibles porque no usan el par√°metro de tipo de manera diferenciadora.

## Q - Gen√©ricos con Miembros

#### 1. **Definici√≥n:**

Si un tipo gen√©rico usa su par√°metro de tipo en un miembro, los tipos deben ser compatibles. üßÆ

#### 2. **Ejemplo:**

```typescript
interface NotEmpty<T> {
  data: T;
}

let x: NotEmpty<number>;
let y: NotEmpty<string>;
x = y; // ¬°Error!
```

**Explicaci√≥n del ejemplo**:
`x` e `y` no son compatibles porque sus miembros `data` tienen tipos diferentes.

## R - Gen√©ricos sin Tipos Especificados

#### 1. **Definici√≥n:**

Si un tipo gen√©rico no tiene sus argumentos de tipo especificados, la compatibilidad se verifica usando `any` en lugar de los argumentos de tipo. üï≥Ô∏è

#### 2. **Ejemplo:**

```typescript
let identity = function <T>(x: T): T {
  // ...
};

let reverse = function <U>(y: U): U {
  // ...
};

identity = reverse; // ¬°Esto es v√°lido!
```

**Explicaci√≥n del ejemplo**:
Ambas funciones son compatibles porque `(x: any) => any` coincide con `(y: any) => any`.

## S - Subtipo vs. Asignaci√≥n

#### 1. **Definici√≥n:**

En TypeScript, hay dos tipos de compatibilidad: subtipo y asignaci√≥n. La asignaci√≥n extiende la compatibilidad de subtipo con reglas para permitir la asignaci√≥n desde y hacia `any`, y desde y hacia `enum` con valores num√©ricos correspondientes. ‚öñÔ∏è

#### 2. **Ejemplo:**

La compatibilidad de asignaci√≥n es m√°s permisiva que la compatibilidad de subtipo.

**Explicaci√≥n del ejemplo**:
La compatibilidad de asignaci√≥n se usa en la mayor√≠a de los casos pr√°cticos.

## T - Asignabilidad de `any`, `unknown`, `object`, `void`, `undefined`, `null` y `never`

#### 1. **Definici√≥n:**

Aqu√≠ tienes una tabla que resume la asignabilidad entre algunos tipos abstractos:

|             | `any` | `unknown` | `object` | `void` | `undefined` | `null` | `never` |
| :---------- | :---: | :-------: | :------: | :----: | :---------: | :----: | :-----: |
| `any`       |   ‚úì   |     ‚úì     |    ‚úì     |   ‚úì    |      ‚úì      |   ‚úì    |    ‚úì    |
| `unknown`   |   ‚úì   |     ‚úì     |    ‚úï     |   ‚úï    |      ‚úï      |   ‚úï    |    ‚úï    |
| `object`    |   ‚úì   |     ‚úì     |    ‚úì     |   ‚úï    |      ‚úï      |   ‚úï    |    ‚úï    |
| `void`      |   ‚úì   |     ‚úì     |    ‚úï     |   ‚úì    |      ‚úì      |   ‚úì    |    ‚úì    |
| `undefined` |   ‚úì   |     ‚úì     |    ‚úì     |   ‚úì    |      ‚úì      |   ‚úì    |    ‚úì    |
| `null`      |   ‚úì   |     ‚úì     |    ‚úì     |   ‚úì    |      ‚úì      |   ‚úì    |    ‚úì    |
| `never`     |   ‚úì   |     ‚úì     |    ‚úì     |   ‚úì    |      ‚úì      |   ‚úì    |    ‚úì    |

**Explicaci√≥n del ejemplo**:
Esta tabla muestra qu√© tipos son asignables a otros tipos.
