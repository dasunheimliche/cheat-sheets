## A - Compatibilidad de Tipos y Subtipado Estructural

#### 1. **DefiniciÃ³n:**

En TypeScript, la compatibilidad de tipos se basa en el **subtipado estructural**. Esto significa que dos tipos son compatibles si tienen la misma estructura, es decir, los mismos miembros (propiedades y mÃ©todos), independientemente de cÃ³mo se llamen o de si son clases o interfaces. Â¡Lo importante es lo que hacen, no cÃ³mo se llaman! ğŸ­

#### 2. **Ejemplo:**

```typescript
interface Pet {
  name: string;
}

class Dog {
  name: string;
}

let pet: Pet;
pet = new Dog(); // Â¡Esto es vÃ¡lido!
```

**ExplicaciÃ³n del ejemplo**:
Aunque `Dog` no "implementa" explÃ­citamente `Pet`, TypeScript permite la asignaciÃ³n porque `Dog` tiene una propiedad `name` de tipo `string`, igual que `Pet`.

## B - Subtipado Estructural vs. Tipado Nominal

#### 1. **DefiniciÃ³n:**

El subtipado estructural de TypeScript es diferente del **tipado nominal** que se usa en lenguajes como C# o Java. En el tipado nominal, los tipos deben declararse explÃ­citamente como compatibles (por ejemplo, implementando una interfaz). TypeScript es mÃ¡s flexible y se basa en la estructura. ğŸ§©

#### 2. **Ejemplo:**

En C# o Java, el ejemplo anterior darÃ­a un error a menos que `Dog` declarara explÃ­citamente que implementa la interfaz `Pet`.

**ExplicaciÃ³n del ejemplo**:
TypeScript es mÃ¡s flexible y se adapta mejor a la forma en que se escribe cÃ³digo en JavaScript, donde los objetos anÃ³nimos son muy comunes.

## C - Una Nota sobre la Solidez

#### 1. **DefiniciÃ³n:**

El sistema de tipos de TypeScript no es completamente "sÃ³lido". Esto significa que permite ciertas operaciones que no se pueden garantizar como seguras en tiempo de compilaciÃ³n. Sin embargo, estas decisiones se toman cuidadosamente para permitir patrones comunes en JavaScript. âš ï¸

#### 2. **Ejemplo:**

Algunas de las flexibilidades que ofrece TypeScript pueden llevar a errores en tiempo de ejecuciÃ³n, pero son necesarias para que el lenguaje sea prÃ¡ctico.

**ExplicaciÃ³n del ejemplo**:
TypeScript prioriza la usabilidad y la compatibilidad con JavaScript sobre la solidez estricta.

## D - Empezando con la Compatibilidad

#### 1. **DefiniciÃ³n:**

La regla bÃ¡sica es: `x` es compatible con `y` si `y` tiene al menos los mismos miembros que `x`. Es decir, `y` debe tener todas las propiedades y mÃ©todos que tiene `x`, y sus tipos deben ser compatibles. ğŸ¯

#### 2. **Ejemplo:**

```typescript
interface Pet {
  name: string;
}

let pet: Pet;
let dog = { name: "Lassie", owner: "Rudd Weatherwax" };
pet = dog; // Â¡Esto es vÃ¡lido!
```

**ExplicaciÃ³n del ejemplo**:
`dog` tiene una propiedad `name` de tipo `string`, que es lo que `pet` requiere. La propiedad extra `owner` no importa.

## E - Compatibilidad en Llamadas a Funciones

#### 1. **DefiniciÃ³n:**

La misma regla de compatibilidad se aplica a los argumentos de las funciones. Si una funciÃ³n espera un tipo `Pet`, puedes pasarle un objeto que tenga al menos las propiedades de `Pet`. ğŸ“

#### 2. **Ejemplo:**

```typescript
interface Pet {
  name: string;
}

let dog = { name: "Lassie", owner: "Rudd Weatherwax" };

function greet(pet: Pet) {
  console.log("Hola, " + pet.name);
}

greet(dog); // Â¡Esto es vÃ¡lido!
```

**ExplicaciÃ³n del ejemplo**:
La funciÃ³n `greet` espera un `Pet`, y `dog` cumple con los requisitos.

## F - Literales de Objeto y Propiedades Extra

#### 1. **DefiniciÃ³n:**

Â¡Cuidado! Los literales de objeto solo pueden especificar propiedades conocidas. Si declaras explÃ­citamente que un objeto es de tipo `Pet`, no puedes aÃ±adirle propiedades extra. ğŸš«

#### 2. **Ejemplo:**

```typescript
interface Pet {
  name: string;
}

let dog: Pet = { name: "Lassie", owner: "Rudd Weatherwax" }; // Â¡Error!
```

**ExplicaciÃ³n del ejemplo**:
TypeScript no permite propiedades extra en literales de objeto cuando se especifica un tipo.

## G - Comparando Dos Funciones

#### 1. **DefiniciÃ³n:**

La compatibilidad de funciones es un poco mÃ¡s compleja. Para que una funciÃ³n `x` sea compatible con una funciÃ³n `y`, cada parÃ¡metro de `x` debe tener un parÃ¡metro correspondiente en `y` con un tipo compatible. Los nombres de los parÃ¡metros no importan, solo sus tipos. ğŸ¤¹â€â™€ï¸

#### 2. **Ejemplo:**

```typescript
let x = (a: number) => 0;
let y = (b: number, s: string) => 0;

y = x; // Â¡Esto es vÃ¡lido!
x = y; // Â¡Error!
```

**ExplicaciÃ³n del ejemplo**:
`x` puede asignarse a `y` porque `y` tiene al menos un parÃ¡metro compatible con el de `x`. Pero `y` no puede asignarse a `x` porque `x` no tiene un segundo parÃ¡metro.

## H - Descartando ParÃ¡metros de Funciones

#### 1. **DefiniciÃ³n:**

TypeScript permite "descartar" parÃ¡metros de funciones. Esto es comÃºn en JavaScript, donde las funciones a menudo reciben mÃ¡s argumentos de los que necesitan. ğŸ—‘ï¸

#### 2. **Ejemplo:**

```typescript
let items = [1, 2, 3];
items.forEach((item, index, array) => console.log(item)); // Â¡Esto es vÃ¡lido!
items.forEach((item) => console.log(item)); // Â¡Esto tambiÃ©n es vÃ¡lido!
```

**ExplicaciÃ³n del ejemplo**:
`forEach` proporciona tres parÃ¡metros, pero podemos usar solo el primero sin problemas.

## I - Compatibilidad de Tipos de Retorno

#### 1. **DefiniciÃ³n:**

El tipo de retorno de una funciÃ³n debe ser un subtipo del tipo de retorno de la funciÃ³n a la que se asigna. Es decir, el tipo de retorno de la funciÃ³n fuente debe ser compatible con el tipo de retorno de la funciÃ³n destino. â†©ï¸

#### 2. **Ejemplo:**

```typescript
let x = () => ({ name: "Alice" });
let y = () => ({ name: "Alice", location: "Seattle" });

x = y; // Â¡Esto es vÃ¡lido!
y = x; // Â¡Error!
```

**ExplicaciÃ³n del ejemplo**:
`y` puede asignarse a `x` porque el tipo de retorno de `y` tiene al menos las propiedades del tipo de retorno de `x`.

## J - Bivariancia de ParÃ¡metros de FunciÃ³n

#### 1. **DefiniciÃ³n:**

TypeScript permite que los parÃ¡metros de funciÃ³n sean bivariantes. Esto significa que la asignaciÃ³n tiene Ã©xito si el parÃ¡metro fuente es asignable al parÃ¡metro destino, o viceversa. Esto puede ser inseguro, pero permite patrones comunes en JavaScript. ğŸ”„

#### 2. **Ejemplo:**

```typescript
enum EventType {
  Mouse,
  Keyboard,
}

interface Event {
  timestamp: number;
}

interface MyMouseEvent extends Event {
  x: number;
  y: number;
}

function listenEvent(eventType: EventType, handler: (n: Event) => void) {
  /* ... */
}

listenEvent(EventType.Mouse, (e: MyMouseEvent) => console.log(e.x + "," + e.y)); // Â¡Esto es vÃ¡lido!
```

**ExplicaciÃ³n del ejemplo**:
Aunque `MyMouseEvent` es mÃ¡s especÃ­fico que `Event`, la asignaciÃ³n es vÃ¡lida.

## K - ParÃ¡metros Opcionales y Rest

#### 1. **DefiniciÃ³n:**

Los parÃ¡metros opcionales y los parÃ¡metros rest son intercambiables al comparar funciones. Los parÃ¡metros opcionales extra en la funciÃ³n fuente no son un error, y los parÃ¡metros opcionales en la funciÃ³n destino sin parÃ¡metros correspondientes en la fuente tampoco son un error. â“

#### 2. **Ejemplo:**

```typescript
function invokeLater(args: any[], callback: (...args: any[]) => void) {
  /* ... */
}

invokeLater([1, 2], (x, y) => console.log(x + ", " + y)); // Â¡Esto es vÃ¡lido!
invokeLater([1, 2], (x?, y?) => console.log(x + ", " + y)); // Â¡Esto tambiÃ©n es vÃ¡lido!
```

**ExplicaciÃ³n del ejemplo**:
TypeScript es flexible con los parÃ¡metros opcionales y rest.

## L - Funciones con Sobrecargas

#### 1. **DefiniciÃ³n:**

Si una funciÃ³n tiene sobrecargas, cada sobrecarga en el tipo destino debe tener una firma compatible en el tipo fuente. Esto asegura que la funciÃ³n fuente pueda ser llamada en todos los casos en que la funciÃ³n destino puede ser llamada. ğŸ”€

#### 2. **Ejemplo:**

Si una funciÃ³n tiene dos sobrecargas, la funciÃ³n que se le asigna debe tener al menos dos sobrecargas compatibles.

**ExplicaciÃ³n del ejemplo**:
TypeScript asegura que las funciones con sobrecargas sean compatibles en todos los casos.

## M - Enums

#### 1. **DefiniciÃ³n:**

Los enums son compatibles con nÃºmeros, y los nÃºmeros son compatibles con enums. Sin embargo, los valores de enums de diferentes tipos no son compatibles. ğŸ”¢

#### 2. **Ejemplo:**

```typescript
enum Status {
  Ready,
  Waiting,
}

enum Color {
  Red,
  Blue,
  Green,
}

let status = Status.Ready;
status = Color.Green; // Â¡Error!
```

**ExplicaciÃ³n del ejemplo**:
No puedes asignar un valor de un enum a una variable de otro enum.

## N - Clases

#### 1. **DefiniciÃ³n:**

Las clases funcionan de manera similar a los literales de objeto y las interfaces, pero solo se comparan los miembros de la instancia. Los miembros estÃ¡ticos y los constructores no afectan la compatibilidad. ğŸ¢

#### 2. **Ejemplo:**

```typescript
class Animal {
  feet: number;
  constructor(name: string, numFeet: number) {}
}

class Size {
  feet: number;
  constructor(numFeet: number) {}
}

let a: Animal;
let s: Size;
a = s; // Â¡Esto es vÃ¡lido!
s = a; // Â¡Esto tambiÃ©n es vÃ¡lido!
```

**ExplicaciÃ³n del ejemplo**:
Solo se compara la propiedad `feet` de la instancia.

## O - Miembros Privados y Protegidos en Clases

#### 1. **DefiniciÃ³n:**

Los miembros privados y protegidos en una clase afectan su compatibilidad. Si el tipo destino tiene un miembro privado, el tipo fuente debe tener un miembro privado que provenga de la misma clase. Lo mismo aplica para los miembros protegidos. ğŸ”’

#### 2. **Ejemplo:**

Una clase puede ser compatible con su superclase, pero no con clases de otra jerarquÃ­a de herencia, aunque tengan la misma forma.

**ExplicaciÃ³n del ejemplo**:
TypeScript asegura que los miembros privados y protegidos se respeten en la compatibilidad de clases.

## P - GenÃ©ricos

#### 1. **DefiniciÃ³n:**

Los parÃ¡metros de tipo genÃ©rico solo afectan el tipo resultante cuando se usan como parte del tipo de un miembro. Si no se usan, los tipos genÃ©ricos son compatibles. ğŸ§¬

#### 2. **Ejemplo:**

```typescript
interface Empty<T> {}

let x: Empty<number>;
let y: Empty<string>;
x = y; // Â¡Esto es vÃ¡lido!
```

**ExplicaciÃ³n del ejemplo**:
`x` e `y` son compatibles porque no usan el parÃ¡metro de tipo de manera diferenciadora.

## Q - GenÃ©ricos con Miembros

#### 1. **DefiniciÃ³n:**

Si un tipo genÃ©rico usa su parÃ¡metro de tipo en un miembro, los tipos deben ser compatibles. ğŸ§®

#### 2. **Ejemplo:**

```typescript
interface NotEmpty<T> {
  data: T;
}

let x: NotEmpty<number>;
let y: NotEmpty<string>;
x = y; // Â¡Error!
```

**ExplicaciÃ³n del ejemplo**:
`x` e `y` no son compatibles porque sus miembros `data` tienen tipos diferentes.

## R - GenÃ©ricos sin Tipos Especificados

#### 1. **DefiniciÃ³n:**

Si un tipo genÃ©rico no tiene sus argumentos de tipo especificados, la compatibilidad se verifica usando `any` en lugar de los argumentos de tipo. ğŸ•³ï¸

#### 2. **Ejemplo:**

```typescript
let identity = function <T>(x: T): T {
  // ...
};

let reverse = function <U>(y: U): U {
  // ...
};

identity = reverse; // Â¡Esto es vÃ¡lido!
```

**ExplicaciÃ³n del ejemplo**:
Ambas funciones son compatibles porque `(x: any) => any` coincide con `(y: any) => any`.

## S - Subtipo vs. AsignaciÃ³n

#### 1. **DefiniciÃ³n:**

En TypeScript, hay dos tipos de compatibilidad: subtipo y asignaciÃ³n. La asignaciÃ³n extiende la compatibilidad de subtipo con reglas para permitir la asignaciÃ³n desde y hacia `any`, y desde y hacia `enum` con valores numÃ©ricos correspondientes. âš–ï¸

#### 2. **Ejemplo:**

La compatibilidad de asignaciÃ³n es mÃ¡s permisiva que la compatibilidad de subtipo.

**ExplicaciÃ³n del ejemplo**:
La compatibilidad de asignaciÃ³n se usa en la mayorÃ­a de los casos prÃ¡cticos.

## T - Asignabilidad de `any`, `unknown`, `object`, `void`, `undefined`, `null` y `never`

#### 1. **DefiniciÃ³n:**

AquÃ­ tienes una tabla que resume la asignabilidad entre algunos tipos abstractos:

|             | `any` | `unknown` | `object` | `void` | `undefined` | `null` | `never` |
| :---------- | :---: | :-------: | :------: | :----: | :---------: | :----: | :-----: |
| `any`       |   âœ“   |     âœ“     |    âœ“     |   âœ“    |      âœ“      |   âœ“    |    âœ“    |
| `unknown`   |   âœ“   |     âœ“     |    âœ•     |   âœ•    |      âœ•      |   âœ•    |    âœ•    |
| `object`    |   âœ“   |     âœ“     |    âœ“     |   âœ•    |      âœ•      |   âœ•    |    âœ•    |
| `void`      |   âœ“   |     âœ“     |    âœ•     |   âœ“    |      âœ“      |   âœ“    |    âœ“    |
| `undefined` |   âœ“   |     âœ“     |    âœ“     |   âœ“    |      âœ“      |   âœ“    |    âœ“    |
| `null`      |   âœ“   |     âœ“     |    âœ“     |   âœ“    |      âœ“      |   âœ“    |    âœ“    |
| `never`     |   âœ“   |     âœ“     |    âœ“     |   âœ“    |      âœ“      |   âœ“    |    âœ“    |

**ExplicaciÃ³n del ejemplo**:
Esta tabla muestra quÃ© tipos son asignables a otros tipos.
