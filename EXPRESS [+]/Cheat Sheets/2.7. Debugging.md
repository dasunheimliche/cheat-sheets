## A - `DEBUG=express:*`: El Interruptor General de Luz 🟡

#### 1. **Introducción:**

Este comando es como encender todas las luces de un edificio para ver qué está pasando en cada habitación y pasillo; activa un flujo detallado de mensajes internos de Express.

#### 2. **Ejemplo:**

Imagina que tu aplicación se llama `index.js`. Para ver _todo_ lo que Express hace por dentro, abres tu terminal y escribes:

**En Mac o Linux:**

```bash
$ DEBUG=express:* node index.js
```

**En Windows (usando PowerShell):**

```powershell
> $env:DEBUG = "express:*"; node index.js
```

**Explicación del ejemplo:**
Al ejecutar esto, tu consola se llenará de vida. Verás algo como:

```
  express:router:route new / +0ms
  express:router:layer new / +1ms
  express:router:route get / +1ms
  express:application compile etag weak +1ms
  ... (muchos más logs)
```

- **`DEBUG=express:*`**: Esto es una **variable de entorno**. No te asustes por el nombre. Es simplemente una instrucción que le das a tu sistema _antes_ de ejecutar tu programa. Le dices: "Oye, activa todos (`*`) los mensajes de depuración que pertenezcan al grupo `express`".
- **`node index.js`**: Este es el comando que ya conoces para iniciar tu aplicación.
- **El resultado**: Cada línea te dice qué parte de Express (`express:router`, `express:application`) está haciendo algo, qué es ese algo (`new route`, `compile etag`), y cuánto tiempo pasó desde el último mensaje (`+1ms`). ¡Es un diario íntimo de tu app!

#### 3. **Desarrollo**:

Usar `DEBUG=express:*` es tu primer instinto cuando algo no funciona y no sabes por qué. ¿Una ruta no responde? ¿Un middleware parece no ejecutarse? Este comando te mostrará si Express está siquiera registrando la ruta o ejecutando el middleware en el orden que esperas. Es ruidoso, sí, pero es el punto de partida más completo.

🟡 **Importante**: Es fundamental para el diagnóstico inicial. Aunque la cantidad de información puede ser abrumadora al principio, aprender a leerla te da superpoderes para entender el flujo interno de Express. No tienes que entender cada línea, pero sí buscar las que se relacionan con tu problema (por ejemplo, buscando el nombre de tu ruta).

---

## B - Depuración Específica: Apuntando con un Láser 🟡

#### 1. **Introducción:**

En lugar de encender todas las luces del edificio (como en el punto A), esto es como usar una linterna para iluminar solo una habitación específica, reduciendo el ruido y enfocándote en el área del problema.

#### 2. **Ejemplo:**

Si sospechas que tu problema está en cómo se manejan las rutas (el problema más común), puedes aislar los logs para ver solo la actividad del router.

**En Mac, Linux o Windows:**

```bash
# Para ver solo los logs del router
$ DEBUG=express:router node index.js

# Para ver solo los logs del ciclo de vida de la aplicación (inicio, configuración)
$ DEBUG=express:application node index.js
```

**Explicación del ejemplo:**
Al usar `DEBUG=express:router`, la avalancha de logs se convierte en un informe manejable y centrado exclusivamente en las rutas:

```
  express:router dispatching GET /users/profile +4h
  express:router query  : /users/profile +2ms
  express:router router  : /users/profile +2ms
```

Ves claramente que el `router` está despachando (`dispatching`) una petición `GET` a la ruta `/users/profile`. ¡Mucho más limpio!

#### 3. **Desarrollo**:

La belleza de esto radica en su precisión. Cuando ya tienes una pista de dónde puede estar el fallo, cambias el `*` (que significa "todo") por el nombre específico del módulo que te interesa (`router`, `application`, etc.). Esto te ahorra tiempo y te evita tener que buscar una aguja en un pajar.

🟡 **Importante**: Esta es la evolución natural del debugging. Empiezas con el general (`express:*`) para tener una visión amplia y, una vez que tienes una hipótesis, te vuelves específico para confirmarla. Dominar esto te hace un depurador mucho más eficiente.

---

## C - Depurando tu App Generada: El Canal Privado de tu App 🟡

#### 1. **Introducción:**

Si creaste tu aplicación usando el `express-generator`, esta ya viene con su propio "canal" de depuración para que puedas emitir tus propios mensajes de diagnóstico.

#### 2. **Ejemplo:**

Supongamos que usaste el comando `express mi-app-genial`. El generador crea una estructura de proyecto para ti. Para ver los mensajes de depuración de _esa aplicación en particular_, harías lo siguiente:

```bash
$ DEBUG=mi-app-genial:* node ./bin/www
```

**Explicación del ejemplo:**

- **`DEBUG=mi-app-genial:*`**: Fíjate que aquí no usamos `express:*`. Usamos el nombre que le diste a tu aplicación. Esto activa los mensajes que el propio código de `mi-app-genial` (o tú mismo) haya definido.
- **`node ./bin/www`**: En las apps generadas, el punto de entrada no suele ser `index.js`, sino este archivo `www` dentro de la carpeta `bin`.

#### 3. **Desarrollo**:

**¡Cuidado con esta confusión!** Es la más común de todas.

- `DEBUG=express:*` te muestra los secretos **del framework Express**.
- `DEBUG=nombre-de-tu-app:*` te muestra los secretos **de tu propio código**.

El generador de Express usa una librería llamada `debug` (la misma que usa Express por debajo) para configurar esto por ti. Esto te permite añadir tus propias "balizas" de depuración en tu código y activarlas o desactivarlas a voluntad desde la terminal, sin tener que llenar tu código de `console.log()` que luego tienes que borrar.

🟡 **Importante**: Si usas el generador de Express, esto es crucial. Te permite separar los problemas del framework de los problemas de tu propia lógica de negocio.

---

## D - Depuración Múltiple: Escuchando Varias Conversaciones a la Vez 🟡

#### 1. **Introducción:**

Puedes combinar múltiples "canales" de depuración en un solo comando para obtener una visión completa de cómo interactúan las diferentes partes de tu sistema.

#### 2. **Ejemplo:**

Quieres ver los logs del router de Express Y los logs de tu propia aplicación (`mi-app-genial`) al mismo tiempo.

```bash
# ¡OJO! Separados por coma, SIN ESPACIOS.
$ DEBUG=express:router,mi-app-genial:* node ./bin/www
```

**Explicación del ejemplo:**
La salida de la consola ahora mezclará los mensajes de ambas fuentes, usualmente con colores diferentes si tu terminal lo soporta, permitiéndote seguir una petición desde que entra al router de Express hasta que es procesada por tu código.

```
  express:router dispatching GET / +1s
  mi-app-genial:database Conectando a la base de datos... +2ms
  express:router dispatching GET /users +5ms
  mi-app-genial:user Se encontró el usuario 'Ana' +12ms
```

#### 3. **Desarrollo**:

Esto es increíblemente poderoso para depurar flujos complejos. Puedes ver la cadena de eventos completa. La regla de oro aquí es la sintaxis: **los nombres de los canales se separan por comas, sin ningún espacio entre ellos**. Si pones un espacio, es muy probable que no funcione como esperas. ¡Te lo digo porque es un error en el que todos hemos caído!

🟡 **Importante**: Es una técnica de nivel intermedio que se vuelve indispensable cuando las aplicaciones crecen en complejidad. Te permite correlacionar eventos entre el framework, tu código y otras librerías.

---

## E - Variables Avanzadas (`DEBUG_*`): Ajustando tu Microscopio 🔵

#### 1. **Introducción:**

Además de activar los mensajes, puedes usar otras variables de entorno para personalizar _cómo_ se muestran esos mensajes en tu consola.

#### 2. **Ejemplo:**

Estas variables se usan en combinación con la variable `DEBUG` principal.

| Variable            | Propósito explicado de forma sencilla                                                                                                                                                       |
| :------------------ | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `DEBUG_COLORS`      | ¿Quieres que los logs usen colores para diferenciarse? Pon esto en `true`. Si te molestan, ponlo en `false`.                                                                                |
| `DEBUG_DEPTH`       | Si un log muestra un objeto (ej: `{ a: { b: { c: 1 } } }`), esto controla qué tan "profundo" se muestra. Por defecto, es bajo. Auméntalo a `5` o `10` para ver todos los detalles anidados. |
| `DEBUG_SHOW_HIDDEN` | Algunos objetos tienen propiedades "secretas" que no se muestran normalmente. Activa esto (`true`) para revelarlas. ¡Para cuando necesitas ser un verdadero detective!                      |
| `DEBUG_FD`          | **(Súper avanzado)** Por defecto, los logs se escriben en la salida de error de la consola. Esto te permite redirigirlos a un archivo. Rara vez lo necesitarás.                             |

**Ejemplo de uso combinado:**

```bash
# Activa los logs del router, sin colores, y mostrando objetos hasta 5 niveles de profundidad
$ DEBUG=express:router DEBUG_COLORS=false DEBUG_DEPTH=5 node index.js
```

#### 3. **Desarrollo**:

No necesitas memorizar esto. Solo necesitas saber que existe. El 99% del tiempo, `DEBUG` será suficiente. Pero para ese 1% de casos en los que un objeto es demasiado complejo y no se muestra completo en el log, recordar `DEBUG_DEPTH` puede ser un salvavidas.

🔵 **Específico**: Estas son herramientas de precisión para situaciones particulares. No son para el día a día, pero conocer su existencia te convierte en un desarrollador con más recursos. Son como los accesorios especiales de una navaja suiza: no los usas siempre, pero cuando los necesitas, te salvan el día.
