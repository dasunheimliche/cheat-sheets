### A - Modificando Express: Elige tu Campo de Batalla (Global vs. Espec√≠fico) üü°

#### 1. **Introducci√≥n:**

Express te permite cambiar su comportamiento en dos niveles: para _todas_ las apps que corren en tu servidor (global), o solo para _una_ en particular (espec√≠fico de la app).

#### 2. **Ejemplo (Conceptual):**

Imagina que tienes una cadena de restaurantes.

- **Cambio Global (`express.request`):** Decides cambiar la receta de la salsa de tomate en la f√°brica central. ¬°Esta nueva salsa se usar√° en _todos_ tus restaurantes, te guste o no! Si la nueva receta sale mal, ¬°arruinas la comida de toda la cadena!
- **Cambio Espec√≠fico (`app.request`):** Decides probar la nueva salsa solo en _un_ restaurante. Creas tu app y luego modificas `app.request`. Si a los clientes no les gusta, el problema est√° contenido y no afecta al resto de tus locales.

```javascript
// Archivo: servidor.js
const express = require("express");

// --- CAMBIO GLOBAL (¬°PELIGROSO!) ---
// Esto afecta a CUALQUIER app de Express en este proceso.
// express.response.miFuncionGlobal = function() { console.log('¬°Soy global!'); };

const app1 = express();
const app2 = express();

// --- CAMBIO ESPEC√çFICO (¬°SEGURO Y RECOMENDADO!) ---
// Esto solo afecta a app1. app2 no se entera de nada.
app1.response.miFuncionEspecifica = function () {
  console.log("¬°Solo para la App 1!");
};

// En una ruta de app1, podr√≠as usar res.miFuncionEspecifica()
// En una ruta de app2, si intentas usar res.miFuncionEspecifica(), te dar√° un error.
```

**Explicaci√≥n del ejemplo:**
El c√≥digo muestra c√≥mo al crear una funci√≥n en `app1.response`, esta solo existe para `app1`. La `app2` sigue funcionando con el comportamiento original de Express, totalmente aislada del cambio. Por eso, casi siempre, **querr√°s hacer cambios a nivel de `app`**.

#### 3. **Desarrollo:**

Express tiene dos "planos" o "moldes" (prototipos) principales desde donde crea los objetos `request` y `response` para cada petici√≥n:

1.  **Prototipos Globales:** `express.request` y `express.response`. Si modificas algo aqu√≠, est√°s cambiando el molde original para _todas las aplicaciones Express_ que se ejecuten en el mismo proceso de Node.js. Es una mala idea porque podr√≠as causar efectos secundarios inesperados en otras partes de tu sistema que no pretend√≠as tocar.
2.  **Prototipos Espec√≠ficos de la App:** `app.request` y `app.response`. Cuando creas una instancia con `const app = express()`, `app` hereda una copia de esos moldes globales. Modificar `app.request` solo afecta a esa instancia `app` en particular. Es la forma segura y correcta de hacer personalizaciones.

üü° **Importante**: Entender esta diferencia es crucial para no causar problemas dif√≠ciles de rastrear. La regla de oro es: **siempre que puedas, haz los cambios en `app.request` o `app.response`, no en `express.request` o `express.response`**. ¬°Tu yo del futuro te lo agradecer√°!

---

### B - Ense√±ando Trucos Nuevos: C√≥mo Cambiar lo que Hace un M√©todo de Express üîµ

#### 1. **Introducci√≥n:**

Puedes reemplazar completamente una funci√≥n existente de Express (como `res.sendStatus`) por una versi√≥n tuya, d√°ndole un comportamiento y unos par√°metros totalmente nuevos.

#### 2. **Ejemplo:**

Vamos a "tunear" el m√©todo `res.sendStatus` para que, adem√°s del c√≥digo de estado, acepte el tipo de contenido y un mensaje en formato JSON.

```javascript
const express = require("express");
const app = express();

// --- ¬°Aqu√≠ ocurre la magia! ---
// Estamos reemplazando la funci√≥n original 'sendStatus' del "plano" de response de nuestra app.
app.response.sendStatus = function (statusCode, type, message) {
  // 'this' aqu√≠ dentro se refiere al objeto 'res' de la ruta.
  // Por eso podemos encadenar m√©todos de 'res' como .contentType(), .status() y .send().
  return this.contentType(type).status(statusCode).send(message);
};

app.get("/not-found", (req, res) => {
  // Ahora usamos nuestra versi√≥n "tuneada" de sendStatus.
  // Le pasamos el c√≥digo 404, el tipo 'application/json' y el mensaje.
  res.sendStatus(404, "application/json", '{"error":"recurso no encontrado"}');
});

app.listen(3000);
```

**Explicaci√≥n del ejemplo:**

1.  `app.response.sendStatus = function(...)`: Le decimos a Express: "Olvida el `sendStatus` que conoces. A partir de ahora, para _mi app_, cuando alguien llame a `res.sendStatus`, vas a ejecutar _esta_ nueva funci√≥n".
2.  `function (statusCode, type, message)`: Nuestra nueva funci√≥n ahora espera tres argumentos, no solo uno como la original.
3.  `this.contentType(type)...`: Dentro de la funci√≥n, `this` es el objeto `res` (la respuesta). Esto es s√∫per importante. Nos permite usar otros m√©todos de `res` para construir la respuesta paso a paso: primero establecemos el tipo de contenido, luego el c√≥digo de estado y finalmente enviamos el cuerpo del mensaje.

#### 3. **Desarrollo:**

Sobrescribir un m√©todo te da un control absoluto. Es como si le dijeras a un mayordomo que siempre ha servido el t√© de una manera: "A partir de ahora, lo servir√°s con tres terrones de az√∫car y una rodaja de lim√≥n, siempre".

La clave es entender que est√°s reemplazando la funcionalidad por completo. Si tu nueva funci√≥n no hace lo que se espera (por ejemplo, no env√≠a una respuesta), la petici√≥n del cliente podr√≠a quedarse colgada para siempre. ¬°Un gran poder conlleva una gran responsabilidad!

üîµ **Espec√≠fico**: No har√°s esto todos los d√≠as, pero es incre√≠blemente √∫til para estandarizar respuestas en una API. Por ejemplo, puedes crear un `res.sendSuccess(data)` y `res.sendError(message)` para que todas las respuestas de tu aplicaci√≥n tengan siempre la misma estructura.

---

### C - Propiedades de Express: Las que Puedes Cambiar y las que No üü°

#### 1. **Introducci√≥n:**

No todas las "variables" (propiedades) de `req` y `res` son iguales; unas son datos fijos para cada petici√≥n (asignadas) y otras son valores que se calculan al momento (getters). **Solo puedes cambiar la _f√≥rmula_ de las que se calculan.**

#### 2. **Desarrollo (No hay ejemplo de c√≥digo aqu√≠, es pura teor√≠a crucial):**

Para que no te vuelvas loco intentando cambiar algo que no se puede, tienes que entender esta diferencia fundamental:

- **1. Propiedades Asignadas (üö´ ¬°NO SE PUEDEN SOBRESCRIBIR!):**

  - **¬øQu√© son?** Propiedades como `req.baseUrl`, `req.path` o `req.originalUrl`.
  - **¬øC√≥mo funcionan?** Piensa en ellas como la "ficha de nacimiento" de una petici√≥n. Cuando una petici√≥n llega a tu servidor, Express la analiza y _asigna_ estos valores directamente al objeto `req`. Son datos est√°ticos, una foto del momento.
  - **¬øPor qu√© no se pueden cambiar?** Porque no hay una "f√≥rmula" que cambiar. El valor ya est√° ah√≠, "escrito en piedra" para esa petici√≥n espec√≠fica. Intentar modificar su comportamiento a nivel de prototipo no funcionar√°.

- **2. Propiedades con Getters (‚úÖ ¬°S√ç SE PUEDEN SOBRESCRIBIR!):**
  - **¬øQu√© son?** Propiedades como `req.ip`, `req.hostname` o `req.secure`.
  - **¬øC√≥mo funcionan?** Estas son m√°s inteligentes. No guardan un valor, sino una **receta (una funci√≥n `get`)** para obtener el valor. Cuando escribes `console.log(req.ip)`, no est√°s leyendo un valor guardado, est√°s ejecutando una peque√±a funci√≥n que calcula la IP en ese preciso instante.
  - **¬øPor qu√© s√≠ se pueden cambiar?** ¬°Porque podemos reemplazar esa receta! Podemos darle a Express una nueva funci√≥n `get` para que, la pr√≥xima vez que alguien pida `req.ip`, se use nuestra nueva l√≥gica. Esto lo veremos en el siguiente punto.

üü° **Importante**: Gr√°bate esto a fuego. Si quieres modificar una propiedad, primero preg√∫ntate: "¬øEs un dato fijo o un c√°lculo?". Si es un c√°lculo (un getter), ¬°puedes continuar! Si es un dato fijo (asignado), tendr√°s que buscar otra soluci√≥n.

---

### D - Cambiando la Receta: C√≥mo Modificar una Propiedad Calculada (Getter) üîµ

#### 1. **Introducci√≥n:**

Ahora que sabes qu√© son los "getters", vamos a ver c√≥mo cambiar la "receta" de una propiedad como `req.ip` para que calcule su valor de una forma totalmente nueva.

#### 2. **Ejemplo:**

Imagina que tu servidor est√° detr√°s de un proxy (algo muy com√∫n). La IP real del usuario no estar√° en `req.ip`, sino en una cabecera (header) especial llamada `Client-IP`. Vamos a ense√±arle a Express a buscarla ah√≠.

```javascript
const express = require("express");
const app = express();

// --- ¬°Aqu√≠ redefinimos la propiedad 'ip'! ---
Object.defineProperty(app.request, "ip", {
  configurable: true,
  enumerable: true,
  // Esta es la nueva "receta" para obtener la IP.
  get() {
    // 'this' es el objeto 'req'.
    // 'this.get()' es el m√©todo de Express para leer una cabecera.
    return this.get("Client-IP");
  },
});

app.get("/", (req, res) => {
  // Cuando Express ejecute esta l√≠nea, usar√° nuestra nueva receta.
  // Buscar√° la cabecera 'Client-IP' en la petici√≥n.
  res.send(`La IP del cliente (seg√∫n nuestra l√≥gica) es: ${req.ip}`);
});

// Para probar esto, necesitar√≠as una herramienta como Postman o curl
// para enviar una petici√≥n con la cabecera: Client-IP: 123.45.67.89
app.listen(3000);
```

**Explicaci√≥n del ejemplo:**

- `Object.defineProperty(...)`: Esta es la herramienta de precisi√≥n de JavaScript para definir o modificar propiedades en un objeto de forma avanzada. No te asustes por el nombre, solo piensa que es el "bistur√≠" para esta operaci√≥n.
- `app.request`: Le decimos que queremos operar sobre el "plano" de los objetos `request` de nuestra app.
- `'ip'`: El nombre de la propiedad que vamos a operar.
- `get () { ... }`: ¬°Esta es la nueva receta! La palabra `get` es clave. Le dice a JavaScript: "No guardes un valor, ejecuta esta funci√≥n cada vez que alguien intente leer la propiedad `ip`".
- `return this.get('Client-IP')`: Dentro de la receta, le decimos que busque el valor de la cabecera `Client-IP` y lo devuelva. `this` se refiere al objeto `req` en el momento de la petici√≥n.

#### 3. **Desarrollo:**

Esta t√©cnica es s√∫per poderosa para adaptar Express a la infraestructura de tu proyecto. Otro caso de uso com√∫n es modificar `req.secure` para que conf√≠e en la cabecera `X-Forwarded-Proto` que a√±aden muchos balanceadores de carga para indicar si la conexi√≥n original era HTTPS.

üîµ **Espec√≠fico**: Al igual que sobrescribir m√©todos, no es algo que hagas a diario. Pero cuando te encuentras con un problema de infraestructura como el del proxy, saber que puedes hacer esto te salva la vida.

---

### E - La Opci√≥n Nuclear: Cambiando el ADN de Request y Response ‚ö™

#### 1. **Introducci√≥n:**

Esta es la t√©cnica m√°s dr√°stica y peligrosa: reemplazar por completo el "plano" base (el prototipo) sobre el que se construyen los objetos `req` y `res` de Express.

#### 2. **Ejemplo:**

Aqu√≠, vamos a decirle a Express que deje de usar los objetos `request` y `response` est√°ndar de Node.js y que en su lugar use nuestras propias clases `FakeRequest` y `FakeResponse`.

```
javascript
const express = require('express');
const app = express();

// Supongamos que tenemos estas clases personalizadas en alg√∫n lugar
class FakeRequest { /* ... nuestro c√≥digo ... */ }
class FakeResponse { /* ... nuestro c√≥digo ... */ }

// --- ¬°ADVERTENCIA! ¬°ZONA DE ALTO RIESGO! ---

// 1. Obtenemos el "plano" actual de los objetos request de nuestra app.
const requestPrototype = Object.getPrototypeOf(app.request);
// 2. Reemplazamos ese plano por el de nuestra clase FakeRequest.
Object.setPrototypeOf(requestPrototype, FakeRequest.prototype);

// Hacemos lo mismo para response.
const responsePrototype = Object.getPrototypeOf(app.response);
Object.setPrototypeOf(responsePrototype, FakeResponse.prototype);
```

**Explicaci√≥n del ejemplo:**

- **¬øQu√© es un prototipo?** ¬°La pregunta del mill√≥n! Imagina que `http.IncomingRequest` (el prototipo por defecto de Node.js) es el chasis y el motor de un coche est√°ndar. Todos los `request` que llegan son coches construidos sobre ese chasis.
- `Object.getPrototypeOf(app.request)`: Esto es como decir: "Dame los planos del chasis del coche `request`".
- `Object.setPrototypeOf(..., FakeRequest.prototype)`: Esto es como tirar los planos originales a la basura y decir: "A partir de ahora, todos los coches `request` se construir√°n usando el chasis de este `FakeRequest` que he dise√±ado yo".

#### 3. **Desarrollo:**

**¬°ADVERTENCIA PARANOICA NIVEL DIOS!** El texto original lo advierte y yo te lo suplico: **NO HAGAS ESTO** a menos que seas un experto y tengas una raz√≥n de vida o muerte para hacerlo.

¬øPor qu√© es tan peligroso? Porque Express y todo su ecosistema de middlewares (como `body-parser`, `cors`, etc.) esperan que los objetos `req` y `res` tengan ciertas funciones y propiedades que vienen del prototipo original de Node.js. Si t√∫ lo reemplazas por tu `FakeRequest` y a este se le olvida incluir, por ejemplo, el manejo de `streams` de datos, ¬°todo se romper√° de formas misteriosas y horribles!

‚ö™ **Raramente usado**: Esta t√©cnica es tan espec√≠fica y arriesgada que el 99.9% de los desarrolladores de Express nunca la necesitar√°n. Es mucho m√°s seguro y pr√°ctico extender el comportamiento existente (como vimos en los puntos B y D) que reemplazarlo por completo. Si alguna vez piensas que necesitas esto, t√≥mate un caf√©, respira hondo y preg√∫ntate si de verdad no hay otra manera. Probablemente la haya.
