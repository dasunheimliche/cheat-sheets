## A - Code Splitting y Lazy Loading

#### 1. **Definici√≥n:**

Imagina que tu aplicaci√≥n web es como una casa muy grande. **Code Splitting** es como dividir esa casa en secciones m√°s peque√±as (m√≥dulos) y solo cargar cada secci√≥n cuando realmente la necesitas. **Lazy Loading** es la acci√≥n de cargar esas secciones "bajo demanda", es decir, solo cuando el usuario va a usarlas.

En lugar de cargar toda la casa (toda la aplicaci√≥n) de golpe al principio, solo cargas la entrada y el sal√≥n. Luego, si el usuario quiere ir a la cocina, ¬°reci√©n ah√≠ cargas la cocina!

#### 2. **Beneficios:**

- **Carga inicial m√°s r√°pida:** La p√°gina web se carga mucho m√°s r√°pido al principio porque el navegador tiene que descargar menos c√≥digo. ¬°Menos espera para el usuario!
- **Mejor rendimiento:** Al cargar solo lo necesario, la aplicaci√≥n se siente m√°s √°gil y responde mejor.
- **Cache m√°s eficiente:** Los navegadores pueden guardar en "cach√©" (memoria temporal) esos m√≥dulos m√°s peque√±os de forma m√°s efectiva. Si el usuario vuelve a la cocina, ¬°ya la tiene guardada y se carga al instante!

#### 3. **En resumen:**

Code Splitting + Lazy Loading = Webs m√°s r√°pidas y felices para todos. üöÄ

## B - Categor√≠as de Code Splitting en TanStack Router

#### 1. **TanStack Router divide el c√≥digo en dos grupos:**

Para hacer Code Splitting de forma inteligente, TanStack Router clasifica el c√≥digo de tus rutas en dos tipos:

- **Configuraci√≥n Cr√≠tica de Ruta:** Es el c√≥digo **esencial** para que la ruta actual funcione desde el principio. Piensa en ello como los cimientos de la casa. Debe estar disponible **inmediatamente**.

  - Ejemplos: C√≥mo entender las URLs (Path Parsing), validaci√≥n de par√°metros, funciones `loader` (para cargar datos), configuraciones b√°sicas de la ruta, enlaces, estilos, etc.

- **Configuraci√≥n No Cr√≠tica / Lazy de Ruta:** Es el c√≥digo que **no es necesario** para que la ruta empiece a funcionar. Se puede cargar **despu√©s**, cuando realmente se necesite. Ser√≠a como los muebles y la decoraci√≥n de la casa.
  - Ejemplos: El componente visual de la ruta (`component`), componentes para errores (`errorComponent`), componentes mientras carga (`pendingComponent`), componente para "p√°gina no encontrada" (`not-found Component`).

#### 2. **¬øPor qu√© el `loader` no se divide?**

Buena pregunta. El `loader` (la funci√≥n que carga datos para tu ruta) **no se divide por defecto** por varias razones importantes:

- **Ya es as√≠ncrono:** El `loader` de por s√≠ ya funciona de forma as√≠ncrona (espera a que lleguen los datos). Si lo dividi√©ramos, tendr√≠as que esperar **dos veces**: una para cargar el c√≥digo del `loader` y otra para que el `loader` cargue los datos. ¬°Ser√≠a m√°s lento!
- **Tama√±o peque√±o:** Normalmente, el c√≥digo del `loader` suele ser m√°s peque√±o que el componente visual. Dividir el componente tiene un impacto mayor en reducir el tama√±o inicial.
- **Pre-carga:** El `loader` es clave para la pre-carga de datos. Si pasas el rat√≥n por encima de un enlace, TanStack Router puede empezar a cargar los datos de esa ruta en segundo plano. ¬°Es importante que el `loader` est√© listo r√°pido para esto!

#### 3. **¬øQuieres dividir el `loader` a pesar de todo?**

Si tienes un `loader` muy grande y est√°s seguro de que dividirlo te beneficia, puedes hacerlo. M√°s adelante te explicamos c√≥mo en la secci√≥n de "Data Loader Splitting". Pero ¬°ojo!, piensa bien si realmente vale la pena. üßê

## C - Formas de hacer Code Splitting en TanStack Router

#### 1. **Si usas rutas basadas en archivos (recomendado):**

Si est√°s usando la forma m√°s com√∫n y recomendada de organizar tus rutas con archivos, tienes varias opciones s√∫per sencillas para hacer Code Splitting:

- **Sufijo `.lazy.tsx`:** La forma m√°s f√°cil y r√°pida. Simplemente renombras tu archivo de ruta a√±adiendo `.lazy` y usas una funci√≥n especial para crear la ruta lazy.
- **Rutas Virtuales:** √ötil cuando quieres dividir todo el c√≥digo de un archivo de ruta y dejar el archivo original vac√≠o. ¬°Puedes incluso eliminar el archivo original!
- **Code Splitting Autom√°tico ‚ú®:** La opci√≥n m√°s m√°gica. TanStack Router divide autom√°ticamente tus rutas bas√°ndose en la configuraci√≥n cr√≠tica y no cr√≠tica que vimos antes. ¬°Casi no tienes que hacer nada!

#### 2. **Si usas rutas basadas en c√≥digo:**

Si defines tus rutas directamente en c√≥digo (menos com√∫n), tambi√©n puedes hacer Code Splitting, pero de forma un poco m√°s manual. Te lo explicamos m√°s adelante en la secci√≥n de "Code-Based Splitting".

## D - Encapsular archivos de ruta en un directorio

#### 1. **Organizaci√≥n:**

Para mantener tus archivos de rutas bien organizados, especialmente cuando usas Code Splitting, puedes meter todos los archivos relacionados con una ruta dentro de una carpeta con el mismo nombre de la ruta.

#### 2. **Ejemplo:**

Imagina que tienes un archivo de ruta llamado `posts.tsx`.

**Antes:**

```
- posts.tsx
- posts.lazy.tsx
```

**Despu√©s:**

Creas una carpeta llamada `posts` y metes dentro los archivos, renombrando el archivo principal a `route.tsx` y el lazy a `route.lazy.tsx`.

```
- posts
    - route.tsx
    - route.lazy.tsx
```

#### 3. **¬øPor qu√© es √∫til?**

- **Claridad:** Ves de un vistazo todos los archivos que pertenecen a una ruta.
- **Escalabilidad:** Si una ruta tiene muchos archivos (componentes, estilos, etc.), la carpeta ayuda a mantener todo ordenado.
- **No requiere configuraci√≥n extra:** TanStack Router entiende esta estructura sin que tengas que configurarlo. ¬°Magia! ‚ú®

## E - Code Splitting con el sufijo `.lazy.tsx`

#### 1. **La forma m√°s f√°cil (para rutas basadas en archivos):**

Si est√°s usando rutas basadas en archivos, hacer Code Splitting es **s√∫per sencillo** con el sufijo `.lazy.tsx`.

#### 2. **Pasos:**

1.  **Crea dos archivos:**
    - `nombre-de-ruta.tsx`: Para la configuraci√≥n **cr√≠tica** de la ruta (loaders, validaciones, etc.).
    - `nombre-de-ruta.lazy.tsx`: Para la configuraci√≥n **no cr√≠tica** (componente principal, componentes de error, etc.).
2.  **Usa `createLazyFileRoute`:** En el archivo `.lazy.tsx`, en lugar de `createFileRoute`, usa `createLazyFileRoute`.

#### 3. **Opciones de `createLazyFileRoute`:**

Estas son las opciones que puedes definir en tu archivo `.lazy.tsx`:

| Nombre de Exportaci√≥n | Descripci√≥n                                                                 |
| --------------------- | --------------------------------------------------------------------------- |
| `component`           | El componente React que se renderizar√° para esta ruta.                      |
| `errorComponent`      | Componente para mostrar si hay un error al cargar la ruta.                  |
| `pendingComponent`    | Componente para mostrar mientras la ruta est√° cargando (pantalla de carga). |
| `notFoundComponent`   | Componente para mostrar si se produce un error de "ruta no encontrada".     |

#### 4. **Excepci√≥n: `__root.tsx`**

El archivo `__root.tsx` (la ruta ra√≠z de tu aplicaci√≥n) **no soporta Code Splitting**. Siempre se carga al principio, as√≠ que no tiene sentido dividirlo.

#### 5. **Ejemplo pr√°ctico:**

**Antes (un solo archivo):**

```tsx
// src/routes/posts.tsx
import { createFileRoute } from "@tanstack/react-router";
import { fetchPosts } from "./api";

export const Route = createFileRoute("/posts")({
  loader: fetchPosts,
  component: Posts,
});

function Posts() {
  // ... c√≥digo del componente Posts ...
}
```

**Despu√©s (dos archivos):**

**Archivo `posts.tsx` (configuraci√≥n cr√≠tica):**

```tsx
// src/routes/posts.tsx
import { createFileRoute } from "@tanstack/react-router";
import { fetchPosts } from "./api";

export const Route = createFileRoute("/posts")({
  loader: fetchPosts, // El loader se queda aqu√≠
});
```

**Archivo `posts.lazy.tsx` (configuraci√≥n no cr√≠tica):**

```tsx
// src/routes/posts.lazy.tsx
import { createLazyFileRoute } from "@tanstack/react-router";

export const Route = createLazyFileRoute("/posts")({
  component: Posts, // El componente Posts se mueve aqu√≠
});

function Posts() {
  // ... c√≥digo del componente Posts ...
}
```

**Explicaci√≥n del ejemplo:**

- Hemos dividido el archivo `posts.tsx` en dos.
- El archivo original `posts.tsx` ahora solo tiene la configuraci√≥n **cr√≠tica** (`loader`).
- Hemos creado `posts.lazy.tsx` con `createLazyFileRoute` y movido el componente `Posts` a este archivo.
- ¬°Listo! Ahora el componente `Posts` se cargar√° solo cuando se necesite, haciendo tu aplicaci√≥n m√°s r√°pida. üöÄ

## F - Usando Rutas Virtuales

#### 1. **¬øQu√© son las Rutas Virtuales?**

Imagina que has dividido tanto tu archivo de ruta con `.lazy.tsx` que el archivo original (`.tsx` sin `.lazy`) se queda **completamente vac√≠o**. En ese caso, ¬°puedes **eliminar** el archivo `.tsx` original!

TanStack Router crear√° autom√°ticamente una **ruta virtual**. Es como si siguiera existiendo un archivo `.tsx` vac√≠o "fantasma" solo para que tus archivos `.lazy.tsx` tengan un lugar donde "anclarse".

#### 2. **Cu√°ndo usar Rutas Virtuales:**

Cuando divides **toda** la configuraci√≥n no cr√≠tica de un archivo de ruta y el archivo original se queda sin nada importante.

#### 3. **Ejemplo pr√°ctico:**

**Antes (con archivo `.tsx` vac√≠o):**

```tsx
// src/routes/posts.tsx
import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/posts")({
  // ¬°Hola? ¬°Aqu√≠ no hay nada!
});
```

```tsx
// src/routes/posts.lazy.tsx
import { createLazyFileRoute } from "@tanstack/react-router";

export const Route = createLazyFileRoute("/posts")({
  component: Posts,
});

function Posts() {
  // ... c√≥digo del componente Posts ...
}
```

**Despu√©s (Rutas Virtuales):**

¬°Simplemente **elimina** `posts.tsx`!

```tsx
// src/routes/posts.lazy.tsx
import { createLazyFileRoute } from "@tanstack/react-router";

export const Route = createLazyFileRoute("/posts")({
  component: Posts,
});

function Posts() {
  // ... c√≥digo del componente Posts ...
}
```

**Explicaci√≥n del ejemplo:**

- Antes, ten√≠amos un archivo `posts.tsx` vac√≠o porque hab√≠amos movido todo a `posts.lazy.tsx`.
- Con Rutas Virtuales, ¬°simplemente borramos `posts.tsx`! TanStack Router sigue entendiendo que la ruta `/posts` existe gracias a `posts.lazy.tsx`.
- ¬°M√°s limpio y sencillo! üéâ

## G - Usando Code Splitting Autom√°tico ‚ú®

#### 1. **La magia del `autoCodeSplitting`:**

Si quieres la forma **m√°s f√°cil** de hacer Code Splitting, ¬°usa el modo autom√°tico! TanStack Router se encarga de dividir tus archivos de ruta **autom√°ticamente** bas√°ndose en la configuraci√≥n cr√≠tica y no cr√≠tica que ya te explicamos.

#### 2. **Importante:**

- **Solo para rutas basadas en archivos:** El Code Splitting autom√°tico solo funciona si est√°s usando rutas basadas en archivos.
- **Bundlers soportados:** Necesitas usar uno de los bundlers compatibles con TanStack Router (Webpack, Rollup, esbuild, Vite, Parcel). No funciona solo con la CLI de TanStack Router (`@tanstack/router-cli`).
- **TODO se divide:** Cuando activas el modo autom√°tico, **todas** tus rutas basadas en archivos se dividir√°n. Aseg√∫rate de que realmente quieres dividir todas tus rutas antes de activarlo.

#### 3. **Preparando tus archivos de ruta para el modo autom√°tico:**

Si ya estabas usando `.lazy.tsx` o Rutas Virtuales, tienes que hacer algunos cambios para usar el modo autom√°tico:

- **Elimina `.lazy.tsx`:** Si hab√≠as dividido rutas con `.lazy.tsx`, vuelve a **unir** los archivos en un solo archivo `.tsx` (sin `.lazy`).
- **Elimina `.lazy.tsx` de Rutas Virtuales:** Si estabas usando Rutas Virtuales, renombra los archivos `.lazy.tsx` a `.tsx` (sin `.lazy`).

**Ejemplo: Antes (con `.lazy.tsx`)**

```tsx
// src/routes/posts.tsx
import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/posts")({
  loader: fetchPosts,
});
```

```tsx
// src/routes/posts.lazy.tsx
import { createLazyFileRoute } from "@tanstack/react-router";

export const Route = createLazyFileRoute("/posts")({
  component: Posts,
});

function Posts() {
  // ... c√≥digo del componente Posts ...
}
```

**Despu√©s (para Code Splitting Autom√°tico):**

```tsx
// src/routes/posts.tsx
import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/posts")({
  loader: fetchPosts,
  component: Posts, // ¬°Volvemos a unir el componente aqu√≠!
});

function Posts() {
  // ... c√≥digo del componente Posts ...
}
```

**Ejemplo: Antes (con Rutas Virtuales)**

```tsx
// src/routes/posts.lazy.tsx
import { createLazyFileRoute } from "@tanstack/react-router";

export const Route = createLazyFileRoute("/posts")({
  /* ... */
});
```

**Despu√©s (para Code Splitting Autom√°tico):**

```tsx
// src/routes/posts.tsx
import { createFileRoute } from "@tanstack/react-router";

export const Route = createFileRoute("/posts")({
  /* ... */
});
```

#### 4. **Activando el Code Splitting Autom√°tico:**

Una vez que hayas preparado tus archivos, solo tienes que a√±adir esta l√≠nea a tu archivo `tsr.config.json`:

```jsonc
{
  // ...
  "autoCodeSplitting": true
}
```

¬°Y listo! TanStack Router har√° la magia y dividir√° autom√°ticamente tus rutas. ‚ú®

## H - Code-Based Splitting (Manual)

#### 1. **Para rutas definidas en c√≥digo:**

Si no est√°s usando rutas basadas en archivos y defines tus rutas directamente en c√≥digo, tambi√©n puedes hacer Code Splitting, pero de forma un poco m√°s manual usando `route.lazy()` y `createLazyRoute`.

#### 2. **Pasos:**

1.  **Crea una ruta "lazy" con `createLazyRoute`:** Define tu ruta "lazy" en un archivo separado usando `createLazyRoute`. Aqu√≠ defines la configuraci√≥n **no cr√≠tica** (componente, etc.).

    ```tsx
    // src/posts.tsx
    export const Route = createLazyRoute("/posts")({
      component: MyComponent,
    });

    function MyComponent() {
      return <div>Mi Componente</div>;
    }
    ```

2.  **Usa `.lazy()` en la ruta principal:** En el archivo donde defines tus rutas principales (por ejemplo, `app.tsx`), usa el m√©todo `.lazy()` en la ruta que quieres dividir. Dentro de `.lazy()`, importa de forma din√°mica (con `import()`) el archivo donde definiste la ruta "lazy" y extrae la exportaci√≥n `Route`.

    ```tsx
    // src/app.tsx
    const postsRoute = createRoute({
      getParentRoute: () => rootRoute,
      path: "/posts",
    }).lazy(() => import("./posts.lazy").then((d) => d.Route));
    ```

**Explicaci√≥n del ejemplo:**

- Creamos una ruta "lazy" para `/posts` en `src/posts.tsx` usando `createLazyRoute` y definiendo el componente `MyComponent`.
- En `app.tsx`, definimos la ruta `/posts` normalmente con `createRoute`.
- Usamos `.lazy(() => import('./posts.lazy').then((d) => d.Route))` para decirle a TanStack Router que el c√≥digo de esta ruta (el componente `MyComponent`) se cargue de forma lazy desde el archivo `posts.lazy.tsx`.

## I - Data Loader Splitting (Dividir el `loader`)

#### 1. **¬°Ojo! Riesgo de doble petici√≥n:**

Dividir el `loader` puede hacer que tu aplicaci√≥n sea **m√°s lenta** en algunos casos. Recuerda que el navegador tendr√° que hacer **dos viajes** al servidor:

1.  Para descargar el c√≥digo del `loader`.
2.  Para ejecutar el `loader` y obtener los datos.

**Solo divide el `loader` si est√°s muy seguro de que el c√≥digo de tu `loader` es muy grande y est√° engordando mucho tu bundle inicial.**

#### 2. **Forma manual (con `import()`):**

Puedes dividir el `loader` usando `import()` din√°mico dentro de la opci√≥n `loader` de tu ruta.

```tsx
import { LoaderContext } from "@tanstack/react-router";

const route = createRoute({
  path: "/my-route",
  component: MyComponent,
  loader: (...args) => import("./loader").then((d) => d.loader(...args)),
});

// En otro archivo (loader.ts):
export const loader = async (context: LoaderContext) => {
  /// ... c√≥digo de tu loader ...
};
```

**Explicaci√≥n del ejemplo:**

- En la opci√≥n `loader`, usamos una funci√≥n que importa din√°micamente el archivo `./loader.ts`.
- Cuando el c√≥digo del `loader` se carga, llamamos a la funci√≥n `loader` que exporta ese archivo, pas√°ndole los argumentos necesarios (`...args`).

#### 3. **Usando `lazyFn` (m√°s sencillo):**

TanStack Router ofrece una funci√≥n llamada `lazyFn` para simplificar la divisi√≥n del `loader`. Es similar a `lazyRouteComponent`.

```tsx
import { lazyFn } from "@tanstack/react-router";

const route = createRoute({
  path: "/my-route",
  component: MyComponent,
  loader: lazyFn(() => import("./loader"), "loader"),
});

// En otro archivo (loader.ts):
export const loader = async (context: LoaderContext) => {
  /// ... c√≥digo de tu loader ...
};
```

**Explicaci√≥n del ejemplo:**

- Usamos `lazyFn(() => import('./loader'), 'loader')` en la opci√≥n `loader`.
- El primer argumento de `lazyFn` es una funci√≥n que importa din√°micamente el archivo del `loader` (`./loader.ts`).
- El segundo argumento `'loader'` es el nombre de la exportaci√≥n que queremos usar de ese archivo (en este caso, `export const loader`).

## J - `getRouteApi`: Acceder a APIs de Ruta desde otros archivos

#### 1. **El problema:**

Cuando divides el componente de una ruta en un archivo separado, a veces necesitas acceder a APIs de la ruta (como `useLoaderData`, `useParams`, etc.) dentro de ese componente. Pero ¬°no quieres importar la ruta en s√≠ en el archivo del componente!

#### 2. **La soluci√≥n: `getRouteApi`:**

TanStack Router te da la funci√≥n `getRouteApi` para solucionar esto. Con `getRouteApi`, puedes acceder a las APIs de una ruta de forma **type-safe** (con tipos seguros) en otro archivo **sin importar la ruta directamente**.

#### 3. **Ejemplo:**

**`my-route.tsx` (archivo de ruta):**

```tsx
import { createRoute } from "@tanstack/react-router";
import { MyComponent } from "./MyComponent";

const route = createRoute({
  path: "/my-route",
  loader: () => ({
    foo: "bar",
  }),
  component: MyComponent,
});
```

**`MyComponent.tsx` (archivo del componente):**

```tsx
import { getRouteApi } from "@tanstack/react-router";

const route = getRouteApi("/my-route"); // ¬°Usamos getRouteApi con la ruta!

export function MyComponent() {
  const loaderData = route.useLoaderData();
  //    ^? { foo: string }  ¬°Typescript sabe que loaderData es { foo: string }!

  return <div>...</div>;
}
```

**Explicaci√≥n del ejemplo:**

- En `MyComponent.tsx`, usamos `getRouteApi('/my-route')` para obtener una "referencia" type-safe a la ruta `/my-route`.
- Ahora podemos usar `route.useLoaderData()`, `route.useParams()`, etc. como si hubi√©ramos importado la ruta directamente.
- ¬°Typescript sabe los tipos de datos gracias a `getRouteApi`!

#### 4. **APIs type-safe a las que puedes acceder con `getRouteApi`:**

- `useLoaderData`
- `useLoaderDeps`
- `useMatch`
- `useParams`
- `useRouteContext`
- `useSearch`
