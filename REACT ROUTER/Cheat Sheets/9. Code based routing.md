## A - **Antes de Empezar (¡Importante!)** ⚠️

#### 1. **Definición:**

Si estás usando **File-Based Routing**, ¡olvídate de esto! Esta guía es solo para **Code-Based Routing**.

#### 2. **Advertencia para Novatos:**

**File-Based Routing es la forma RECOMENDADA** en TanStack Router. Si no estás seguro de cuál usar, lee primero la guía de File-Based Routing. Si aún así prefieres el código, ¡adelante!, pero lee la guía de File-Based Routing primero para entender los conceptos básicos.

#### 3. **En resumen:**

Code-Based Routing es una opción más manual, pero si entiendes File-Based Routing, ¡esto será pan comido!

---

## B - **Route Trees (Árboles de Rutas)** 🌳

#### 1. **Definición:**

Tanto en Code-Based como en File-Based Routing, usamos **árboles de rutas**. Imagina un árbol genealógico, pero de rutas web. Este árbol organiza cómo se relacionan las rutas entre sí y cómo se mostrarán tus componentes. La única diferencia aquí es que, en lugar de usar carpetas y archivos, ¡lo hacemos con código!

#### 2. **Ejemplo:**

**File-Based Routing (carpetas y archivos):**

```
routes/
├── __root.tsx
├── index.tsx
├── about.tsx
├── posts/
│   ├── index.tsx
│   ├── $postId.tsx
├── posts.$postId.edit.tsx
├── settings/
│   ├── profile.tsx
│   ├── notifications.tsx
├── _layout.tsx
├── _layout/
│   ├── layout-a.tsx
├── ├── layout-b.tsx
├── files/
│   ├── $.tsx
```

**Code-Based Routing (código):**

```tsx
import { createRootRoute, createRoute } from "@tanstack/react-router";

const rootRoute = createRootRoute();

const indexRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "/",
});

const aboutRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "about",
});

const postsRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "posts",
});

const postsIndexRoute = createRoute({
  getParentRoute: () => postsRoute,
  path: "/",
});

const postRoute = createRoute({
  getParentRoute: () => postsRoute,
  path: "$postId",
});

const postEditorRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "posts/$postId/edit",
});

const settingsRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "settings",
});

const profileRoute = createRoute({
  getParentRoute: () => settingsRoute,
  path: "profile",
});

const notificationsRoute = createRoute({
  getParentRoute: () => settingsRoute,
  path: "notifications",
});

const layoutRoute = createRoute({
  getParentRoute: () => rootRoute,
  id: "layout",
});

const layoutARoute = createRoute({
  getParentRoute: () => layoutRoute,
  path: "layout-a",
});

const layoutBRoute = createRoute({
  getParentRoute: () => layoutRoute,
  path: "layout-b",
});

const filesRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "files/$",
});
```

**Explicación del ejemplo:**

Vemos que la estructura es la misma, ¡solo que ahora la definimos con código en lugar de carpetas! `createRoute` es la función mágica para crear cada ruta.

#### 3. **En resumen:**

Árbol de rutas = organización de rutas. Code-Based Routing = árbol de rutas definido con código.

---

## C - **File-Based vs Code-Based Routing (¿Cuál elegir?)** ⚖️

#### 1. **Definición:**

File-Based Routing es como una versión "avanzada" de Code-Based Routing. Usa el sistema de archivos (tus carpetas y archivos) para generar automáticamente la estructura de rutas que vimos antes. ¡Es como si el ordenador escribiera el código de rutas por ti!

#### 2. **Conceptos Clave (¡Repaso rápido!):**

Asumimos que ya conoces estos conceptos de File-Based Routing (si no, ¡échale un vistazo a esa guía primero!):

- **Root Route (Ruta Raíz):** La base de todo.
- **Static Routes (Rutas Estáticas):** Rutas normales como `/about`.
- **Index Routes (Rutas Índice):** La ruta principal dentro de una sección, como `/posts` (sin nada más).
- **Dynamic Route Segments (Segmentos de Ruta Dinámicos):** Partes de la URL que cambian, como `/posts/$postId` (el `$postId` es dinámico).
- **Splat / Catch-All Routes (Rutas "Comodín"):** Para capturar cualquier ruta que no coincida con otras, como `/files/$` (todo después de `/files/`).
- **Pathless Routes (Rutas sin Path):** Rutas que no cambian la URL, usadas para layouts o componentes contenedores.
- **Non-Nested Routes (Rutas No Anidadas):** Rutas que parecen estar dentro de otra sección en la URL, pero no lo están en la estructura de componentes.
- **Not-Found Routes (Rutas "No Encontrado"):** Para cuando la URL no coincide con ninguna ruta definida (error 404).

#### 3. **En resumen:**

File-Based Routing = automático y fácil. Code-Based Routing = manual pero te da control total. File-Based usa el sistema de archivos para hacer el Code-Based por ti.

---

## D - **The Root Route (La Ruta Raíz)** 🏠

#### 1. **Definición:**

La **ruta raíz** es la madre de todas las rutas. Es el punto de partida de tu árbol de rutas.

#### 2. **Cómo crearla en Code-Based:**

Usamos la función `createRootRoute()`. ¡Igual que en File-Based!

```tsx
import { createRootRoute } from "@tanstack/react-router";

const rootRoute = createRootRoute();
```

#### 3. **Notas Importantes:**

- **No necesitas exportarla:** A diferencia de File-Based Routing, aquí no es obligatorio exportar la `rootRoute` si no quieres. ¡Pero ojo! No es buena idea tener todo tu árbol de rutas en un solo archivo gigante (aunque para ejemplos cortos, ¡vale!).
- **`createRootRouteWithContext<TContext>()`:** Si necesitas inyectar dependencias en toda tu app de rutas de forma segura (con TypeScript), usa esta función. Más info en la sección de [Contexto](https://tanstack.com/router/latest/docs/framework/react/guide/router-context).

#### 4. **En resumen:**

`createRootRoute()` = crea la ruta raíz. Es la base de todo.

---

## E - **Anatomía de una Ruta (createRoute)** 🦴

#### 1. **Definición:**

Todas las rutas, excepto la raíz, se crean con la función `createRoute()`. Esta función necesita algunas opciones para saber cómo funciona la ruta.

#### 2. **Ejemplo Básico:**

```tsx
const route = createRoute({
  getParentRoute: () => rootRoute, // ¡Ruta padre!
  path: "/posts", // Path de la URL
  component: PostsComponent, // Componente a mostrar
});
```

#### 3. **Opciones Clave:**

- **`getParentRoute`:** ¡Obligatoria! Es una función que dice cuál es la ruta "padre" de esta ruta. Define la jerarquía del árbol de rutas.
- **`path`:** El segmento de la URL que esta ruta va a "escuchar" (comparar). Si la URL coincide con este path, ¡esta ruta se activa! Necesaria para todas las rutas **que no sean la raíz o pathless routes**.

#### 4. **Pregunta Frecuente (¡Anticipando dudas!):**

**❓❓❓ "¿Tengo que pasar la ruta padre para cada ruta? ¡Qué rollo!"**

**¡Sí!** Y tiene una razón de ser muy importante: **¡Type Safety (Seguridad de Tipos) con TypeScript!** Si no le dices quién es el padre, TypeScript no sabría qué tipos de datos manejar en tu ruta. ¡Es para que todo sea más seguro y sin errores!

#### 5. **En resumen:**

`createRoute()` = crea una ruta. `getParentRoute` = define el padre (jerarquía). `path` = define la URL que activa la ruta. ¡Todo por la type safety!

---

## F - **El Opción `path` (Detalles Importantes)** 🛤️

#### 1. **Definición:**

La opción `path` define cómo se "activa" una ruta al navegar a una URL. Es la parte de la URL que TanStack Router compara con la ruta que definiste.

#### 2. **Slashes al Principio y al Final (Normalización):**

Cuando defines `path` en código, ¡no te preocupes por las barras `/` al principio o al final! TanStack Router las ignora y las normaliza internamente. Puedes ponerlas si quieres, pero él las ajustará.

#### 3. **Tabla de Normalización:**

| Path     | Normalized Path |
| :------- | :-------------- |
| `/`      | `/`             |
| `/about` | `about`         |
| `about/` | `about`         |
| `about`  | `about`         |
| `$`      | `$`             |
| `/$`     | `$`             |
| `/$/`    | `$`             |

**Explicación de la tabla:**

Como ves, da igual si pones `/about`, `about/` o `about`, ¡siempre se normaliza a `about`! Lo mismo con los splat routes (`$`).

#### 4. **En resumen:**

`path` = define la parte de la URL que activa la ruta. ¡No te preocupes por las barras `/`! Router lo normaliza.

---

## G - **Construyendo el Route Tree Manualmente (addChildren)** 🏗️

#### 1. **Definición:**

En Code-Based Routing, no basta con decir quién es el padre de cada ruta con `getParentRoute`. ¡También tienes que construir el árbol de rutas final "a mano"! Esto se hace añadiendo cada ruta a la lista `children` de su ruta padre. En File-Based Routing, esto se hace automáticamente, ¡pero aquí no!

#### 2. **Ejemplo con `addChildren`:**

```tsx
/* prettier-ignore */
const routeTree = rootRoute.addChildren([
  indexRoute,
  aboutRoute,
  postsRoute.addChildren([ // Añadiendo rutas hijas a 'postsRoute'
    postsIndexRoute,
    postRoute,
  ]),
  postEditorRoute,
  settingsRoute.addChildren([ // Añadiendo rutas hijas a 'settingsRoute'
    profileRoute,
    notificationsRoute,
  ]),
  layoutRoute.addChildren([ // Añadiendo rutas hijas a 'layoutRoute'
    layoutARoute,
    layoutBRoute,
  ]),
  filesRoute.addChildren([ // Añadiendo rutas hijas a 'filesRoute'
    fileRoute,
  ]),
])
/* prettier-ignore-end */
```

**Explicación del ejemplo:**

- `rootRoute.addChildren([...])`: Añadimos rutas hijas directamente a la ruta raíz.
- `postsRoute.addChildren([...])`: Añadimos rutas hijas a la ruta `postsRoute`. ¡Y así sucesivamente!
- `/* prettier-ignore */`: Esto es solo para que el formateador de código no cambie el formato de la lista, ¡para que sea más fácil de leer!

#### 3. **En resumen:**

`addChildren()` = función para construir el árbol de rutas manualmente. ¡Conecta cada ruta con sus hijas!

---

## H - **Static Routes (Rutas Estáticas)** 📍

#### 1. **Definición:**

Rutas estáticas son las más simples. Son rutas con paths fijos, como `/about`, `/contact`, etc. Siempre apuntan al mismo lugar.

#### 2. **Ejemplo en Código:**

```tsx
const aboutRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "about", // Path estático: 'about'
});
```

**Explicación del ejemplo:**

Simplemente le das un `path` normal, ¡sin cosas raras! En este caso, `path: 'about'` crea una ruta que se activa cuando la URL es `/about`.

#### 3. **En resumen:**

Static Routes = paths fijos y normales. ¡Fácil!

---

## I - **Index Routes (Rutas Índice)** 🏠️

#### 1. **Definición:**

Las rutas índice son las rutas "principales" dentro de una sección. Por ejemplo, en `/posts`, la ruta índice sería la que se muestra cuando solo vas a `/posts` (sin nada más después). En File-Based Routing, usábamos `index.tsx`.

#### 2. **Ejemplo en Código:**

```tsx
const postsRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "posts", // Ruta padre: /posts
});

const postsIndexRoute = createRoute({
  getParentRoute: () => postsRoute, // ¡Hija de 'postsRoute'!
  path: "/", // Path índice: '/'
});
```

**Explicación del ejemplo:**

- `postsRoute` define la ruta padre `/posts`.
- `postsIndexRoute` es hija de `postsRoute` y tiene `path: '/'`. ¡La clave está en el `/`! Esto significa que esta ruta se activa cuando la URL coincide con la ruta padre (`/posts`) **exactamente**, sin nada más.

#### 3. **Diferencia con File-Based Routing:**

En File-Based Routing, `index.tsx` en la carpeta `posts` hacía de ruta índice para `/posts`. Aquí, usamos `path: '/'` dentro de `createRoute`.

#### 4. **En resumen:**

Index Routes = ruta principal de una sección. En Code-Based, usa `path: '/'`.

---

## J - **Dynamic Route Segments (Segmentos de Ruta Dinámicos)** 🚀

#### 1. **Definición:**

Segmentos de ruta dinámicos son partes de la URL que pueden cambiar. Se usan para capturar información variable de la URL, como IDs de posts, nombres de usuario, etc. En File-Based Routing, usábamos `$postId.tsx`.

#### 2. **Ejemplo en Código:**

```tsx
const postsRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "posts",
});

const postIdRoute = createRoute({
  getParentRoute: () => postsRoute,
  path: "$postId", // Segmento dinámico: '$postId'
  loader: ({ params }) => fetchPost(params.postId), // Usando 'params' en el loader
  component: PostComponent,
});

function PostComponent() {
  const { postId } = postIdRoute.useParams(); // Usando 'useParams' en el componente
  return <div>Post ID: {postId}</div>;
}
```

**Explicación del ejemplo:**

- `path: '$postId'`: El `$` al principio de `postId` lo convierte en un segmento dinámico. Cualquier cosa que esté en esa posición de la URL (después de `/posts/`) se capturará como el parámetro `postId`.
- `loader: ({ params }) => fetchPost(params.postId)`: En el `loader` (función para cargar datos), podemos acceder a los parámetros dinámicos con `params.postId`.
- `postIdRoute.useParams()`: En el componente `PostComponent`, usamos `postIdRoute.useParams()` para acceder a los parámetros dinámicos de forma type-safe.

#### 3. **Tip Pro:**

Si tu componente está en un archivo separado (code-split), usa `getRouteApi` para acceder a `useParams` sin importar la configuración de `postIdRoute` directamente. Más info en [Code Splitting](https://tanstack.com/router/latest/docs/framework/react/guide/code-splitting#manually-accessing-route-apis-in-other-files-with-the-getrouteapi-helper).

#### 4. **En resumen:**

Dynamic Route Segments = partes variables de la URL. Usa `$` al principio del segmento en `path`. Accede a los parámetros con `params` en `loader` y `useParams()` en componentes.

---

## K - **Splat / Catch-All Routes (Rutas "Comodín")** 🪤

#### 1. **Definición:**

Rutas "comodín" o "splat" capturan cualquier parte de la URL que no coincida con otras rutas más específicas. Son como un "cajón desastre" para URLs que no encajan en otro sitio. En File-Based Routing, usábamos `$.tsx`.

#### 2. **Ejemplo en Código:**

```tsx
const filesRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "files",
});

const fileRoute = createRoute({
  getParentRoute: () => filesRoute,
  path: "$", // Splat route: '$'
});
```

**Explicación del ejemplo:**

- `path: '$'`: Un `$` solito como `path` crea una splat route. Captura todo lo que venga después de la ruta padre (`/files/` en este caso).

#### 3. **Ejemplo de URL y Parámetros:**

Para la URL `/files/documents/hello-world`, el objeto `params` será:

```js
{
  '_splat': 'documents/hello-world' // ¡Todo lo capturado está en '_splat'!
}
```

**Explicación:**

El parámetro capturado se guarda bajo la clave `_splat` en el objeto `params`.

#### 4. **En resumen:**

Splat Routes = capturan "todo lo demás" de la URL. Usa `path: '$'`. Accede a lo capturado con `params._splat`.

---

## L - **Pathless Routes (Rutas sin Path)** 👻

#### 1. **Definición:**

Pathless Routes son rutas que **no cambian la URL**. Se usan principalmente para layouts o componentes contenedores que envuelven a otras rutas. En File-Based Routing, usábamos `_layout.tsx`.

#### 2. **Ejemplo en Código:**

```tsx
const layoutRoute = createRoute({
  getParentRoute: () => rootRoute,
  id: "layout", // ¡Usamos 'id' en lugar de 'path'!
  component: LayoutComponent,
});

const layoutARoute = createRoute({
  getParentRoute: () => layoutRoute,
  path: "layout-a", // Rutas hijas sí tienen 'path'
});

const layoutBRoute = createRoute({
  getParentRoute: () => layoutRoute,
  path: "layout-b", // Rutas hijas sí tienen 'path'
});

const routeTree = rootRoute.addChildren([
  layoutRoute.addChildren([layoutARoute, layoutBRoute]), // 'layoutRoute' es padre de 'layoutARoute' y 'layoutBRoute'
]);
```

**Explicación del ejemplo:**

- `id: 'layout'`: En lugar de `path`, usamos `id: 'layout'`. Esto hace que `layoutRoute` sea una pathless route. **No afecta a la URL**.
- `layoutARoute` y `layoutBRoute` sí tienen `path` y son hijas de `layoutRoute`.

#### 3. **Comportamiento en la URL:**

Ahora, tanto `/layout-a` como `/layout-b` mostrarán su contenido **dentro** del `LayoutComponent`. La URL solo cambiará a `/layout-a` o `/layout-b`, pero `LayoutComponent` siempre estará presente.

```tsx
// URL: /layout-a
<LayoutComponent>
  <LayoutAComponent />
</LayoutComponent>

// URL: /layout-b
<LayoutComponent>
  <LayoutBComponent />
</LayoutComponent>
```

#### 4. **Diferencia con File-Based Routing:**

En File-Based Routing, usábamos `_layout.tsx` para indicar una pathless route. Aquí, usamos `id` en lugar de `path`.

#### 5. **En resumen:**

Pathless Routes = no cambian la URL, para layouts. Usa `id` en lugar de `path`.

---

## M - **Non-Nested Routes (Rutas No Anidadas)** 💔

#### 1. **Definición:**

Non-Nested Routes son rutas que, aunque en la URL parezcan estar dentro de otra sección, **no están anidadas en la estructura de componentes**. Por ejemplo, `/posts/$postId/edit` podría parecer hija de `/posts/$postId`, pero podemos hacer que no lo sea. En File-Based Routing, usábamos `posts_/$postId/edit.tsx` (con un `_` después del nombre de la carpeta).

#### 2. **Ejemplo en Código:**

Queremos que `/posts/$postId/edit` **no** esté dentro de `/posts`.

```tsx
// 'postEditorRoute' NO está anidada dentro de 'postsRoute'
const postEditorRoute = createRoute({
  getParentRoute: () => rootRoute, // ¡Padre es 'rootRoute'!
  path: "posts/$postId/edit", // Path completo desde la raíz
});

const postsRoute = createRoute({
  getParentRoute: () => rootRoute,
  path: "posts",
});

const postRoute = createRoute({
  getParentRoute: () => postsRoute,
  path: "$postId",
});

const routeTree = rootRoute.addChildren([
  postEditorRoute, // 'postEditorRoute' directamente en la raíz
  postsRoute.addChildren([postRoute]), // 'postsRoute' y sus hijas también en la raíz
]);
```

**Explicación del ejemplo:**

- `postEditorRoute` tiene `getParentRoute: () => rootRoute` y `path: 'posts/$postId/edit'`. ¡Está directamente bajo la ruta raíz! Aunque el `path` contiene `posts`, **no está anidada dentro de `postsRoute` en el árbol de componentes**.
- `postsRoute` y sus hijas (`postRoute`) también están bajo la ruta raíz, pero en una rama separada.

#### 3. **Resultado:**

- `/posts/$postId/edit` se renderizará **sin** el layout o componentes de `/posts` o `/posts/$postId`.
- `/posts` y `/posts/$postId` se renderizarán con su propia estructura (si la tienen definida).

#### 4. **Diferencia con File-Based Routing:**

En File-Based Routing, usábamos `posts_/$postId/edit.tsx` para indicar que no era anidada. Aquí, lo logramos definiendo `getParentRoute: () => rootRoute` y el `path` completo.

#### 5. **En resumen:**

Non-Nested Routes = parecen anidadas en la URL, pero no en componentes. Define `getParentRoute` a la ruta donde _realmente_ quieres anidarla y usa el `path` completo.

---

## N - **404 / NotFoundRoutes (Rutas "No Encontrado")** 💔

#### 1. **Definición:**

NotFoundRoutes son para cuando la URL **no coincide con ninguna de las rutas que has definido**. Es la página de "Error 404 - No Encontrado".

#### 2. **Cómo configurarlas:**

La guía explica que la configuración de NotFoundRoutes se verá en la guía de [Not Found Errors](https://tanstack.com/router/latest/docs/framework/react/guide/not-found-errors). ¡Así que tendremos que esperar a esa guía para más detalles! 😉

#### 3. **En resumen:**

NotFoundRoutes = para URLs que no coinciden con nada. ¡Más info en la guía de "Not Found Errors"!
