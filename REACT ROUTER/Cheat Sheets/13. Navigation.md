## A - Navegación Relativa: Todo es Relativo

#### 1. **Definición:**

En TanStack Router, **toda navegación es relativa**. Incluso cuando no usas rutas relativas explícitas como `../../`, siempre te mueves **desde** una ruta de origen **hacia** una ruta de destino. Piensa en ello como ir de un punto A a un punto B.

#### 2. **Explicación:**

TanStack Router siempre considera dos puntos clave en cada navegación:

- **`from`**: El ID de la ruta de **origen**, es decir, desde dónde partes.
- **`to`**: El ID de la ruta de **destino**, es decir, hacia dónde vas.

Si no se especifica `from`, el router asume que partes desde la ruta raíz (`/`).

#### 3. **Ejemplo Mental:**

Imagina que estás en la página `/productos/detalles/123` (origen) y haces clic en un enlace para ir a `/productos/categorias` (destino). La navegación es relativa porque vas desde un lugar específico (`/productos/detalles/123`) a otro (`/productos/categorias`).

## B - API de Navegación Compartida

#### 1. **Definición:**

TanStack Router utiliza una **API de navegación centralizada** para todas las operaciones de navegación y coincidencia de rutas. Esto significa que una vez que aprendes los conceptos básicos, puedes aplicarlos en diferentes partes de la librería.

#### 2. **Interfaces Clave:**

Existen interfaces principales que se utilizan en la API de navegación. Las más importantes son:

- **`ToOptions`**: La interfaz base para definir **a dónde** quieres navegar.
- **`NavigateOptions`**: Extiende `ToOptions` y se usa para las funciones que **realizan** la navegación.
- **`LinkOptions`**: Extiende `NavigateOptions` y se utiliza específicamente para el componente `<Link>`.

## C - Interfaz `ToOptions`

#### 1. **Definición:**

`ToOptions` es como el "menú" de opciones para decirle al router a dónde quieres ir. Es una interfaz que define las propiedades para especificar la ruta de destino y sus parámetros.

#### 2. **Componentes de `ToOptions`:**

- **`from` (opcional)**: Indica la ruta de origen. Si no lo pones, solo funcionarán las rutas absolutas (rutas completas desde la raíz). Es útil poner `route.fullPath` de la ruta actual para que sea más fácil usar rutas relativas.
- **`to` (obligatorio)**: Define la ruta de destino. Puede ser una ruta absoluta (ej: `/inicio`) o relativa a `from` (ej: `../categorias`). **¡Ojo!** No incluyas aquí parámetros, `hash` o `search params` directamente en `to`. Usa las opciones `params`, `search` y `hash` para eso.
- **`params` (opcional)**: Un objeto o función para pasar parámetros dinámicos a la ruta (`/blog/post/$postId`). Es la **única** forma correcta de pasar parámetros dinámicos. TypeScript te avisará si faltan parámetros obligatorios.
- **`search` (opcional)**: Objeto o función para definir query params (lo que va después del `?` en la URL, ej: `?ordenarPor=precio`). Similar a `params`, TypeScript te ayuda con los tipos.
- **`hash` (opcional)**: String o función para definir el hash (lo que va después del `#` en la URL, ej: `#seccion-contacto`). Se usa para ir a una parte específica de la página.
- **`state` (opcional)**: Objeto o función para pasar datos de estado que **no** quieres que aparezcan en la URL. Se guarda en el historial del navegador y es útil para datos temporales entre rutas.

#### 3. **Ejemplo Mental:**

Imagina que quieres ir a la ruta `/productos/detalles/123?mostrarReviews=true#reviews`. Con `ToOptions`, lo definirías así:

```typescript
{
  to: '/productos/detalles/$productId', // Ruta con parámetro dinámico
  params: { productId: '123' }, // Valor del parámetro
  search: { mostrarReviews: true }, // Query param
  hash: 'reviews' // Hash para ir a la sección de reviews
}
```

#### 4. **`route.to` para rutas type-safe:**

Cada objeto de ruta (`Route`) en TanStack Router tiene una propiedad `.to`. ¡Úsala! Te permite referenciar rutas de forma segura y evitar errores de escritura en strings.

```tsx
import { Route as aboutRoute } from "./routes/about.tsx";

function MiComponente() {
  return <Link to={aboutRoute.to}>Acerca de</Link>;
}
```

## D - Interfaz `NavigateOptions`

#### 1. **Definición:**

`NavigateOptions` **extiende** `ToOptions` y añade opciones específicas para **navegar**, es decir, para cambiar la URL y la página.

#### 2. **Componentes Adicionales de `NavigateOptions`:**

- **`replace` (opcional)**: Booleano que indica cómo se guarda la navegación en el historial del navegador.
  - `replace: true`: **Reemplaza** la página actual en el historial. Útil para redirecciones o cuando no quieres que el usuario pueda volver atrás con el botón "Atrás".
  - `replace: false` (o no definido): **Añade** una nueva página al historial. Es el comportamiento normal al navegar.

#### 3. **En Resumen:**

`NavigateOptions` es `ToOptions` + la opción `replace` para controlar el historial de navegación.

## E - Interfaz `LinkOptions`

#### 1. **Definición:**

`LinkOptions` **extiende** `NavigateOptions` y se usa específicamente para el componente `<Link>`. Añade opciones propias de los enlaces HTML (`<a>`) y funcionalidades extra de TanStack Router para los enlaces.

#### 2. **Componentes Adicionales de `LinkOptions`:**

- **`target` (opcional)**: Funciona igual que el atributo `target` de un enlace HTML (`<a>`). Define dónde se abrirá el enlace (ej: `_blank` para nueva pestaña).
- **`activeOptions` (opcional)**: Objeto para configurar cómo se determina si un enlace está "activo" (ej: para aplicar estilos diferentes al enlace de la página actual). Por defecto: `{ exact: false, includeHash: false }`. Veremos más detalles en la sección de "Opciones de Activo".
- **`preload` (opcional)**: `false` o `'intent'`. Si se pone a `'intent'`, TanStack Router **precarga** la ruta del enlace cuando el usuario pasa el ratón por encima o toca el enlace (en dispositivos táctiles). Mejora la velocidad de navegación.
- **`preloadDelay` (opcional)**: Número de milisegundos para **retardar** la precarga. Útil para evitar precargas innecesarias si el usuario solo pasa el ratón brevemente por el enlace.
- **`disabled` (opcional)**: Booleano. Si es `true`, el enlace se renderiza **sin el atributo `href`** y no funciona. Útil para deshabilitar enlaces condicionalmente.

#### 3. **En Resumen:**

`LinkOptions` es `NavigateOptions` + opciones para enlaces HTML, estado "activo", precarga y deshabilitado.

## F - API de Navegación (Componentes y Hooks)

#### 1. **Definición:**

TanStack Router ofrece varias formas de navegar en tu aplicación. Elige la que mejor se adapte a tu caso:

#### 2. **Opciones de API de Navegación:**

- **`<Link>` Componente**: La forma **principal** de navegar. Renderiza un tag `<a>` real con `href` válido. Permite clic normal, Ctrl/Cmd + clic para abrir en nueva pestaña, etc. Deberías usar `<Link>` siempre que sea posible para la navegación del usuario (menús, botones, enlaces en texto, etc.).
- **`useNavigate()` Hook**: Devuelve una función `navigate` para realizar navegaciones **imperativas** (desde código). Útil cuando la navegación ocurre como resultado de una acción (ej: después de enviar un formulario exitosamente).
- **`<Navigate>` Componente**: Renderiza **nada** y realiza una navegación **inmediata** al montarse el componente. Útil para redirecciones dentro de la app (lado cliente).
- **`router.navigate()` Método**: La API de navegación **más potente**. Similar a `useNavigate`, pero disponible **en cualquier parte** donde tengas acceso a tu instancia del router. Ideal para navegaciones imperativas desde cualquier lugar de tu aplicación, incluso fuera de componentes React.

#### 3. **Advertencia Importante:**

Ninguna de estas APIs reemplaza las **redirecciones del lado del servidor**. Si necesitas redirigir al usuario **antes** de que tu aplicación React se monte (ej: por autenticación), usa redirecciones del servidor, no estas APIs de TanStack Router.

## G - Componente `<Link>`

#### 1. **Definición:**

El componente `<Link>` es la forma más común y recomendada de crear enlaces de navegación en TanStack Router. Renderiza un elemento `<a>` HTML estándar con todas las ventajas que esto conlleva (accesibilidad, clic derecho, etc.).

#### 2. **Props Adicionales de `<Link>` (además de `LinkOptions`):**

- **`activeProps` (opcional)**: Función o objeto que devuelve props adicionales para el estado **"activo"** del enlace. Si el enlace está activo, estas props se aplican al `<a>`. Los `style` se **mergean** y los `className` se **concatenan** con las props originales del `<Link>`.
- **`inactiveProps` (opcional)**: Similar a `activeProps`, pero para el estado **"inactivo"**. Props para cuando el enlace **no** está activo.

#### 3. **Ejemplo de `activeProps`:**

```tsx
<Link
  to="/blog"
  activeProps={{
    style: { fontWeight: "bold" }, // Estilo extra cuando está activo
    className: "enlace-activo", // Clase CSS extra cuando está activo
  }}
>
  Blog
</Link>
```

## H - Enlaces Absolutos con `<Link>`

#### 1. **Definición:**

Un enlace absoluto siempre apunta a la misma ruta, **sin importar** la ruta actual en la que te encuentres. Empieza con `/`.

#### 2. **Ejemplo:**

```tsx
import { Link } from "@tanstack/react-router";

const enlaceAbout = <Link to="/about">Acerca de</Link>;
```

Este enlace siempre te llevará a `/about`, estés donde estés en la app.

## I - Enlaces Dinámicos con `<Link>`

#### 1. **Definición:**

Enlaces dinámicos contienen **segmentos dinámicos** en su ruta (ej: `/blog/post/$postId`). Necesitas usar la prop `params` para pasar los valores de estos segmentos.

#### 2. **Ejemplo:**

```tsx
const enlaceBlog = (
  <Link
    to="/blog/post/$postId"
    params={{ postId: "mi-primer-post" }} // Pasamos el valor de postId
  >
    Mi Primer Post
  </Link>
);
```

Este enlace generará la URL `/blog/post/mi-primer-post`.

#### 3. **Tipado de Parámetros:**

Los parámetros dinámicos suelen ser strings, pero pueden ser otros tipos según la definición de tu ruta. TypeScript te ayudará a asegurar que pases el tipo correcto.

## J - Enlaces Relativos con `<Link>`

#### 1. **Definición:**

Por defecto, los enlaces en TanStack Router son **absolutos**. Para crear un enlace **relativo** a la ruta actual, debes usar la prop `from`.

#### 2. **Ejemplo:**

```tsx
import { createRoute, Link } from "@tanstack/react-router";

const rutaPost = createRoute({
  path: "/blog/post/$postId",
});

const enlaceCategorias = (
  <Link from={rutaPost.fullPath} to="../categorias">
    {" "}
    {/* "from" define la ruta base */}
    Categorías
  </Link>
);
```

Si estás en `/blog/post/mi-post`, este enlace te llevará a `/blog/categorias`. `../categorias` es relativo a `/blog/post/mi-post`.

#### 3. **`route.fullPath` para `from`:**

Usar `route.fullPath` como valor de `from` es una buena práctica. Si cambias la estructura de tus rutas, `route.fullPath` se actualizará automáticamente. Si no puedes importar la ruta directamente, puedes usar el path como string, pero `route.fullPath` es más seguro.

## K - Enlaces con `search` params en `<Link>`

#### 1. **Definición:**

Los `search params` (query parameters) son una forma de añadir información extra a una ruta (ej: `?ordenarPor=precio`). Usa la prop `search` del `<Link>` para definirlos.

#### 2. **Ejemplo Básico:**

```tsx
const enlaceBuscar = (
  <Link
    to="/buscar"
    search={{ query: "tanstack" }} // Define el search param "query"
  >
    Buscar "tanstack"
  </Link>
);
```

Este enlace generará la URL `/buscar?query=tanstack`.

#### 3. **Actualizar `search` params existentes:**

Puedes usar una función en la prop `search` para actualizar solo algunos `search params` sin perder los que ya existen.

```tsx
const enlacePaginaSiguiente = (
  <Link
    to="." // "." significa "la ruta actual"
    search={(prevSearch) => ({
      // Función para actualizar search params
      ...prevSearch, // Mantiene los search params anteriores
      page: (prevSearch.page || 0) + 1, // Actualiza o crea "page"
    })}
  >
    Página Siguiente
  </Link>
);
```

Si la URL actual es `/productos?categoria=libros&page=1`, este enlace te llevará a `/productos?categoria=libros&page=2`.

## L - Seguridad de Tipado en `search` params

#### 1. **Importancia del Tipado:**

Es crucial asegurar que los `search params` tengan los tipos de datos correctos. TanStack Router ofrece mecanismos para validar y tipar los `search params`, lo cual veremos en detalle más adelante.

## M - Enlaces con `hash` en `<Link>`

#### 1. **Definición:**

Los `hash` links te permiten enlazar a una sección específica dentro de una página (ej: `#seccion-contacto`). Usa la prop `hash` del `<Link>`.

#### 2. **Ejemplo:**

```tsx
const enlaceSeccion = (
  <Link
    to="/blog/post/$postId"
    params={{ postId: "mi-post" }}
    hash="seccion-comentarios" // Define el hash
  >
    Ir a Comentarios
  </Link>
);
```

Este enlace generará la URL `/blog/post/mi-post#seccion-comentarios`.

## N - Props `activeProps` e `inactiveProps` en `<Link>`

#### 1. **Definición:**

Las props `activeProps` e `inactiveProps` te permiten aplicar estilos o atributos diferentes a un `<Link>` dependiendo de si está "activo" o no.

#### 2. **Ejemplo:**

```tsx
<Link
  to="/servicios"
  activeProps={{ style: { color: "green" } }} // Texto verde si está activo
  inactiveProps={{ style: { color: "gray" } }} // Texto gris si no está activo
>
  Servicios
</Link>
```

Si la ruta actual coincide con `/servicios` (o es un hijo, según `activeOptions`), el texto del enlace será verde, de lo contrario, será gris.

## O - Atributo `data-status` en `<Link>`

#### 1. **Definición:**

El componente `<Link>` añade automáticamente el atributo `data-status` al elemento `<a>` cuando está en estado "activo". El valor de `data-status` será `"active"` si el enlace está activo, y `undefined` si no lo está.

#### 2. **Uso con CSS:**

Puedes usar este atributo para aplicar estilos CSS basados en el estado activo del enlace:

```css
a[data-status="active"] {
  font-weight: bold;
}
```

## P - Opciones de `activeOptions` en `<Link>`

#### 1. **Definición:**

La prop `activeOptions` del `<Link>` te permite personalizar cómo se determina si un enlace está "activo".

#### 2. **Opciones de `activeOptions`:**

- **`exact: boolean` (por defecto: `false`)**:
  - `true`: El enlace solo se considera activo si la ruta actual **coincide exactamente** con la ruta del enlace (sin rutas hijas).
  - `false`: El enlace se considera activo si la ruta del enlace es un **prefijo** de la ruta actual.
- **`includeHash: boolean` (por defecto: `false`)**:
  - `true`: El enlace solo se considera activo si el `hash` de la URL actual **coincide** con el `hash` del enlace.
  - `false`: El `hash` no se tiene en cuenta para determinar si el enlace está activo.
- **`includeSearch: boolean` (por defecto: `true`)**:
  - `true`: El enlace solo se considera activo si los `search params` del enlace están **incluidos** (son un subconjunto) en los `search params` de la URL actual.
  - `false`: Los `search params` no se tienen en cuenta para determinar si el enlace está activo.
- **`explicitUndefined: boolean` (por defecto: `false`)**:
  - Modifica el comportamiento de `includeSearch`.
  - `true`: Si un `search param` en la prop `search` del `<Link>` es explícitamente `undefined`, ese `search param` **no debe estar presente** en la URL actual para que el enlace se considere activo.

#### 3. **Ejemplos de `activeOptions`:**

- **Enlace "Home" (activo solo en la página principal):**

  ```tsx
  <Link to="/" activeOptions={{ exact: true }}>
    Home
  </Link>
  ```

- **Enlace que considera el `hash`:**

  ```tsx
  <Link to="/documentacion#seccion1" activeOptions={{ includeHash: true }}>
    Sección 1
  </Link>
  ```

- **Enlace que ignora los `search params`:**

  ```tsx
  <Link to="/productos" activeOptions={{ includeSearch: false }}>
    Productos
  </Link>
  ```

## Q - Pasar `isActive` a hijos del `<Link>`

#### 1. **Definición:**

El componente `<Link>` puede recibir una **función como hijo** en lugar de un elemento JSX. Esta función recibe un objeto con la propiedad `isActive` (booleano). Puedes usar `isActive` para aplicar estilos o lógica condicional a los elementos hijos del `<Link>`.

#### 2. **Ejemplo:**

```tsx
<Link to="/blog">
  {(
    { isActive } // Función como hijo
  ) => (
    <>
      <span>Blog</span>
      {isActive ? <IconoActivo /> : <IconoInactivo />} {/* Icono condicional */}
    </>
  )}
</Link>
```

## R - Precarga de Enlaces en `<Link>`

#### 1. **Definición:**

La precarga de enlaces permite a TanStack Router **cargar en segundo plano** los recursos de una ruta (código, datos) cuando el usuario tiene la **intención** de navegar a ella (ej: al pasar el ratón por encima). Mejora la percepción de velocidad de la app.

#### 2. **Activar la Precarga:**

- **Por defecto en el router (configuración global):** Se configura al crear el router (veremos más adelante).
- **En un `<Link>` específico:** Usando la prop `preload="intent"`.

#### 3. **Ejemplo:**

```tsx
<Link to="/blog/post/$postId" preload="intent">
  Blog Post
</Link>
```

Cuando el usuario pase el ratón por este enlace, TanStack Router empezará a precargar la ruta `/blog/post/$postId`.

#### 4. **Beneficios de la Precarga:**

- **Mejora la velocidad percibida:** La página se carga más rápido cuando el usuario finalmente hace clic en el enlace.
- **Funciona bien con caché:** Si usas una librería de caché como `@tanstack/query`, los datos precargados se mantienen en caché y pueden ofrecer una experiencia "stale-while-revalidate" (mostrar datos antiguos inmediatamente y actualizar en segundo plano).

## S - `preloadDelay` en `<Link>` (Retraso de Precarga)

#### 1. **Definición:**

La prop `preloadDelay` te permite definir un **retraso en milisegundos** antes de que se inicie la precarga al pasar el ratón por un enlace. Útil para evitar precargas innecesarias si el usuario solo pasa el ratón brevemente.

#### 2. **Ejemplo:**

```tsx
<Link to="/blog/post/$postId" preload="intent" preloadDelay={200}>
  Blog Post
</Link>
```

La precarga solo se iniciará si el usuario mantiene el ratón sobre el enlace durante al menos 200 milisegundos.

## T - Hook `useNavigate()`

#### 1. **Cuándo usar `useNavigate()`:**

Se recomienda usar el componente `<Link>` para la navegación interactiva del usuario (botones, enlaces). `useNavigate()` es útil para navegaciones **imperativas** que ocurren como **efecto secundario** de alguna acción (ej: después de enviar un formulario, al recibir datos de una API, etc.).

#### 2. **Función `navigate`:**

El hook `useNavigate()` devuelve una función `navigate` que puedes llamar para realizar una navegación.

#### 3. **Ejemplo:**

```tsx
import { useNavigate } from "@tanstack/react-router";

function MiFormulario() {
  const navigate = useNavigate(); // Obtiene la función navigate

  const handleSubmit = async (e) => {
    e.preventDefault();
    // ... enviar formulario ...
    if (respuesta.ok) {
      navigate({ to: "/exito" }); // Navega a "/exito" después del éxito
    }
  };

  // ...
}
```

#### 4. **Opción `from` en `useNavigate()`:**

Puedes pasar la opción `from` al **hook `useNavigate()`** al inicializarlo. Es recomendable hacerlo aquí en lugar de pasar `from` cada vez que llamas a `navigate`. Ayuda a evitar errores y simplifica el tipado.

```tsx
const navigate = useNavigate({ from: "/perfil" }); // Define "from" al inicio
navigate({ to: "/configuracion" }); // No necesitas repetir "from" aquí
```

## U - Opciones de `navigate` (función de `useNavigate()`)

#### 1. **Interfaz `NavigateOptions`:**

La función `navigate` que devuelve `useNavigate()` acepta un objeto que cumple con la interfaz `NavigateOptions`. Esto significa que puedes usar todas las opciones que vimos en `NavigateOptions` (como `to`, `params`, `search`, `hash`, `state`, `replace`).

## V - Componente `<Navigate>`

#### 1. **Cuándo usar `<Navigate>`:**

Usa el componente `<Navigate>` cuando necesites realizar una navegación **inmediatamente** cuando un componente se monta. Es una forma declarativa de hacer redirecciones del lado del cliente.

#### 2. **No es para redirecciones del servidor:**

`<Navigate>` **no** reemplaza las redirecciones del lado del servidor. Para redirecciones importantes antes de que la app React se monte (ej: autenticación), usa redirecciones del servidor.

#### 3. **Ejemplo:**

```tsx
import { Navigate } from '@tanstack/react-router';

function PaginaPrivada({ usuarioLogueado }) {
  if (!usuarioLogueado) {
    return <Navigate to="/login" replace />; // Redirige a "/login" si no está logueado
  }
  return (
    // ... contenido de la página privada ...
  );
}
```

Este componente `<Navigate>` redirigirá al usuario a `/login` inmediatamente si `usuarioLogueado` es `false`.

## W - Método `router.navigate()`

#### 1. **Similitud con `useNavigate()`:**

El método `router.navigate()` es **idéntico** a la función `navigate` que devuelve `useNavigate()`. También acepta la interfaz `NavigateOptions`.

#### 2. **Disponibilidad Global:**

A diferencia de `useNavigate()`, `router.navigate()` está disponible **en cualquier parte** de tu aplicación donde tengas acceso a la instancia del router. Es útil para navegaciones imperativas desde fuera de componentes React o en lugares donde no tienes acceso al hook `useNavigate()`.

#### 3. **Ejemplo (fuera de un componente React):**

```javascript
// Supongamos que tienes acceso a la instancia del router como "miRouter"

miRouter.navigate({ to: "/inicio" }); // Navega a "/inicio" imperativamente
```

## X - Hooks y Componentes `useMatchRoute` y `<MatchRoute>`

#### 1. **Función:**

`useMatchRoute` (hook) y `<MatchRoute>` (componente) sirven para **verificar si una ruta coincide** con la ruta actual. Devuelven `true` o `false` (o un objeto "match" en el caso del componente con función hijo).

#### 2. **Opción `pending`:**

Ambos (`useMatchRoute` y `<MatchRoute>`) tienen una opción `pending`. Si `pending: true`, verifican si la ruta está **pendiente** (en transición). Útil para mostrar UI optimista (ej: un spinner) mientras se navega.

#### 3. **Componente `<MatchRoute>`:**

- **Uso básico:** Renderiza sus hijos solo si la ruta coincide.

  ```tsx
  <Link to="/usuarios">
    Usuarios
    <MatchRoute to="/usuarios">
      {" "}
      {/* Solo se renderiza si /usuarios coincide */}
      <IconoUsuarioActivo />
    </MatchRoute>
  </Link>
  ```

- **Con función hijo:** Recibe un objeto `match` (booleano) como argumento. Permite renderizar contenido dinámicamente según si la ruta coincide o no.

  ```tsx
  <MatchRoute to="/productos">
    {(match) => (match ? <TextoEnRutaProductos /> : null)}{" "}
    {/* Renderizado condicional */}
  </MatchRoute>
  ```

#### 4. **Hook `useMatchRoute`:**

Devuelve una función `matchRoute` que puedes llamar programáticamente para verificar si una ruta coincide.

```tsx
import { useMatchRoute } from "@tanstack/react-router";
import { useEffect } from "react";

function MiComponente() {
  const matchRoute = useMatchRoute();

  useEffect(() => {
    if (matchRoute({ to: "/admin", pending: true })) {
      // Verifica si /admin está pendiente
      console.log("/admin está pendiente!");
    }
  }, [matchRoute]);

  // ...
}
```

¡Uf! ¡Mucha navegación! Pero ahora deberías tener una buena base para moverte por tu aplicación con TanStack Router. ¡Sigamos adelante!
