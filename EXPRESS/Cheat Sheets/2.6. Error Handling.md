## A - Manejo de Errores en Express (Error Handling)

#### 1. **Definici√≥n:**

Imag√≠nate que tu aplicaci√≥n Express es como un coche. A veces, las cosas no salen como esperamos: un usuario introduce datos incorrectos, un archivo no se encuentra, ¬°o algo se rompe por dentro! El **manejo de errores** es como el sistema de seguridad de tu coche: se encarga de "atrapar" esos problemas (errores) y gestionarlos de forma elegante para que tu aplicaci√≥n no se estrelle y siga funcionando bien.

#### 2. **Ejemplo:**

Piensa en una tienda online. Si un cliente intenta comprar un producto que ya no est√° en stock, en lugar de que la p√°gina se rompa y muestre un mensaje feo, el manejo de errores permite mostrar un mensaje amigable como "Lo sentimos, este producto est√° agotado".

#### 3. **Notas o advertencias:**

- Un buen manejo de errores hace que tu aplicaci√≥n sea m√°s robusta y f√°cil de usar.
- Express ya viene con un sistema b√°sico de manejo de errores, ¬°pero puedes personalizarlo para que se adapte a tus necesidades!

## B - Atrapando Errores S√≠ncronos

#### 1. **Definici√≥n:**

Los errores **s√≠ncronos** son como tropiezos que ocurren justo cuando est√°s caminando. En c√≥digo, son errores que pasan directamente en la l√≠nea de c√≥digo que se est√° ejecutando. ¬°La buena noticia es que Express es muy listo y los atrapa autom√°ticamente!

#### 2. **Ejemplo:**

Mira este c√≥digo:

```javascript
app.get("/", (req, res) => {
  throw new Error("¬°Algo sali√≥ mal!"); // ¬°Error s√≠ncrono!
});
```

**Explicaci√≥n del ejemplo:**
Si ejecutas esta ruta, Express detectar√° el `throw new Error('¬°Algo sali√≥ mal!')` y se encargar√° de manejar el error sin que tengas que hacer nada especial. ¬°Es como si tuviera reflejos s√∫per r√°pidos!

#### 3. **Notas o advertencias:**

- Para errores s√≠ncronos dentro de tus rutas y middlewares, ¬°Express te cubre las espaldas! No necesitas c√≥digo extra para atraparlos.

## C - Atrapando Errores As√≠ncronos (con Callbacks)

#### 1. **Definici√≥n:**

Los errores **as√≠ncronos** son m√°s escurridizos. Imagina que env√≠as una carta (una operaci√≥n as√≠ncrona) y no sabes cu√°ndo llegar√° la respuesta o si habr√° alg√∫n problema en el camino. En c√≥digo as√≠ncrono (como cuando lees un archivo o haces una petici√≥n a una base de datos), los errores pueden ocurrir "m√°s tarde", cuando la operaci√≥n as√≠ncrona termina. Para estos casos, ¬°necesitas ayudar un poquito a Express!

#### 2. **Ejemplo:**

Aqu√≠ intentamos leer un archivo que no existe:

```javascript
app.get("/", (req, res, next) => {
  fs.readFile("/archivo-inexistente.txt", (err, data) => {
    if (err) {
      next(err); // ¬°Pasa el error a Express con 'next(err)'!
    } else {
      res.send(data);
    }
  });
});
```

**Explicaci√≥n del ejemplo:**

- `fs.readFile` es una funci√≥n as√≠ncrona.
- Si ocurre un error al leer el archivo (`err` no es nulo), llamamos a `next(err)`. **`next(err)` es como decirle a Express: "¬°Oye, aqu√≠ hay un error, enc√°rgate t√∫!".**
- Si no hay error, seguimos con el c√≥digo normal (`res.send(data)`).

#### 3. **Notas o advertencias:**

- **¬°Important√≠simo!** Para errores as√≠ncronos con callbacks, usa `next(err)` para que Express sepa que hay un problema y pueda manejarlo. Si olvidas el `next(err)`, ¬°Express no se enterar√° del error!

## D - Atrapando Errores As√≠ncronos (con Promises y Async/Await)

#### 1. **Definici√≥n:**

Si usas **Promises** o **async/await** (que son formas m√°s modernas de trabajar con c√≥digo as√≠ncrono), ¬°atrapar errores es a√∫n m√°s f√°cil! Express 5 y versiones superiores son lo suficientemente inteligentes como para detectar errores en Promises autom√°ticamente.

#### 2. **Ejemplo:**

Mira este ejemplo con `async/await`:

```javascript
app.get("/usuario/:id", async (req, res, next) => {
  const usuario = await obtenerUsuarioPorId(req.params.id); // Funci√≥n as√≠ncrona que devuelve una Promise
  res.send(usuario);
});
```

**Explicaci√≥n del ejemplo:**

- `obtenerUsuarioPorId` es una funci√≥n as√≠ncrona que devuelve una Promise.
- Si `obtenerUsuarioPorId` falla (la Promise se rechaza o lanza un error), Express autom√°ticamente llamar√° a `next(err)` con el error. ¬°No necesitas `try...catch` ni `next(err)` expl√≠cito!

#### 3. **Notas o advertencias:**

- Con Promises y async/await en Express 5+, el manejo de errores as√≠ncronos se simplifica mucho.
- Si usas una versi√≥n anterior de Express, puede que necesites usar `.catch(next)` en tus Promises para pasar los errores a Express.

## E - Pasando Errores a `next()`: El Mensajero de Errores

#### 1. **Definici√≥n:**

La funci√≥n `next()` en Express no solo sirve para pasar al siguiente middleware o ruta. ¬°Tambi√©n es tu mensajero de errores! Cuando llamas a `next(err)` (donde `err` es un objeto de error), le est√°s diciendo a Express: "¬°Oye, ha ocurrido un error! Deja de procesar las rutas y middlewares normales y busca un **manejador de errores** para que se encargue de esto".

#### 2. **Ejemplo:**

Ya hemos visto ejemplos con `fs.readFile` y `async/await`. En general, siempre que tengas un error en c√≥digo as√≠ncrono (o incluso s√≠ncrono si quieres forzar el manejo de error), usa `next(err)` para "lanzarlo" al sistema de manejo de errores de Express.

#### 3. **Notas o advertencias:**

- Si llamas a `next()` sin argumentos (o con `'route'`), Express simplemente pasa al siguiente middleware o ruta "normal".
- Solo cuando usas `next(err)`, Express activa el modo de "manejo de errores".

## F - El Manejador de Errores Predeterminado de Express

#### 1. **Definici√≥n:**

Express ya viene con un **manejador de errores predeterminado**. Es como un "plan B" por si no has definido tus propios manejadores de errores. Este manejador predeterminado se ejecuta al final de la cadena de middlewares y hace lo siguiente:

- Muestra un mensaje de error al cliente.
- En desarrollo, muestra la **pila de error** (stack trace) para ayudarte a depurar.
- En producci√≥n (cuando `NODE_ENV` est√° configurado como `production`), no muestra la pila de error por seguridad.

#### 2. **Ejemplo:**

Si en tu aplicaci√≥n ocurre un error y no lo manejas con tus propios middlewares, ver√°s una p√°gina de error gen√©rica de Express en el navegador. En desarrollo, esta p√°gina incluir√° informaci√≥n detallada del error.

#### 3. **Notas o advertencias:**

- El manejador de errores predeterminado es √∫til para empezar, ¬°pero en aplicaciones reales querr√°s personalizar el manejo de errores!
- Para activar el modo producci√≥n (y ocultar la pila de error), configura la variable de entorno `NODE_ENV=production` antes de iniciar tu aplicaci√≥n.

## G - Escribiendo tus Propios Manejadores de Errores

#### 1. **Definici√≥n:**

Puedes crear tus propios **manejadores de errores personalizados** para controlar c√≥mo se muestran los errores a los usuarios, registrarlos en logs, ¬°o hacer cualquier otra cosa que necesites! Los manejadores de errores son middlewares especiales que tienen **cuatro argumentos**: `(err, req, res, next)`. ¬°El primer argumento (`err`) es el objeto de error que se pas√≥ con `next(err)`!

#### 2. **Ejemplo:**

Aqu√≠ tienes un ejemplo sencillo de un manejador de errores personalizado:

```javascript
app.use((err, req, res, next) => {
  console.error("¬°Error detectado!", err.stack); // Registra el error en la consola del servidor
  res.status(500).send("¬°Ups! Algo se rompi√≥."); // Env√≠a un mensaje de error amigable al cliente
});
```

**Explicaci√≥n del ejemplo:**

- `app.use(...)` registra este middleware.
- Los cuatro argumentos `(err, req, res, next)` indican que es un manejador de errores.
- `console.error(err.stack)` imprime la pila de error en la consola del servidor para depuraci√≥n.
- `res.status(500).send(...)` env√≠a una respuesta HTTP con c√≥digo de estado 500 (Error interno del servidor) y un mensaje de error al cliente.

#### 3. **Notas o advertencias:**

- ¬°Recuerda los **cuatro argumentos** `(err, req, res, next)` para definir un manejador de errores!
- Puedes tener varios manejadores de errores en tu aplicaci√≥n, ¬°y se ejecutar√°n en el orden en que los definas!

## H - Estructura y Posici√≥n de los Manejadores de Errores

#### 1. **Definici√≥n:**

Los manejadores de errores se definen como cualquier otro middleware en Express, usando `app.use()`. **¬°La clave es el orden!** Debes definir tus manejadores de errores **despu√©s** de todos tus otros middlewares y rutas "normales". Express ejecutar√° los manejadores de errores **solo cuando se produzca un error** y se llame a `next(err)`.

#### 2. **Ejemplo:**

Mira este ejemplo de c√≥mo organizar tus middlewares y manejadores de errores:

```javascript
const bodyParser = require("body-parser");
const methodOverride = require("method-override");

app.use(bodyParser.urlencoded({ extended: true })); // Middleware normal
app.use(bodyParser.json()); // Middleware normal
app.use(methodOverride()); // Middleware normal

// ... aqu√≠ ir√≠an tus rutas (app.get, app.post, etc.) ...

app.use((err, req, res, next) => {
  // ¬°Manejador de errores! (al final)
  console.error(err.stack);
  res.status(500).send("Algo sali√≥ muy mal.");
});
```

**Explicaci√≥n del ejemplo:**
Los middlewares `bodyParser` y `methodOverride` se definen primero. Luego, **al final**, se define el manejador de errores. As√≠, Express primero intentar√° procesar la petici√≥n con los middlewares y rutas normales, y **solo si ocurre un error**, pasar√° el control al manejador de errores.

#### 3. **Notas o advertencias:**

- ¬°El orden importa! Define los manejadores de errores **al final** de tu cadena de middlewares.
- Express solo llamar√° a los manejadores de errores si se llama a `next(err)` en alg√∫n punto anterior del procesamiento de la petici√≥n.

## I - M√∫ltiples Manejadores de Errores: ¬°Especializaci√≥n al Rescate!

#### 1. **Definici√≥n:**

Puedes tener **varios** manejadores de errores en tu aplicaci√≥n, ¬°y esto es muy √∫til para organizar mejor el manejo de errores! Puedes crear manejadores de errores especializados para diferentes prop√≥sitos, como:

- **`logErrors`**: Para registrar los errores en logs (ficheros, bases de datos, servicios externos...).
- **`clientErrorHandler`**: Para manejar errores de forma diferente seg√∫n si la petici√≥n viene de una petici√≥n AJAX (`req.xhr`) o no.
- **`errorHandler`**: Un manejador de errores gen√©rico para casos que no cubren los anteriores.

#### 2. **Ejemplo:**

Aqu√≠ tienes un ejemplo de c√≥mo usar varios manejadores de errores:

```javascript
app.use(logErrors); // Primero: Registrar el error
app.use(clientErrorHandler); // Segundo: Manejar errores de cliente (AJAX)
app.use(errorHandler); // Tercero: Manejador gen√©rico para el resto
```

**Ejemplos de los manejadores:**

```javascript
function logErrors(err, req, res, next) {
  console.error("Error:", err.stack); // Registrar en consola (¬°o en un log real!)
  next(err); // ¬°Importante! Pasa el error al siguiente manejador
}

function clientErrorHandler(err, req, res, next) {
  if (req.xhr) {
    // ¬øEs una petici√≥n AJAX?
    res.status(500).send({ error: "¬°Algo fall√≥ en el servidor!" }); // Respuesta JSON para AJAX
  } else {
    next(err); // Si no es AJAX, pasa al siguiente manejador
  }
}

function errorHandler(err, req, res, next) {
  res.status(500); // C√≥digo de estado 500
  res.render("error", { error: err }); // Renderiza una plantilla de error (ejemplo con Pug)
}
```

**Explicaci√≥n del ejemplo:**

- `logErrors` registra el error y luego llama a `next(err)` para pasar el error al siguiente manejador. **¬°Es importante llamar a `next(err)` si quieres que se ejecuten los siguientes manejadores de errores!**
- `clientErrorHandler` comprueba si la petici√≥n es AJAX (`req.xhr`). Si lo es, env√≠a una respuesta JSON con un mensaje de error. Si no, llama a `next(err)` para que el error lo maneje el siguiente manejador.
- `errorHandler` es un manejador gen√©rico que renderiza una plantilla de error (en este ejemplo, usando un template engine).

#### 3. **Notas o advertencias:**

- Usar m√∫ltiples manejadores de errores te permite separar responsabilidades y hacer un manejo de errores m√°s organizado y flexible.
- Recuerda llamar a `next(err)` en los manejadores intermedios si quieres que el error siga siendo procesado por los siguientes manejadores.
- Si un manejador de errores **no llama a `next(err)`**, se considera que ha "consumido" el error y la cadena de manejo de errores se detiene ah√≠. ¬°Aseg√∫rate de enviar una respuesta al cliente en ese caso!

## J - `next('route')`: Saltando a la Siguiente Ruta

#### 1. **Definici√≥n:**

En Express, `next()` normalmente te lleva al siguiente middleware **en la misma ruta**. Pero hay un caso especial: `next('route')`. Si llamas a `next('route')` dentro de un middleware de una ruta, ¬°Express se saltar√° **todos los middlewares restantes de esa ruta** y buscar√° la **siguiente ruta** que coincida con la petici√≥n!

#### 2. **Ejemplo:**

Imagina una ruta `/secreto` que solo quieres que se ejecute si el usuario est√° autenticado. Puedes usar `next('route')` para saltar a la siguiente ruta si no lo est√°:

```javascript
app.get(
  "/secreto",
  (req, res, next) => {
    // Primer middleware de la ruta '/secreto'
    if (!req.usuarioAutenticado) {
      console.log("Usuario no autenticado, saltando a la siguiente ruta...");
      return next("route"); // ¬°Usuario no autenticado, salta a la siguiente ruta!
    }
    next(); // Usuario autenticado, sigue con los siguientes middlewares de esta ruta
  },
  (req, res, next) => {
    // Segundo middleware de la ruta '/secreto' (solo se ejecuta si el usuario est√° autenticado)
    res.send("¬°Contenido secreto para usuarios autenticados!");
  }
);

app.get("/secreto", (req, res) => {
  // ¬°Siguiente ruta '/secreto'! (se ejecuta si el middleware anterior llama a 'next('route')')
  res.status(403).send("Acceso denegado. Debes iniciar sesi√≥n.");
});
```

**Explicaci√≥n del ejemplo:**

- El primer middleware de `/secreto` comprueba si el usuario est√° autenticado (`req.usuarioAutenticado`).
- Si el usuario **no** est√° autenticado, llama a `next('route')`. Esto hace que Express se salte el segundo middleware de `/secreto` y busque la **siguiente ruta** que coincida con `/secreto`.
- La siguiente ruta `/secreto` (la segunda definici√≥n de `app.get('/secreto', ...)`) se ejecuta entonces, mostrando un mensaje de "Acceso denegado".
- Si el usuario **s√≠** est√° autenticado, el primer middleware llama a `next()` (sin argumentos), y se ejecuta el segundo middleware de la primera ruta `/secreto`, mostrando el contenido secreto.

#### 3. **Notas o advertencias:**

- `next('route')` es √∫til para crear "rutas de respaldo" o para implementar l√≥gica de autorizaci√≥n que puede redirigir a diferentes rutas seg√∫n ciertas condiciones.
- Recuerda que `next('route')` solo salta a la **siguiente ruta que coincida**, no a cualquier ruta arbitraria.

## K - Resumen R√°pido: `next()` vs `next(err)`

#### 1. **Definici√≥n:**

Para que no te l√≠es, aqu√≠ tienes un resumen r√°pido de las diferencias entre `next()` y `next(err)`:

- **`next()` (sin argumentos o con `'route'`):**

  - Significa "todo bien hasta ahora, pasa al siguiente middleware o ruta **normal**".
  - En una ruta, `next()` pasa al siguiente middleware **de la misma ruta**.
  - `next('route')` (caso especial) salta a la **siguiente ruta que coincida**.

- **`next(err)` (con un objeto de error como argumento):**
  - Significa "¬°ha ocurrido un error! Deja de procesar rutas y middlewares normales y busca un **manejador de errores**".
  - Activa el sistema de manejo de errores de Express.
  - El error (`err`) se pasa al primer manejador de errores que encuentre.

#### 2. **Ejemplo:**

Piensa en `next()` como "sem√°foro verde" para seguir adelante con el flujo normal, y `next(err)` como "sem√°foro rojo" que activa el protocolo de emergencia (manejo de errores).

#### 3. **Notas o advertencias:**

- ¬°Usar `next()` o `next(err)` correctamente es clave para controlar el flujo de tu aplicaci√≥n Express y manejar los errores de forma adecuada!
- Si tienes dudas, ¬°revisa los ejemplos anteriores y experimenta un poco! La pr√°ctica hace al maestro (o a la maestra üòâ).
