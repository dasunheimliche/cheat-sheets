## A - 쯈u칠 es Middleware? El Portero Inteligente de tu Web 游댮

#### 1. **Introducci칩n:**

El middleware es como un portero que se para en la puerta de tu sitio web; intercepta cada visita (petici칩n) antes de que llegue a la p치gina, permiti칠ndote revisar, modificar o a침adir cosas sobre la marcha.

#### 2. **Ejemplo:**

Imagina que quieres saber cada vez que alguien visita cualquier p치gina de tu sitio. Creas un "portero" que anota la visita en una libreta (la consola).

**`src/middleware.js`**

```javascript
// Este es nuestro "portero". Se ejecuta con CADA visita.
export function onRequest(context, next) {
  // 1. El portero ve que alguien llega y anota la URL que quiere visitar.
  console.log(`춰Alguien est치 visitando la p치gina: ${context.url.pathname}!`);

  // 2. Despu칠s de anotar, le dice "adelante, puede pasar" a la p치gina.
  // `next()` es la orden para continuar. 춰Si no la pones, nadie entra!
  return next();
}
```

**Explicaci칩n del ejemplo:**
Este c칩digo se coloca en un archivo especial llamado `src/middleware.js`. Astro sabe que debe ejecutar la funci칩n `onRequest` de este archivo **autom치ticamente** por cada petici칩n que recibe tu servidor. `context` contiene toda la informaci칩n de la visita (como la URL), y `next()` es la funci칩n que le da permiso para continuar hacia la p치gina solicitada. Sin `return next()`, el visitante se quedar칤a atascado en la puerta y nunca ver칤a la p치gina.

#### 3. **Desarrollo:**

Pi칠nsalo as칤: cada vez que alguien escribe una direcci칩n de tu web en su navegador, se crea una "petici칩n". El middleware "atrapa" esa petici칩n. Esto te da un poder incre칤ble:

- **Seguridad:** Puedes verificar si un usuario ha iniciado sesi칩n antes de dejarle ver una p치gina privada.
- **Personalizaci칩n:** Puedes cambiar el t칤tulo de una p치gina o mostrar un banner de bienvenida diferente para cada usuario.
- **An치lisis:** Puedes registrar qu칠 p치ginas son las m치s visitadas.

Todo esto ocurre en el servidor, antes de que el HTML se env칤e al navegador del usuario.

游댮 **Fundamental**: Entender el middleware es crucial porque es la herramienta principal en Astro para manejar l칩gica din치mica y datos que dependen de cada petici칩n individual (como la sesi칩n de un usuario). Es la base para crear aplicaciones web interactivas y seguras, no solo sitios est치ticos.

---

## B - `context.locals`: Tu Mensajero Personal entre Archivos 游댮

#### 1. **Introducci칩n:**

`context.locals` es una "caja" especial que tu middleware puede llenar con informaci칩n, y luego entregar esa misma caja a tus p치ginas `.astro` para que usen lo que hay dentro.

#### 2. **Ejemplo:**

Nuestro portero (middleware) identifica al visitante y le pone una etiqueta con su nombre. Luego, la p치gina de bienvenida usa esa etiqueta para saludarlo personalmente.

**`src/middleware.js`**

```javascript
export function onRequest({ locals }, next) {
  // 1. El portero (middleware) decide que el visitante se llama "Ana".
  //    Guarda este nombre en la "caja" `locals`.
  locals.nombreDeUsuario = "Ana";
  locals.rol = "Admin";

  // 2. Deja pasar al visitante con su caja de datos.
  return next();
}
```

**`src/pages/index.astro`**

```astro
---
// 1. La p치gina recibe la "caja" del middleware.
//    En los archivos .astro, se accede a ella con `Astro.locals`.
const datosDelVisitante = Astro.locals;
---

<!-- 2. La p치gina usa los datos de la caja para personalizar el saludo. -->
<h1>춰Hola, {datosDelVisitante.nombreDeUsuario}!</h1>
<p>Tu rol es: {datosDelVisitante.rol}</p>
```

**Explicaci칩n del ejemplo:**
En `middleware.js`, usamos `locals` (que es una abreviatura de `context.locals`) para guardar datos. En este caso, el nombre y el rol del usuario. Luego, en cualquier p치gina `.astro`, podemos acceder a esos mismos datos a trav칠s de `Astro.locals`. 춰Es como un puente de informaci칩n! F칤jate en el peque침o pero crucial detalle: en el middleware es `context.locals` (o solo `locals`), y en la p치gina es `Astro.locals`. Son la misma "caja", pero se llaman ligeramente diferente dependiendo de d칩nde est칠s.

#### 3. **Desarrollo:**

La clave de `locals` es que **vive y muere con cada petici칩n**. Si Ana visita la p치gina, se crea una caja para ella. Si Pedro la visita un segundo despu칠s, se crea una caja completamente nueva y separada para 칠l. La informaci칩n de Ana no se mezcla con la de Pedro.

Esto es perfecto para guardar datos espec칤ficos de la sesi칩n de un usuario, como su informaci칩n de perfil, sus permisos, o si ha iniciado sesi칩n o no. Puedes guardar cualquier cosa: texto, n칰meros, 춰incluso funciones!

游댮 **Fundamental**: `locals` es el mecanismo principal para pasar datos desde la l칩gica del servidor (middleware) a la vista (p치ginas `.astro`). Sin 칠l, el middleware y las p치ginas estar칤an aislados y no podr칤an compartir informaci칩n din치mica, lo cual es el prop칩sito central de esta herramienta.

---

## C - La Funci칩n `next()`: La Llave para Continuar 游리

#### 1. **Introducci칩n:**

La funci칩n `next()` es la instrucci칩n que le das al middleware para que termine su trabajo y deje que la petici칩n contin칰e su camino, ya sea hacia otro middleware o hacia la p치gina final.

#### 2. **Ejemplo:**

Imagina un control de seguridad. Si no tienes permiso, te detienen. Si lo tienes, te dicen "adelante" (`next()`).

**`src/middleware.js`**

```javascript
export function onRequest({ request, locals }, next) {
  // Leemos una cabecera especial para ver si el usuario tiene la "llave secreta".
  const tienePermiso = request.headers.get("X-Pase-Secreto") === "abracadabra";

  if (tienePermiso) {
    // 춰Perfecto! Tienes la llave. Te dejamos pasar.
    locals.mensaje = "Bienvenido, agente secreto.";
    return next(); // <-- 춰La puerta se abre!
  } else {
    // No tienes la llave. No puedes pasar.
    // En lugar de `next()`, devolvemos una respuesta de "Acceso Denegado".
    return new Response("ACCESO DENEGADO", { status: 403 });
  }
}
```

**Explicaci칩n del ejemplo:**
Aqu칤, el middleware act칰a como un verdadero guardia. Si la petici칩n viene con una "cabecera" especial (`X-Pase-Secreto`) y el valor correcto, se ejecuta `return next()`, y el usuario ver치 la p치gina que solicit칩. Si no, el proceso se detiene en seco y se le env칤a una respuesta de "ACCESO DENEGADO" en su lugar. El usuario **nunca** llegar치 a ver la p치gina original.

#### 3. **Desarrollo:**

`next()` es m치s que un simple "continuar". Es el coraz칩n del sistema de encadenamiento. Cuando llamas a `await next()`, est치s diciendo: "Pausa mi trabajo aqu칤, deja que todo lo dem치s (otros middlewares, la p치gina) se ejecute, y cuando terminen, devu칠lveme el resultado (la respuesta HTML final)". Esto nos lleva a un uso m치s avanzado...

游리 **Importante**: Aunque `return next()` parece simple, es el mecanismo que controla el flujo de CADA petici칩n. Entender que puedes detener el flujo o dejarlo continuar es clave para implementar l칩gica condicional como la autenticaci칩n. No es solo una funci칩n, es el interruptor de encendido/apagado de tu p치gina.

---

## D - Modificar el HTML de Salida: El Editor de 칔ltimo Minuto 游리

#### 1. **Introducci칩n:**

El middleware puede esperar a que Astro genere el HTML de una p치gina y, justo antes de enviarlo al usuario, hacer cambios en ese HTML, como si fuera un editor corrigiendo un texto a 칰ltima hora.

#### 2. **Ejemplo:**

Imagina que en varias p치ginas de tu blog has escrito accidentalmente "INFORMACI칍N PRIVADA". Quieres asegurarte de que nadie lo vea, as칤 que creas un middleware que lo reemplaza por "[CENSURADO]" en todas las p치ginas.

**`src/middleware.js`**

```javascript
export const onRequest = async (context, next) => {
  // 1. Primero, dejamos que Astro haga su trabajo y genere la p치gina.
  //    `await next()` nos devuelve la respuesta completa (con el HTML dentro).
  const response = await next();

  // 2. Extraemos el contenido HTML de la respuesta como si fuera un texto.
  const html = await response.text();

  // 3. Reemplazamos todas las apariciones de la frase prohibida.
  const htmlCensurado = html.replaceAll("INFORMACI칍N PRIVADA", "[CENSURADO]");

  // 4. Creamos una NUEVA respuesta con el HTML ya modificado y la enviamos.
  return new Response(htmlCensurado, {
    status: 200, // Mantenemos el estado original (OK)
    headers: response.headers, // Mantenemos las cabeceras originales
  });
};
```

**Explicaci칩n del ejemplo:**
El truco aqu칤 est치 en el `await next()`. No solo llama a la siguiente etapa, sino que **espera** a que termine y le entrega el resultado: la `response`. Esta `response` contiene el HTML final. A partir de ah칤, es como manipular cualquier texto en JavaScript. Lo lees, lo modificas con `replaceAll()`, y finalmente creas una `new Response` con tu versi칩n limpia del HTML para enviarla al navegador del usuario. El usuario nunca sabr치 que el texto original estaba all칤.

#### 3. **Desarrollo:**

Este patr칩n es incre칤blemente poderoso. No solo sirve para censurar, sino tambi칠n para:

- **Inyectar scripts:** A침adir un script de an치lisis o un banner de cookies a todas las p치ginas.
- **Personalizar contenido:** Cambiar palabras o frases dependiendo del usuario (por ejemplo, cambiar "tu carrito" por "su carrito" en un tono m치s formal).
- **Optimizaci칩n:** Modificar el HTML para mejorar el rendimiento (aunque Astro ya hace mucho de esto por ti).

游리 **Importante**: Esta t칠cnica te da control total sobre la salida final sin tener que modificar cada uno de tus archivos `.astro`. Es una forma centralizada y elegante de aplicar cambios globales a la apariencia o contenido de tu sitio.

---

## E - `sequence()`: Poniendo a tus Porteros en Fila 游댯

#### 1. **Introducci칩n:**

`sequence()` es una herramienta que te permite usar m칰ltiples funciones de middleware y ejecutarlas en un orden espec칤fico, como si tuvieras una fila de porteros, cada uno con una tarea diferente.

#### 2. **Ejemplo:**

Tienes tres porteros:

1.  `validaci칩n`: Revisa que la petici칩n sea v치lida.
2.  `auth`: Revisa si el usuario ha iniciado sesi칩n.
3.  `saludo`: Registra un saludo.

Quieres que se ejecuten en ese orden exacto.

**`src/middleware.js`**

```javascript
import { sequence } from "astro:middleware";

// Portero 1: Validaci칩n
async function validacion(_, next) {
  console.log("1. Petici칩n de validaci칩n (entrando)");
  const response = await next(); // Pasa al siguiente portero
  console.log("4. Respuesta de validaci칩n (saliendo)");
  return response;
}

// Portero 2: Autenticaci칩n
async function auth(_, next) {
  console.log("2. Petici칩n de autenticaci칩n (entrando)");
  const response = await next(); // Pasa al siguiente portero
  console.log("5. Respuesta de autenticaci칩n (saliendo)");
  return response;
}

// Portero 3: Saludo (este es el 칰ltimo antes de la p치gina)
async function saludo(_, next) {
  console.log("3. Petici칩n de saludo (entrando)");
  const response = await next(); // Pasa a la p치gina
  console.log("6. Respuesta de saludo (saliendo)");
  return response;
}

// `sequence` los pone en fila: validaci칩n -> auth -> saludo
export const onRequest = sequence(validacion, auth, saludo);
```

**Salida en la consola:**

```
1. Petici칩n de validaci칩n (entrando)
2. Petici칩n de autenticaci칩n (entrando)
3. Petici칩n de saludo (entrando)
6. Respuesta de saludo (saliendo)
5. Respuesta de autenticaci칩n (saliendo)
4. Respuesta de validaci칩n (saliendo)
```

**Explicaci칩n del ejemplo:**
Observa el orden. Las peticiones van "hacia adentro" en el orden que definimos (1, 2, 3). Una vez que la 칰ltima (`saludo`) llama a `next()`, se genera la p치gina. Luego, las respuestas van "hacia afuera" en orden inverso (6, 5, 4). Es como un juego de mu침ecas rusas: abres una, luego otra, luego otra... y para cerrarlas, vas desde la m치s peque침a hacia la m치s grande.

#### 3. **Desarrollo:**

쯇or qu칠 hacer esto en lugar de una funci칩n gigante? Por **organizaci칩n y reutilizaci칩n**. Cada funci칩n tiene una 칰nica responsabilidad (Principio de Responsabilidad 칔nica). Esto hace que tu c칩digo sea:

- **M치s f치cil de leer:** Sabes exactamente qu칠 hace cada pieza.
- **M치s f치cil de depurar:** Si algo falla en la autenticaci칩n, solo tienes que mirar la funci칩n `auth`.
- **Reutilizable:** Podr칤as querer usar la funci칩n `auth` en otro proyecto.

游댯 **Espec칤fico**: Para un sitio peque침o con una sola verificaci칩n, quiz치s no necesites `sequence`. Pero en cuanto tu l칩gica de servidor crece (autenticaci칩n, logging, manejo de datos, etc.), `sequence` se vuelve indispensable para mantener el c칩digo limpio y ordenado.

---

## F - `context.rewrite()`: Muestra otra P치gina sin Cambiar la URL 游댯

#### 1. **Introducci칩n:**

`context.rewrite()` es un truco que te permite mostrarle al usuario el contenido de una p치gina completamente diferente a la que solicit칩, pero manteniendo la URL original en la barra de direcciones del navegador.

#### 2. **Ejemplo:**

Un usuario intenta acceder a `/panel-de-control`, pero no ha iniciado sesi칩n. En lugar de redirigirlo a `/login` (cambiando la URL), le mostramos el contenido de la p치gina de login, pero la URL seguir치 siendo `/panel-de-control`.

**`src/middleware.js`**

```javascript
import { isLoggedIn } from "~/auth.js"; // Una funci칩n imaginaria que devuelve true/false

export function onRequest(context, next) {
  // Si el usuario intenta acceder al panel Y NO ha iniciado sesi칩n...
  if (context.url.pathname === "/panel-de-control" && !isLoggedIn(context)) {
    // ...le servimos el contenido de la p치gina de login.
    // 춰OJO! Esto reinicia todo el ciclo de middleware.
    return context.rewrite("/login");
  }

  // Si ha iniciado sesi칩n o va a otra p치gina, todo sigue normal.
  return next();
}
```

**Explicaci칩n del ejemplo:**
El usuario escribe `misitio.com/panel-de-control`. El middleware se activa, comprueba que no est치 logueado y ejecuta `context.rewrite('/login')`. Internamente, Astro detiene lo que estaba haciendo y dice: "Ok, olv칤dense del panel, ahora vamos a renderizar la p치gina `/login`". Lo crucial es que para el navegador del usuario, la URL no ha cambiado. Esto es 칰til para que, una vez que inicie sesi칩n, puedas enviarlo directamente al panel sin que pierda la p치gina en la que estaba.

#### 3. **Desarrollo:**

La diferencia clave con una redirecci칩n (`return new Response(null, { status: 302, headers: { Location: '/login' } })`) es que la redirecci칩n **cambia la URL** en el navegador y le dice "ve a esta otra direcci칩n". `rewrite` es m치s sutil, es un cambio interno.

**춰Cuidado!** Una caracter칤stica muy importante de `context.rewrite()` es que **reinicia todo el proceso de middleware**. Esto significa que si tienes una secuencia de middlewares, al hacer `rewrite`, el proceso vuelve a empezar desde el primer middleware de la secuencia, pero ahora para la nueva ruta (`/login` en nuestro ejemplo).

游댯 **Espec칤fico**: `rewrite` es una herramienta avanzada para casos de uso concretos, como renderizado condicional de p치ginas basado en autenticaci칩n o pruebas A/B (mostrar diferentes versiones de una p치gina a diferentes usuarios bajo la misma URL). No es algo que usar치s todos los칤as, pero es muy potente cuando lo necesitas.
