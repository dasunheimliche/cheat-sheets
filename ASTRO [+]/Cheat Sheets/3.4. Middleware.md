## A - ¿Qué es Middleware? El Portero Inteligente de tu Web 🔴

#### 1. **Introducción:**

El middleware es como un portero que se para en la puerta de tu sitio web; intercepta cada visita (petición) antes de que llegue a la página, permitiéndote revisar, modificar o añadir cosas sobre la marcha.

#### 2. **Ejemplo:**

Imagina que quieres saber cada vez que alguien visita cualquier página de tu sitio. Creas un "portero" que anota la visita en una libreta (la consola).

**`src/middleware.js`**

```javascript
// Este es nuestro "portero". Se ejecuta con CADA visita.
export function onRequest(context, next) {
  // 1. El portero ve que alguien llega y anota la URL que quiere visitar.
  console.log(`¡Alguien está visitando la página: ${context.url.pathname}!`);

  // 2. Después de anotar, le dice "adelante, puede pasar" a la página.
  // `next()` es la orden para continuar. ¡Si no la pones, nadie entra!
  return next();
}
```

**Explicación del ejemplo:**
Este código se coloca en un archivo especial llamado `src/middleware.js`. Astro sabe que debe ejecutar la función `onRequest` de este archivo **automáticamente** por cada petición que recibe tu servidor. `context` contiene toda la información de la visita (como la URL), y `next()` es la función que le da permiso para continuar hacia la página solicitada. Sin `return next()`, el visitante se quedaría atascado en la puerta y nunca vería la página.

#### 3. **Desarrollo:**

Piénsalo así: cada vez que alguien escribe una dirección de tu web en su navegador, se crea una "petición". El middleware "atrapa" esa petición. Esto te da un poder increíble:

- **Seguridad:** Puedes verificar si un usuario ha iniciado sesión antes de dejarle ver una página privada.
- **Personalización:** Puedes cambiar el título de una página o mostrar un banner de bienvenida diferente para cada usuario.
- **Análisis:** Puedes registrar qué páginas son las más visitadas.

Todo esto ocurre en el servidor, antes de que el HTML se envíe al navegador del usuario.

🔴 **Fundamental**: Entender el middleware es crucial porque es la herramienta principal en Astro para manejar lógica dinámica y datos que dependen de cada petición individual (como la sesión de un usuario). Es la base para crear aplicaciones web interactivas y seguras, no solo sitios estáticos.

---

## B - `context.locals`: Tu Mensajero Personal entre Archivos 🔴

#### 1. **Introducción:**

`context.locals` es una "caja" especial que tu middleware puede llenar con información, y luego entregar esa misma caja a tus páginas `.astro` para que usen lo que hay dentro.

#### 2. **Ejemplo:**

Nuestro portero (middleware) identifica al visitante y le pone una etiqueta con su nombre. Luego, la página de bienvenida usa esa etiqueta para saludarlo personalmente.

**`src/middleware.js`**

```javascript
export function onRequest({ locals }, next) {
  // 1. El portero (middleware) decide que el visitante se llama "Ana".
  //    Guarda este nombre en la "caja" `locals`.
  locals.nombreDeUsuario = "Ana";
  locals.rol = "Admin";

  // 2. Deja pasar al visitante con su caja de datos.
  return next();
}
```

**`src/pages/index.astro`**

```astro
---
// 1. La página recibe la "caja" del middleware.
//    En los archivos .astro, se accede a ella con `Astro.locals`.
const datosDelVisitante = Astro.locals;
---

<!-- 2. La página usa los datos de la caja para personalizar el saludo. -->
<h1>¡Hola, {datosDelVisitante.nombreDeUsuario}!</h1>
<p>Tu rol es: {datosDelVisitante.rol}</p>
```

**Explicación del ejemplo:**
En `middleware.js`, usamos `locals` (que es una abreviatura de `context.locals`) para guardar datos. En este caso, el nombre y el rol del usuario. Luego, en cualquier página `.astro`, podemos acceder a esos mismos datos a través de `Astro.locals`. ¡Es como un puente de información! Fíjate en el pequeño pero crucial detalle: en el middleware es `context.locals` (o solo `locals`), y en la página es `Astro.locals`. Son la misma "caja", pero se llaman ligeramente diferente dependiendo de dónde estés.

#### 3. **Desarrollo:**

La clave de `locals` es que **vive y muere con cada petición**. Si Ana visita la página, se crea una caja para ella. Si Pedro la visita un segundo después, se crea una caja completamente nueva y separada para él. La información de Ana no se mezcla con la de Pedro.

Esto es perfecto para guardar datos específicos de la sesión de un usuario, como su información de perfil, sus permisos, o si ha iniciado sesión o no. Puedes guardar cualquier cosa: texto, números, ¡incluso funciones!

🔴 **Fundamental**: `locals` es el mecanismo principal para pasar datos desde la lógica del servidor (middleware) a la vista (páginas `.astro`). Sin él, el middleware y las páginas estarían aislados y no podrían compartir información dinámica, lo cual es el propósito central de esta herramienta.

---

## C - La Función `next()`: La Llave para Continuar 🟡

#### 1. **Introducción:**

La función `next()` es la instrucción que le das al middleware para que termine su trabajo y deje que la petición continúe su camino, ya sea hacia otro middleware o hacia la página final.

#### 2. **Ejemplo:**

Imagina un control de seguridad. Si no tienes permiso, te detienen. Si lo tienes, te dicen "adelante" (`next()`).

**`src/middleware.js`**

```javascript
export function onRequest({ request, locals }, next) {
  // Leemos una cabecera especial para ver si el usuario tiene la "llave secreta".
  const tienePermiso = request.headers.get("X-Pase-Secreto") === "abracadabra";

  if (tienePermiso) {
    // ¡Perfecto! Tienes la llave. Te dejamos pasar.
    locals.mensaje = "Bienvenido, agente secreto.";
    return next(); // <-- ¡La puerta se abre!
  } else {
    // No tienes la llave. No puedes pasar.
    // En lugar de `next()`, devolvemos una respuesta de "Acceso Denegado".
    return new Response("ACCESO DENEGADO", { status: 403 });
  }
}
```

**Explicación del ejemplo:**
Aquí, el middleware actúa como un verdadero guardia. Si la petición viene con una "cabecera" especial (`X-Pase-Secreto`) y el valor correcto, se ejecuta `return next()`, y el usuario verá la página que solicitó. Si no, el proceso se detiene en seco y se le envía una respuesta de "ACCESO DENEGADO" en su lugar. El usuario **nunca** llegará a ver la página original.

#### 3. **Desarrollo:**

`next()` es más que un simple "continuar". Es el corazón del sistema de encadenamiento. Cuando llamas a `await next()`, estás diciendo: "Pausa mi trabajo aquí, deja que todo lo demás (otros middlewares, la página) se ejecute, y cuando terminen, devuélveme el resultado (la respuesta HTML final)". Esto nos lleva a un uso más avanzado...

🟡 **Importante**: Aunque `return next()` parece simple, es el mecanismo que controla el flujo de CADA petición. Entender que puedes detener el flujo o dejarlo continuar es clave para implementar lógica condicional como la autenticación. No es solo una función, es el interruptor de encendido/apagado de tu página.

---

## D - Modificar el HTML de Salida: El Editor de Último Minuto 🟡

#### 1. **Introducción:**

El middleware puede esperar a que Astro genere el HTML de una página y, justo antes de enviarlo al usuario, hacer cambios en ese HTML, como si fuera un editor corrigiendo un texto a última hora.

#### 2. **Ejemplo:**

Imagina que en varias páginas de tu blog has escrito accidentalmente "INFORMACIÓN PRIVADA". Quieres asegurarte de que nadie lo vea, así que creas un middleware que lo reemplaza por "[CENSURADO]" en todas las páginas.

**`src/middleware.js`**

```javascript
export const onRequest = async (context, next) => {
  // 1. Primero, dejamos que Astro haga su trabajo y genere la página.
  //    `await next()` nos devuelve la respuesta completa (con el HTML dentro).
  const response = await next();

  // 2. Extraemos el contenido HTML de la respuesta como si fuera un texto.
  const html = await response.text();

  // 3. Reemplazamos todas las apariciones de la frase prohibida.
  const htmlCensurado = html.replaceAll("INFORMACIÓN PRIVADA", "[CENSURADO]");

  // 4. Creamos una NUEVA respuesta con el HTML ya modificado y la enviamos.
  return new Response(htmlCensurado, {
    status: 200, // Mantenemos el estado original (OK)
    headers: response.headers, // Mantenemos las cabeceras originales
  });
};
```

**Explicación del ejemplo:**
El truco aquí está en el `await next()`. No solo llama a la siguiente etapa, sino que **espera** a que termine y le entrega el resultado: la `response`. Esta `response` contiene el HTML final. A partir de ahí, es como manipular cualquier texto en JavaScript. Lo lees, lo modificas con `replaceAll()`, y finalmente creas una `new Response` con tu versión limpia del HTML para enviarla al navegador del usuario. El usuario nunca sabrá que el texto original estaba allí.

#### 3. **Desarrollo:**

Este patrón es increíblemente poderoso. No solo sirve para censurar, sino también para:

- **Inyectar scripts:** Añadir un script de análisis o un banner de cookies a todas las páginas.
- **Personalizar contenido:** Cambiar palabras o frases dependiendo del usuario (por ejemplo, cambiar "tu carrito" por "su carrito" en un tono más formal).
- **Optimización:** Modificar el HTML para mejorar el rendimiento (aunque Astro ya hace mucho de esto por ti).

🟡 **Importante**: Esta técnica te da control total sobre la salida final sin tener que modificar cada uno de tus archivos `.astro`. Es una forma centralizada y elegante de aplicar cambios globales a la apariencia o contenido de tu sitio.

---

## E - `sequence()`: Poniendo a tus Porteros en Fila 🔵

#### 1. **Introducción:**

`sequence()` es una herramienta que te permite usar múltiples funciones de middleware y ejecutarlas en un orden específico, como si tuvieras una fila de porteros, cada uno con una tarea diferente.

#### 2. **Ejemplo:**

Tienes tres porteros:

1.  `validación`: Revisa que la petición sea válida.
2.  `auth`: Revisa si el usuario ha iniciado sesión.
3.  `saludo`: Registra un saludo.

Quieres que se ejecuten en ese orden exacto.

**`src/middleware.js`**

```javascript
import { sequence } from "astro:middleware";

// Portero 1: Validación
async function validacion(_, next) {
  console.log("1. Petición de validación (entrando)");
  const response = await next(); // Pasa al siguiente portero
  console.log("4. Respuesta de validación (saliendo)");
  return response;
}

// Portero 2: Autenticación
async function auth(_, next) {
  console.log("2. Petición de autenticación (entrando)");
  const response = await next(); // Pasa al siguiente portero
  console.log("5. Respuesta de autenticación (saliendo)");
  return response;
}

// Portero 3: Saludo (este es el último antes de la página)
async function saludo(_, next) {
  console.log("3. Petición de saludo (entrando)");
  const response = await next(); // Pasa a la página
  console.log("6. Respuesta de saludo (saliendo)");
  return response;
}

// `sequence` los pone en fila: validación -> auth -> saludo
export const onRequest = sequence(validacion, auth, saludo);
```

**Salida en la consola:**

```
1. Petición de validación (entrando)
2. Petición de autenticación (entrando)
3. Petición de saludo (entrando)
6. Respuesta de saludo (saliendo)
5. Respuesta de autenticación (saliendo)
4. Respuesta de validación (saliendo)
```

**Explicación del ejemplo:**
Observa el orden. Las peticiones van "hacia adentro" en el orden que definimos (1, 2, 3). Una vez que la última (`saludo`) llama a `next()`, se genera la página. Luego, las respuestas van "hacia afuera" en orden inverso (6, 5, 4). Es como un juego de muñecas rusas: abres una, luego otra, luego otra... y para cerrarlas, vas desde la más pequeña hacia la más grande.

#### 3. **Desarrollo:**

¿Por qué hacer esto en lugar de una función gigante? Por **organización y reutilización**. Cada función tiene una única responsabilidad (Principio de Responsabilidad Única). Esto hace que tu código sea:

- **Más fácil de leer:** Sabes exactamente qué hace cada pieza.
- **Más fácil de depurar:** Si algo falla en la autenticación, solo tienes que mirar la función `auth`.
- **Reutilizable:** Podrías querer usar la función `auth` en otro proyecto.

🔵 **Específico**: Para un sitio pequeño con una sola verificación, quizás no necesites `sequence`. Pero en cuanto tu lógica de servidor crece (autenticación, logging, manejo de datos, etc.), `sequence` se vuelve indispensable para mantener el código limpio y ordenado.

---

## F - `context.rewrite()`: Muestra otra Página sin Cambiar la URL 🔵

#### 1. **Introducción:**

`context.rewrite()` es un truco que te permite mostrarle al usuario el contenido de una página completamente diferente a la que solicitó, pero manteniendo la URL original en la barra de direcciones del navegador.

#### 2. **Ejemplo:**

Un usuario intenta acceder a `/panel-de-control`, pero no ha iniciado sesión. En lugar de redirigirlo a `/login` (cambiando la URL), le mostramos el contenido de la página de login, pero la URL seguirá siendo `/panel-de-control`.

**`src/middleware.js`**

```javascript
import { isLoggedIn } from "~/auth.js"; // Una función imaginaria que devuelve true/false

export function onRequest(context, next) {
  // Si el usuario intenta acceder al panel Y NO ha iniciado sesión...
  if (context.url.pathname === "/panel-de-control" && !isLoggedIn(context)) {
    // ...le servimos el contenido de la página de login.
    // ¡OJO! Esto reinicia todo el ciclo de middleware.
    return context.rewrite("/login");
  }

  // Si ha iniciado sesión o va a otra página, todo sigue normal.
  return next();
}
```

**Explicación del ejemplo:**
El usuario escribe `misitio.com/panel-de-control`. El middleware se activa, comprueba que no está logueado y ejecuta `context.rewrite('/login')`. Internamente, Astro detiene lo que estaba haciendo y dice: "Ok, olvídense del panel, ahora vamos a renderizar la página `/login`". Lo crucial es que para el navegador del usuario, la URL no ha cambiado. Esto es útil para que, una vez que inicie sesión, puedas enviarlo directamente al panel sin que pierda la página en la que estaba.

#### 3. **Desarrollo:**

La diferencia clave con una redirección (`return new Response(null, { status: 302, headers: { Location: '/login' } })`) es que la redirección **cambia la URL** en el navegador y le dice "ve a esta otra dirección". `rewrite` es más sutil, es un cambio interno.

**¡Cuidado!** Una característica muy importante de `context.rewrite()` es que **reinicia todo el proceso de middleware**. Esto significa que si tienes una secuencia de middlewares, al hacer `rewrite`, el proceso vuelve a empezar desde el primer middleware de la secuencia, pero ahora para la nueva ruta (`/login` en nuestro ejemplo).

🔵 **Específico**: `rewrite` es una herramienta avanzada para casos de uso concretos, como renderizado condicional de páginas basado en autenticación o pruebas A/B (mostrar diferentes versiones de una página a diferentes usuarios bajo la misma URL). No es algo que usarás todos losías, pero es muy potente cuando lo necesitas.
