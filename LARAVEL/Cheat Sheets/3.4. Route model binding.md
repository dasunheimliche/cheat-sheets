## A - Route Model Binding

#### 1. **DefiniciÃ³n:**

ImagÃ­nate que en tus rutas de Laravel, en vez de recibir solo IDs, Â¡puedes recibir directamente los modelos de tu base de datos! Route Model Binding hace justo eso: automÃ¡ticamente busca el modelo que corresponde a un ID en tu ruta y te lo pasa directamente a tu controlador o funciÃ³n de ruta. Â¡Magia pura! âœ¨

#### 2. **Ejemplo:**

**Ruta sin Model Binding:**

```php
Route::get('/users/{id}', function ($id) {
    $user = User::find($id); // Â¡TÃº tienes que buscar el usuario!
    return $user->email;
});
```

**Ruta con Model Binding:**

```php
use App\Models\User;

Route::get('/users/{user}', function (User $user) {
    return $user->email; // Â¡Laravel te da el usuario directamente!
});
```

**ExplicaciÃ³n del ejemplo:**
En el segundo ejemplo, Laravel ve que en la ruta `/users/{user}` tienes un parÃ¡metro `{user}` y en la funciÃ³n de la ruta, pides un `User $user`. Â¡AutomÃ¡ticamente busca un `User` con el ID que viene en la URL y te lo pasa como `$user`! Si no lo encuentra, Â¡devuelve un error 404 por ti! ğŸ¤¯

#### 3. **Notas o advertencias:**

- Â¡AsegÃºrate de que el nombre del parÃ¡metro en la ruta (`{user}`) coincida con el nombre de la variable type-hinted en tu funciÃ³n o controlador (`$user`)!
- Esto funciona de maravilla con Eloquent models.

## B - Implicit Binding (Binding ImplÃ­cito)

#### 1. **DefiniciÃ³n:**

Es la forma mÃ¡s fÃ¡cil y automÃ¡tica de usar Route Model Binding. Laravel es listo y, basÃ¡ndose en el nombre del parÃ¡metro de la ruta y el type-hinting en tu funciÃ³n o controlador, Â¡resuelve el modelo por ti! ğŸ§ 

#### 2. **Ejemplo:**

**DefiniciÃ³n de ruta:**

```php
use App\Http\Controllers\UserController;
use App\Models\User;

Route::get('/users/{user}', [UserController::class, 'show']);
```

**Controlador:**

```php
<?php

namespace App\Http\Controllers;

use App\Models\User;
use App\Http\Controllers\Controller;

class UserController extends Controller
{
    public function show(User $user)
    {
        return view('user.profile', ['user' => $user]);
    }
}
```

**ExplicaciÃ³n del ejemplo:**
Mira cÃ³mo el parÃ¡metro `{user}` en la ruta y el argumento `$user` en el mÃ©todo `show` del controlador coinciden, Â¡y ambos son de tipo `User`! Laravel hace la magia y te inyecta el modelo `User` correcto. âœ¨

#### 3. **Notas o advertencias:**

- Â¡La clave estÃ¡ en la **coincidencia** del nombre del parÃ¡metro de la ruta y el nombre de la variable type-hinted!
- Si no encuentra el modelo, Â¡automÃ¡ticamente lanza un 404!

## C - Soft Deleted Models (Modelos con Soft Delete)

#### 1. **DefiniciÃ³n:**

Por defecto, Implicit Binding solo encuentra modelos que **no** han sido "soft deleted" (eliminados suavemente). Pero, Â¿y si quieres incluir tambiÃ©n los que estÃ¡n "soft deleted"? Â¡Laravel te da la soluciÃ³n!

#### 2. **Ejemplo:**

```php
use App\Models\User;

Route::get('/users/{user}', function (User $user) {
    return $user->email;
})->withTrashed(); // Â¡AÃ±ade esto para incluir soft-deleted models!
```

**ExplicaciÃ³n del ejemplo:**
AÃ±adiendo `->withTrashed()` al final de la definiciÃ³n de tu ruta, le dices a Laravel: "Â¡Oye, incluye tambiÃ©n los usuarios que han sido soft deleted!". Â¡AsÃ­ de fÃ¡cil! ğŸ˜

#### 3. **Notas o advertencias:**

- `withTrashed()` solo funciona con Implicit Binding.
- Recuerda que necesitas tener Soft Deletes configurado en tu modelo `User` para que esto funcione.

## D - Customizing the Key (Personalizar la Clave)

#### 1. **DefiniciÃ³n:**

Normalmente, Model Binding busca modelos usando la columna `id`. Pero, Â¿y si quieres usar otra columna, como `slug`? Â¡Sin problema! Puedes especificar quÃ© columna usar directamente en la ruta.

#### 2. **Ejemplo:**

**Usando `slug` en la ruta:**

```php
use App\Models\Post;

Route::get('/posts/{post:slug}', function (Post $post) {
    return $post;
});
```

**O, definiendo `getRouteKeyName` en el modelo:**

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class Post extends Model
{
    /**
     * Get the route key for the model.
     */
    public function getRouteKeyName(): string
    {
        return 'slug'; // Â¡Ahora 'slug' es la clave por defecto para las rutas!
    }
}
```

**ExplicaciÃ³n del ejemplo:**
En el primer ejemplo, `{post:slug}` le dice a Laravel que busque `Post`s usando la columna `slug` en lugar de `id`. En el segundo, definimos en el modelo `Post` que la clave para las rutas siempre serÃ¡ `slug`. Â¡Elige la opciÃ³n que mejor te venga! ğŸ˜‰

#### 3. **Notas o advertencias:**

- Si usas `getRouteKeyName` en el modelo, Â¡afecta a **todas** las rutas que usen Implicit Binding para ese modelo!
- Especificar la columna en la ruta (`{post:slug}`) es mÃ¡s especÃ­fico y solo afecta a esa ruta.

## E - Custom Keys and Scoping (Claves Personalizadas y Alcance)

#### 1. **DefiniciÃ³n:**

Cuando tienes rutas anidadas (como `/users/{user}/posts/{post}`), a veces quieres que el segundo modelo (`Post` en este caso) estÃ© relacionado con el primero (`User`). "Scoping" (Alcance) asegura que solo se encuentren los posts que pertenecen al usuario correcto.

#### 2. **Ejemplo:**

**Ruta anidada con scoping implÃ­cito:**

```php
use App\Models\Post;
use App\Models\User;

Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {
    return $post;
});
```

**Ruta anidada con scoping explÃ­cito:**

```php
use App\Models\Post;
use App\Models\User;

Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {
    return $post;
})->scopeBindings(); // Â¡Forzamos el scoping!
```

**ExplicaciÃ³n del ejemplo:**
En el primer ejemplo, al usar `{post:slug}` dentro de `/users/{user}`, Laravel automÃ¡ticamente asume que quieres buscar posts **del usuario** actual. En el segundo, `->scopeBindings()` fuerza este comportamiento incluso si no usas una clave personalizada como `slug`. Laravel buscarÃ¡ posts relacionados con el `$user`. Â¡AsÃ­ te aseguras de que no se mezclen posts de diferentes usuarios! ğŸ¤

#### 3. **Notas o advertencias:**

- Laravel usa convenciones para adivinar la relaciÃ³n (en este caso, asume que `User` tiene una relaciÃ³n `posts`).
- `scopeBindings()` es Ãºtil cuando **no** usas claves personalizadas pero aÃºn quieres scoping.
- `withoutScopedBindings()` hace lo contrario: desactiva el scoping si no lo quieres.

## F - Customizing Missing Model Behavior (Personalizar el Comportamiento de Modelo No Encontrado)

#### 1. **DefiniciÃ³n:**

Â¿QuÃ© pasa si el modelo no se encuentra? Por defecto, Laravel muestra un error 404. Pero, Â¡puedes personalizar esto! Puedes definir quÃ© hacer si un modelo no se encuentra en Implicit Binding.

#### 2. **Ejemplo:**

```php
use App\Http\Controllers\LocationsController;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Redirect;

Route::get('/locations/{location:slug}', [LocationsController::class, 'show'])
    ->name('locations.view')
    ->missing(function (Request $request) {
        return Redirect::route('locations.index'); // Â¡Redirige a 'locations.index' si no encuentra la location!
    });
```

**ExplicaciÃ³n del ejemplo:**
Con `->missing(...)`, defines una funciÃ³n que se ejecuta si Laravel no encuentra el modelo `Location`. En este caso, en vez de un 404, Â¡redirigimos al usuario a la ruta `locations.index`! Â¡Mucho mÃ¡s amigable! ğŸ˜Š

#### 3. **Notas o advertencias:**

- `missing()` te da control total sobre quÃ© pasa cuando un modelo no se encuentra.
- Puedes redirigir, mostrar un mensaje personalizado, Â¡lo que quieras!

## G - Implicit Enum Binding (Binding ImplÃ­cito de Enums)

#### 1. **DefiniciÃ³n:**

Si usas PHP 8.1 o superior, Â¡puedes usar Enums! Laravel tambiÃ©n soporta Model Binding para Enums. Puedes type-hint un "backed Enum" en tu ruta, y Laravel se asegura de que el segmento de la ruta corresponda a un valor vÃ¡lido del Enum.

#### 2. **Ejemplo:**

**Enum `Category`:**

```php
<?php

namespace App\Enums;

enum Category: string
{
    case Fruits = 'fruits';
    case People = 'people';
}
```

**Ruta usando el Enum:**

```php
use App\Enums\Category;
use Illuminate\Support\Facades\Route;

Route::get('/categories/{category}', function (Category $category) {
    return $category->value;
});
```

**ExplicaciÃ³n del ejemplo:**
AquÃ­, `$category` es de tipo `Category`. Laravel solo ejecutarÃ¡ esta ruta si el segmento `{category}` es `fruits` o `people` (los valores definidos en el Enum). Si no, Â¡devuelve un 404! Â¡Perfecto para validar valores de ruta! ğŸ‘Œ

#### 3. **Notas o advertencias:**

- Funciona solo con "backed Enums" (Enums con un tipo de dato asociado, como `string` o `int`).
- Â¡Ayuda a mantener tus rutas limpias y validadas!

## H - Explicit Binding (Binding ExplÃ­cito)

#### 1. **DefiniciÃ³n:**

Si no quieres usar Implicit Binding (que es automÃ¡tico), puedes definir explÃ­citamente cÃ³mo los parÃ¡metros de ruta se relacionan con los modelos. Es como decirle a Laravel exactamente quÃ© modelo usar para cada parÃ¡metro.

#### 2. **Ejemplo:**

**Definiendo el binding explÃ­cito en `AppServiceProvider`:**

```php
use App\Models\User;
use Illuminate\Support\Facades\Route;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Route::model('user', User::class); // Â¡Le decimos a Laravel que '{user}' siempre es un 'User'!
}
```

**Ruta usando el binding explÃ­cito:**

```php
use App\Models\User;

Route::get('/users/{user}', function (User $user) {
    // ...
});
```

**ExplicaciÃ³n del ejemplo:**
Con `Route::model('user', User::class)`, registramos que cada vez que veamos un parÃ¡metro `{user}` en una ruta, Â¡queremos que se resuelva como un modelo `User`! Luego, en la ruta, al type-hint `User $user`, Laravel ya sabe quÃ© hacer gracias al binding explÃ­cito. Â¡MÃ¡s control, menos magia! âœ¨

#### 3. **Notas o advertencias:**

- Los bindings explÃ­citos se definen en el mÃ©todo `boot` de `AppServiceProvider`.
- `Route::model()` asocia un nombre de parÃ¡metro (`'user'`) con una clase de modelo (`User::class`).

## I - Customizing the Resolution Logic (Personalizar la LÃ³gica de ResoluciÃ³n)

#### 1. **DefiniciÃ³n:**

Â¿Quieres aÃºn mÃ¡s control? Puedes personalizar **cÃ³mo** Laravel busca el modelo en Explicit Binding. Puedes definir tu propia lÃ³gica de bÃºsqueda usando `Route::bind` o sobrescribiendo mÃ©todos en tu modelo.

#### 2. **Ejemplo:**

**Usando `Route::bind` en `AppServiceProvider`:**

```php
use App\Models\User;
use Illuminate\Support\Facades\Route;

/**
 * Bootstrap any application services.
 */
public function boot(): void
{
    Route::bind('user', function (string $value) {
        return User::where('name', $value)->firstOrFail(); // Â¡Busca usuarios por 'name' en vez de 'id'!
    });
}
```

**Sobrescribiendo `resolveRouteBinding` en el modelo `User`:**

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    /**
     * Retrieve the model for a bound value.
     *
     * @param  mixed  $value
     * @param  string|null  $field
     * @return \Illuminate\Database\Eloquent\Model|null
     */
    public function resolveRouteBinding($value, $field = null)
    {
        return $this->where('name', $value)->firstOrFail(); // Â¡TambiÃ©n busca por 'name' aquÃ­!
    }
}
```

**ExplicaciÃ³n del ejemplo:**
Con `Route::bind`, defines una funciÃ³n que se ejecuta cuando Laravel necesita resolver el parÃ¡metro `'user'`. En este caso, buscamos usuarios por el campo `name` en lugar del `id` por defecto. Sobrescribir `resolveRouteBinding` en el modelo hace lo mismo, pero directamente en el modelo `User`. Â¡Elige tu forma favorita de personalizar! ğŸ¨

#### 3. **Notas o advertencias:**

- `Route::bind` es mÃ¡s flexible si quieres lÃ³gica de resoluciÃ³n diferente para distintos bindings.
- `resolveRouteBinding` en el modelo es Ãºtil si quieres que la lÃ³gica de resoluciÃ³n sea consistente para ese modelo en todas partes.
- `resolveChildRouteBinding` se usa para personalizar la resoluciÃ³n en rutas anidadas con scoping.
