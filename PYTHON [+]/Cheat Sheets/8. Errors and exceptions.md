### **Paso 0: Nuestro Mapa de Ruta**

Antes de sumergirnos, aquí tienes un índice de todo lo que vamos a explorar. Es mi forma de asegurarme de que no nos dejamos ni una sola migaja de pan por el camino. ¡Quiero que veas el panorama completo desde el principio!

1.  **Tipos de Errores:** La primera gran división: Errores de Sintaxis vs. Excepciones.
2.  **Errores de Sintaxis (`SyntaxError`):** Los "errores de tipeo" que Python detecta antes de empezar.
3.  **Excepciones:** Errores que ocurren mientras tu código ya está corriendo.
4.  **Anatomía de un Mensaje de Excepción:** Cómo leer el "informe del detective" que Python te da.
5.  **Manejo de Excepciones (`try...except`):** La red de seguridad para atrapar errores sin que tu programa se rompa.
6.  **El Flujo de `try...except`:** Qué pasa cuando todo va bien, y qué pasa cuando algo sale mal.
7.  **Manejando Múltiples Excepciones (Una por una):** Poner varias redes de seguridad para diferentes tipos de caídas.
8.  **Manejando Múltiples Excepciones (En grupo):** Usar una sola red para varios tipos de caídas similares.
9.  **Jerarquía de Excepciones:** Cómo atrapar un error "general" puede atrapar también a sus "hijos" más específicos.
10. **Accediendo a los Detalles del Error (`as`):** Cómo interrogar al error para saber exactamente qué pasó.
11. **La Cláusula `else`:** El código que se ejecuta solo si todo en el `try` salió perfecto.
12. **Las Excepciones se Propagan:** Cómo un error en una función puede ser atrapado fuera de ella.
13. **Lanzando Excepciones (`raise`):** Cómo crear y lanzar tus propias "señales de alarma".
14. **Re-lanzando una Excepción:** Volver a lanzar un error que ya atrapaste para que alguien más lo maneje.
15. **Encadenamiento de Excepciones (Implícito):** Cuando un error causa otro y Python te muestra la conexión.
16. **Encadenamiento de Excepciones (Explícito con `from`):** Dejar claro que un error es consecuencia directa de otro.
17. **Desactivando el Encadenamiento (`from None`):** Ocultar el error original para mostrar solo el nuevo.
18. **Excepciones Definidas por el Usuario:** Creando tus propias alarmas personalizadas.
19. **Acciones de Limpieza (`finally`):** El código que se ejecuta "pase lo que pase".
20. **Acciones de Limpieza Predefinidas (`with`):** La forma elegante y automática de limpiar.
21. **Grupos de Excepciones (`ExceptionGroup`):** Lanzando varios errores a la vez en un solo paquete.
22. **Manejo Parcial de Grupos (`except*`):** Atrapando solo algunos errores específicos de un grupo.
23. **Enriqueciendo Excepciones (`add_note`):** Dejando pistas adicionales en el informe del error.

¡Listo! Con nuestro mapa en mano, ¡comencemos la aventura!

---

## A - Errores de Sintaxis vs. Excepciones: ¿Tropezar al Escribir o al Correr? 🔴

#### 1. **Introducción:**

Entender la diferencia entre estos dos tipos de errores es el primer paso para dejar de tenerles miedo: uno es un error de "gramática" y el otro es un error de "lógica" que ocurre durante la ejecución.

#### 2. **Ejemplo Comparativo:**

Imagina que estás dando instrucciones a un robot de cocina.

**Error de Sintaxis (Gramática incorrecta):**
Le dices: `mientras haya huevos batir`
El robot ni siquiera empieza. Te dice: "No entiendo esa frase. Falta algo después de 'huevos'".

```python
# Python se queja ANTES de ejecutar nada.
while True print('Hello world')
#          ^^^^^
# SyntaxError: invalid syntax.  Faltan los dos puntos ':'
```

**Excepción (Instrucción imposible de ejecutar):**
Le dices: `divide 10 galletas entre 0 personas`
El robot entiende la frase, empieza la tarea, pero se detiene y te dice: "¡Error! No puedo dividir entre cero. Es imposible."

```python
# Python entiende la sintaxis, pero la operación falla AL EJECUTARSE.
10 * (1/0)
# ZeroDivisionError: division by zero
```

#### 3. **Desarrollo:**

Piénsalo de esta manera, que es crucial para que no te confundas nunca más:

- **Errores de Sintaxis (`SyntaxError`):** Son como intentar hablar un idioma con la gramática incorrecta. La otra persona (Python) ni siquiera puede entender lo que quieres decir, por lo que la conversación (la ejecución del programa) nunca comienza. Python revisa tu código en busca de estos errores _antes_ de ejecutar una sola línea. Olvidarte de dos puntos `:`, cerrar un paréntesis que no abriste, o escribir mal una palabra clave como `whle` en vez de `while` son ejemplos clásicos.

- **Excepciones:** Son errores que ocurren cuando tu "frase" es gramaticalmente perfecta, pero la acción que pides es imposible en ese momento. El programa empieza a correr, pero en medio de la ejecución, ¡BUM!, se encuentra con un problema. Intentar dividir por cero, usar una variable que no existe (`NameError`), o sumar un número a un texto (`TypeError`) son excepciones comunes.

La gran diferencia es **cuándo** se detectan: los errores de sintaxis son _antes_ de la ejecución, las excepciones son _durante_ la ejecución.

🔴 **Fundamental:** Esta distinción es la base de todo el manejo de errores. Si no entiendes esto, te sentirás perdido. Saber si tu problema es de "escritura" o de "ejecución" te dice inmediatamente dónde y cómo empezar a buscar la solución.

## B - Errores de Sintaxis (`SyntaxError`): Arreglando la Gramática de tu Código 🔴

#### 1. **Introducción:**

Un `SyntaxError` es simplemente Python diciéndote: "No entiendo lo que escribiste, revisa las reglas del lenguaje".

#### 2. **Ejemplo:**

```python
while True print('Hello world')
  File "<stdin>", line 1
    while True print('Hello world')
               ^^^^^
SyntaxError: invalid syntax
```

**Explicación del ejemplo:**
Python esperaba dos puntos (`:`) después de `while True` para saber qué bloque de código repetir. Al no encontrarlos, se detuvo en `print` y dijo: "Esto no debería estar aquí". Las flechitas `^^^^^` te señalan dónde se confundió Python.

#### 3. **Desarrollo:**

¡Cuidado! Y esto es una trampa en la que caemos todos al principio. Las flechitas `^^^^^` no siempre apuntan al error exacto, sino al **primer lugar donde Python se dio cuenta de que algo andaba mal**. En nuestro ejemplo, el error real es la _falta_ de los dos puntos _antes_ de `print`.

El mensaje de error también te da pistas valiosas:

- **File "<stdin>", line 1:** Te dice el archivo y la línea del problema. `<stdin>` significa que lo escribiste directamente en la consola interactiva. Si fuera un archivo, diría algo como `"mi_programa.py", line 23`.
- **SyntaxError: invalid syntax:** Te dice el tipo de error. En este caso, que la "frase" está mal construida.

🔴 **Fundamental:** Aprender a leer estos mensajes es como aprender a leer un mapa. Son tu guía más directa para encontrar y aplastar bugs. Siempre mira la línea que te indica y busca errores de "puntuación" o palabras clave mal escritas.

## C - Excepciones: Cuando las Instrucciones Válidas Fallan 🔴

#### 1. **Introducción:**

Una excepción es un error que ocurre durante la ejecución de un programa que, hasta ese momento, era sintácticamente perfecto.

#### 2. **Ejemplo:**

```python
edad_texto = '25'
peso = 70

# Esto es sintácticamente correcto, pero fallará al ejecutarse
resultado = edad_texto + peso
```

**Salida del error:**

```
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
    '25' + 70
    ~~~~~^~~~
TypeError: can only concatenate str (not "int") to str
```

**Explicación del ejemplo:**
El código intenta sumar (`+`) un texto (`'25'`) y un número (`70`). Python no sabe cómo "sumar" estas dos cosas tan diferentes. ¿Debería convertir `70` a texto y unirlos ("2570")? ¿O convertir `'25'` a número y sumarlos (95)? Como no puede adivinar, lanza un `TypeError` para decirte que los tipos de datos son incompatibles para esa operación.

#### 3. **Desarrollo:**

El mensaje de error de una excepción es un informe completo de lo que salió mal. Vamos a desglosarlo:

1.  **`Traceback (most recent call last):`**: Esto es el "historial de llamadas" o "trazado de la pila". Te muestra el camino que siguió tu código hasta que se estrelló. Si una función A llama a B, y B llama a C, y el error ocurre en C, el traceback te mostrará ese camino (A -> B -> C).
2.  **`File "<stdin>", line 1, in <module>`**: De nuevo, te dice dónde ocurrió el error (archivo y línea).
3.  **`'25' + 70`**: Te muestra la línea de código exacta que causó el problema.
4.  **`TypeError: can only concatenate str (not "int") to str`**: Esta es la línea más importante.
    - **`TypeError`**: El nombre de la excepción. Te dice la _categoría_ del error. Otros comunes son `NameError` (variable no definida) o `ZeroDivisionError` (dividir por cero).
    - **`can only concatenate str...`**: Un mensaje descriptivo que explica _por qué_ ocurrió el error.

🔴 **Fundamental:** Las excepciones son inevitables en la programación. No se trata de evitarlas, sino de aprender a anticiparlas y manejarlas con gracia para que tu programa no se cierre inesperadamente.

## D - Manejo de Excepciones (`try...except`): La Red de Seguridad 🔴

#### 1. **Introducción:**

El bloque `try...except` te permite "intentar" ejecutar un código que podría fallar y, si falla, "atrapar" el error para hacer algo al respecto en lugar de dejar que el programa se rompa.

#### 2. **Ejemplo:**

Imagina que pides al usuario su edad para calcular en qué año nació. El usuario podría escribir "veinte" en lugar de "20".

````python
while True:
    try:
        # INTENTAMOS ejecutar este bloque de código
        edad_str = input("Por favor, introduce tu edad: ")
        edad_num = int(edad_str) # Esto puede fallar si no es un número
        print(f"Naciste aproximadamente en el año {2024 - edad_num}.")
        break # Si todo sale bien, salimos del bucle
    except ValueError:
        # Si ocurre un ValueError en el 'try', SE EJECUTA ESTE BLOQUE
        print("¡Ups! Eso no parece un número válido. Inténtalo de nuevo.")```

**Explicación del ejemplo:**
1.  El programa **intenta (`try`)** convertir la entrada del usuario a un número entero con `int()`.
2.  **Si tienes éxito** (el usuario escribe "30"), el bloque `except` se ignora por completo, se imprime el año de nacimiento y el `break` nos saca del bucle.
3.  **Si fallas** (el usuario escribe "treinta"), `int()` lanza una excepción `ValueError`. Python detiene la ejecución del `try`, salta directamente al bloque `except ValueError`, imprime el mensaje de error amigable y el bucle `while` vuelve a empezar, pidiendo la edad de nuevo.

#### 3. **Desarrollo:**

El flujo es la clave para entender esto, y es más simple de lo que parece:

*   **Paso 1: El Intento (`try`)**: Python ejecuta el código dentro del bloque `try`.
*   **Paso 2: El Resultado**:
    *   **Éxito (Sin Excepción)**: Si el código en `try` se completa sin errores, el bloque `except` se omite por completo y el programa continúa después de la estructura `try...except`.
    *   **Fallo (Con Excepción)**: Si ocurre una excepción, Python busca un `except` que coincida con el tipo de error.
        *   **Si encuentra una coincidencia**: Ejecuta el código dentro de ese `except` y luego continúa la ejecución *después* del bloque `try...except`. ¡El programa no se detiene!
        *   **Si NO encuentra una coincidencia**: El error no se maneja. Se comporta como si no hubiera un `try...except` y el programa se detiene mostrando el mensaje de error.

🔴 **Fundamental:** `try...except` es la herramienta principal para crear programas robustos y a prueba de fallos. Te permite controlar el caos, manejar entradas inesperadas y asegurar que tu aplicación no se cierre bruscamente ante el primer problema.

## E - Manejando Múltiples Tipos de Errores 🟡

#### 1. **Introducción:**

Un solo bloque de código puede fallar de muchas maneras distintas; puedes preparar diferentes "redes de seguridad" (`except`) para cada tipo de error posible.

#### 2. **Ejemplo:**

Vamos a leer un número de un archivo y a dividirlo por otro número. Pueden salir mal dos cosas: que el archivo no exista (`OSError`) o que el contenido no sea un número (`ValueError`).

```python
import sys

try:
    # Intentamos abrir un archivo cuyo nombre viene como argumento
    f = open('mi_archivo.txt')
    linea = f.readline()
    numero = int(linea.strip())
    resultado = 100 / numero # También podría dar ZeroDivisionError
except OSError:
    print("Error de sistema operativo: No se pudo abrir el archivo.")
except ValueError:
    print("Error de valor: No se pudo convertir el contenido a un número.")
except ZeroDivisionError:
    print("Error matemático: ¡No se puede dividir por cero!")
except Exception as err:
    # Un 'atrapa-todo' para cualquier otro error inesperado
    print(f"Ocurrió un error inesperado: {err}")
````

**Explicación del ejemplo:**
El código dentro de `try` se ejecuta.

- Si `open()` falla, salta al `except OSError`.
- Si `int()` falla, salta al `except ValueError`.
- Si `numero` es `0`, la división falla y salta al `except ZeroDivisionError`.
- Si ocurre cualquier otro error que no previmos, el último `except Exception` lo atrapará.

**¡Paranoia Pedagógica!** ¿Por qué tener `except` separados en lugar de uno solo que lo atrape todo? Porque quieres dar respuestas **específicas y útiles**. No es lo mismo decirle al usuario "Falló algo" que decirle "El archivo que especificaste no existe". Ser específico te ayuda a ti a depurar y al usuario a corregir su acción.

#### 3. **Desarrollo:**

Puedes estructurar tus `except` de dos maneras:

1.  **Múltiples Cláusulas `except` (como en el ejemplo):** Es la forma más clara y recomendada. Cada `except` se especializa en un tipo de error. Python los revisa en orden y se detiene en el primero que coincida.

2.  **Una Cláusula `except` con una Tupla:** Si quieres que varios tipos de error ejecuten exactamente el mismo código, puedes agruparlos.

    ```python
    try:
        # ... código que puede fallar ...
    except (RuntimeError, TypeError, NameError):
        print("Ocurrió un error de ejecución, de tipo o de nombre.")
        pass
    ```

🟡 **Importante:** Ser específico con los errores que atrapas es una buena práctica. Atrapa solo los errores que sabes cómo manejar. Usar un `except Exception:` genérico es como poner una manta sobre un motor que hace ruidos raros: oculta el problema, pero no lo soluciona y puede esconder errores graves que deberías conocer.

## F - Jerarquía de Excepciones: Atrapando al "Jefe" de los Errores 🔵

#### 1. **Introducción:**

Las excepciones en Python están organizadas en una jerarquía, como un árbol genealógico; si atrapas a un "padre", también atraparás a todos sus "hijos".

#### 2. **Ejemplo:**

Imagina que tenemos una familia de excepciones: `B` es el padre, `C` es hijo de `B`, y `D` es hijo de `C` (y por tanto, nieto de `B`).

```python
class B(Exception): pass
class C(B): pass
class D(C): pass

for error_a_lanzar in [B, C, D]:
    try:
        raise error_a_lanzar() # Forzamos que ocurra el error
    except B:
        print("Atrapado por B")
```

**Salida:**

```
Atrapado por B
Atrapado por B
Atrapado por B
```

**Explicación del ejemplo:**
El `except B:` es como una red de pesca grande. Como `C` y `D` son "tipos de" `B`, la red para `B` los atrapa a todos.

**¡CUIDADO! El orden importa.** Si pones el `except` del padre _antes_ que el del hijo, el del hijo nunca se ejecutará.

```python
for error_a_lanzar in [B, C, D]:
    try:
        raise error_a_lanzar()
    except B: # Este atrapa a B, C, y D
        print("B")
    except C: # Este NUNCA se alcanzará
        print("C")
    except D: # Este NUNCA se alcanzará
        print("D")
# Salida: B, B, B
```

El orden correcto es ir del más específico al más general:

```python
for error_a_lanzar in [B, C, D]:
    try:
        raise error_a_lanzar()
    except D: # Primero el más específico (nieto)
        print("D")
    except C: # Luego el siguiente (hijo)
        print("C")
    except B: # Al final el más general (padre)
        print("B")
# Salida: D, C, B
```

#### 3. **Desarrollo:**

Toda excepción hereda de una clase base llamada `BaseException`. La más importante para nosotros es `Exception`, de la que heredan casi todos los errores comunes (`ValueError`, `TypeError`, etc.).

Saber esto es útil. Si escribes `except Exception:`, estás poniendo una red de seguridad para casi cualquier cosa que pueda salir mal en tu programa (excepto errores muy graves como `SystemExit` o `KeyboardInterrupt`). Por eso se usa como un "atrapa-todo" al final de tus bloques `except`, para registrar errores inesperados.

🔵 **Específico:** No necesitas memorizar toda la jerarquía de excepciones, pero entender el concepto de "padre-hijo" es clave para ordenar correctamente tus bloques `except` y no ocultar accidentalmente un error específico con un manejador demasiado general.

## G - La Cláusula `else`: El Código de la Victoria 🟡

#### 1. **Introducción:**

La cláusula `else` en un bloque `try...except` contiene código que se ejecuta **únicamente si el bloque `try` se completó sin lanzar ninguna excepción**.

#### 2. **Ejemplo:**

Queremos abrir un archivo, contar sus líneas y luego cerrarlo. Cerrar el archivo solo tiene sentido si se abrió con éxito.

```python
# Intenta abrir un archivo llamado 'poema.txt'
try:
    archivo = open('poema.txt', 'r')
except OSError:
    print('No se pudo abrir el archivo poema.txt')
else:
    # Este bloque SOLO se ejecuta si el 'try' tuvo éxito
    print('El archivo se abrió correctamente.')
    print(f'Tiene {len(archivo.readlines())} líneas.')
    archivo.close() # Es seguro cerrarlo porque sabemos que se abrió
```

**Explicación del ejemplo:**

- Si `open('poema.txt', 'r')` falla y lanza un `OSError`, se ejecuta el `except` y el `else` se ignora por completo.
- Si `open()` tiene éxito, el `except` se ignora, y el programa salta al bloque `else` para procesar y cerrar el archivo.

**¡Paranoia Pedagógica! ¿Por qué no poner todo dentro del `try`?**

```python
# FORMA INCORRECTA (y muy común en principiantes)
try:
    archivo = open('poema.txt', 'r')
    # ¡PELIGRO! Si readlines() o len() lanzan una excepción,
    # será atrapada por el 'except OSError', ¡lo cual es incorrecto y confuso!
    print(f'Tiene {len(archivo.readlines())} líneas.')
    archivo.close()
except OSError:
    print('No se pudo abrir el archivo poema.txt')
```

El propósito del `try` es proteger **únicamente** la línea de código que te preocupa que falle (en este caso, `open()`). El `else` te da un lugar limpio y seguro para el código que debe ejecutarse solo después de que esa operación riesgosa haya tenido éxito. Así, evitas atrapar accidentalmente errores que no esperabas.

#### 3. **Desarrollo:**

El `else` fomenta un código más limpio y lógico. La regla de oro es:

- **En `try`**: Pon la menor cantidad de código posible, idealmente solo la línea o líneas que pueden lanzar la excepción que te interesa manejar.
- **En `except`**: Pon el código que maneja el error.
- **En `else`**: Pon el código que debe ejecutarse si no hubo error.

🟡 **Importante:** Usar `else` no es obligatorio, pero es una señal de código bien estructurado. Te fuerza a pensar claramente sobre qué parte de tu código es "peligrosa" y qué parte es la "consecuencia del éxito".

## H - Lanzando Excepciones (`raise`): Sonando la Alarma Manualmente 🟡

#### 1. **Introducción:**

La instrucción `raise` te permite forzar la ocurrencia de una excepción, creando una "alarma" personalizada cuando detectas una condición de error en tu código.

#### 2. **Ejemplo:**

Imagina una función que inscribe a un estudiante, pero solo si es mayor de edad.

```python
def inscribir_estudiante(nombre, edad):
    if edad < 18:
        # La condición de error se cumple, así que LANZAMOS una excepción.
        raise ValueError("El estudiante debe ser mayor de 18 años.")

    print(f"Estudiante {nombre} inscrito correctamente.")

try:
    inscribir_estudiante("Ana", 25) # Esto funcionará
    inscribir_estudiante("Luis", 16) # Esto lanzará el error
except ValueError as e:
    print(f"Error de inscripción: {e}")
```

**Salida:**

```
Estudiante Ana inscrito correctamente.
Error de inscripción: El estudiante debe ser mayor de 18 años.
```

**Explicación del ejemplo:**
La función `inscribir_estudiante` actúa como un guardia de seguridad. Revisa la edad. Si es menor de 18, considera que es una situación de error y usa `raise ValueError(...)` para detenerse y notificar el problema. El código que llamó a la función puede entonces atrapar (`except`) este `ValueError` y manejarlo.

#### 3. **Desarrollo:**

Usas `raise` cuando una situación, aunque no sea un error para Python (como una división por cero), sí lo es para la lógica de tu aplicación.

Puedes lanzar una excepción de dos formas:

1.  **`raise NombreDeLaExcepcion('mensaje')`**: Creas una nueva instancia del error con un mensaje descriptivo. Es la forma más común.
2.  **`raise NombreDeLaExcepcion`**: Una forma corta de `raise NombreDeLaExcepcion()`.

**Re-lanzar una excepción:**
A veces, quieres atrapar un error, hacer algo (como registrarlo en un log), y luego dejar que continúe "subiendo" para que otra parte del programa lo maneje. Para esto, usas `raise` sin argumentos dentro de un bloque `except`.

```python
try:
    resultado = 10 / 0
except ZeroDivisionError:
    print("¡Alerta! Intento de división por cero detectado. Registrando...")
    # Ahora lo re-lanzamos para que el programa principal se entere.
    raise
```

🟡 **Importante:** `raise` es fundamental para escribir funciones y módulos reutilizables. Permite que tus funciones comuniquen claramente los problemas a quien las usa, en lugar de fallar silenciosamente o devolver valores extraños como `None` o `-1`.

## I - Encadenamiento de Excepciones (`from`): Contando la Historia Completa del Error 🔵

#### 1. **Introducción:**

El encadenamiento de excepciones te permite vincular un error con otro, dejando claro que el segundo error fue una consecuencia directa del primero.

#### 2. **Ejemplo:**

Imagina que intentas procesar datos de una base de datos. Falla la conexión (`ConnectionError`). En lugar de solo mostrar ese error técnico, lo "envuelves" en un error más descriptivo para tu aplicación, como `RuntimeError('Fallo al procesar datos')`, pero sin perder la causa original.

```python
def procesar_datos():
    # Simulamos un fallo de conexión
    raise ConnectionError("No se pudo conectar al servidor de la base de datos")

try:
    procesar_datos()
except ConnectionError as exc:
    # Lanzamos un nuevo error, pero lo 'encadenamos' al original con 'from'
    raise RuntimeError("Fallo al procesar los datos del usuario") from exc
```

**Salida del error (lo importante es cómo Python lo muestra):**

```
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
    procesar_datos()
  File "<stdin>", line 3, in procesar_datos
ConnectionError: No se pudo conectar al servidor de la base de datos

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "<stdin>", line 5, in <module>
    raise RuntimeError("Fallo al procesar los datos del usuario") from exc
RuntimeError: Fallo al procesar los datos del usuario
```

**Explicación del ejemplo:**
El `traceback` es ahora una historia en dos partes. Primero te muestra el `ConnectionError` original. Luego, explícitamente dice: "La excepción de arriba fue la causa directa de la siguiente excepción", y te muestra el `RuntimeError` que creamos. Esto es increíblemente útil para la depuración.

#### 3. **Desarrollo:**

Hay tres escenarios con el encadenamiento:

1.  **Encadenamiento Implícito (automático):** Si lanzas una excepción dentro de un bloque `except` sin usar `from`, Python asume que el nuevo error fue causado por el que se estaba manejando y los encadena automáticamente.

2.  **Encadenamiento Explícito (`raise ... from ...`):** Como en nuestro ejemplo. Te da control total para decir "este error (`RuntimeError`) viene de este otro (`exc`)".

3.  **Desactivar Encadenamiento (`raise ... from None`):** A veces, el error original es un detalle de implementación que no quieres exponer. `from None` te permite lanzar un nuevo error ocultando completamente el anterior.

    ```python
    try:
        open('database.sqlite')
    except OSError:
        # Ocultamos el OSError y solo mostramos nuestro error genérico
        raise RuntimeError("Error de configuración en la aplicación") from None
    ```

🔵 **Específico:** El encadenamiento de excepciones es una técnica más avanzada, pero es extremadamente valiosa en aplicaciones grandes. Te ayuda a crear "capas" de manejo de errores, donde cada capa puede añadir su propio contexto sin borrar la información de las capas inferiores.

---

## J - Excepciones Definidas por el Usuario: Creando tus Propias Alarmas 🔵

#### 1. **Introducción:**

Puedes crear tus propios tipos de error para representar problemas específicos de la lógica de tu aplicación, haciendo tu código mucho más claro y fácil de entender.

#### 2. **Ejemplo:**

Imagina que estás programando un cajero automático. Python no tiene un error llamado `SaldoInsuficienteError`, ¡así que vamos a crearlo!

```python
# 1. Definimos nuestra propia clase de error.
#    Hereda de 'Exception', la madre de casi todos los errores.
class SaldoInsuficienteError(Exception):
    pass # No necesita nada más, solo existir.

# 2. Usamos nuestro error personalizado en una función.
def retirar_dinero(saldo_actual, cantidad):
    if cantidad > saldo_actual:
        # Lanzamos NUESTRO error específico.
        raise SaldoInsuficienteError(f"No puedes retirar {cantidad}, solo tienes {saldo_actual}.")

    print(f"Retiro exitoso. Saldo restante: {saldo_actual - cantidad}")

# 3. Manejamos nuestro error específico.
mi_saldo = 500
try:
    retirar_dinero(mi_saldo, 100)  # Esto funcionará.
    retirar_dinero(mi_saldo, 700)  # Esto fallará.
except SaldoInsuficienteError as e:
    print(f"¡Operación denegada! Motivo: {e}")
```

**Salida:**

```
Retiro exitoso. Saldo restante: 400
¡Operación denegada! Motivo: No puedes retirar 700, solo tienes 500.
```

**Explicación del ejemplo:**
Hemos creado una nueva categoría de error que es semánticamente perfecta para nuestro programa. Ahora, en lugar de lanzar un `ValueError` genérico, lanzamos un `SaldoInsuficienteError` que es auto-descriptivo. Cualquiera que lea `except SaldoInsuficienteError:` sabe exactamente qué tipo de problema se está manejando.

#### 3. **Desarrollo:**

Crear tus propias excepciones es una práctica excelente, especialmente cuando escribes código que otras personas usarán (o que tú mismo usarás en el futuro).

- **¿Por qué hacerlo?** Por **claridad**. Hace que tu código "hable" el lenguaje del problema que estás resolviendo (finanzas, videojuegos, ciencia de datos, etc.), no solo el lenguaje de Python.
- **¿Cómo se hace?** Simplemente crea una clase que herede de `Exception`. Por convención, los nombres de las excepciones terminan en `Error`.
- **¿Qué pueden contener?** Aunque a menudo se dejan vacías (`pass`), estas clases pueden tener sus propios métodos y atributos, igual que cualquier otra clase, para almacenar información detallada sobre el error.

🔵 **Específico:** No necesitas crear excepciones personalizadas para cada script pequeño que hagas. Pero en cuanto empieces a construir aplicaciones o bibliotecas más grandes, se convierte en una herramienta indispensable para escribir código limpio, mantenible y profesional.

## K - Acciones de Limpieza (`finally`): El Código que se Ejecuta "Pase lo que Pase" 🔴

#### 1. **Introducción:**

La cláusula `finally` define un bloque de código que se ejecutará **siempre**, sin importar si el bloque `try` tuvo éxito, si lanzó una excepción que fue manejada, o si lanzó una excepción que NO fue manejada.

#### 2. **Ejemplo:**

Usemos una función que divide números para ver `finally` en todas las situaciones posibles.

```python
def dividir(x, y):
    try:
        print("Intentando la división...")
        resultado = x / y
    except ZeroDivisionError:
        print("¡Error! División por cero.")
    else:
        print("La división fue exitosa. Resultado:", resultado)
    finally:
        # ESTO SE EJECUTA SIEMPRE.
        print("--- Bloque 'finally': La limpieza se ha completado. ---")

# Caso 1: Éxito total
print("Llamada 1:")
dividir(10, 2)

# Caso 2: Error manejado (ZeroDivisionError)
print("\nLlamada 2:")
dividir(10, 0)

# Caso 3: Error NO manejado (TypeError)
print("\nLlamada 3:")
try:
    dividir("10", "2")
except TypeError as e:
    print(f"Se atrapó un TypeError fuera de la función: {e}")
```

**Salida:**

````
Llamada 1:
Intentando la división...
La división fue exitosa. Resultado: 5.0
--- Bloque 'finally': La limpieza se ha completado. ---

Llamada 2:
Intentando la división...
¡Error! División por cero.
--- Bloque 'finally': La limpieza se ha completado. ---

Llamada 3:
Intentando la división...
--- Bloque 'finally': La limpieza se ha completado. ---
Se atrapó un TypeError fuera de la función: unsupported operand type(s) for /: 'str' and 'str'```

**Explicación del ejemplo:**
Observa cómo la línea "La limpieza se ha completado" aparece en los tres casos.
1.  **Éxito:** Se ejecuta `try`, luego `else`, y finalmente `finally`.
2.  **Error Manejado:** Se ejecuta `try` (falla), salta a `except`, y finalmente `finally`.
3.  **Error NO Manejado:** Se ejecuta `try` (falla), no hay un `except TypeError`, así que **antes de que el error detenga el programa o se propague hacia afuera**, se ejecuta el `finally`. Después, el error continúa su camino.

#### 3. **Desarrollo:**

**¡Paranoia Pedagógica! La Diferencia CRUCIAL entre `else` y `finally`:**
Esta es una fuente común de confusión. Grábatelo a fuego:
*   `else`: Se ejecuta **SÓLO SI NO HAY ERRORES** en el `try`. Es el "código de la victoria".
*   `finally`: Se ejecuta **SIEMPRE**. Es el "conserje" que limpia al final, sin importar si la fiesta fue un éxito o un desastre.

El uso más común de `finally` es para liberar recursos externos, como cerrar un archivo o una conexión de red, para asegurarte de que no queden "abiertos" consumiendo memoria, incluso si tu código falla.

🔴 **Fundamental:** `finally` te da la garantía absoluta de que un pedazo de código se ejecutará. Esta garantía es esencial para escribir programas robustos que gestionan recursos externos de manera segura.

## L - Acciones de Limpreza Predefinidas (`with`): La Forma Elegante de Limpiar 🟡

#### 1. **Introducción:**

La instrucción `with` simplifica el manejo de recursos (como archivos) al garantizar que se limpien automáticamente, haciendo que tu código sea más seguro y legible que usar `try...finally` manualmente.

#### 2. **Ejemplo:**

Compararemos la forma "antigua" (`try...finally`) con la forma moderna y elegante (`with`) para leer un archivo.

**Forma Antigua (Manual y Verbosa):**
```python
f = None # Necesitamos declararla fuera para que 'finally' la vea
try:
    f = open("mi_poema.txt", "r")
    contenido = f.read()
    print(contenido)
finally:
    # Nos aseguramos de que el archivo se cierre, incluso si 'read()' falla.
    if f:
        f.close()
````

**Forma Moderna con `with` (Automática y Limpia):**

```python
try:
    with open("mi_poema.txt", "r") as f:
        contenido = f.read()
        print(contenido)
    # ¡Y YA ESTÁ! No necesitas 'f.close()'.
    # Python lo hace por ti automáticamente al salir del bloque 'with'.
except FileNotFoundError:
    print("El poema no fue encontrado.")
```

**Explicación del ejemplo:**
Ambos códigos logran lo mismo: abrir, leer y garantizar el cierre de un archivo. Pero la versión con `with` es mucho más corta, clara y menos propensa a errores. El `with` se encarga del `try...finally` por debajo. En cuanto el bloque de código indentado bajo el `with` termina (ya sea porque se completó o por un error), Python llama automáticamente al método de "limpieza" del objeto (en este caso, `f.close()`).

#### 3. **Desarrollo:**

Piensa en `with` como un "espacio de trabajo temporal y seguro". Le dices a Python: "Voy a usar este recurso (`open(...)`) dentro de este bloque. Por favor, encárgate de limpiarlo cuando termine, sin importar cómo termine".

No todos los objetos se pueden usar con `with`. Solo aquellos que implementan un protocolo especial (llamado "protocolo de gestor de contexto"). La documentación de cualquier objeto o librería te dirá si es compatible con `with`. Los archivos, las conexiones a bases de datos y los bloqueos en programación concurrente son los ejemplos más comunes.

🟡 **Importante:** Acostúmbrate a usar `with` siempre que trabajes con recursos que necesiten ser cerrados o liberados. Es la forma "Pythónica" (idiomática y preferida) de hacerlo. Te ahorra escribir código repetitivo y te protege de olvidarte de la limpieza.

## M - Grupos de Excepciones (`ExceptionGroup`): Lanzando Varios Errores a la Vez 🔵

#### 1. **Introducción:**

Un `ExceptionGroup` es un tipo especial de error que actúa como un contenedor para agrupar y lanzar múltiples excepciones no relacionadas como si fueran una sola.

#### 2. **Ejemplo:**

Imagina que estás ejecutando varias tareas en paralelo (como descargar 3 imágenes a la vez) y varias de ellas fallan por diferentes motivos. En lugar de detenerte en el primer error, quieres completar todas las tareas y luego informar de todos los fallos juntos.

```python
def ejecutar_tareas():
    errores = [
        OSError("No se pudo escribir la imagen 1 en el disco."),
        ValueError("El formato de la imagen 2 es inválido.")
    ]
    # Si hubo errores, los agrupamos y los lanzamos todos juntos.
    if errores:
        raise ExceptionGroup("Fallaron algunas tareas de descarga", errores)

try:
    ejecutar_tareas()
except ExceptionGroup as eg:
    print(f"Se produjo un grupo de errores: {eg.message}")
    print(f"Número de errores en el grupo: {len(eg.exceptions)}")
    for error in eg.exceptions:
        print(f"  - Error individual: {error}")
```

**Salida del Traceback (lo que Python muestra):**

```
  + Exception Group Traceback (most recent call last):
  |   ...
  | ExceptionGroup: Fallaron algunas tareas de descarga (2 sub-exceptions)
  +-+---------------- 1 ----------------
    | OSError: No se pudo escribir la imagen 1 en el disco.
    +---------------- 2 ----------------
    | ValueError: El formato de la imagen 2 es inválido.
    +------------------------------------
```

**Explicación del ejemplo:**
Hemos creado una lista de errores que ocurrieron. Luego, los empaquetamos en un `ExceptionGroup` con un mensaje general. El `traceback` que Python genera es especial: te muestra el error principal (`ExceptionGroup`) y luego lista cada "sub-excepción" de forma ordenada. Nuestro bloque `except` puede entonces "desempaquetar" este grupo y analizar cada error individualmente.

#### 3. **Desarrollo:**

Esta es una característica avanzada, principalmente útil en escenarios de programación concurrente o asíncrona, donde múltiples operaciones se ejecutan de forma independiente y pueden fallar en paralelo. También es útil para validadores que necesitan reportar _todos_ los campos incorrectos de un formulario a la vez, en lugar de detenerse en el primero.

🔵 **Específico:** Como principiante, no usarás `ExceptionGroup` todos los días. Lo importante es saber que existe para esas situaciones complejas en las que necesitas manejar una colección de fallos en lugar de un único fallo que detiene todo.

## N - Manejo Parcial de Grupos (`except*`): Atrapando Solo Algunos Errores del Grupo 🔵

#### 1. **Introducción:**

La sintaxis `except*` (con un asterisco) es la compañera de `ExceptionGroup` y te permite manejar selectivamente solo ciertos tipos de errores de un grupo, dejando que los demás continúen su camino para ser manejados por otro bloque o para detener el programa.

#### 2. **Ejemplo:**

Imagina un grupo de errores con fallos de sistema (`SystemError`) y fallos de archivo (`OSError`). Queremos manejar cada tipo de forma diferente.

```python
def funcion_con_errores_variados():
    raise ExceptionGroup(
        "Grupo de errores mixtos",
        [
            OSError("Fallo de archivo 1"),
            SystemError("Fallo de sistema 1"),
            OSError("Fallo de archivo 2"),
            RecursionError("Bucle infinito detectado") # Este no lo manejaremos
        ]
    )

try:
    funcion_con_errores_variados()
except* OSError as eg: # Atrapa TODOS los OSErrors del grupo
    print(f"--- Manejando Errores de Archivo ({len(eg.exceptions)}) ---")
    for e in eg.exceptions:
        print(f"  - Solucionando: {e}")
except* SystemError as eg: # Atrapa TODOS los SystemErrors del grupo
    print(f"--- Manejando Errores de Sistema ({len(eg.exceptions)}) ---")
    for e in eg.exceptions:
        print(f"  - Reportando: {e}")

```

**Salida:**

```
--- Manejando Errores de Archivo (2) ---
  - Solucionando: Fallo de archivo 1
  - Solucionando: Fallo de archivo 2
--- Manejando Errores de Sistema (1) ---
  - Reportando: Fallo de sistema 1
  + Exception Group Traceback (most recent call last):
  |   ...
  | ExceptionGroup: Grupo de errores mixtos (1 sub-exception)
  +-+---------------- 1 ----------------
    | RecursionError: Bucle infinito detectado
    +------------------------------------
```

**Explicación del ejemplo:**
El `try` lanza un grupo con 4 errores.

1.  El `except* OSError` actúa como un filtro: "saca" los dos `OSError` del grupo y los maneja.
2.  El `except* SystemError` hace lo mismo con el único `SystemError`.
3.  El `RecursionError` no coincide con ningún `except*`, por lo que lo que queda del `ExceptionGroup` (conteniendo solo ese error) es re-lanzado y detiene el programa, como se ve en el traceback final.

#### 3. **Desarrollo:**

La diferencia clave entre `except` y `except*`:

- `except ExceptionGroup as eg:`: Atrapa el grupo **entero** como un solo objeto. La ejecución continúa después del bloque `try...except`.
- `except* SomeError as eg:`: "Extrae" del grupo todos los errores que coincidan con `SomeError`. El resto de los errores que no coincidan **son re-lanzados** en un nuevo `ExceptionGroup` más pequeño.

🔵 **Específico:** `except*` es una herramienta de precisión para trabajar con `ExceptionGroup`. Es la forma de desmantelar un paquete de errores y dar a cada tipo el tratamiento que se merece.

## O - Enriqueciendo Excepciones (`add_note`): Dejando Pistas Adicionales ⚪

#### 1. **Introducción:**

El método `.add_note()` te permite añadir cadenas de texto (notas) a una excepción _después_ de que ha sido atrapada, para enriquecerla con contexto adicional que solo conoces en el momento del manejo del error.

#### 2. **Ejemplo:**

Estamos procesando una lista de archivos en un bucle. Si uno falla, queremos saber exactamente en qué iteración ocurrió el fallo.

```python
archivos_a_procesar = ["datos1.csv", "config.json", "datos_corruptos.csv"]

for i, nombre_archivo in enumerate(archivos_a_procesar):
    try:
        if "corruptos" in nombre_archivo:
            raise ValueError("El archivo contiene datos inválidos.")
        print(f"Procesando '{nombre_archivo}'... OK.")
    except ValueError as e:
        # Atrapamos el error y le AÑADIMOS CONTEXTO.
        e.add_note(f"El error ocurrió al procesar el archivo #{i+1}: '{nombre_archivo}'")
        # Ahora lo re-lanzamos, pero enriquecido con nuestra nota.
        raise
```

**Salida del Traceback:**

```
Procesando 'datos1.csv'... OK.
Procesando 'config.json'... OK.
Traceback (most recent call last):
  File "<stdin>", line 4, in <module>
    raise ValueError("El archivo contiene datos inválidos.")
ValueError: El archivo contiene datos inválidos.
El error ocurrió al procesar el archivo #3: 'datos_corruptos.csv'
```

**Explicación del ejemplo:**
El `ValueError` original solo dice "El archivo contiene datos inválidos". ¡No es muy útil si procesas miles de archivos! Al atraparlo, usamos `e.add_note()` para añadir una pieza de información crucial: el nombre del archivo y su posición. Cuando re-lanzamos el error, el traceback ahora incluye nuestra nota, haciendo la depuración infinitamente más fácil.

#### 3. **Desarrollo:**

`add_note()` es como ser un detective que llega a la escena del crimen (el `except`) y añade etiquetas a la evidencia. Estas notas se convierten en parte del informe oficial del error (el `traceback`). Es una forma limpia de añadir información contextual sin tener que crear complejas excepciones personalizadas cada vez.

⚪ **Raramente usado (pero muy útil cuando se necesita):** No es una herramienta que usarás en cada `try...except`, pero para depurar en bucles, procesos por lotes o sistemas complejos, es una joya. Saber que existe te puede ahorrar horas de frustración.

---

### **Checklist de Completitud**

¡Lo hemos logrado! He revisado de nuevo el segundo texto que me proporcionaste y confirmo que hemos cubierto exhaustivamente todos los nuevos conceptos: la creación de excepciones personalizadas, la garantía de limpieza con `finally`, la elegancia de `with`, y las características avanzadas y modernas como `ExceptionGroup`, `except*` y `add_note`. Cada punto ha sido desglosado, ejemplificado y explicado con el máximo cuidado para que no quede ninguna duda. ¡Tu conocimiento sobre el manejo de errores en Python es ahora mucho más robusto y completo
