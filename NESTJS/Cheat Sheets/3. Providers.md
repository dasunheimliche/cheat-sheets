## A - Providers en NestJS ‚öôÔ∏èüîå

¬øAlguna vez te has preguntado c√≥mo se conectan las diferentes partes de una aplicaci√≥n? ¬°Los Providers en NestJS son los "cables" que hacen que todo funcione en armon√≠a!

#### 1. **Definicion:**

- Un provider es una clase (como servicios, repositorios, f√°bricas, etc.) que se puede "inyectar" como dependencia en otras clases, como los Controllers. Imag√≠nalos como herramientas reutilizables que permiten construir relaciones entre diferentes partes de la aplicaci√≥n.
- El contenedor de Nest se encarga de la gesti√≥n de estas dependencias. Por lo que no debes crear objetos directamente con `new MiClase()`, el frameword se encargar√°.
- Son fundamentales para organizar una app de forma "orientada a objetos". Debes guiarte por los _principios SOLID_.

#### 2. **Ejemplo:**

```typescript
import { Injectable } from "@nestjs/common";
import { Cat } from "./interfaces/cat.interface";

@Injectable()
export class CatsService {
  private readonly cats: Cat[] = [];

  create(cat: Cat) {
    this.cats.push(cat);
  }

  findAll(): Cat[] {
    return this.cats;
  }
}
```

**Explicaci√≥n del ejemplo**: La clase `CatsService` gestiona la informacion relacionada a un `Cat`, usando la etiqueta `@Injectable()`, se la notifica a NestJS que puede crear este provider y usarlo de dependencia en otros. `Cat` seria una interface de tipo (un formato) como esto:

```typescript
export interface Cat {
  name: string;
  age: number;
  breed: string;
}
```

Un Controller que utiliza este provider luce algo as√≠:

```typescript
import { Controller, Get, Post, Body } from "@nestjs/common";
import { CreateCatDto } from "./dto/create-cat.dto";
import { CatsService } from "./cats.service";
import { Cat } from "./interfaces/cat.interface";

@Controller("cats")
export class CatsController {
  constructor(private catsService: CatsService) {}

  @Post()
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto);
  }

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll();
  }
}
```

El `constructor(private catsService: CatsService)` nos ayuda a decirle a NestJS que se encargue de crear un `CatsService` como dependiencia en esta clase.

#### 3. **Utilidad:**

- Ayuda a estructurar tu aplicaci√≥n con un sistema _Dependency Injection_, en la que los m√≥dulos se coordinan (usando interfaces o abstraciones) entre ellos pero son clases indepedientes y "de-acopladas", es la mejor manera para lograr _testing_ y organizar la logica a nivel arquitectura.

## B - Inyecci√≥n de Dependencias en NestJS üíâüîÑ

¬øC√≥mo se le proporciona una herramienta al mec√°nico? En NestJS, ¬°la inyecci√≥n de dependencias es la manera en la que los Providers reciben sus dependencias!

#### 1. **Definicion:**

- Es un patron en el cual una clase recibe sus dependencias externas a trav√©s de un constructor o m√©todos. NestJS gestiona el ciclo de vida (cuando crear y cuando borrar los objetos) de forma transparente.

- NestJS utiliza el sistema de tipos de Typescript para hacer m√°s simple esta inyecci√≥n, se basa en el _type_, con lo cual solo al tipar un argumento como `MiServicio`, Nest sabra encontrar una clase con dicho tipo como proveedor en el contenedor de la aplicaci√≥n y se encargar√° de su instancia como dependencia al inicio de la aplicacion.

#### 2. **Ejemplo:**

En el ejemplo de _Providers_, ya hemos usado inyeccion de dependencia mediante el `constructor`, observa:

```typescript
import { Controller, Get, Post, Body } from "@nestjs/common";
import { CreateCatDto } from "./dto/create-cat.dto";
import { CatsService } from "./cats.service";
import { Cat } from "./interfaces/cat.interface";

@Controller("cats")
export class CatsController {
  constructor(private catsService: CatsService) {}
  // ...
}
```

**Explicaci√≥n del ejemplo**: En este c√≥digo, `CatsService` se "inyecta" en el `CatsController` a trav√©s de su constructor. Nest se encarga de la creacion de un objeto `CatsService` y pasarselo como par√°metro. De esta forma un controller que usa el servicio se desacopla y no hace un `new CatsService()`, algo que no es correcto bajo las convenciones del framework. El contenedor resuelve y lo pasa al constructor o a alguna de las propiedades, tal cual indica su definici√≥n

#### 3. **Utilidad:**

- Permite que cada clase este "libre" de c√≥mo crear sus dependencias y reciba el objeto instanciado como par√°metro del constructor, esto es muy util para escalar un sistema modular.
- Evita que clases o servicios se tengan que saber como crear "el objeto necesario", cada modulo solo se concentra en "consumir" servicios.
- Permite un mayor testeo de unidades de codigo m√°s independientes.

## C - Scopes de Providers en NestJS ‚è≥ ‚ôªÔ∏è

¬øCuanto tiempo "vive" un Provider? ¬°Los Scopes en NestJS nos indican durante cu√°nto tiempo debe existir una instancia!

#### 1. **Definicion:**

- Los Scopes (o ambitos) de los Providers determinan su tiempo de vida dentro de una aplicaci√≥n.
- La mayoria de providers tienen su scope vinculado al de la propia aplicaci√≥n, instanci√°ndose al arrancar la aplicaci√≥n y siendo destruidos al apagarse. (se crean 1 sola vez), como _singletons_ o instancias √∫nicas para toda la aplicacion
- Pero, mediante tecnicas avanzadas de Inyecci√≥n, se podria hacer un provider que viva el mismo tiempo de una request (`request scoped`) esto es cuando por algun motivo se necesita una instancia nueva en cada peticion y la informaci√≥n se "destruya" en cada peticion

#### 2. **Ejemplo:**

No hay un ejemplo de codigo para esta funcionalidad especifica en este resumen, pero el resumen ya da las instrucciones para saber de que tratan y como influyen en nuestro c√≥digo.

#### 3. **Utilidad:**

- Controlar mejor los recursos al determinar cuantos "objects" existiran de dicho servicio, de la misma manera podremos elegir un scope particular si se requiere logica diferente seg√∫n el request por alguna peculiaridad en ese √°mbito concreto.

## D - Custom Providers en NestJS ‚öôÔ∏è‚ú®

¬øNecesitas m√°s flexibilidad a la hora de configurar tus dependencias? ¬°Los Custom Providers en NestJS te permiten definir Providers con tu propia l√≥gica!

#### 1. **Definicion:**

- Permite usar no solo clases, tambien valores, o factory functions (tanto s√≠ncronas o as√≠ncronas) para la resoluci√≥n de dependencias. Permitiendonos mayor control de como y con qu√© instanciar dependencias.

- Esta funcionalidad avanza al framework ya que nos da mayor personalizaci√≥n y "afinamiento" para nuestra necesidades a la hora de resolver una dependencia, siendo una extension "mas avanzada" del framework con un valor a√±adido al sencillo ejemplo con la inyecci√≥n por clase con Typescript que vimos antes

#### 2. **Ejemplo:**

En la definici√≥n se muestra una breve mencion pero este ejemplo esta relacionado a `optional providers`:

```typescript
import { Injectable, Optional, Inject } from "@nestjs/common";

@Injectable()
export class HttpService<T> {
  constructor(@Optional() @Inject("HTTP_OPTIONS") private httpClient: T) {}
}
```

**Explicaci√≥n del ejemplo**: Se esta inyectando una opcion (`'HTTP_OPTIONS'`) como un provider personalizado y ademas la dependencia en este caso, es optional (`@Optional()`).

#### 3. **Utilidad:**

- Configurar proveedores mediante _tokens_ personalizados para ser inyectados.

  - M√°s control sobre c√≥mo se resuelven las dependencias, pudiendo incluso cambiar la l√≥gica mediante configuraciones u opciones especiales al vuelo (como opciones opcionales) para diferentes providers del sistema.
  - Util para injectar variables o valores, adem√°s de usar clases m√°s especializadas.

- Nos habilita el patron "_Factory_".

## E - Optional Providers en NestJS ü§î ‚ùì

¬øQu√© pasa si una dependencia no es obligatoria? ¬°Los Optional Providers en NestJS nos ayudan a resolver este escenario!

#### 1. **Definicion:**

- A veces las dependencias no tienen que estar siempre presentes (o existir un proveedor definido de ella) , por lo que si no existe algun provider definido, la dependencia puede asignarse a `undefined` (un valor por defecto). Por lo cual nuestro modulo, tiene el control y se asegura no quebrar por "falta de informaci√≥n".
  - La notacion `@Optional()` le da el poder a un parametro para ser _nullish_ (undefined o null).

#### 2. **Ejemplo:**

Ya lo hemos visto en Custom Providers:

```typescript
import { Injectable, Optional, Inject } from "@nestjs/common";

@Injectable()
export class HttpService<T> {
  constructor(@Optional() @Inject("HTTP_OPTIONS") private httpClient: T) {}
}
```

**Explicaci√≥n del ejemplo**: Aqu√≠, si no se proporciona un proveedor para `'HTTP_OPTIONS'`, `httpClient` ser√° `undefined`.

#### 3. **Utilidad:**

    -  Para la creaci√≥n de modulos  m√°s  *resistentes* ya que, al usar la opcionalidad como opci√≥n, evitan el colapso en tiempo de ejecucion si "algo falt√≥", esto pasa mucho con las configuraciones que se basan en valores de entorno del OS y pueden o no, ser configuradas, el *optional provider* es lo m√°s util para tener siempre un control sobre eso.

## F - Inyecci√≥n de Propiedades en NestJS ‚öôÔ∏è üîÄ

¬øConstructor demasiado complejo? ¬°La Inyecci√≥n de Propiedades en NestJS ofrece una alternativa para asignar las dependencias en clase!

#### 1. **Definicion:**

- Alternativa a la inyecci√≥n por constructor en la que una dependencia no se inyecta via parametro, sino que es asignada directamente como propiedad de clase.

- Usa la anotacion `@Inject()` para indicar una variable/propiedad en el nivel superior de la clase en donde se asignara una inyecci√≥n del contenedor de Nestjs

#### 2. **Ejemplo:**

```typescript
import { Injectable, Inject } from "@nestjs/common";

@Injectable()
export class HttpService<T> {
  @Inject("HTTP_OPTIONS")
  private readonly httpClient: T;
}
```

**Explicaci√≥n del ejemplo**: Aqui, la dependencia `'HTTP_OPTIONS'` se "inyecta" en la propiedad `httpClient`, de manera m√°s directa, y fuera de la firma del contructor. A tener en cuenta que al ser una inyeccion sobre el atributo debe tener acceso `readonly`.

#### 3. **Utilidad:**

- Muy √∫til si tu clase superior debe ser usada en _sub clases_ donde heredar un constructor _overly-verbose_ seria un incordio en cascada al llamar `super()`. Por ejemplo heredar contructores de clases con muchas dependencias

- Por lo general, debe preferirse la _constructor injection_ por claridad.
- Menos legible en comparaci√≥n con constructor, por ello en casos "estandar", ev√≠tala si puedes.

## G - Registro de Providers en NestJS üìù üß©

¬øC√≥mo le dices a Nest que quieres usar un Provider? ¬°El Registro de Providers es el paso final para hacer la conexi√≥n!

#### 1. **Definicion:**

- Para que Nest conozca tus providers, debes agregarlos al array `providers` del decorador `@Module()` de tu modulo, indicandole el lugar para que pueda gestionarlo
- Asi el provider es "reconocido" por la app al inicio

#### 2. **Ejemplo:**

```typescript
import { Module } from "@nestjs/common";
import { CatsController } from "./cats/cats.controller";
import { CatsService } from "./cats/cats.service";

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class AppModule {}
```

**Explicaci√≥n del ejemplo**: Aqu√≠ `CatsService` est√° registrado en `AppModule`, y Nest podra usarlo al instanciarlo en un componente que necesite la dependecia mediante constructor o inject properties (como los controladores que hemos visto anteriormente).

#### 3. **Utilidad:**

- Darle de "alta" el _provider_ a la aplicaci√≥n.

- Habilitar la resoluci√≥n de dependencias en la app.

## H - Instanciaci√≥n Manual en NestJS üõ†Ô∏è ‚úã

¬øQu√© pasa si necesitas crear instancias "por tu cuenta"? La Instanciaci√≥n Manual en NestJS te da esa flexibilidad para romper la regla (para casos MUY espec√≠ficos).

#### 1. **Definicion:**

- En general en Nest los componentes o servicios son "gestionados" por NestJS para que las instancias o providers est√©n desacopladas de su "consumidor" pero en algunos casos muy especiales hay ocasiones para instanciarlos a mano, fuera del sistema DI de Nest.

  - Con `Module reference` (ya en temas m√°s avanzados del framework) se permite "traer" las instancias o crear dinamicamente, fuera del "esquema" habitual de injectar en contructor o propuedades.

  - Hay metodos `boostrap` para _standalone aplications_ donde los m√≥dulos actuan en "modo server-less". En estos casos la configuracion con variables o el provider puede hacerse al incio, (fuera del flujo normal de "providers como singletons").

#### 2. **Ejemplo:**

No se han dado ejemplos especificos del c√≥digo dentro de la explicaci√≥n, la definici√≥n ha sido dada lo suficientemente claro para que sirva como explicaci√≥n con ese texto.

#### 3. **Utilidad:**

- Cuando necesitas saltarte "el sistema DI de Nest" por la particularidad de que necesitas obtener dependencias din√°micas (y no mediante contructor).

- Usos m√°s especiales del `boostrap` para apps m√°s aisladas (independientes).
