## A - Módulos en NestJS 🧩 🧱

¿Alguna vez has construido algo con bloques? ¡Los módulos en NestJS son como esos bloques, organizando y encapsulando funcionalidades!

#### 1. **Definicion:**

- Un módulo es una clase decorada con `@Module()` , un _decorador_ que tiene información o metadatos con las instrucciones para construir la _estructura de nuestra aplicacion_, por la cual el framework entiende las relaciones (las dependencias o _Dependency Injection_) entre las distintas piezas del código (o `modules` ).

- Cada aplicación tiene un módulo raíz, pero a medida que la complejidad de una app incrementa, lo normal es que los modulos definan de forma clara un area de su aplicación, esto da lugar al "feature modules" que es parte fundamental de la arquitectura. Cada module tiene providers (servicios), controllers y otros módulos dentro o exportando estos objetos (por encapsulacion), para formar las dependencias con la forma mas limpia y modular posible (SOLID).

#### 2. **Ejemplo:**

Aqui esta un modulo `CatsModule` como ejemplo

```typescript
import { Module } from "@nestjs/common";
import { CatsController } from "./cats.controller";
import { CatsService } from "./cats.service";

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}
```

Ahora se veria como usa appmodule

```typescript
import { Module } from "@nestjs/common";
import { CatsModule } from "./cats/cats.module";

@Module({
  imports: [CatsModule],
})
export class AppModule {}
```

**Explicación del ejemplo**: `CatsModule` es una pieza central de funcionalidad dentro de la app, usando el decorador `Module()` se "declara" que contendrá una lista de controllers (`controllers`), providers o services (`providers`). Y además lo importa (la pieza de "LEGO") dentro del módulo principal `AppModule` mediante la clave `imports`, para que la aplicacion lo use de esta manera. Es importante entender que los providers (el service en este ejemplo) estaran disponible solo al interior de dicho module (`CatsModule`) excepto si dicho provider (como veremos más adelante en otros casos) son `exports`.

#### 3. **Utilidad:**

- Organizar las funcionalidades en módulos, para facilitar el mantenimiento y reusabilidad del código

- Hacer uso de _DI_, _IoC_ que es la base del sistema que forma nuestra app

- Evita complicaciones al ser reutilizable el modulo por toda la aplicación (o sus parts o feature modules).
- Control del _scope_ al definir a que modulos esta acotado su providers.

## B - Módulos de Característica (Feature Modules) en NestJS 🧩 🗂️

¿Cómo agrupamos funcionalidades relacionadas en NestJS? ¡Los módulos de característica son la herramienta ideal para agrupar de forma logica el dominio de nuestra aplicacion con ayuda de modules!

#### 1. **Definicion:**

- Se encarga de agrupar por "dominios o secciones" nuestra app, al concentrar (o modularizar) logica por funciones. El concepto `cats`, `users`, o `posts`, puede convertirse en modulos, al tener servicios controllers (en comun).
- Ayuda al desarrollo modular, siguiendo los principios SOLID con un codigo más limpio y sencillo al organizar su app en base a una feature de su aplicacion o "dominio" en concreto y una "responsabilidad única" dentro del proyecto ( y que puede reutilizarse si se definen correctamente, dado el poder de encapsulacion en cada module), en resumen: _cohesion en modules y decoupling entre modules_ ( alta cohesión y bajo acoplamiento).
- En una app "ideal" siempre se usa multiples feature modules que reutilicen los core module por todos lado, esta modularidad da orden al crecimiento del app o que en _grupos de desarrollo_ con distintas features pueden desarrollar al mismo tiempo "en paralelo" (gracias al encapsulado).

#### 2. **Ejemplo:**

Ejemplo reutilizado

```typescript
import { Module } from "@nestjs/common";
import { CatsController } from "./cats.controller";
import { CatsService } from "./cats.service";

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}
```

**Explicación del ejemplo**: `CatsModule` organiza (o _encapsula_) todo lo necesario para su dominio _cats_. Tiene controladores para procesar requests y el provider (que gestiona las tareas logicas) para sus controllers (como el ejemplo `CatsService`,). Esta separación hace fácil "desconectar la logica" (service) para otras funciones en otras partes del app

#### 3. **Utilidad:**

- Separar lógicamente la funcionalidad en grupos ( o domain modules).
- Ayudar al framework con IoC con dependecias declaradas
- Mejora la mantenibilidad del proyecto y da flexibilidad a la escalabilidad al ser unidades de codigo independientes

## C - Módulos Compartidos (Shared Modules) en NestJS 🤝 📦

¿Cómo hacemos para usar un mismo Provider en varios módulos? ¡Los módulos compartidos en NestJS nos permiten reutilizar dependencias en múltiples partes de nuestra aplicación!

#### 1. **Definicion:**

- Los modulos son _singletons_, es decir por defecto solo existen 1 instancia. Un shared module expone a otro módulo (u otro modulo que usa este como _dependency_ ) una instancia "unica" ( es decir comparte ese objeto como tal, no una copia), esto ayuda mucho en tema de "administracion de estado" de un modulo por varios puntos. Es decir todos usan "el mismo servicio en la app" en sus diferentes areas

- Hay que indicar qué providers son compartidos con `exports:[  ]` dentro del `Module()` y una vez el modulo exporte providers, esta sera accessible al importarlos desde otros modules (es su API) , la lista que se muestra se considera "el API publico". De no estar ahi, quedara "aislado o encapsulado" solo a lo interno del propio módulo

- Si un servicio se instancia en dos modules independiente sin usar un shared modules o (no hacer el _export_, quedará separado), esto hara que exista 2 objetos en memoria diferentes, lo cual es bueno si realmente lo requiere (la independencia o desacoplamiento).

#### 2. **Ejemplo:**

Aqui se puede ver el mismo ejemplo con el "export"

```typescript
import { Module } from "@nestjs/common";
import { CatsController } from "./cats.controller";
import { CatsService } from "./cats.service";

@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService],
})
export class CatsModule {}
```

**Explicación del ejemplo**: Si ahora otro modulo importa el `CatsModule` podrá utilizar la instancia (única) del `CatsService`, la razón, es por que el export la hace accesible, y si se declara un constructor que usa la dependency del servicio, el mismo `CatsService` instancia sera compartida ( como singleton), como ya mencionamos si la importas de forma separada la dependencia `CatsService` o no se hace export se considera que tendrian instancias separadas de ese mismo provider o servicio

#### 3. **Utilidad:**

- Permite la reutilización de la misma instancia (en forma _Singleton_) de los _services_ o _providers_ de nuestra aplicación por otros modules
- Mantenimiento más eficaz si hay una necesidad de refactor del código, al compartir "instancias unicas", hay menos riesgos a errores al existir solo una dependencia en memoria.

- Reducir la duplicidad en codigo o _instancias_, que afectan de manera directa al uso de la RAM por la creación de varios objetos.

## D - Re-exportación de Módulos en NestJS ♻️ 📦

¿Qué pasa si quieres hacer que las dependencias de un módulo importado estén disponibles también en el módulo que las importa? ¡La re-exportación de módulos en NestJS hace que todo sea más sencillo!

#### 1. **Definicion:**

- Es cuando un módulo "exporta" otro módulo, donde no se tienen las _dependency_, si no, se usan las que el modulo reexportado _exporto_ o lo que hace disponible otro modulo
- Una pieza "en medio" al dar a entender a una api como usa otros modulos con ayuda de este (pero no para el mismo). Ej: Si un module _A_ usa otro _B_ , y el modulo _C_ quiere usar todo lo que B ofrece, _A_ re-exportando a B, permite que _C_ al usar _A_, no necesite hacer import del modulo _B_, ya lo hace a través del modulo A, ya que ese _module A_, da un alcance más global a través de ese _reexport_ del modulo _B_.
- Este feature puede servir para encapsular las implementaciones (de terceras partes), con ayuda de un reexport del module al ser un interface a una configuracion y encapsular "los detalles"

#### 2. **Ejemplo:**

Este module core, que importa a `CommonModule`, lo re-exporta.

```typescript
import { Module } from "@nestjs/common";
import { CommonModule } from "./common/common.module";

@Module({
  imports: [CommonModule],
  exports: [CommonModule],
})
export class CoreModule {}
```

**Explicación del ejemplo**: En `CoreModule` se declara la lista de `imports` ( como siempre) e incluso se puede usar en el contructor el _service/provider_ si tuviera `commonmodule`, (aunque esto no se vera, pues lo interesante esta en lo siguiente, ya que si `otroModule`, importa `CoreModule`, ahora, además de acceder al provider/service de `CoreModule`, _tambien tendrá_ acceso al provider/service de `CommonModule`, por esta característica de Nest de que se puede extender/re-exportar dependencias.

#### 3. **Utilidad:**

- Ayudar a la reusabilidad y acceso del module "transitivamente". (es decir si A->B , ahora `C`->`A`->"tiene todo lo de _B_ tambien").
- A simplificar las importaciones en la aplicación al _re-exportar_
- Organizar/ocultar modulos _de bajo nivel_ como una libreria en un único entrypoint (como en este ejemplo donde common module seria una configuracion/librería reusable) y a partir de ahi otros _re-export_ a través del module _core_.

## E - Inyección de Dependencias en Módulos en NestJS 💉 📦

¿Pueden los módulos usar otros providers? ¡Por supuesto! La inyección de dependencias en módulos te permite aprovechar dependencias ya definidas.

#### 1. **Definicion:**

- Al igual que un controller o service puede usar providers de dependencias , un módulo puede ser parte de estas jerarquias con uso normal al declarar la lista `providers` en la configuracion `@Module`, e inyectando mediante el _constructor_. En caso que fuera requerido dentro de los parámetros del contructor de cada module.
- Es importante señalar (por _limitación de diseño de Nest_) que una clase _module_ **NO** debe injectarse como un provider por un _ciclo de dependencia_. No deben considerarse como servicios en el frameword. No hay casos validos donde una module tenga a otro como dependencia
- En general la razón de la DI en un module, no es tanto por el _lifecycle_, si no, para leer una configuracion dentro del módulo, dado que si necesitas inyectar "en otros lugares un servicio", ya el _framework_ tiene un mecanismo "para registrar en la configuración y inyectarlo donde corresponda", asi como un patrón de singleton.

#### 2. **Ejemplo:**

Un example de uso.

```typescript
import { Module } from "@nestjs/common";
import { CatsController } from "./cats.controller";
import { CatsService } from "./cats.service";

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {
  constructor(private catsService: CatsService) {} //  ej de  Dependency injection
}
```

**Explicación del ejemplo**: En el ejemplo del modulo anterior la clase `CatsModule`, con la tipada `private catsService :  CatsService` dentro del contructor hace que _typescript_ sepa el type, al ser inyectada una dependecia dentro de la logica interna (usandola en este contructor). Aqui como en los ejemplos del _controller_ los _services/provider_, son singletons o al menos deben concebirse asi por la arquitectura de Node en como funcionan. No siempre hace falta en si en el `module class`, esta injection del _provider_ ya que un module es de alto nivel en la organizacion del sistema. Suele usar la injection del module con propósitos de configuracion interna. En general la forma de definir providers, lo deja como tal el decorador `Module()`.

#### 3. **Utilidad:**

- Facilita la inyección de dependencias (como providers o services), para realizar _configuracion a nivel de modulo_.

- Proporcionar una clase `module` sin _responsabilidades de servicio_ ya que esto son otros. Un module no es servicio, y a partir de eso una mejor organizacion de una app
- No sirve para inyectar modulos con un ciclo dependecia , _anular_ que se use el modulo de este manera ya que seria _una mala practica de diseno_.

## F - Módulos Globales en NestJS 🌐 🚀

¿Cómo tener providers disponibles en toda la aplicación sin tener que importar módulos en todos los sitios? ¡Los módulos globales son la solución a este "problema" ya que extiende el ámbito, con ayuda del _decorator global_ !

#### 1. **Definicion:**

- El _decorator @Global()_ extiende el alcance o scope por defecto de un `module`, haciendo sus dependencias o _providers_ a nivel GLOBAL (como los _services_ singleton, son de unico scope dentro de una app), al definirlo una vez. Por ello los que necesiten el provider de dicho módulo ya no deberán hacer el _import_ del module, si no solo inyectar _el servicio_. Es util para dependencias "fundamentales" o _helper_, en general _utils, conexiones de db, o configuraciones_. Si fuera lo "opuesto", el framework te obligaría siempre hacer el `import` (scope limitado en base al module donde se definio la dependency, sin hacer esta declaracion con @Global().
-     Se ha  de usar la propiedad `exports:[]`, como siempre,  pero, de la  dependencia (el provider/service), la diferencia al no tener esta configuración seria usar import e instanciar `Module A`->`Service A` en el contructor, con la propiedad `exports` en Module A   el contructor instanciara directo el  `Service A`. con un import normal
- Los *modulos global*es se deben registrar solo una vez por lo que normalmente solo existen un solo entry point y se haria esta _configuración con la etiqueta Global_ en el AppModule. Tener en cuenta que en muchos casos es "mejor el sistema por imports", (que son las recomendaciones en si que hacer muchos modulos con el _decorator_ de @Global().)

#### 2. **Ejemplo:**

Configurando _module cats como Global_

```typescript
import { Module, Global } from "@nestjs/common";
import { CatsController } from "./cats.controller";
import { CatsService } from "./cats.service";

@Global()
@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService],
})
export class CatsModule {}
```

**Explicación del ejemplo**: Ahora si, en un "otroModule", inyectamos en su _constructor_ la dependencia `CatsService`, Nest entenderá la dependencia de que es un servicio `global` ya no tenemos la "necesidad de hacer el import: [CatsModule] del "otroModule"", sino con el "simple hecho" de inyectar su dependencias `@Inject(CatsService)`. O tiparlo. Como podemos notar un gran beneficio en las apps mas grandes con los modulos globales (un boilerplate reducido en importations) al poder usar `inject` en el constructor de las dependencias en vez del `import`. Tener presente que los global scope afecta a todos los module , y por esta razon deben usarse de manera correcta

#### 3. **Utilidad:**

- Acceso fácil y sin import a servicios en todos los modulos con acceso en toda la app ( para utils, conex, loggins, helper , configs, etc).
- Quitar código duplicado (boilerplate) que harían innecesaria varias lineas imports (ahorro a futuro).
- Menos _dependencias anidadas o repetidas_, con codigo _limpio y claro_ (ya no usara los `import: []`), ya no hay dependencia implicita sino que los servicios ya estarán disponibles en toda app . Sin embargo en modulos más pequeños la _anotacion con `global`_ no es tan necesaria como lo puede ser en apps mas grande y complejas

## G - Módulos Dinámicos en NestJS ⚙️ 🔄

¿Quieres crear módulos configurables al inicio? ¡Los módulos dinámicos en NestJS son muy flexibles que con el _for Root_ definen como usar "la configuración del provider al iniciar la app".!

#### 1. **Definicion:**

- Se utilizan en escenarios donde queremos configuraciones o opciones personalizadas de "nuestros providers". (normalmente database providers o similares, dado que requiere configurar que bases de datos, sus credenciales, etc.) .
- A traves de un method static que es opcional llamado `forRoot()`, al ser invocada "de inicio del proyecto" permite añadir providers extra (como repositorios) de manera _dinamica_. `forRoot` , extiende/merge la configuracion declarada del `@Module`.
- El uso mas usual es el paso de configuracion del driver de base de datos. Estos pueden ir por environment variables y son diferentes en dev,prod o test, o en algunos casos con una variable del OS u otro valor concreto de entrada al sistema.
- Además este comportamiento permite también definir _providers_ usando clases factory y con otras _tecnicas avanzadas de Injection_. Incluso el `forRoot` , al poder usar async await se puede leer una configuration mediante archivos u otro tipo de _remote call_, pero siempre en inicio de la app, ( al instanciar este módulo) con la particularidad de poder extender este objeto en la propia definición del `@Module` mediante la definicion de su `forRoot()` method.

#### 2. **Ejemplo:**

Módulo dinámico:

```typescript
import { Module, DynamicModule } from "@nestjs/common";
import { createDatabaseProviders } from "./database.providers";
import { Connection } from "./connection.provider";

@Module({
  providers: [Connection],
  exports: [Connection],
})
export class DatabaseModule {
  static forRoot(entities = [], options?): DynamicModule {
    const providers = createDatabaseProviders(options, entities);
    return {
      module: DatabaseModule,
      providers: providers,
      exports: providers,
    };
  }
}
```

Uso en la app:

```typescript
import { Module } from "@nestjs/common";
import { DatabaseModule } from "./database/database.module";
import { User } from "./users/entities/user.entity";

@Module({
  imports: [DatabaseModule.forRoot([User])],
})
export class AppModule {}
```

**Explicación del ejemplo**: `DatabaseModule` , de manera "normal", tiene definida el _provider `Connection`_ a traves del decorador `Module()`. Usando el method estatico (y opcional en caso de tener la funcion de config del provider _ dinámico_) , al definir la configuración o `providers` (dinámicos). , esta funcion con el patron `forRoot` expone como extender la config del provider (`options`,`entities`). Y se usa la _importación de `forRoot` de DatabaseModule (extendiendo a partir del objeto de los argumentos )_ en AppModule en forma de un _module instance_. La caracteristica especial es la configuración del `createDatabaseProviders` , que podria venir por valores, con archivos, enviroment o un endpoint para el obtener esa informacion

#### 3. **Utilidad:**

- Poder _configurar de inicio_ los providers, al momento que se crea la aplicacion
- Usar _patterns advanced injection_ mediante factorie e inyectar la configuration a lo providers o services de los modulos.
- Adaptar y ser mucho mas flexible a cada entorno con `options`, ya que "todo está en JS o TS" (e instanciacion desde un static method como _forRoot_) en el inicio de una aplicacion mediante imports del modulo
- Configuración de acceso a DB con distintas configuraciones.
