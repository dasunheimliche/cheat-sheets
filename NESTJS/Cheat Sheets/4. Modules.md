## A - M√≥dulos en NestJS üß© üß±

¬øAlguna vez has construido algo con bloques? ¬°Los m√≥dulos en NestJS son como esos bloques, organizando y encapsulando funcionalidades!

#### 1. **Definicion:**

- Un m√≥dulo es una clase decorada con `@Module()` , un _decorador_ que tiene informaci√≥n o metadatos con las instrucciones para construir la _estructura de nuestra aplicacion_, por la cual el framework entiende las relaciones (las dependencias o _Dependency Injection_) entre las distintas piezas del c√≥digo (o `modules` ).

- Cada aplicaci√≥n tiene un m√≥dulo ra√≠z, pero a medida que la complejidad de una app incrementa, lo normal es que los modulos definan de forma clara un area de su aplicaci√≥n, esto da lugar al "feature modules" que es parte fundamental de la arquitectura. Cada module tiene providers (servicios), controllers y otros m√≥dulos dentro o exportando estos objetos (por encapsulacion), para formar las dependencias con la forma mas limpia y modular posible (SOLID).

#### 2. **Ejemplo:**

Aqui esta un modulo `CatsModule` como ejemplo

```typescript
import { Module } from "@nestjs/common";
import { CatsController } from "./cats.controller";
import { CatsService } from "./cats.service";

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}
```

Ahora se veria como usa appmodule

```typescript
import { Module } from "@nestjs/common";
import { CatsModule } from "./cats/cats.module";

@Module({
  imports: [CatsModule],
})
export class AppModule {}
```

**Explicaci√≥n del ejemplo**: `CatsModule` es una pieza central de funcionalidad dentro de la app, usando el decorador `Module()` se "declara" que contendr√° una lista de controllers (`controllers`), providers o services (`providers`). Y adem√°s lo importa (la pieza de "LEGO") dentro del m√≥dulo principal `AppModule` mediante la clave `imports`, para que la aplicacion lo use de esta manera. Es importante entender que los providers (el service en este ejemplo) estaran disponible solo al interior de dicho module (`CatsModule`) excepto si dicho provider (como veremos m√°s adelante en otros casos) son `exports`.

#### 3. **Utilidad:**

- Organizar las funcionalidades en m√≥dulos, para facilitar el mantenimiento y reusabilidad del c√≥digo

- Hacer uso de _DI_, _IoC_ que es la base del sistema que forma nuestra app

- Evita complicaciones al ser reutilizable el modulo por toda la aplicaci√≥n (o sus parts o feature modules).
- Control del _scope_ al definir a que modulos esta acotado su providers.

## B - M√≥dulos de Caracter√≠stica (Feature Modules) en NestJS üß© üóÇÔ∏è

¬øC√≥mo agrupamos funcionalidades relacionadas en NestJS? ¬°Los m√≥dulos de caracter√≠stica son la herramienta ideal para agrupar de forma logica el dominio de nuestra aplicacion con ayuda de modules!

#### 1. **Definicion:**

- Se encarga de agrupar por "dominios o secciones" nuestra app, al concentrar (o modularizar) logica por funciones. El concepto `cats`, `users`, o `posts`, puede convertirse en modulos, al tener servicios controllers (en comun).
- Ayuda al desarrollo modular, siguiendo los principios SOLID con un codigo m√°s limpio y sencillo al organizar su app en base a una feature de su aplicacion o "dominio" en concreto y una "responsabilidad √∫nica" dentro del proyecto ( y que puede reutilizarse si se definen correctamente, dado el poder de encapsulacion en cada module), en resumen: _cohesion en modules y decoupling entre modules_ ( alta cohesi√≥n y bajo acoplamiento).
- En una app "ideal" siempre se usa multiples feature modules que reutilicen los core module por todos lado, esta modularidad da orden al crecimiento del app o que en _grupos de desarrollo_ con distintas features pueden desarrollar al mismo tiempo "en paralelo" (gracias al encapsulado).

#### 2. **Ejemplo:**

Ejemplo reutilizado

```typescript
import { Module } from "@nestjs/common";
import { CatsController } from "./cats.controller";
import { CatsService } from "./cats.service";

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}
```

**Explicaci√≥n del ejemplo**: `CatsModule` organiza (o _encapsula_) todo lo necesario para su dominio _cats_. Tiene controladores para procesar requests y el provider (que gestiona las tareas logicas) para sus controllers (como el ejemplo `CatsService`,). Esta separaci√≥n hace f√°cil "desconectar la logica" (service) para otras funciones en otras partes del app

#### 3. **Utilidad:**

- Separar l√≥gicamente la funcionalidad en grupos ( o domain modules).
- Ayudar al framework con IoC con dependecias declaradas
- Mejora la mantenibilidad del proyecto y da flexibilidad a la escalabilidad al ser unidades de codigo independientes

## C - M√≥dulos Compartidos (Shared Modules) en NestJS ü§ù üì¶

¬øC√≥mo hacemos para usar un mismo Provider en varios m√≥dulos? ¬°Los m√≥dulos compartidos en NestJS nos permiten reutilizar dependencias en m√∫ltiples partes de nuestra aplicaci√≥n!

#### 1. **Definicion:**

- Los modulos son _singletons_, es decir por defecto solo existen 1 instancia. Un shared module expone a otro m√≥dulo (u otro modulo que usa este como _dependency_ ) una instancia "unica" ( es decir comparte ese objeto como tal, no una copia), esto ayuda mucho en tema de "administracion de estado" de un modulo por varios puntos. Es decir todos usan "el mismo servicio en la app" en sus diferentes areas

- Hay que indicar qu√© providers son compartidos con `exports:[  ]` dentro del `Module()` y una vez el modulo exporte providers, esta sera accessible al importarlos desde otros modules (es su API) , la lista que se muestra se considera "el API publico". De no estar ahi, quedara "aislado o encapsulado" solo a lo interno del propio m√≥dulo

- Si un servicio se instancia en dos modules independiente sin usar un shared modules o (no hacer el _export_, quedar√° separado), esto hara que exista 2 objetos en memoria diferentes, lo cual es bueno si realmente lo requiere (la independencia o desacoplamiento).

#### 2. **Ejemplo:**

Aqui se puede ver el mismo ejemplo con el "export"

```typescript
import { Module } from "@nestjs/common";
import { CatsController } from "./cats.controller";
import { CatsService } from "./cats.service";

@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService],
})
export class CatsModule {}
```

**Explicaci√≥n del ejemplo**: Si ahora otro modulo importa el `CatsModule` podr√° utilizar la instancia (√∫nica) del `CatsService`, la raz√≥n, es por que el export la hace accesible, y si se declara un constructor que usa la dependency del servicio, el mismo `CatsService` instancia sera compartida ( como singleton), como ya mencionamos si la importas de forma separada la dependencia `CatsService` o no se hace export se considera que tendrian instancias separadas de ese mismo provider o servicio

#### 3. **Utilidad:**

- Permite la reutilizaci√≥n de la misma instancia (en forma _Singleton_) de los _services_ o _providers_ de nuestra aplicaci√≥n por otros modules
- Mantenimiento m√°s eficaz si hay una necesidad de refactor del c√≥digo, al compartir "instancias unicas", hay menos riesgos a errores al existir solo una dependencia en memoria.

- Reducir la duplicidad en codigo o _instancias_, que afectan de manera directa al uso de la RAM por la creaci√≥n de varios objetos.

## D - Re-exportaci√≥n de M√≥dulos en NestJS ‚ôªÔ∏è üì¶

¬øQu√© pasa si quieres hacer que las dependencias de un m√≥dulo importado est√©n disponibles tambi√©n en el m√≥dulo que las importa? ¬°La re-exportaci√≥n de m√≥dulos en NestJS hace que todo sea m√°s sencillo!

#### 1. **Definicion:**

- Es cuando un m√≥dulo "exporta" otro m√≥dulo, donde no se tienen las _dependency_, si no, se usan las que el modulo reexportado _exporto_ o lo que hace disponible otro modulo
- Una pieza "en medio" al dar a entender a una api como usa otros modulos con ayuda de este (pero no para el mismo). Ej: Si un module _A_ usa otro _B_ , y el modulo _C_ quiere usar todo lo que B ofrece, _A_ re-exportando a B, permite que _C_ al usar _A_, no necesite hacer import del modulo _B_, ya lo hace a trav√©s del modulo A, ya que ese _module A_, da un alcance m√°s global a trav√©s de ese _reexport_ del modulo _B_.
- Este feature puede servir para encapsular las implementaciones (de terceras partes), con ayuda de un reexport del module al ser un interface a una configuracion y encapsular "los detalles"

#### 2. **Ejemplo:**

Este module core, que importa a `CommonModule`, lo re-exporta.

```typescript
import { Module } from "@nestjs/common";
import { CommonModule } from "./common/common.module";

@Module({
  imports: [CommonModule],
  exports: [CommonModule],
})
export class CoreModule {}
```

**Explicaci√≥n del ejemplo**: En `CoreModule` se declara la lista de `imports` ( como siempre) e incluso se puede usar en el contructor el _service/provider_ si tuviera `commonmodule`, (aunque esto no se vera, pues lo interesante esta en lo siguiente, ya que si `otroModule`, importa `CoreModule`, ahora, adem√°s de acceder al provider/service de `CoreModule`, _tambien tendr√°_ acceso al provider/service de `CommonModule`, por esta caracter√≠stica de Nest de que se puede extender/re-exportar dependencias.

#### 3. **Utilidad:**

- Ayudar a la reusabilidad y acceso del module "transitivamente". (es decir si A->B , ahora `C`->`A`->"tiene todo lo de _B_ tambien").
- A simplificar las importaciones en la aplicaci√≥n al _re-exportar_
- Organizar/ocultar modulos _de bajo nivel_ como una libreria en un √∫nico entrypoint (como en este ejemplo donde common module seria una configuracion/librer√≠a reusable) y a partir de ahi otros _re-export_ a trav√©s del module _core_.

## E - Inyecci√≥n de Dependencias en M√≥dulos en NestJS üíâ üì¶

¬øPueden los m√≥dulos usar otros providers? ¬°Por supuesto! La inyecci√≥n de dependencias en m√≥dulos te permite aprovechar dependencias ya definidas.

#### 1. **Definicion:**

- Al igual que un controller o service puede usar providers de dependencias , un m√≥dulo puede ser parte de estas jerarquias con uso normal al declarar la lista `providers` en la configuracion `@Module`, e inyectando mediante el _constructor_. En caso que fuera requerido dentro de los par√°metros del contructor de cada module.
- Es importante se√±alar (por _limitaci√≥n de dise√±o de Nest_) que una clase _module_ **NO** debe injectarse como un provider por un _ciclo de dependencia_. No deben considerarse como servicios en el frameword. No hay casos validos donde una module tenga a otro como dependencia
- En general la raz√≥n de la DI en un module, no es tanto por el _lifecycle_, si no, para leer una configuracion dentro del m√≥dulo, dado que si necesitas inyectar "en otros lugares un servicio", ya el _framework_ tiene un mecanismo "para registrar en la configuraci√≥n y inyectarlo donde corresponda", asi como un patr√≥n de singleton.

#### 2. **Ejemplo:**

Un example de uso.

```typescript
import { Module } from "@nestjs/common";
import { CatsController } from "./cats.controller";
import { CatsService } from "./cats.service";

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {
  constructor(private catsService: CatsService) {} //  ej de  Dependency injection
}
```

**Explicaci√≥n del ejemplo**: En el ejemplo del modulo anterior la clase `CatsModule`, con la tipada `private catsService :  CatsService` dentro del contructor hace que _typescript_ sepa el type, al ser inyectada una dependecia dentro de la logica interna (usandola en este contructor). Aqui como en los ejemplos del _controller_ los _services/provider_, son singletons o al menos deben concebirse asi por la arquitectura de Node en como funcionan. No siempre hace falta en si en el `module class`, esta injection del _provider_ ya que un module es de alto nivel en la organizacion del sistema. Suele usar la injection del module con prop√≥sitos de configuracion interna. En general la forma de definir providers, lo deja como tal el decorador `Module()`.

#### 3. **Utilidad:**

- Facilita la inyecci√≥n de dependencias (como providers o services), para realizar _configuracion a nivel de modulo_.

- Proporcionar una clase `module` sin _responsabilidades de servicio_ ya que esto son otros. Un module no es servicio, y a partir de eso una mejor organizacion de una app
- No sirve para inyectar modulos con un ciclo dependecia , _anular_ que se use el modulo de este manera ya que seria _una mala practica de diseno_.

## F - M√≥dulos Globales en NestJS üåê üöÄ

¬øC√≥mo tener providers disponibles en toda la aplicaci√≥n sin tener que importar m√≥dulos en todos los sitios? ¬°Los m√≥dulos globales son la soluci√≥n a este "problema" ya que extiende el √°mbito, con ayuda del _decorator global_ !

#### 1. **Definicion:**

- El _decorator @Global()_ extiende el alcance o scope por defecto de un `module`, haciendo sus dependencias o _providers_ a nivel GLOBAL (como los _services_ singleton, son de unico scope dentro de una app), al definirlo una vez. Por ello los que necesiten el provider de dicho m√≥dulo ya no deber√°n hacer el _import_ del module, si no solo inyectar _el servicio_. Es util para dependencias "fundamentales" o _helper_, en general _utils, conexiones de db, o configuraciones_. Si fuera lo "opuesto", el framework te obligar√≠a siempre hacer el `import` (scope limitado en base al module donde se definio la dependency, sin hacer esta declaracion con @Global().
-     Se ha  de usar la propiedad `exports:[]`, como siempre,  pero, de la  dependencia (el provider/service), la diferencia al no tener esta configuraci√≥n seria usar import e instanciar `Module A`->`Service A` en el contructor, con la propiedad `exports` en Module A   el contructor instanciara directo el  `Service A`. con un import normal
- Los *modulos global*es se deben registrar solo una vez por lo que normalmente solo existen un solo entry point y se haria esta _configuraci√≥n con la etiqueta Global_ en el AppModule. Tener en cuenta que en muchos casos es "mejor el sistema por imports", (que son las recomendaciones en si que hacer muchos modulos con el _decorator_ de @Global().)

#### 2. **Ejemplo:**

Configurando _module cats como Global_

```typescript
import { Module, Global } from "@nestjs/common";
import { CatsController } from "./cats.controller";
import { CatsService } from "./cats.service";

@Global()
@Module({
  controllers: [CatsController],
  providers: [CatsService],
  exports: [CatsService],
})
export class CatsModule {}
```

**Explicaci√≥n del ejemplo**: Ahora si, en un "otroModule", inyectamos en su _constructor_ la dependencia `CatsService`, Nest entender√° la dependencia de que es un servicio `global` ya no tenemos la "necesidad de hacer el import: [CatsModule] del "otroModule"", sino con el "simple hecho" de inyectar su dependencias `@Inject(CatsService)`. O tiparlo. Como podemos notar un gran beneficio en las apps mas grandes con los modulos globales (un boilerplate reducido en importations) al poder usar `inject` en el constructor de las dependencias en vez del `import`. Tener presente que los global scope afecta a todos los module , y por esta razon deben usarse de manera correcta

#### 3. **Utilidad:**

- Acceso f√°cil y sin import a servicios en todos los modulos con acceso en toda la app ( para utils, conex, loggins, helper , configs, etc).
- Quitar c√≥digo duplicado (boilerplate) que har√≠an innecesaria varias lineas imports (ahorro a futuro).
- Menos _dependencias anidadas o repetidas_, con codigo _limpio y claro_ (ya no usara los `import: []`), ya no hay dependencia implicita sino que los servicios ya estar√°n disponibles en toda app . Sin embargo en modulos m√°s peque√±os la _anotacion con `global`_ no es tan necesaria como lo puede ser en apps mas grande y complejas

## G - M√≥dulos Din√°micos en NestJS ‚öôÔ∏è üîÑ

¬øQuieres crear m√≥dulos configurables al inicio? ¬°Los m√≥dulos din√°micos en NestJS son muy flexibles que con el _for Root_ definen como usar "la configuraci√≥n del provider al iniciar la app".!

#### 1. **Definicion:**

- Se utilizan en escenarios donde queremos configuraciones o opciones personalizadas de "nuestros providers". (normalmente database providers o similares, dado que requiere configurar que bases de datos, sus credenciales, etc.) .
- A traves de un method static que es opcional llamado `forRoot()`, al ser invocada "de inicio del proyecto" permite a√±adir providers extra (como repositorios) de manera _dinamica_. `forRoot` , extiende/merge la configuracion declarada del `@Module`.
- El uso mas usual es el paso de configuracion del driver de base de datos. Estos pueden ir por environment variables y son diferentes en dev,prod o test, o en algunos casos con una variable del OS u otro valor concreto de entrada al sistema.
- Adem√°s este comportamiento permite tambi√©n definir _providers_ usando clases factory y con otras _tecnicas avanzadas de Injection_. Incluso el `forRoot` , al poder usar async await se puede leer una configuration mediante archivos u otro tipo de _remote call_, pero siempre en inicio de la app, ( al instanciar este m√≥dulo) con la particularidad de poder extender este objeto en la propia definici√≥n del `@Module` mediante la definicion de su `forRoot()` method.

#### 2. **Ejemplo:**

M√≥dulo din√°mico:

```typescript
import { Module, DynamicModule } from "@nestjs/common";
import { createDatabaseProviders } from "./database.providers";
import { Connection } from "./connection.provider";

@Module({
  providers: [Connection],
  exports: [Connection],
})
export class DatabaseModule {
  static forRoot(entities = [], options?): DynamicModule {
    const providers = createDatabaseProviders(options, entities);
    return {
      module: DatabaseModule,
      providers: providers,
      exports: providers,
    };
  }
}
```

Uso en la app:

```typescript
import { Module } from "@nestjs/common";
import { DatabaseModule } from "./database/database.module";
import { User } from "./users/entities/user.entity";

@Module({
  imports: [DatabaseModule.forRoot([User])],
})
export class AppModule {}
```

**Explicaci√≥n del ejemplo**: `DatabaseModule` , de manera "normal", tiene definida el _provider `Connection`_ a traves del decorador `Module()`. Usando el method estatico (y opcional en caso de tener la funcion de config del provider _ din√°mico_) , al definir la configuraci√≥n o `providers` (din√°micos). , esta funcion con el patron `forRoot` expone como extender la config del provider (`options`,`entities`). Y se usa la _importaci√≥n de `forRoot` de DatabaseModule (extendiendo a partir del objeto de los argumentos )_ en AppModule en forma de un _module instance_. La caracteristica especial es la configuraci√≥n del `createDatabaseProviders` , que podria venir por valores, con archivos, enviroment o un endpoint para el obtener esa informacion

#### 3. **Utilidad:**

- Poder _configurar de inicio_ los providers, al momento que se crea la aplicacion
- Usar _patterns advanced injection_ mediante factorie e inyectar la configuration a lo providers o services de los modulos.
- Adaptar y ser mucho mas flexible a cada entorno con `options`, ya que "todo est√° en JS o TS" (e instanciacion desde un static method como _forRoot_) en el inicio de una aplicacion mediante imports del modulo
- Configuraci√≥n de acceso a DB con distintas configuraciones.
