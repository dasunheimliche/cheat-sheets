## A - Controllers en NestJS üö¶ üì§

¬øAlguna vez te has preguntado c√≥mo una aplicaci√≥n web recibe y procesa tus peticiones? ¬°Los Controllers en NestJS son los encargados de esa labor, recibiendo las _requests_ y dando las _responses_ al cliente!

#### 1. **Definicion:**

- Son clases con metadatos que gestionan las peticiones del cliente (requests) para realizar acciones especificas, devolviendo las respuestas adecuadas (response). Imag√≠nalos como el "cerebro" de cada ruta en tu aplicaci√≥n.
- Se definen utilizando decoradores, que conectan rutas HTTP (URL's) con m√©todos concretos que son sus gestores, as√≠ se enruta la peticion. Adem√°s son clases reutilizables que pueden inyectar (Dependency Injection) los Providers, donde hay l√≥gica reusable que esta conectada.
- Suele ser normal que cada Controller tenga m√∫ltiples rutas o acciones asociadas (o "endpoints").

#### 2. **Ejemplo:**

```typescript
import { Controller, Get } from "@nestjs/common";

@Controller("cats")
export class CatsController {
  @Get()
  findAll(): string {
    return "This action returns all cats";
  }
}
```

**Explicaci√≥n del ejemplo**: Este ejemplo muestra un controller llamado `CatsController`, escucha rutas que empiecen por `cats` (`@Controller('cats')`) y tiene un manejador, la funcion `findAll()` con `@Get()` para capturar requests de tipo GET, de manera que al realizar una request a `GET /cats` se llamara al m√©todo. El resultado en este caso seria simplemente un `string`.

#### 3. **Utilidad:**

- Dirige el flujo de la aplicaci√≥n y es el punto de acceso para "los datos de entrada del exterior".
- A partir de la respuesta de la ruta (o "endopoint") los Controllers generan una salida del resultado, que la aplicacion cliente deberia de poder consumir, normalmente JSON.

## B - Routing en NestJS üõ£Ô∏è üìç

¬øC√≥mo sabe Nest qu√© Controlador usar? ¬°El Routing es el sistema que dirige cada solicitud al lugar correcto!

#### 1. **Definicion:**

- Es el mecanismo de asignaci√≥n entre un _endpoint_ de una url (es decir, una ruta o `path`) y la funci√≥n que ejecutar√°, por ejemplo los controllers y las acciones (los m√©todos de clase).

- Al usar decoradores como `@Controller()` y `@Get()`, `@Post()`, etc., el framework conoce las "instrucciones" de c√≥mo mapear una ruta a un controlador y su m√©todo espec√≠fico (llamado `handler` en el texto). El controlador no tiene relevancia (para Nest) por su nombre, solo su metadatos (`@Controller` y los decoradores tipo `@Get`,`@Post`,`@Put`,etc) de los m√©todos le interesan para la construccion de rutas.

- Es posible usar comodines, por ejemplo `ab*cd`, para el registro de la ruta (los _wildcards_, o _path patterns_, soportados var√≠an segun el framework, ver express/fastify). El "orden" de las rutas (para prevenir conflictos, o superposici√≥n) tambien puede tener efecto si existen diferentes registros (es m√°s logico definir `cats/:id` despues de `cats/all`).

#### 2. **Ejemplo:**

En el ejemplo de Controllers, ya vimos lo esencial:

```typescript
import { Controller, Get } from "@nestjs/common";

@Controller("cats")
export class CatsController {
  @Get()
  findAll(): string {
    return "This action returns all cats";
  }
}
```

**Explicaci√≥n del ejemplo**: El `@Controller('cats')` es el "prefix" de la ruta (`/cats`), y el `@Get()` del `findAll()` en este ejemplo define la "concatenaci√≥n" entre los dos, siendo en definitiva `/cats` , el mapeo total de la ruta a un metodo de clase. Se puede ver que es opcional incluir el prefix en la anotacion del controller. Un ejemplo con ruta con parametro `GET  /cats/:id`, con el _handler_ `findOne`

```typescript
import { Controller, Get, Param } from "@nestjs/common";

@Controller("cats")
export class CatsController {
  @Get(":id")
  findOne(@Param("id") id: string) {
    return `This action returns a #${id} cat`;
  }
}
```

#### 3. **Utilidad:**

- Asignar a cada ruta el "handler" m√°s apropiado, para delegar el control de esa ruta, dando asi mayor organizaci√≥n y robustez a nuestra aplicaci√≥n.
- Gestionar paths en forma din√°mica y configurable mediante el uso de path variables con `:id`, etc.

## C - Response en NestJS üì§ üîÑ

¬øQu√© sucede despu√©s de procesar una solicitud? ¬°El Response en NestJS es c√≥mo enviamos la informaci√≥n al cliente!

#### 1. **Definicion:**

- Nest permite 2 formas para generar la respuesta que el usuario obtendr√° tras un request: **standard** y **library specific**.
- El modo _Standard_ o por defecto (la forma que te recomiendan usar) permite manipular las responses con mayor control por parte de Nest, este serializar√° la salida a JSON de manera _autom√°tica_, si es un objeto o array. Sin embargo un primitivo tipo string,number, boolean sera enviado sin transformacion alguna. (sin JSON serialize)
- Para configurar headers o cualquier otra necesidad, tambien existe el uso del Response object (`@Res()`) propio del framework web en el que esta basada NestJS (Express por defecto). En este ultimo caso Nest detectar√° este cambio al modo library specific e ignorara la via de configuraci√≥n _standard_ si esta "coexiste" en el mismo handler (hay que configurar la opci√≥n passthrough a `true`, para que use standard a pesar de esto). En resumen es "todo o nada".

#### 2. **Ejemplo:**

**Standard (por defecto)**
```typescript
import { Controller, Get } from '@nestjs/common';

    @Controller('cats')
    export class CatsController {
    @Get()
    findAll(): string {
    return 'This action returns all cats'; // el valor string
    }

     @Get('/array')
      getArray(){
        return [{name:"miau"}]; // la devolucion a json
       }
     }

    ```

**Library-Specific (@Res())**

    ```typescript

import { Controller, Get, Post, Res, HttpStatus } from '@nestjs/common';
import { Response } from 'express';

@Controller('cats')
export class CatsController {
@Get()
findAll(@Res() res: Response) {
return res.status(HttpStatus.OK).json([]); // ejemplo de serializacion manual a json, y envio de status
}
}

````
**Explicaci√≥n del ejemplo**: En el primer ejemplo de response standar al retornar  la cadena  de  `This action returns all cats`   sera usada como valor  de salida sin cambios, el   segundo, el `getArray`, se  convetira a JSON  `[{name: "miau"}]`, usando la ruta `/cats/array`.   En  library specific , podemos hacer  uso explicito de las APIs, por  ejemplo la api `json()` de `res`,  con la opcion  statuscode usando `status` ( y tambien  `send()`,`redirect()`,`header()`, etc) y obtener mayor control. Se tiene que tener muy en cuenta que al utilizar  la libreria (express), tenemos menos gestion automatica de NestJS.

#### 3. **Utilidad:**
-  Retornar  data  al cliente usando las diferentes  vias que nos provee el framework (status codes, headers, redirecciones, cuerpo de response...).

- Dar respuesta de la informacion procesada o algun error, usando el  tipo adecuado, siempre de manera lo mas consistente posible (con los estandares rest json, por lo general).
-    Tener un mayor control del resultado de  salida usando APIs espec√≠ficas de `express.res`.

## D - Request Object en NestJS üì• üéÅ

¬øQu√© datos acompa√±an a cada solicitud del cliente? ¬°El Request Object en NestJS es donde encontrar√°s todos esos detalles!

#### 1. **Definicion:**

 - Representa la informaci√≥n asociada a cada  request entrante en formato HTTP, y por lo general en express (el adaptador que  tiene por defecto) representa `express.request` , lo  cual significa:  query parameters (atributos pasados por la URL ej: `?nombre=miau`), url  parameters ( como en `/users/:id` donde `:id` es url param) ,  headers, cookies, etc.

 - Podemos extraer del *request* (el nombre gen√©rico) , usando la notacion `@Req() request: Request`, (el  *request type* es opcional, pero facilita entender el type), tambi√©n tiene helpers por separado, en  `@Query(),  @Param(), @Body(), @Headers()`, etc.

 -  `@Res()`  es  la opcion al request equivalente en la Response (`express.Response`), por lo tanto debe usar typings propias de ese framework, asi  como estar muy pendientes al *library-specific mode*, antes explicado (al ser una inyecci√≥n a una API diferente de  la "core" del Nest framework)
#### 2. **Ejemplo:**

Ejemplo con *request* tradicional.
```typescript
import { Controller, Get, Req } from '@nestjs/common';
import { Request } from 'express';

@Controller('cats')
export class CatsController {
  @Get()
  findAll(@Req() request: Request): string {
    console.log(request.query);
    return 'This action returns all cats';
  }
}
````

Uso con la notacion simplificada `Body()`

```typescript
import { Controller, Post, Body } from "@nestjs/common";
import { CreateCatDto } from "./dto/create-cat.dto";

@Controller("cats")
export class CatsController {
  @Post()
  async create(@Body() createCatDto: CreateCatDto) {
    console.log(createCatDto);
    return "This action adds a new cat";
  }
}
```

**Explicaci√≥n del ejemplo**: Usando `@Req()` le estamos pidiendo a nest que pase el _objeto request de express_, para examinar por ej. sus _query parameters_, pero tambien seria posible leer otras propiedades como headers, parametros del body, o de la ruta (ej `req.param.id`), los datos POST/PUT normalmente van en `req.body`. Para tener ayuda de tipado (de los type de express) hay que instalar la libreria de `@types/express`, lo que indica un dependencia del proyecto a un API en concreto (una mala pr√°ctica seg√∫n Nest) dado que una app debe poder portarse a cualquier framework que sirva de plataforma base en cualquier otro momento en el futuro. Por ejemplo si tenemos el DTO como esto

```typescript
export class CreateCatDto {
  name: string;
  age: number;
  breed: string;
}
```

La request POST recibida pasar√° (si el validador est√° correctamente configurado, tal como indica el framework) al `createCatDto` como una instancia del DTO si se han configurado las propiedades correctas. La idea es simplificar lectura de atributos mediante estos "helpers" para leer parametros concretos (y validarlos mediante _pipes_ tal como indica en otro cap√≠tulo el framework), para evitar acceder directamente al "objeto request gen√©rico" (por ejemplo con el cuerpo mediante `@Body()` y los query strings con `@Query()`), que por cierto tambi√©n pueden aceptar "subatributos", ejemplo `@Query('limit')`, de tipo string (`?limit=10`) lo retornaria en forma string `const limit=10`.

#### 3. **Utilidad:**

- Acceder a informaci√≥n enviada desde cliente para operar en la l√≥gica del Controller.

- Facilitar el acceso a determinados campos espec√≠ficos del request (body,query parameters) en formato ya "listo para usar".

- Permite un mayor desacoplamiento, dado que estos objetos no se crear mediante instancia en la aplicacion, por ejemplo con la construccion por `new Request()`.

## E - Resources en NestJS üóÇÔ∏è üîó

¬øC√≥mo organizamos las acciones sobre una misma entidad en nuestra app? ¬°Los Resources en NestJS son la forma est√°ndar de hacerlo, definiendo _CRUD_!

#### 1. **Definicion:**

- Un Resource en Nest es una agrupaci√≥n logica en torno a una entidad o elemento de nuestra app que debemos gestionar (ej. _Cat, User, Post_, etc). Que en REST define como estandar la operaciones b√°sicas del CRUD (Crear,Leer,Modificar,Borrar), donde es comun encontrar diferentes "rutas" en un controller como por ejemplo `GET  /cats`, `GET /cats/:id`, `PUT /cats/:id`,`DELETE  /cats/:id`,`POST  /cats` . Cada ruta un tipo especifico, y accion ( o endpoint).

- Por norma, existe un metodo del controller por cada una de estas "acciones":
- `@Get() findOne` para el `/cats/:id`.
- `@Post() create` para el `/cats`.
- `@Get() findAll` para el `/cats`.
- `@Put(':id') update` para el `/cats/:id`.
- `@Delete(':id') remove` para el `/cats/:id`.

- Por lo general la entrada o body, de la request PUT/POST deberia seguir la forma del `DTO` (Data transfer Object), mediante Typescript para poder controlar y usar una correcta _validaci√≥n_ del tipo.

#### 2. **Ejemplo:**

Aqu√≠ se muestra un controller siguiendo la convenci√≥n de Resources:

```typescript
import {
  Controller,
  Get,
  Query,
  Post,
  Body,
  Put,
  Param,
  Delete,
} from "@nestjs/common";
import { CreateCatDto, UpdateCatDto, ListAllEntities } from "./dto";

@Controller("cats")
export class CatsController {
  @Post()
  create(@Body() createCatDto: CreateCatDto) {
    return "This action adds a new cat";
  }

  @Get()
  findAll(@Query() query: ListAllEntities) {
    return `This action returns all cats (limit: ${query.limit} items)`;
  }

  @Get(":id")
  findOne(@Param("id") id: string) {
    return `This action returns a #${id} cat`;
  }

  @Put(":id")
  update(@Param("id") id: string, @Body() updateCatDto: UpdateCatDto) {
    return `This action updates a #${id} cat`;
  }

  @Delete(":id")
  remove(@Param("id") id: string) {
    return `This action removes a #${id} cat`;
  }
}
```

**Explicaci√≥n del ejemplo**: Se puede observar que todas las rutas bajo el controller de `cats` siguen la forma standar de la estructura _RESTful_ usando una convencion, ya conocida para facilitar el manejo por las APIs y de datos. Se usa DTO (en create y update, tal y como recomienda Nest). Adem√°s tenemos "endpoints" para ver el listado completo (usando query string), para ver uno con id en particular, otro para editarlo y otro para borrado.

#### 3. **Utilidad:**

- Seguir la metodologia y convencion est√°ndar _CRUD_, o _REST_
- Provee metadatos especificos en los Decorators con lo que define los verbos de las rutas (`Get,Post,Delete`, etc).
- Permite a los modulos de frontend crear un patron muy "standar" para las conexiones mediante URLs

## F - Wildcards en NestJS üÉè üîó

¬øQuieres crear rutas que respondan a m√∫ltiples patrones? ¬°Los Wildcards en NestJS te dan el poder de crear rutas din√°micas que entiendan _regex patterns_ o similares!

#### 1. **Definicion:**

- El framework usa `regex` para la creacion del _router_ y a traves de comodines (o patrones con caractereres comod√≠n: asterisco `*`, interrogante `?`, m√°s `+`, o par√©ntesis `()` para submatches) se permite mayor dinamismo a la hora de configurar paths
- Es util para que una ruta coincida no solo a una unica direcci√≥n sino que se use el asterisco por ej. `'ab*cd'`, coincidiendo en `abcd`, `ab_cd` o `ab123cd`. o la version parametrizada `/api/users/:userid` como ejemplo que utiliza `regex` internamente el framework. El resto, `-` (el guion) o el punto (`.`) tienen un funcionamiento literal.
- Como los wildcard son construidos por el framework, debes tener cuidado que estas routes NO superpongan otros endpoints, dado que en algun framework no son soportados.

#### 2. **Ejemplo:**

```typescript
import { Controller, Get } from "@nestjs/common";

@Controller("cats")
export class CatsController {
  @Get("ab*cd")
  findAll() {
    return "This route uses a wildcard";
  }
}
```

**Explicaci√≥n del ejemplo**: Se ha registrado en `findAll()` con la notacion `"ab*cd"` lo cual coincide en urls tipo: `/cats/abcd`, `/cats/ab_cd` o `/cats/ab123cd`, al usar un wildcard en la misma ruta, sin necesidad de tener m√°s m√©todos o mas controladores con rutas similares o usando regex, este concepto puede ser llevado para multiples variables y combinaciones complejas para "filtrar" el tr√°fico

#### 3. **Utilidad:**

- Definir routes m√°s dinamicas de forma sencilla.

- Usar un comportamiento muy parecido al del concepto _regex_ dentro de la definici√≥n de una ruta (pero que lo abstrae el framework de forma _transparent_), es mucho mas sencilla para alcanzar patrones dinamicos para una ruta.

- Usar una estrategia m√°s "compacta" a la hora de registrar un patron sobre una variable en la ruta (sin la necesidad de mas c√≥digo).

## G - Status Code en NestJS üî¢ ‚úÖ

¬øC√≥mo indicamos el resultado de una petici√≥n al cliente? ¬°Los Status Codes en NestJS te permiten comunicar si todo ha ido bien, o ha habido errores con la ruta (endpoints)!

#### 1. **Definicion:**

- Nest envia el status `200` (OK), como status code por defecto en todas las peticiones exceptuando las POST ( `201` , _Created_) o incluso algun que otra redirecci√≥n
- Mediante la anotacion `@HttpCode(codigo)` podemos definir cual es status esperado en nuestra l√≥gica
- Existe la posibilidad de manipular _a mano_ los Statuscodes a trav√©s de la propiedad status en el objeto de respuesta (a traves de `express.Response`) `res.status(status)` para ser m√°s flexible, siempre teniendo el "control completo", del mismo objeto, pero usando el modo library specific, para "no confiar" el response a NestJS.

- Los valores tambien pueden ir en funci√≥n de "un calculo" al usar _Library-Specific Mode_. o el caso del objeto retorno que puede ir configurando de forma dinamica el `statusCode` a traves de la propiedad del mismo objeto al hacer el `return`.

#### 2. **Ejemplo:**

Uso del status 204

```typescript
import { Controller, Post, HttpCode } from "@nestjs/common";

@Controller("cats")
export class CatsController {
  @Post()
  @HttpCode(204)
  create() {
    return "This action adds a new cat";
  }
}
```

Cambio dinamico en funci√≥n de query params ( o algun otra via ).

```typescript
import { Controller, Get, Redirect, Query } from "@nestjs/common";

@Controller("cats")
export class CatsController {
  @Get("docs")
  @Redirect("https://docs.nestjs.com", 302)
  getDocs(@Query("version") version) {
    if (version && version === "5") {
      return { url: "https://docs.nestjs.com/v5/", statusCode: 301 }; // redireccion dinamica y con cambio status
    }
  }
}
```

**Explicaci√≥n del ejemplo**: Al realizar un `POST` al `/cats` retornara el status code 204 ( `No content`), para el segundo ejemplo, si la query params con `?version=5`, redirigir√° con un _301 (moved permantly)_. Al cambiar de forma din√°mica tanto el `url`, como el _status_, estamos utilizando lo que el framewok da soporte a la definici√≥n de status, ya que en condiciones normales retornar√° el valor 302 del decorator si no existiera dicha l√≥gica y siempre en un entorno _Library-Specific Mode_ o usando el statuscode del `res.status` por `express` con el `@Res` method handler parameter decorator.

#### 3. **Utilidad:**

- Enviar "el resultado de la petici√≥n", que ayude al usuario ( o cliente web) a reaccionar ante la informaci√≥n recibida (ya sea que funciono o algun error) en los endpoint REST

- Dar feedback (de alguna acci√≥n por un lado y una response estandar del lado del _endpoint_) mediante codigos estandar.

## H - Headers en NestJS üè∑Ô∏è ‚úâÔ∏è

¬øC√≥mo enviar informaci√≥n adicional con la respuesta HTTP? ¬°Los Headers en NestJS te permiten personalizar las cabeceras de respuesta para una petici√≥n!

#### 1. **Definicion:**

- Los Headers en el contexto de la respuesta, son campos metadata que pueden transportar informaci√≥n "especial", que usualmente no encajan dentro de la _payload_ (data o body) del HTTP response como `Cache-Control`,`Content-type` u otro header en especifico para dar "mas control" al _consumidor_ del servicio o API

- Hay dos maneras de definirlos, uno mediante el uso de `@Header()` (que a√±ade headers que queramos a la respuesta en _modo estandar_) o la API espec√≠fica del response de `res.header(name,value)` mediante `@Res()` para tener "control total" a traves de una propiedad de objeto que gestiona Express y es por lo tanto es un caso m√°s especifico donde se sale de lo standar.
- En los casos din√°micos, en un entorno `@Res()` library specific, o dentro del objeto respuesta si el handler devuelve el `HttpRedirectResponse`.

#### 2. **Ejemplo:**

Anotacion Header

```typescript
import { Controller, Post, Header } from "@nestjs/common";

@Controller("cats")
export class CatsController {
  @Post()
  @Header("Cache-Control", "no-store")
  create() {
    return "This action adds a new cat";
  }
}
```

Usando el objeto _response_:

```typescript
import { Controller, Get, Post, Res, HttpStatus } from "@nestjs/common";
import { Response } from "express";

@Controller("cats")
export class CatsController {
  @Post()
  create(@Res() res: Response) {
    res.status(HttpStatus.CREATED).header("x-mia-header", "valorsito");
    return res.send();
  }
}
```

**Explicaci√≥n del ejemplo**: En la primera declaracion de headers la funcion create responder√° a un request POST con la siguiente cabecera en HTTP: `Cache-Control : no-store`.
La segunda, utiliza `header('x-mia-header',"valorsito")` con _library specific_, donde la propiedad header asigna de forma directa la configuracion al _response object_ (`express.response`), como podemos ver ambos m√©todos dan opciones distintas en base al nivel de control del comportamiento. (de forma m√°s sencilla la anotacion del framework y usando `res.header()` un control mas directo)

#### 3. **Utilidad:**

- Permitir configuraciones adicionales sobre la respuesta del HTTP usando metadata tipo header con fines muy especificos como cacheo de la petici√≥n, content types etc.

- Guiar al cliente como puede interactuar sobre esta misma petici√≥n en un nuevo request usando la cabecera espec√≠fica por ejemplo una location de una respuesta http.
- Ofrece "mas informacion extra", pero muy estructurada y de forma predefinida (un _meta meta dato_ sobre una operacion/petici√≥n o la response del servicio/aplicacion).

## I - Redirecciones en NestJS ‚Ü©Ô∏è üîó

¬øC√≥mo enviar al cliente a otra direcci√≥n? ¬°Las Redirecciones en NestJS hacen que el cliente web acceda a otro "recurso" u otra URL por su navegador web (ej `location` header)!

#### 1. **Definicion:**

- Sirven para hacer redirecciones desde un endpoint concreto a un "nuevo destino" , utilizando por lo general un _status code_ como 301(moved permantentely), o 302 (found) tal cual un protocolo estandar (redirecciones desde una URL a otra).

- Tiene un anotador `@Redirect('url', code )` para casos mas simples (a una url fija) pero permite un manejo m√°s dinamico en los handlers (de los metodos en los Controller) por el objeto `res`, al definirlo con el `@Res()` _library-specific mode_ (ejemplo para poder configurar con el method `res.redirect( url  )`) o, dentro del _return_ en si el objeto puede tener un _url_ y opcionalmente el _statusCode_

#### 2. **Ejemplo:**

- Anotacion simple (sin `code` en redirect usara `302` por defecto)

```typescript
import { Controller, Get, Redirect } from "@nestjs/common";
@Controller("cats")
export class CatsController {
  @Get()
  @Redirect("https://nestjs.com")
  redirect() {}
}
```

- Modo dinamico

```typescript
import { Controller, Get, Redirect, Query } from "@nestjs/common";

@Controller("cats")
export class CatsController {
  @Get("docs")
  @Redirect("https://docs.nestjs.com", 302)
  getDocs(@Query("version") version) {
    if (version && version === "5") {
      return { url: "https://docs.nestjs.com/v5/" };
    }
  }
}
```

**Explicaci√≥n del ejemplo**: En el primer ejemplo, la petici√≥n del m√©todo GET del controller cats redirige al cliente a la url `https://nestjs.com`, usando por defecto el status code 302 (_found_) y agregando al header `location` la nueva ruta para su redirecci√≥n (por el navegador web), pero si se le pasa la querystring `?version=5` al _endpoint_ `cats/docs` , usara de forma _dinamica_ a `https://docs.nestjs.com/v5/` , si la condici√≥n no se diera se enviar√≠a al redirect a `https://docs.nestjs.com` con 302 que esta configurado a traves del decorador (que es la manera por defecto y mas sencilla).

#### 3. **Utilidad:**

- Redirigir al usuario hacia otras localizaciones web

- Manejar logicamente diferentes comportamientos en el endpoint, con una nueva peticion desde un cliente a un recurso distinto.

## J - Route parameters en NestJS üìç üîÄ

¬øC√≥mo capturar valores din√°micos desde una ruta? ¬°Los Route parameters en NestJS extraen valores del propio URL mediante los `:params`!

#### 1. **Definicion:**

- Cuando una URL contiene informaci√≥n, se puede acceder a ella (ej: `/cats/1` y querremos sacar el _id_ que tiene valor de _1_) como `path variables`. Se logran gracias a la definicion `:` ej `/cats/:id`, siendo `:id` la forma de definirla en Nest. El nombre puede ser cualquiera.
- Para su extracci√≥n usa `@Param()` dentro del _method-handler_ y nos ayudamos por la notacion `@Param(parameter)`, indicando su variable y que adem√°s hace su type check de manera nativa al usar typescript

- Hay un "orden" de registro, es mejor definir rutas especificas de estatico y _paths params_ como ultima ruta (el que hace matching) en caso de que un path variable y una url similar entren en conflicto (si esto se da, puede pasar que no entre en las rutas concretas y de prioridad mayor)

#### 2. **Ejemplo:**

```typescript
import { Controller, Get, Param } from "@nestjs/common";

@Controller("cats")
export class CatsController {
  @Get(":id")
  findOne(@Param("id") id: string): string {
    return `This action returns a #${id} cat`;
  }
}
```

**Explicaci√≥n del ejemplo**: Con el m√©todo `@Get(':id')`, cualquier URL que termine como `/cats/algun_valor`, asignar√° a `algun_valor` dentro de la variable de ruta `id` y a la funcion, mediante `@Param('id')`, el acceso y control de este valor. Se puede observar que no es un "string gen√©rico" al haberlo tipado, si fuera otra cosa tendr√≠amos un fallo de Type en nuestro backend. Hay la opcion tambien para `Param()` con ` @Param() params : {id : string }`, para mapear los path parameters sin typecheck dentro de un mismo objeto que recoge los diferentes path variables. (ej `:id/:userid/:other_variable`).

#### 3. **Utilidad:**

- Extaer valor a traves de URL (identificador, u otro tipo de informaci√≥n relevante desde una parte especifica del url)
- Conocer la informacion relevante desde paths que cambian dinamicamente como el ejemplo ` /user/:userid/posts` con sus diferentes combinaciones de userid, de manera facil con ayuda del typescript.

## K - Subdomain Routing en NestJS üåê üîó

¬øQuieres direccionar tr√°fico en base al subdominio del HTTP Host? ¬°El Subdomain Routing en NestJS hace posible direccionar la aplicaci√≥n o endpoint a dominios diferentes por configuraci√≥n con subdominio!

#### 1. **Definicion:**

- Nest puede configurar el controller por la propiedad host ( del HTTP request) de entrada (sub dominio del HTTP Header) de modo que segun que `Host`, sera redireccionado al controllador concreto que escuche a ese `host`
- Con esta configuraci√≥n no solamente define una variable, adem√°s filtra seg√∫n sub dominio para diferentes controllers (por ejemplo tener subdominios `admin.ejemplo.com` , y otros `users.ejemplo.com` , para las operaciones relativas a admin y user en diferente "parte del backend").
- Usa `@HostParam(name)`, para su captura (forma de path params en el propio host (en vez del path como antes). ) Y `*` tambi√©n como wildcard en la definici√≥n
- La forma standard con path tambien soporta wildcard al mismo tiempo con el Host como configuraciones `*` , pero solo la expresion literal se le permitira `-` o el punto `.` en ambas opciones

#### 2. **Ejemplo:**

Subdominios con una _sub route_, ademas

```typescript
import { Controller, Get } from "@nestjs/common";

@Controller({ host: "admin.example.com" })
export class AdminController {
  @Get()
  index(): string {
    return "Admin page";
  }
}
```

Ejemplo con _path params_, capturados de forma separada y de uso simultaneo.

```typescript
import { Controller, Get, HostParam } from "@nestjs/common";

@Controller({ host: ":account.example.com" })
export class AccountController {
  @Get()
  getInfo(@HostParam("account") account: string) {
    return account;
  }
}
```

**Explicaci√≥n del ejemplo**: Para `admin.example.com`, cualquier GET en el "host" del request a ese valor (en `http://admin.example.com` por ejemplo) ejecutara `AdminController`, la URL (`/` sin _sub route_ en la parte de _path_) , y se le entregar√° la String `"Admin page"`. Si el _Host_ (del header HTTP ) coincide con `:account.example.com` entonces se inyectar√° el valor antes del `.example.com` como `account`, al m√©todo `getInfo()`, a trav√©s del par√°metro con la anotacion `HostParam('account')`, con el typo definido (o inferido), esto podria ser `miau` o `lulu` dentro de `miau.example.com` y `lulu.example.com`. Esta feature puede ser "anidada" dentro del path con lo cual hay bastante granularidad.

#### 3. **Utilidad:**

- Poder enrutar peticiones usando como base, el propio dominio para diferentes prop√≥sitos. (mismo path con diferente subdomain)

- Permitir una estructura que segmenta funcionalidades o informaci√≥n seg√∫n una parte concreta de la jerarqu√≠a de un sub dominio que recibe (como en el ejemplo anterior en una app admin con respecto al user o como microservices).

## L - Scopes de Controllers en NestJS ‚è±Ô∏è ‚ôªÔ∏è

¬øComparten la informaci√≥n los controllers en m√∫ltiples peticiones? Los Scopes en NestJS nos indican la duraci√≥n de los controller (su tiempo de vida) entre peticiones!

#### 1. **Definicion:**

- Por norma general (y as√≠ ocurre en Node), cada Controller (como todas las dependencias y services) est√°n compartidos para todas las requests ya que Javascript/Node tiene solo un unico Thread (en un solo nucleo) o el Worker Thread no tiene mucho impacto como si fuera Multi Thread (Java, C#,Go), ya que los Controllers son por norma singletons al usar el DI, aunque las promesas ( y las ejecuciones as√≠ncronas del runtime javascript) hagan uso intensivo de EventLoop. El tener Singletons evita overhead y la instancia se da solo al arrancar el server. Por defecto Nest sigue este comportamiento y hace que los servicios compartan estado.

-     En algunos casos, como un cacheo por request,  o para  *multi tenancy* , la existencia de controller por peticion podria llegar a ser interesante, esto no suele pasar mucho pero ahi la opcion  de scopes, (hay que configurar el *Provider* para el cambio de scopes ya que  los controller y  el providers comparten scope en si, sino el controler tendria "su singleton" pero sus services no!)  esta opcion  al  tener menos overhead , esta totalmente habilitada ( a costa de un impacto a nivel de memoria del servidor)  (ver detalles en *Dependency Injection scopes* )

#### 2. **Ejemplo:**

No hay un ejemplo especifico del codigo sobre el tema en particular. El texto hace referencia a \*injection
